<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="飞琼君·个人博客">
<meta name="description" content="仰天大笑出门去，吾辈岂是蓬高人！">
<meta name="theme-color" content="#000">
<title>禁用IPv6 | 飞琼君·WebOS</title>
<link rel="shortcut icon" href="/favicon.ico?v=1619406900285">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>




<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?&lt;script&gt; var _hmt = _hmt || []; (function() {   var hm = document.createElement(&#34;script&#34;);   hm.src = &#34;https://hm.baidu.com/hm.js?5c912626dffb7cf525cd2e85591b7fbd&#34;;   var s = document.getElementsByTagName(&#34;script&#34;)[0];    s.parentNode.insertBefore(hm, s); })(); &lt;/script&gt;";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>


  <meta name="description" content="禁用IPv6" />
  <meta name="keywords" content="linux运维" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>飞琼君·WebOS</span>
            </a>  
          
        </div>
        
          <p class="subtitle">君子精于心，简于形</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <section class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://fqj-web.github.io/post/jin-yong-ipv6/">
      禁用IPv6
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span class="publish-time" data-t="2020-09-02 10:14:11">2020-09-02</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://fqj-web.github.io/tag/nAh6_wabP/">
        <span>linux运维</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>1<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>150<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
  </div>
</section>
            <div class="post-body next-md-body" id="post_body">
              <p>有的时候在使用wget下载文件的时候，默认使用ipv6地址进行解析，导致无法解析域名或者下载速度很慢，此时便需要禁用ipv6地址，具体方法如下：<br>
永久生效：</p>
<pre><code class="language-shell">vi /etc/sysctl.conf
    # 全部网卡禁用ipv6
    net.ipv6.conf.all.disable_ipv6 =1
    net.ipv6.conf.default.disable_ipv6 =1
    # 指定网卡(enp0s3)禁用ipv6\
    net.ipv6.conf.enp0s3.disable_ipv6 =1
sysctl -p  # 使配置文件生效
</code></pre>
<p>临时生效</p>
<pre><code class="language-shell">echo 1&gt;/proc/sys/net/ipv6/conf/all/disable_ipv6
echo 1&gt;/proc/sys/net/ipv6/conf/default/disable_ipv6
# 或者
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1
</code></pre>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      飞琼君
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://fqj-web.github.io/post/jin-yong-ipv6/" title="禁用IPv6">https://fqj-web.github.io/post/jin-yong-ipv6/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://fqj-web.github.io/tag/nAh6_wabP/"># linux运维</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="更换pip源" href="https://fqj-web.github.io/post/geng-huan-pip-yuan/">更换pip源</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="更换pip源" href="https://fqj-web.github.io/post/geng-huan-pip-yuan/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="CentOS7管理环境变量" href="https://fqj-web.github.io/post/centos-guan-li-huan-jing-bian-liang/">CentOS7管理环境变量</a>
        <a class="nav-mobile-next" title="CentOS7管理环境变量" href="https://fqj-web.github.io/post/centos-guan-li-huan-jing-bian-liang/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://fqj.myds.me:4433/" target="_blank">WebOS</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'true'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

<div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/windows-xiu-gai-yuan-cheng-zhuo-mian-rdp-duan-kou/"" data-c="
          &lt;ol&gt;
&lt;li&gt;修改之前确认已经打开远程桌面的功能：&lt;br&gt;
如果没有开启，可执行以下步骤：win+E打开资源管理器--&amp;gt;右键点击“此电脑”并选择“属性”--&amp;gt;左击“远程设置”--&amp;gt;在远程选项卡中选择“允许远程连接到此计算机”，默认是所有用户，可以根据自己的需求选择只能通过某些用户远程&lt;/li&gt;
&lt;li&gt;修改远程桌面默认端口号（举例使用12345端口）：
&lt;ol&gt;
&lt;li&gt;修改注册表：&lt;code&gt;运行regedit打开注册表&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;将&lt;code&gt;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp&lt;/code&gt;中的&lt;code&gt;PortNamber&lt;/code&gt;的值（使用十进制查看和修改，默认3389）修改为自己想要远程的端口，例如修改为12345&lt;/li&gt;
&lt;li&gt;同理，将&lt;code&gt;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp&lt;/code&gt;中的&lt;code&gt;PortNamber&lt;/code&gt;的值也修改为自己想要的远程端口号，例如修改为12345&lt;/li&gt;
&lt;li&gt;如果开启了防火墙，可通过注册表修改防火墙的入站规则，修改方法如下：将&lt;code&gt;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\SharedAccess\\Defaults\\FirewallPolicy\\FirewallRules&lt;/code&gt;和&lt;code&gt;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\services\\SharedAccess\\Parameters\\FirewallPolicy\\FirewallRules&lt;/code&gt;这两个注册表中的&lt;code&gt;RemoteDesktop-UserMode-In-TCP&lt;/code&gt;的值中的3389全部修改为12345&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;重启远程服务：&lt;code&gt;运行services.msc打开服务管理&lt;/code&gt;&lt;br&gt;
找到服务“Remote Desktop Services”--&amp;gt;右键选择“重新启动”&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;远程测试：&lt;br&gt;
运行mstsc打开远程连接--&amp;gt;输入&lt;code&gt;IP地址:端口号&lt;/code&gt;，例如&lt;code&gt;192.168.1.1:12345&lt;/code&gt;--&amp;gt;远程连接&lt;/li&gt;
&lt;/ol&gt;
">windows修改远程桌面RDP端口</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/github-fang-wen-jia-su-mian-fei-fang-shi/"" data-c="
          &lt;p&gt;github访问慢的原因有很多，比如配置了不恰当的DNS服务器或者github的CDN域名遭到了DNS污染等等，基本上是dns解析的问题，即无法连接使用github的加速分发服务器，才使得国内访问速变慢。&lt;br&gt;
以下有两种解决方案，都是通过修改hosts文件来解决域名解析的问题。其中，方案一，即使用站长之家dns解析的地址是国内加速器的地址；方案二，即使用ipaddress.com进行dns解析的是github的美国地址。&lt;/p&gt;
&lt;h1 id=&#34;方案一推荐更快&#34;&gt;方案一：（推荐，更快）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;访问站长之家&lt;a href=&#34;http://tool.chinaz.com/dns?type=1&amp;amp;host=github.com&amp;amp;ip=&#34;&gt;http://tool.chinaz.com/dns?type=1&amp;amp;host=github.com&amp;amp;ip=&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在DNS查询工具中查询&lt;code&gt;github.com&lt;/code&gt;等地址&lt;/li&gt;
&lt;li&gt;记录下TTL值最小的响应IP，例如我这里记录的是&lt;code&gt;192.30.255.112&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1619000262730.png&#34; alt=&#34;TTLmin&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;编辑host文件，windows的hosts文件的位置&lt;code&gt;C:\\Windows\\System32\\drivers\\etc\\hosts&lt;/code&gt;，而Linux和macOS的hosts文件的位置&lt;code&gt;/etc/hosts&lt;/code&gt;，追加如下内容：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;192.30.255.112 github.com
104.244.43.57 github.global.ssl.fastly.net
8.7.198.45 gist.github.com
192.30.255.120 codeload.github.com
185.199.108.153 desktop.github.com
185.199.111.153 guides.github.com
185.199.109.153 blog.github.com
140.82.114.18 status.github.com
185.199.111.153 developer.github.com
185.199.111.153 services.github.com
140.82.112.21 enterprise.github.com
140.82.113.21 education.github.com
185.199.111.153 pages.github.com
140.82.112.22 classroom.github.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;方案二更稳定&#34;&gt;方案二：（更稳定）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;访问&lt;a href=&#34;https://www.ipaddress.com&#34;&gt;https://www.ipaddress.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;输入&lt;code&gt;github.com&lt;/code&gt;等域名进行查询，例如查到的地址是&lt;code&gt;140.82.112.4&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1619000780917.png&#34; alt=&#34;ipaddress&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;编辑hosts文件，追加以下内容：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;140.82.112.4 github.com
199.232.69.194 github.global.ssl.fastly.net
&lt;/code&gt;&lt;/pre&gt;
">Github访问加速免费方式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/che-di-guan-bi-windowsupdate-geng-xin/"" data-c="
          &lt;p&gt;如果需要彻底关闭win10或者win7的系统更新，仅仅关闭服务是无法彻底关闭的，因为还有任务计划、注册表等内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关闭服务&lt;code&gt;cmd运行services.msc打开服务管理&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;Windows Update
&lt;ol&gt;
&lt;li&gt;常规选项卡--启动类型选择禁用--服务状态点击停止&lt;/li&gt;
&lt;li&gt;恢复选项卡--第一次、第二次、后续失败均选择无操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Windows Modules Installer
&lt;ol&gt;
&lt;li&gt;常规选项卡--启动类型选择禁用--服务状态点击停止&lt;/li&gt;
&lt;li&gt;恢复选项卡--第一次、第二次、后续失败均选择无操作&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;修改组策略&lt;code&gt;cmd运行gpedit.msc打开组策略管理&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;计算机配置--管理模板--Windows组件--Windows更新
&lt;ol&gt;
&lt;li&gt;配置自动更新--选择已禁用&lt;/li&gt;
&lt;li&gt;始终在计划的时间重新启动--选择已禁用&lt;/li&gt;
&lt;li&gt;删除使用所有Windows更新功能的访问权限--选择已启用&lt;/li&gt;
&lt;li&gt;自动更新频率检测--选择已禁用&lt;/li&gt;
&lt;li&gt;不要连接任何Windows更新Internet位置--选择已启用&lt;/li&gt;
&lt;li&gt;允许自动更新立即安装--选择已禁用&lt;/li&gt;
&lt;li&gt;启用通过自动更新建议的更新--选择已禁用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;删除任务计划&lt;code&gt;cmd运行taskschd.msc打开任务计划管理&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;任务计划程序库--Microsoft--Windows--WindowsUpdate--把里面的项目都右键选择禁用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;修改注册表&lt;code&gt;cmd运行regedit打开注册表管理&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;HKEY_LOCAL_MACHINE--SYSTEM--CurrentControlSet--Services--UsoSvc
&lt;ol&gt;
&lt;li&gt;Start--把值改成16进制的4&lt;/li&gt;
&lt;li&gt;FailureActions（有的没有）--将0010、0018行的左起第5个数值由原来的01改为00&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">彻底关闭WindowsUpdate更新</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie_20210414_-shen-zhen-mian-shi/"" data-c="
          &lt;h1 id=&#34;面试题目&#34;&gt;面试题目&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;使用画图的方式介绍IGMP Snooping的工作原理&lt;/li&gt;
&lt;li&gt;园区网部署&lt;sub&gt;与笔记中不同的是，考试的拓扑中每个接入下面都有一台打印机&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;ospf、isis、bgp如何进行路由撤销&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;答题顺序&#34;&gt;答题顺序&lt;/h1&gt;
&lt;h2 id=&#34;路由撤销20min&#34;&gt;路由撤销（20+min）&lt;/h2&gt;
&lt;h3 id=&#34;答题思路&#34;&gt;答题思路&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ospf，先说3中撤销方式分别针对哪些LSA，然后展开将1类和2类的各种场景，3、5、7类LSA一句话带过，主要讲一下4类LSA的撤销&lt;/li&gt;
&lt;li&gt;isis，先说2种撤销方式针对哪些LSP，然后展开将域内的2个场景和域外的1个场景&lt;/li&gt;
&lt;li&gt;bgp，直接说使用update报文，然后将withdrawn由长度和撤销路由组成，长度为0没有撤销路由，然后说一下撤销路由的二元组是什么。最后讲一下多协议，先说路由更新三元组和前缀信息三元组，然后说一下路由撤销只用二元组，没有下一跳&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;追问&#34;&gt;追问&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ospfv3的路由撤销，先说1类和2类不传递路由，再说3、4、5、7和v2相同，最后说8和9的作用，讲完作用再说撤销&lt;/li&gt;
&lt;li&gt;BGP的refresh报文作用，这个当时没答上来&lt;code&gt;评价的时候让我回去看看&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;园区网20min&#34;&gt;园区网（20+min）&lt;/h2&gt;
&lt;h3 id=&#34;答题思路-2&#34;&gt;答题思路&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;vlan+eth-trunk&lt;/li&gt;
&lt;li&gt;rstp+网关&lt;/li&gt;
&lt;li&gt;dhcp+防护+802.1x&lt;code&gt;说道dhcp的时候被打断，时间不够，不用展开讲&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;NAT+PPPoE（PPPoE都没来得及说）&lt;/li&gt;
&lt;li&gt;打印机&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;追问-2&#34;&gt;追问&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;华为stp默认的方式，我说成rstp了，应该是mstp&lt;/li&gt;
&lt;li&gt;根保护需不需要再接入交换机部署，这个我没有直接回答，我说的是接入交换机一般在全局配置边缘端口并且配置了BPDU保护，然后把上行端口的边缘端口disable了，哪怕接入交换机下再接入一个交换机也不会抢根，然后考官就说这种情况下需不需要配，因为不确定，我说stp收到更优的bpdu会丢弃掉，但是rstp不会，会重新选举&lt;code&gt;考官评价的时候说接入也需要配置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;提问华为私有技术easy ip，旁边有个考官说easy nat，我当时有点蒙，说不知道，只说了如果单纯上网，那么配置简单的一对一地址转换即可，如果对外提供web服务需要使用nat server&lt;/li&gt;
&lt;li&gt;接上一个追问，如果提供ftp服务怎么办？我给讲了一下外部需要使用主动模式，以及不能使用被动模式的原因，然后被追问还有哪些协议需要开启ALG，当时没想起来，就让考官给我提几个，我选择，结果考官说我平时都用哪些，我说除了ftp、ftps、ssh、http，其他的没用过&lt;/li&gt;
&lt;li&gt;后面的pppoe等都没讲，考官让讲下一个题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;igmp-snnoping20-min&#34;&gt;IGMP Snnoping（20-min）&lt;/h2&gt;
&lt;h3 id=&#34;答题思路-3&#34;&gt;答题思路&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先说一下场景，为了省钱，买的二层交换机，后来网络学习兴起，需要组播，还设备成本高，为了实现组播，可以开启IGMP Snooping，说了一下Snnoping是侦听的意思，就像传话筒，不像proxy可以代处理一些报文&lt;/li&gt;
&lt;li&gt;普遍组查询、成员发送的报文（成员报告报文、对普遍组查询的响应）、离组以及触发的特定源组查询报文等处理方式&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;追问-3&#34;&gt;追问&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;igmp snooping生成的那个表叫什么名字，都有什么内容，表的内容我说出来了，但是表的名字，说问的这么突然，一时间想不起来了&lt;/li&gt;
&lt;li&gt;组播地址都有哪些？当时我先回到的是SSM和ASM用的地址，然后问常用组播组地址，我就说了IGMP中常用的1、2和22&lt;code&gt;考官评价的时候让我回去看看常用的组播地址，比如ospf的等等我这才反应过来这是问的所有的组播地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;又追问了一次离组，然后说了一下v3没有离组报文，是通过发送成员报告报文离组的，报文中组播源数量为0，考官追问到底是发送成员报告还是查询报文，我很确认的回答了是成员报告报文，接收者没法发送查询报文&lt;/li&gt;
&lt;li&gt;然后说了一下v3没有成员报告抑制，因为查询者监控的是22，其他接收者无法收到此报文&lt;/li&gt;
&lt;li&gt;追问交换机如何处理组播报文，收到所有组播报文之后先向vlan内所有的接口转发，同时上交三层处理，如果没有开启组播则不处理，如果开启组播，没有表项也不处理，有表项则按照表项转发。然后考官问需不需要上交CPU处理，是不是直接转发，我说不是，第一次上交CPU，后面会形成表项，下发到FIB，后面再收到此类报文，则按照表项转发&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;备考&#34;&gt;备考&lt;/h1&gt;
&lt;h2 id=&#34;笔试15days&#34;&gt;笔试（&amp;lt;15Days）&lt;/h2&gt;
&lt;p&gt;笔试都是选择题，教育机构都会给出响应的题库，我准备的时候，两份文档，大概是700道题，但是去掉重复和堪错部分，大概也就是500道题左右。&lt;br&gt;
备考笔试那段时间，单位比较忙，大概备考了一个月，大体的流程是先看两份PDF，第一遍和第二遍需要细看，第三遍和第四遍粗略的浏览一下，后面就用模拟软件开始模拟考试，每次把所有的题都选上，然后在1个小时内完成，把错题记录下来，后面每天先做错题，然后再重新做一遍全部的题库。如果晚上不加班的话，笔试部分大概需要一两个星期就可以完成备考。&lt;/p&gt;
&lt;h2 id=&#34;实验40days&#34;&gt;实验（=40Days）&lt;/h2&gt;
&lt;p&gt;笔试过后，拿到LAB的排错TS的B版本，大概需要10天到两个星期的时间将这套版本熟练，当然也可以时间更长，不仅需要知道这个排错中具体的排错顺序与方法，还需要大概的了解涉及的协议的相关内容，比如路由优选、RP选举等等。&lt;br&gt;
报名之后，拿到剩下的题库，包括排错TS的A版本和项目实施lab的v1和v2版本，这些实验的命名是根据拓扑中BGP MPLS VPN的部署方式来命名的。TSA相对来说比较简单，但是labv1和labv2基本是从零开始部署，比较繁琐，需要掌握大量的命令，如果在上课的时候认认真真做实验，这一块内容相对来说会简单好多。&lt;br&gt;
由于自身对项目实施不太熟虚，又错过了达叔将MPLS VPN的课程，后来干脆把30天的年假全部休了，用来全力备考，前前后后大概用了40天左右的时间。&lt;br&gt;
除了上面两大块内容之外，上午排错考试还有一部分是写文档，这个其实每个机构，甚至每个机构的不同老师给出的答案是不一样的，但是理解之后，发现这好多版本、好多排错、好多思路都是殊途同归、大道至简。&lt;br&gt;
下午的项目实施，没有太好的方法，除了要细心之外，还要形成肌肉记忆，哪怕大脑网络，手指也能敲出来这种感觉，因为这部分分值很高，并且一旦自己挖坑，很难排查出问题来。&lt;br&gt;
在备考实验的过程中，得到了好多同学的帮助，比如耿同学、孟同学、张同学、支同学等等，有的时候要排查lab中出的问题，确实比较难，又一次孟同学帮忙排错排到凌晨一点，再次感谢这些同学。&lt;/p&gt;
&lt;h2 id=&#34;面试90days&#34;&gt;面试（=90Days）&lt;/h2&gt;
&lt;p&gt;实验过后，老师给了一些视频和文档，准备面试，基本没有头绪，向群里的好多同学请教之后，大概做了一下规划，前两个月先整理笔记，整理的过程中理解为什么要设计这些协议、为什么要采取这种工作方式、采取这种工作流程的优势与弊端等，有些地方实在不理解，就去查找hedex文档或者网上查找相关协议的发展历史，这两个月工作是比较细致和繁琐的，也决定了后面能不能顺利的进行下去。&lt;br&gt;
最后一个月，记忆协议中的细节，例如各种计时器的默认值、各种组播的地址、各种时间如何计算等等，最重要的是参加模拟面试，但模拟面试也不是参加的越多越好，我当时基本是每周最多参加4场面试，每次面试完，针对老师和同学提出的问题做相应的补充、修改、调整讲解顺序、如何穿插知识点等&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;面试&#34;&gt;面试&lt;/h1&gt;
&lt;p&gt;面试的时候刚开始还是蛮紧张的，当时考官喊我的时候，让我登陆之后查看题目，准备一下。&lt;br&gt;
当时看了题目之后，也没打草稿，就想进行自我介绍，考官直接打断，说时间还没到，不用着急，等另一个考官过来之后再开始，让我准备一下。&lt;br&gt;
这段时间还是蛮长的，不仅把题目的提纲列在了纸上，同时也把自己进行自我介绍的大概情况也记在了记事本上，这时候其实已经不那么紧张了，因为心里有底了，知道讲什么、该怎么讲了。&lt;br&gt;
讲题目的时候，穿插一些技术历史背景、应用场景、发展前景和其他协议的关联与区别，在我讲这些的时候，考官从来没有打断过，就是我在讲技术细节的时候，考官突然打断我，说时间不够了，追问几个问题。&lt;br&gt;
应对追问的时候，基本避免连个两个问题说自己不知道，哪怕第二个问题不知道，可以绕过去，这个就看临时应变了，或者把你自己知道的说出来，或者分析一下，不要直接说结果。&lt;br&gt;
最后一个题，并没有讲完，主要是前两个题讲的时间比较长，考官说时间快结束，开始点评。&lt;br&gt;
我面对的华为的面试考官挺不错的，提问的时候，我说不会，考官也不会进行穷追猛打，有的时候还会进行适当的引导，当然有的时候也会试探一下你对知识的掌握是否牢固，这时候只需要斩钉截跌的告诉考官，“我记得是这样的”，不要犹豫。&lt;/p&gt;
">HCIE_2021.04.14_深圳面试（追加备考和个人面试经验）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/lab-he-zhui-wen-bu-chong/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8C%E7%82%B9%E5%8F%8C%E5%90%91%E5%BC%95%E5%85%A5&#34;&gt;双点双向引入&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%BC%95%E5%85%A5%E7%9A%84%E7%90%86%E8%A7%A3&#34;&gt;路由引入的理解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E5%BC%95%E5%85%A5&#34;&gt;为什么需要配置路由引入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%BC%95%E5%85%A5%E7%9A%84%E6%9C%AC%E8%B4%A8&#34;&gt;路由引入的本质&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%BC%95%E5%85%A5%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%BC%80%E9%94%80%E5%80%BC%E7%9A%84%E5%8F%98%E5%8C%96&#34;&gt;路由引入需要注意开销值的变化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%B2%E6%B3%951%E6%8E%A8%E8%8D%90%E5%8F%8C%E7%82%B9%E5%8F%8C%E5%90%91%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;讲法1（推荐）：双点双向存在的问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%9C%A8r1%E4%B8%8A%E5%AE%9E%E6%96%BD%E5%8F%8C%E5%90%91%E5%BC%95%E5%85%A5&#34;&gt;1. 在R1上实施双向引入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%9C%A8r2%E4%B8%8A%E5%AE%9E%E6%96%BD%E5%8F%8C%E7%82%B9%E5%8F%8C%E5%90%91%E5%BC%95%E5%85%A5&#34;&gt;2. 在R2上实施双点双向引入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E8%A7%A3%E5%86%B3%E7%8E%AF%E8%B7%AF%E9%97%AE%E9%A2%98&#34;&gt;3. 解决环路问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%B2%E6%B3%952%E5%8F%8C%E7%82%B9%E5%8F%8C%E5%90%91%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;讲法2：双点双向存在的问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%AC%A1%E4%BC%98%E8%B7%AF%E5%BE%84&#34;&gt;1. 次优路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%8E%AF%E8%B7%AF&#34;&gt;2. 环路&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E5%9B%9E%E7%81%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E7%8E%AF%E8%B7%AF&#34;&gt;1. 路由回灌导致的环路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E8%99%9A%E5%81%87%E7%8E%AF%E8%B7%AF%E5%8A%A8%E8%8D%A1%E7%8E%AF%E8%B7%AF&#34;&gt;2. 虚假环路（动荡环路）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%A4%A7%E5%8D%8F%E8%AE%AE%E5%AF%B9ipv6%E7%9A%84%E6%94%AF%E6%8C%81&#34;&gt;三大协议对IPv6的支持&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ospf&#34;&gt;ospf&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80&#34;&gt;1. 组播地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E9%93%BE%E8%B7%AF&#34;&gt;2. 链路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%A4%9A%E5%AE%9E%E4%BE%8B%E5%A4%8D%E7%94%A8&#34;&gt;3. 多实例复用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E9%80%9A%E8%BF%87routerid%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E9%82%BB%E5%B1%85&#34;&gt;4. 通过RouterID唯一标识邻居&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E8%AE%A4%E8%AF%81%E5%8F%98%E5%8C%96&#34;&gt;5. 认证变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-stub%E5%8C%BA%E5%9F%9F%E7%9A%84%E6%94%AF%E6%8C%81&#34;&gt;6. stub区域的支持&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8%E7%9A%84%E5%8F%98%E5%8C%96&#34;&gt;7. 报文头部的变化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-1%E7%B1%BB%E5%92%8C2%E7%B1%BB&#34;&gt;8. 1类和2类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-%E5%A2%9E%E5%8A%A02%E7%A7%8Dlsa&#34;&gt;9. 增加2种LSA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis&#34;&gt;isis&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%96%B0%E5%A2%9E2%E7%A7%8Dtlv%E5%92%8C1%E4%B8%AAnlpid&#34;&gt;1. 新增2种TLV和1个NLPID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-isis%E5%A4%9A%E6%8B%93%E6%89%91&#34;&gt;2. isis多拓扑&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp&#34;&gt;bgp&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf-isis-bgp%E8%B7%AF%E7%94%B1%E6%92%A4%E9%94%80%E4%BB%A5%E5%8F%8A%E6%8A%A5%E6%96%87&#34;&gt;ospf、isis、bgp路由撤销以及报文&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ospf%E8%B7%AF%E7%94%B1%E6%92%A4%E9%94%80&#34;&gt;1. ospf路由撤销&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%9F%E5%86%851%E7%B1%BB%E5%92%8C2%E7%B1%BB&#34;&gt;域内（1类和2类）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1%E7%B1%BBlsa%E7%9A%84%E6%92%A4%E9%94%80&#34;&gt;1类lsa的撤销&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E7%B1%BBlsa%E7%9A%84%E6%92%A4%E9%94%80&#34;&gt;2类lsa的撤销&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%9F%E9%97%B4%E5%92%8C%E5%9F%9F%E5%A4%963%E7%B1%BB-4%E7%B1%BB-5%E7%B1%BB%E5%92%8C7%E7%B1%BB&#34;&gt;域间和域外（3类、4类、5类和7类）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospfv3&#34;&gt;OSPFv3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-isis%E8%B7%AF%E7%94%B1%E6%92%A4%E9%94%80&#34;&gt;2. isis路由撤销&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%92%A4%E9%94%80%E5%86%85%E9%83%A8%E8%B7%AF%E7%94%B1&#34;&gt;撤销内部路由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%92%A4%E9%94%80%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1&#34;&gt;撤销外部路由&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-bgp%E8%B7%AF%E7%94%B1%E6%92%A4%E9%94%80&#34;&gt;3. bgp路由撤销&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv4%E5%92%8Cipv6%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8%E7%9A%84%E4%B8%8D%E5%90%8C&#34;&gt;IPv4和IPv6报文头部的不同&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E6%94%B6%E5%88%B0%E6%9C%AA%E7%9F%A5%E8%A1%A8%E9%A1%B9%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86&#34;&gt;三层交换机和路由器收到未知表项如何处理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%AC%E5%8F%91%E5%8E%9F%E7%90%86%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;转发原理的区别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;1. 路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%BA%A4%E6%8D%A2%E6%9C%BA&#34;&gt;2. 交换机&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E5%8C%BA%E5%88%AB&#34;&gt;处理流程区别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E5%99%A8-2&#34;&gt;1. 路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%BA%A4%E6%8D%A2%E6%9C%BA-2&#34;&gt;2. 交换机&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85&#34;&gt;补充&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%AB%E5%8D%95%E6%92%AD%E8%BF%98%E6%98%AF%E7%BB%84%E6%92%AD&#34;&gt;如何区别单播还是组播？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%AA%E7%9F%A5%E5%8D%95%E6%92%AD%E5%B8%A7%E5%92%8C%E5%B9%BF%E6%92%AD%E5%B8%A7%E6%B3%9B%E6%B4%AA%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;未知单播帧和广播帧泛洪的区别？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%B1%82%E5%B9%BF%E6%92%AD%E5%92%8C%E4%B8%89%E5%B1%82%E5%B9%BF%E6%92%AD%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;二层广播和三层广播的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%8C%E4%B8%BA&#34;&gt;交换机处理数据的行为：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2%E5%87%BA%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;交换机和路由器的流量整形出接口的区别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E5%99%A8%E6%95%B4%E5%BD%A2&#34;&gt;1. 路由器整形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%95%B4%E5%BD%A2&#34;&gt;2. 交换机整形&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;双点双向引入&#34;&gt;双点双向引入&lt;/h1&gt;
&lt;h2 id=&#34;路由引入的理解&#34;&gt;路由引入的理解&lt;/h2&gt;
&lt;h3 id=&#34;为什么需要配置路由引入&#34;&gt;为什么需要配置路由引入&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;为了让其他设备通过本设备访问到引入的路由&lt;/code&gt;&lt;br&gt;
例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署不同路由协议的机构合并，不同的网络使用不同的协议，并且这些网络需要共享路由信息，此时需要进行路由引入&lt;/li&gt;
&lt;li&gt;采用不同厂商的协议、同一设备同一协议但不同进程的配置&lt;/li&gt;
&lt;li&gt;网络协议的限制，比如使用拨号链路连接两个ISIS网络，而在拨号链路上是不适合运行ISIS协议的；需要配置静态路由，然后将静态路由引入ISIS&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由引入的本质&#34;&gt;路由引入的本质&lt;/h3&gt;
&lt;p&gt;把其他协议（或者同一协议不同进程）学习到的路由表，以及运行该协议的直连引进到本协议的数据库。&lt;br&gt;
例如将OSPF的路由引入RIP，会将下面两条命令显示所有的OSPF的路由全部引入RIP：&lt;code&gt;dis ip rou pro ospf(对应第一句话)&lt;/code&gt;和&lt;code&gt;dis ospf int(对应第二句话)&lt;/code&gt;，&lt;code&gt;即将ospf协议优先的路由和宣告进ospf的路由都引入到rip中&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;路由引入需要注意开销值的变化&#34;&gt;路由引入需要注意开销值的变化&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;引入OSPF或者ISIS路由到RIP时，如果不指定COST，&lt;strong&gt;开销值默认是1&lt;/strong&gt;。应该手工配置开销值以反映网络的真实拓扑&lt;/li&gt;
&lt;li&gt;引入OSPF默认为1&lt;/li&gt;
&lt;li&gt;引入ISIS，窄度量时默认为64，宽度量为10，即引入ISIS路由之前一般需要先更改ISIS的cost类型
&lt;ol&gt;
&lt;li&gt;L1、L2区域都支持外部路由，但外部路由默认是从L2的方式引入进来的，路由cost值=指定引入路由的开销值(参数cost的值，缺省值为0)+64&lt;/li&gt;
&lt;li&gt;如果要在L1区域引入外部路由，由于默认为引入路由到Level-2路由表中，所以必须要加level-1参数，才能引入成功&lt;/li&gt;
&lt;li&gt;外部路由引入之后，每进过一跳，cost值加10&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;讲法1推荐双点双向存在的问题&#34;&gt;讲法1（推荐）：双点双向存在的问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1618065087057.png&#34; alt=&#34;讲法2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R1、R2、R3、R5运行OSPF协议，区域ID为0&lt;br&gt;
R1、R2、R4之间运行IS-IS协议，使用Level-2区域&lt;br&gt;
AR5将自己的Loopback0接口做为外部路由引入到OSPF区域中&lt;br&gt;
&lt;code&gt;在现网中，做实施的时候，一般是做完一台设备再去做另外一台设备的实施&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-在r1上实施双向引入&#34;&gt;1. 在R1上实施双向引入&lt;/h3&gt;
&lt;p&gt;R1上实施双点双向引入之后，R2会从ospf区域和isis区域同时收到5.5.5.5的路由，不同协议之间，首先比较的是外部优先级，ospf外部路由的外部优先级为150，isis外部路由的外部优先级为10，所以R2选择isis区域的路由放入路由表中，即R2访问5.5.5.5的路由为R2--&amp;gt;R4--&amp;gt;R1--&amp;gt;R3--&amp;gt;R5，出现了次优路径的问题&lt;/p&gt;
&lt;h3 id=&#34;2-在r2上实施双点双向引入&#34;&gt;2. 在R2上实施双点双向引入&lt;/h3&gt;
&lt;p&gt;在R2实施双点双向引入，由于R2上关于5.5.5.5的路由已经优选了isis区域的路由，所以从ospf区域引入isis区域的路由中已经不再包含5.5.5.5的路由&lt;br&gt;
但是从isis引入ospf区域的路由中还存在5.5.5.5的路由，即此时针对5.5.5.5这条路由来说，&lt;strong&gt;双点双向中只有isis区域路由到ospf区域生效了&lt;/strong&gt;&lt;br&gt;
在AR3上：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果AR5与AR3之间是以太链路，此时AR3上针对5.5.5.5的路由出现了负载，一条指向R5，一条指向R2&lt;/li&gt;
&lt;li&gt;如果AR5与AR3之间是P2P链路，那么AR3的路由表中只有一条指向R2的路由，因为ospf引入外部路由默认是type2，OE2的路由先比较外部cost，再比较内部cost，外部cost都为1，内部cost计算方式是&lt;code&gt;100M/接口带宽&lt;/code&gt;，AR3和AR2之间带宽大于100M则cost为1，AR3与AR5之间是用的1M的串口线，则cost为100，那么R3会优选R2&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AR3上针对5.5.5.5路由，不管是负载还是优选R2，在R2访问R5时的路由为R2--&amp;gt;R4--&amp;gt;R1--&amp;gt;R3--&amp;gt;R2，出现环路问题&lt;/p&gt;
&lt;h3 id=&#34;3-解决环路问题&#34;&gt;3. 解决环路问题&lt;/h3&gt;
&lt;p&gt;只在R1上实施双点双向时出现次优路径，然后在R2上再实施双点双向引入，则会出现环路问题，究其原因是在isis区域中已经存在5.5.5.5这条路由，在AR2实施双点双向之后路由回灌导致的环路。此时不仅需要解决次优路径的问题，还需要解决路由回灌的问题&lt;br&gt;
扩展性比较好的方式是通过打tag来解决路由回灌的问题，通过修改ospf外部路由的外部优先级的方式解决次优路径的问题，修改外部路由的优先级的方式有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;所有的外部路由的优先级都修改为10（小于15即可）。这种方式下，如果isis区域引入外部路由，同样会出现次优路径的问题，原因和ospf区域出现次优的原因相同&lt;/li&gt;
&lt;li&gt;只是针对此条外部路由5.5.5.5修改优先级，但如果在引入外部路由6.6.6.6/32，还会出现同样的问题，扩展性很差&lt;/li&gt;
&lt;li&gt;在引入外部路由5.5.5.5/32的时候打上tag，例如tag5，针对这个tag修改ospf的外部路由的优先级，这种方案扩展性比较好，如果引入其他外部路由时，只需要打上tag5即可&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决方案如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R1上实施步骤如下：
&lt;ol&gt;
&lt;li&gt;ospf引入isis的路由打上tag100，同时deny掉tag400&lt;/li&gt;
&lt;li&gt;isis引入ospf的路由打上tag200，同时deny掉tag300&lt;/li&gt;
&lt;li&gt;使用router-policy针对tag5的路由修改优先级为10&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;R2上实施步骤如下：
&lt;ol&gt;
&lt;li&gt;ospf引入isis的路由打上tag300，同时deny掉tag200&lt;/li&gt;
&lt;li&gt;isis引入ospf的路由打上tag400，同时deny掉tag100&lt;/li&gt;
&lt;li&gt;使用router-policy针对tag5的路由修改优先级为10&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;讲法2双点双向存在的问题&#34;&gt;讲法2：双点双向存在的问题&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615476644699.png&#34; alt=&#34;讲法2&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-次优路径&#34;&gt;1. 次优路径&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;R1将网段10.0.0.0/24引入到OSPF&lt;/li&gt;
&lt;li&gt;R2/R3分别将该路由引入ISIS，正常情况下，R2/R3 将路由引入ISIS会有先后，假设R3先于R2将该路由引入到ISIS&lt;/li&gt;
&lt;li&gt;那么R2就会同时从OSPF和ISIS学到10.0.0.0/24的路由，于是R2会根据路由协议的优先级优选通过 ISIS学到的路由（OSPF的外部路由优先级为150，ISIS的路由优先级为15）&lt;/li&gt;
&lt;li&gt;于是，当R2访问10.0.0.0/24网段时，会使用R4-R3-R1这条次优路径&lt;/li&gt;
&lt;li&gt;为了避免出现这种情况，可以在路由器R2上使用route-policy修改OSPF ASE路由的优先级，&lt;code&gt;即在OSPF进程下修改外部路由优先级小于15即可&lt;/code&gt;，使得10.0.0.0/24优先从ospf学到，使得R2选择正确的路由。但是具体的修改方法有以下几种：
&lt;ol&gt;
&lt;li&gt;所有的外部路由的优先级都修改为14，这样isis会出现次优，原因和ospf区域出现次优的原因相同&lt;/li&gt;
&lt;li&gt;只是针对此条外部路由10.0.0.0/24修改，但如果在引入外部路由20.0.0.0/24，还会出现同样的问题，扩展性很差&lt;/li&gt;
&lt;li&gt;比较好的做法是，在引入外部路由10.0.0.0/24的时候打上tag，针对这个tag修改ospf的外部路由的优先级&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-环路&#34;&gt;2. 环路&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;环路是由次优路径导致，即先出现次优路径，然后再导致环路的出现&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-路由回灌导致的环路&#34;&gt;1. 路由回灌导致的环路&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;因为R2和R3认为isis的外部路由更优，引入ospf区域后，会触发R1的选路&lt;/li&gt;
&lt;li&gt;引入时默认的外部路由格式type2，根据选路原则，O&amp;gt;OIA&amp;gt;OE1&amp;gt;OE2，OE2会先比较外部cost，再比较内部cost。&lt;/li&gt;
&lt;li&gt;因为外部cost默认是1，所以开始比较内部cost，R1引入外部路由走的是p2p，cost为48，而R1到R2是以太网，其cost为1，因此R1选择走R2&lt;/li&gt;
&lt;li&gt;形成环路，R2访问外部路由时的路由时R2--R4--R3--R1--R2&lt;/li&gt;
&lt;li&gt;解决方案：&lt;br&gt;
在R2和R3上防止路由回灌，通过先deny再打tag的方式，即使用4个tag即可解决路由回灌导致的环路，在lab实验中做过&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-虚假环路动荡环路&#34;&gt;2. 虚假环路（动荡环路）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果不是通过打tag解决路由回灌导致的环路，而是通过修改优先级的方式解决，则会出现虚假环路的问题&lt;/li&gt;
&lt;li&gt;例如R4的环回口上路由4.4.4.4/32通过import-route方式引入到isis的，此时将其undo掉，这条路由消失，那么他会发送生存周期为0的LSP进行撤销，即毒化LSP&lt;/li&gt;
&lt;li&gt;假设R3先收到该LSP，因为R3也能从ospf区域学到该路由，但是isis优先。此时isis撤销该网段的路由，那么R3再访问4.4.4.4/32时，会选择走ospf区域，因为没有通过打tag的方式抑制路由回灌，就会再次引入isis，导致R2上会出现以下行为：
&lt;ol&gt;
&lt;li&gt;收到isis区域的毒化LSP，会撤销掉之前引入ospf区域的路由&lt;/li&gt;
&lt;li&gt;然后又收到R3给的新的4.4.4.4/32的路由，以为该路由又恢复了，又引入ospf&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;同理，R3上也有相同的问题：有时会收到R2的撤销该路由的LSP，有时又会收到R2能到达该路由的LSP&lt;/li&gt;
&lt;li&gt;因此产生了动荡环路，也叫虚假环路&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;三大协议对ipv6的支持&#34;&gt;三大协议对IPv6的支持&lt;/h1&gt;
&lt;h2 id=&#34;ospf&#34;&gt;ospf&lt;/h2&gt;
&lt;p&gt;ospfv3在ospfv2基础上进行了修改，是一个独立的路由协议，但协议号仍然是89，在IPv6的Next Header字段进行标识&lt;/p&gt;
&lt;h3 id=&#34;1-组播地址&#34;&gt;1. 组播地址&lt;/h3&gt;
&lt;p&gt;ospfv3以组播地址的方式发送协议报文，并且ipv6 hop limit为1；虚连接则通过单播发送更新。&lt;br&gt;
在ospfv2中所有路由器监听的地址为224.0.0.5，那么在IPv6中对应的链路本地地址为FF02::5；&lt;br&gt;
在ospfv2中DR监听的地址为224.0.0.6，那么在IPv6中对应的链路本地地址为FF02::6。&lt;/p&gt;
&lt;h3 id=&#34;2-链路&#34;&gt;2. 链路&lt;/h3&gt;
&lt;p&gt;IPv6中重点强调链路的概念，在IPv6中，一个链路上可以分配多个IP子网，也就是IPv6前缀，同一个链路上的两个节点即使不具有相同的IPv6前缀，也可以直接通过这个链路通信，这点极大的改变了ospf的行为。&lt;br&gt;
opsfv3是基于链路来运行的，ospfv3的路由器使用链路本地地址作为发送报文的源地址，一个路由器可以学习到这个链路上相连的所有其他路由器的链路本地地址，并使用这些链路本地地址作为下一跳来转发报文，这样做有什么好处呢？一是不需要配置IPv6全局地址就可以得到ospfv3拓扑，实现拓扑与地址的分离；二是在本链路上泛洪的报文不会传到其他链路上，从而减少报文不必要的泛洪，节省带宽。&lt;/p&gt;
&lt;h3 id=&#34;3-多实例复用&#34;&gt;3. 多实例复用&lt;/h3&gt;
&lt;p&gt;ospfv3支持在同一链路上运行多个实例，实现链路复用，节约成本。&lt;br&gt;
一个ospfv3物理接口和多个实例绑定，并用不同的实例标识（Instance ID）区分，即ospfv3的单个链路支持运行多个ospfv3实例。&lt;br&gt;
这些运行在同一物理链路上的多个ospfv3实例，分别与链路对端设备建立邻居以及发送报文，互不干扰，充分共享同一链路资源。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615623930020.png&#34; alt=&#34;多实例复用&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过Instance ID可以实现R2和R3建立ospfv3邻居关系，R1和R4也建立ospfv3邻居关系。&lt;/p&gt;
&lt;h3 id=&#34;4-通过routerid唯一标识邻居&#34;&gt;4. 通过RouterID唯一标识邻居&lt;/h3&gt;
&lt;p&gt;ospfv2中，当网络类型为点到点或者虚连接时，通过RouterID来标识邻居，但是当网络类型为广播或者NBMA时，通过邻居接口的IP地址来标识邻居。&lt;br&gt;
ospfv3中取消了这种复杂的标识邻居的方法，不论何种网络，统一采用RouterID来标识邻居&lt;/p&gt;
&lt;h3 id=&#34;5-认证变化&#34;&gt;5. 认证变化&lt;/h3&gt;
&lt;p&gt;ospfv3报文头中不再包含认证字段，而是依赖ipv6的扩展认证头，通过ipv6提供的安全机制来保证自身报文的合法性。&lt;br&gt;
IPSEC有两种安全认证方法：AH和ESP，AH支持认证、完整性校验、防报文重放功能，ESP则更加强大，除了AH的前面几样功能，ESP还支持加密功能&lt;br&gt;
认证配置方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1. 进程或区域认证配置
authentication-mode hmac-sha256 key-id &amp;quot;keyid字符串&amp;quot; plain &amp;quot;密码&amp;quot;
#    或者
authentication-mode hmac-sha256 key-id &amp;quot;keyid字符串&amp;quot; cipher &amp;quot;密码&amp;quot;
# 使用区域验证时，一个区域中所有的设备在该区域下的验证模式和口令必须一致

# 2. 接口下认证【需要绑定实例ID】
undo portswitch # 接口下配置认证，需要先切换到三层
ospfv3 authentication-mode hmac-sha256 key-id &amp;quot;keyid字符串&amp;quot; plain &amp;quot;密码&amp;quot; instance &amp;quot;InstanceID&amp;quot;
#    或者
ospfv3 authentication-mode hmac-sha256 key-id &amp;quot;keyid字符串&amp;quot; cipher &amp;quot;密码&amp;quot; instance &amp;quot;InstanceID&amp;quot;
# 接口验证优于区域验证，同一网段的接口的验证模式和口令必须相同，不同网段可以不同
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;6-stub区域的支持&#34;&gt;6. stub区域的支持&lt;/h3&gt;
&lt;p&gt;ospfv3支持对未知类型LSA的泛洪，为防止大量未知类型LSA泛洪进入stub区域，对于向stub区域泛洪的未知类型LSA进行了明确规定：&lt;code&gt;只有当未知类型LSA的泛洪范围是区域或链路，并且U比特没有置位时，未知类型LSA才可以向stub区域泛洪&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-报文头部的变化&#34;&gt;7. 报文头部的变化&lt;/h3&gt;
&lt;p&gt;ospfv3报文头、Hello、DD以及LSR报文中的字段与ospfv2略有不同，主要有以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;版本号由2变为3&lt;/li&gt;
&lt;li&gt;报文头的不同：&lt;br&gt;
ospfv3的报文头只有16字节，去掉了认证类型字段，但是添加了InstanceID字段&lt;sub&gt;认证类型字段为16bit，实例ID只用8bit，后面还有8bit的0&lt;/sub&gt;，用来支持同一条链路运行多个实例，只在链路本地范围有效，如果路由器收到的的Hello报文中的InstanceID与当前接口配置的InstanceID不同，则无法建立邻居&lt;/li&gt;
&lt;li&gt;Hello报文：去掉了网络掩码字段，增加了InterfaceID，用来标识发送该Hello报文的接口ID&lt;br&gt;
options：ospfv3扩展到24bit，即3字节；而ospfv2只有8bit，即1字节&lt;br&gt;
在ospfv3中，option字段除了在hello报文和DD报文存在，还在1类、2类、8类、9类LSA中出现（ospfv2是所有的LSA中出现），主要增加了R位和V6位：
&lt;ol&gt;
&lt;li&gt;R位：用来标识设备是否具备转发能力，如果为0，则标识该设备不参加路由计算，即该设备不转发非本地地址的报文&lt;/li&gt;
&lt;li&gt;V6位：如果为0，则标识该设备或者链路不会参加IPv6路由计算&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;LSA报文中的LS type由1B扩展到2B，指定LSA的类型，支持了对未知LSA的处理
&lt;ol&gt;
&lt;li&gt;U位：0，未知类型的LSA仅在链路范围内泛洪；1，未知类型的LSA按照LS type字段描述的泛洪范围进行泛洪&lt;/li&gt;
&lt;li&gt;S2/S1位：共同标识LSA的泛洪范围。00表示在产生该LSA的本地链路上泛洪；01标识产生LSA的路由器所在区域；10表示在整个自治系统内；11保留&lt;/li&gt;
&lt;li&gt;LSA Function Code：LSA的类型编码，描述LSA的类型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8-1类和2类&#34;&gt;8. 1类和2类&lt;/h3&gt;
&lt;p&gt;ospfv3移除了IP地址的意义，实现了拓扑和地址的分离，ospfv3中的1类和2类LSA不再包含IP地址。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;RouteLSA不再包含地址信息&lt;/strong&gt;，使能ospfv3的路由器使用8类LSA（Link LSA），将当前接口的链路本地地址以及路由器在这条连路上的一系列ipv6地址信息向该链路上的所有其他路由器通告。&lt;br&gt;
而1类LSA的Link ID改为本地有意义的Interface ID，用来标识拓扑，分为以下3种：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615643651737.png&#34; alt=&#34;RouterLSA的3种类型&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NetworkLSA不再包含路由信息&lt;/strong&gt;，路由信息由9类LSA（Intra Area Prefix LSA，区域内前缀LSA）负责通告，9类LSA通告IPV6地址前缀。二类LSA将头部中的LS ID变为DR的Inteface ID，而且取消了掩码字段，仅仅用来描述拓扑连接情况&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;9-增加2种lsa&#34;&gt;9. 增加2种LSA&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;8类LSA，链路LSA&lt;br&gt;
每个设备都会为每个链路产生一个8类LSA，仅在此链路内传播。向链路上的其他路由器通告本地链路地址，作为他们的下一跳；向链路上的其他路由器通告本地链路上的所有IPv6前缀；在广播或者NBMA网络上为DR提供Options取值&lt;br&gt;
&lt;code&gt;8类LSA泛洪范围是链路本地，并且收到8类LSA的邻居并不会将该LSA通告给任何人。只在本地链路上传递信息是不够的，还需要在区域内传播，因此产生了9类LSA，在区域内通告路由前缀&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ospfv2中，LSDB通过描述一个有向线段图来描述网络拓扑结构，该有向图的端点有三种类型，路由器节点、Stub网段、Transit网段，依附于路由器节点和stub网段的subnet（子网）出现在1类LSA中，依附于Transit网段的subnet出现在2类LSA中，但是ospfv3中的1类和2类LSA不再包含地址信息，所以引入9类LSA（即区域内前缀LSA）来描述这些信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;9类LSA，区域内前缀LSA&lt;br&gt;
每个设备及DR都会产生至少一个9类LSA，在所属区域内传播。&lt;br&gt;
设备上产生的9类LSA描述与1类LSA相关联的IPv6前缀地址；而DR产生的描述的是与2类LSA相关联的IPv6前缀地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;isis&#34;&gt;isis&lt;/h2&gt;
&lt;h3 id=&#34;1-新增2种tlv和1个nlpid&#34;&gt;1. 新增2种TLV和1个NLPID&lt;/h3&gt;
&lt;p&gt;为了支持IPv6的路由计算，isis新增2种TLV和1个网络层协议标识符NLPID&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;232号TLV：相当于ipv4中的132号TLV（接口IP地址tlv），只不过把原来32位的地址改为128位的地址。对于Hello报文，接口地址只能包含发送hello报文接口的链路本地地址；但是对于LSP报文，接口地址只能包含分配给设备接口的非链路本地地址&lt;/li&gt;
&lt;li&gt;236号TLV：通过定义路由信息前缀、度量值等信息来说明网络的可达性，相当于ipv4中的128号（IP内部可达性TLV）和130号TLV（IP外部可达性TLV）之和，通过X位来标识IPv6内部和外部可达性信息&lt;/li&gt;
&lt;li&gt;129号TLV（协议支持TLV）新增一个NLPID，NLPID是用来标识网络层协议报文的8比特字段，IPv6的NLPID值为142（0x8E，IPv4是204，0xCC），如果isis支持IPv6，那么向外发布IPv6路由时必须携带此NLPID值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-isis多拓扑&#34;&gt;2. isis多拓扑&lt;/h3&gt;
&lt;p&gt;isis单拓扑存在的问题：&lt;br&gt;
混合拓扑中，一些设备或者链路如果不支持ipv6协议，但是支持ipv6的设备又无法感知到，仍然将ipv6报文转发给他们，导致ipv6报文无法继续转发而丢弃&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615651052163.png&#34; alt=&#34;isis多拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为了维护相同的拓扑，所有接口都必须同时运行isis ipv4和isis ipv6，部署十分不灵活。isis多拓扑就是为了解决此问题而出现的。&lt;br&gt;
一个isis自治域内运行多个独立的ip拓扑，例如ipv4拓扑和ipv6拓扑，这有利于isis在路由计算时根据实际组网情况来单独考虑ipv4和ipv6网络，根据链路所支持的IP协议，不同的拓扑分别进行SPF计算。&lt;br&gt;
在isis多拓扑中，为了实现多拓扑的相互隔离，定义了4种新TLV：222（多拓扑中间系统）、229（多拓扑标识符）、235（多拓扑可达ipv4前缀）、237（多拓扑可达ipv6前缀）&lt;/p&gt;
&lt;h2 id=&#34;bgp&#34;&gt;bgp&lt;/h2&gt;
&lt;p&gt;bgp4+中引入的两个NLRI属性（可选非传递属性）分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MP_Reach_NLRI（14）：多协议可达NLRI，用于发布可达路由和下一跳信息。该属性由至少一个三元组&lt;code&gt;&amp;lt;地址族信息(3B)、下一跳信息(可变)、前缀信息(可变)&amp;gt;&lt;/code&gt;组成
&lt;ol&gt;
&lt;li&gt;地址族信息：由2B的AFI和1B的SAFI组成，ipv6的AFI编码为2，单播时SAFI为1，组播时SAFI为2，vpn路由的SAFI为128&lt;/li&gt;
&lt;li&gt;下一跳信息：1B的下一跳地址长度  和  可变长度的下一跳地址组成&lt;/li&gt;
&lt;li&gt;前缀信息：放在该属性的NLRI字段传递，不同的地址族格式不同。至少一个三元组&lt;code&gt;&amp;lt;长度(1B)、标签(可变)、前缀(可变)&amp;gt;&lt;/code&gt;组成
&lt;ol&gt;
&lt;li&gt;长度：标签域和前缀域的&lt;strong&gt;总比特数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;标签：至少一个标签，&lt;strong&gt;每个标签长度为3字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;前缀：前缀域由RD和IP地址前缀组成&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;MP_UnReach_NLRI（15）：多协议不可达NLRI，用于撤销路由。该属性由至少一个二元组&lt;code&gt;&amp;lt;地址族信息(3B)、撤销路由(可变)&amp;gt;&lt;/code&gt;组成
&lt;ol&gt;
&lt;li&gt;地址族信息和MP_Reach_NLRI相同&lt;/li&gt;
&lt;li&gt;撤销路由（Withdrawn Routes）：和MP_Reach_NLRI前缀信息中的NLRI内容相同。当撤销路由时，如果指定了标签，只有指定了标签的路由被撤销；如果没有指定标签，只有不带标签的路由被撤销。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;bgp4+中的Next_Hop属性用IPv6地址来表示，可以是IPv6的全球单播地址或者链路本地地址&lt;br&gt;
下一跳地址长度字段决定了下一跳地址的个数，长度为16时，下一跳地址为下一跳路由器的全球单播地址，长度为32时，再加一个链路本地地址。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ospf-isis-bgp路由撤销以及报文&#34;&gt;ospf、isis、bgp路由撤销以及报文&lt;/h1&gt;
&lt;h2 id=&#34;1-ospf路由撤销&#34;&gt;1. ospf路由撤销&lt;/h2&gt;
&lt;p&gt;在ospf中以lsa去承载路由信息，ospf中撤销路由就是撤销lsa或更新这条lsa，即撤销报文都是LSU。&lt;br&gt;
&lt;code&gt;撤销方式有3种：1. 更新，发送一条序列号加1的LSA，该LSA不包含原来的路由，针对还有其他路由的LSA；2. 老化，将原来LSA的age设置为3600之后发出去，针对已经没有路由的LSA（更新的LSA的优先级要大于老化LSA的优先级）；3. 设备故障，不能主动发送LSA撤销，其他设备执行ISPF，该lsa在3600后撤销&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;域内1类和2类&#34;&gt;域内（1类和2类）&lt;/h3&gt;
&lt;h4 id=&#34;1类lsa的撤销&#34;&gt;1类lsa的撤销&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1617188030292.png&#34; alt=&#34;1类-1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;情景1：R1的环回口去使能之后，&lt;strong&gt;R1会发送一条新的的1类LSA撤销环回口的路由&lt;/strong&gt;，R2收到之后更新LSDB&lt;code&gt;更新&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;情景2：R1与R2之间的链路故障之后，触发ispf算法，此时R1和R2上均有两条1类LSA，一条是自己产生的、一条是邻居产生的，此时&lt;strong&gt;自动撤销自身产生的1类LSA&lt;/strong&gt;，不需要发送LSA，至于&lt;strong&gt;邻居产生的，只能等待3600进行自然老化&lt;/strong&gt;&lt;code&gt;不能撤销非自身产生的&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617188407457.png&#34; alt=&#34;1类-2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;场景3：R1与R2之间的链路故障，此时R1、R2、R3上各有3条1类LSA，&lt;strong&gt;R2和R3上的R1的1类LSA只能等待3600秒之后自然老化&lt;/strong&gt;，但是R2和R3自身产生的1类LSA不会撤销，因为其还有存在的必要。此种情况下会触发R2的ispf算法，如果R2是DR，还会触发2类LSA的更新&lt;code&gt;不能撤销非自身产生的&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2类lsa的撤销&#34;&gt;2类lsa的撤销&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;非DR故障&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617189076935.png&#34; alt=&#34;2类-1&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;场景1：R1与R2之间的链路故障，因为此时描述R1与R2之间联系的这个2类LSA已经没有路由了，所以将原来的LSA的age=3600进行路由撤销&lt;code&gt;老化&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617189371287.png&#34; alt=&#34;2类-2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;场景2：R1故障之后，除了触发R2和R3的ispf算法进行路由收敛之外，R3作为DR还要进行2类LSA的更新，将序列号加1，此条LSA中不再包含R1与R3之间的网段的链路状态信息&lt;code&gt;更新&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DR故障&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617189371287.png&#34; alt=&#34;2类-2&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;场景3：R3作为DR故障之后，触发R1和R2的ispf算法进行路由收敛，R2作为BDR会变成DR，同时选举R1作为BDR，R2会发送一条新的LSA来描述R1与R2之间的网段，关于R3的二类LSA只能等待3600秒自然老化&lt;code&gt;不能撤销非自身产生的&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;场景4：如果在3600秒之内，R3恢复了，那么R3只能成为DR other，此时从R2处同步到lsdb后，发现之前自身发送的2类LSA，此时会将此条LSA的age修改为3600秒之后进行撤销&lt;code&gt;老化&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;域间和域外3类-4类-5类和7类&#34;&gt;域间和域外（3类、4类、5类和7类）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;该三种LSA的撤销方式一致，通过发送3600秒的LSA，只不过5类和7类的LSA只有当OSPF引入了外部路由的时候才产生，而3类LSA则是当添加或撤销路由时候ABR向其它区域通告的&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;3类lsa的撤销&lt;/strong&gt;&lt;br&gt;
ABR会产生一条3类LSA，age=3600秒，ospf的LSA最大老化时间为3600秒，当达到最大老化时间后该LSA将不可用，路由器就会删除与该LSA相关的路由，以此来撤销路由&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4类lsa的撤销&lt;/strong&gt;&lt;br&gt;
4类LSA由ABR设备发送，只有不存在ASBR的区域才会存在描述该ASBR的4类LSA，如果该ASBR不再引入外部路由或者已经不是ASBR了，即ASBR所在区域的1类LSA的E比特为为0了，则由ABR撤销该4类LSA，方式是age=3600&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5类lsa的撤销：外部路由&lt;/strong&gt;&lt;br&gt;
5类和7类lsa产生的路由，当产生该5类或7类的ASBR不引入某路由后，ASBR会产生一条Age=3600秒的lsa向相应区域进行泛洪，路由器收到后就会5、7类lsa对应的路由条目撤销&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ospfv3&#34;&gt;OSPFv3&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ospfv3中1类和2类LSA用来描述拓扑信息，只有3类、4类、5类、7类描述路由信息，撤销方式与v2相同，均使用age=3600的方式。&lt;/li&gt;
&lt;li&gt;增加2类LSA，8类LSA（链路LSA）和9类LSA（区域内前缀LSA）：
&lt;ol&gt;
&lt;li&gt;8类LSA通告的是链路本地地址和网络前缀（只有配置了全局单播地址或者唯一本地地址才会有网络前缀），8类LSA的撤销是通过序列+1的方式进行撤销，告知邻居撤销该路由&lt;/li&gt;
&lt;li&gt;9类LSA分为Router（实节点）和Network（伪节点）
&lt;ol&gt;
&lt;li&gt;Router的撤销方式为序列号+1&lt;/li&gt;
&lt;li&gt;Network的撤销方式，如果该LSA中不再包含可用的路由则采用age=3600的方式，如果还包含可用的路由则采用序列号+1的方式&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-isis路由撤销&#34;&gt;2. isis路由撤销&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;撤销方式有两种：1. 进程下使用import-route引入的路由撤销，通过发送生存周期为0的报文撤销；2. 接口下使能isis的路由撤销，通过发送新的不包含该路由的lsp（序列号加1）撤销&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;撤销内部路由&#34;&gt;撤销内部路由&lt;/h3&gt;
&lt;p&gt;isis 的路由信息是封装在lsp的tlv中的&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613195503931.png&#34; alt=&#34;isis路由撤销&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当R8在&lt;strong&gt;isis进程下将lo0去使能后&lt;/strong&gt;&lt;sub&gt;通过import-route引入的直连路由&lt;/sub&gt;，R8会&lt;strong&gt;将原来的这份lsp的remaining lifetime时间变为0&lt;/strong&gt;发出，撤销这条lsp，从而撤销这条路由&lt;/li&gt;
&lt;li&gt;当R8在lo0&lt;strong&gt;接口下将isis去使能后&lt;/strong&gt;， R8会产生一个不携带lo0接口信息的lsp，序列号加1，在L2区域泛洪，其他路由器收到该lsp后重新收敛计算，把路由表中的关于R8的lo0接口的路由撤销&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;撤销外部路由&#34;&gt;撤销外部路由&lt;/h3&gt;
&lt;p&gt;撤销外部路由的时候会&lt;strong&gt;将原来的lsp的remaining lifetime时间变为0&lt;/strong&gt;发出，撤销这条lsp，从而撤销这条路由&lt;br&gt;
&lt;strong&gt;当生存周期减到0后该LSP不可用&lt;/strong&gt;，再等60sLSP从数据库中删除，路由删除，该60秒称为零老化时间，在该时间内，路由器会向网络通告撤销的lsp，该lsp里的剩余生存时间为0秒，用于加速网络收敛，收到该lsp的路由器会将路由删除。&lt;/p&gt;
&lt;h2 id=&#34;3-bgp路由撤销&#34;&gt;3. bgp路由撤销&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;bgp使用Update报文来携带被撤销的路由&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613195991269.png&#34; alt=&#34;bgp路由撤销&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R3在bgp中通告3.3.3.3/32位路由，R1和R2上均有此路由。当R2的g0/0/1接口down之后，R2会向R1发送update报文，撤销掉它此前向R1通告的该路由&lt;br&gt;
该update报文中Withdrawn Routes Length表示Withdrawn Routes字段的数据长度，如果Withdrawn Routes Length字段数值为0，则表示Withdrawn Routes字段没有任何数据。Withdrawn Routes是撤销路由，该字段包括一系列的IP地址前缀信息，以&lt;code&gt;&amp;lt;length, prefix&amp;gt;&lt;/code&gt;的格式来表示，比如&lt;code&gt;&amp;lt;19,198.18.160.0&amp;gt;&lt;/code&gt;表示一个&lt;code&gt;198.18.160.0 255.255.224.0&lt;/code&gt;的网络&lt;br&gt;
如果撤销一条多协议BGP（MP-BGP）路由，是通过可选非传递属性MP_UnReach_NLRI来撤销的，该属性由至少一个二元组&lt;code&gt;&amp;lt;地址族信息(3B)、撤销路由(可变)&amp;gt;&lt;/code&gt;组成，其中地址族信息包含2B的AFI和1B的SAFI，撤销路由是由至少一个&lt;code&gt;&amp;lt;长度(1B)、标签(可变)、前缀(可变)&amp;gt;&lt;/code&gt;三元组组成&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ipv4和ipv6报文头部的不同&#34;&gt;IPv4和IPv6报文头部的不同&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;IPv6相比IPv4有哪些优势?&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;地址空间更大&lt;/li&gt;
&lt;li&gt;报头格式更简单&lt;/li&gt;
&lt;li&gt;IPv6有状态/无状态自动配置和重新编址&lt;/li&gt;
&lt;li&gt;IPv6端到端的路由，没有NAT转换&lt;/li&gt;
&lt;li&gt;网络层支持IPSec的认证和加密，支持端到端的安全&lt;/li&gt;
&lt;li&gt;IPv6新增了流标记域，提供QoS保证&lt;/li&gt;
&lt;li&gt;IPv6支持移动性更好&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;IPv4报文头部：&lt;code&gt;可变长度，最少20B&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617198193966.png&#34; alt=&#34;IPv4报文头部&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IPv6报文头部：&lt;code&gt;固定长度40B，其中32字节的地址，剩下的8字节只有版本、流量类型、流标签、净载荷长度、下一个头部和跳数限制&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617198222668.png&#34; alt=&#34;IPv6报文头部&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
整体对比：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617199020251.png&#34; alt=&#34;整体对比&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IPv4中的&lt;strong&gt;主要字段&lt;/strong&gt;都已经被IPv6继承了，而删除的一部分确实没必要的字段，还有一部分字段可以使用扩展头部的形式出现在IPv6报文里。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;删除的内容&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;头部长度：头部没有选项字段，头部长度固定为40B，所有不再需要头部长度字段&lt;/li&gt;
&lt;li&gt;用于分片的（标识、DF、MF、分段偏移）：IPv6分段使用分段扩展头，并且IPv6分片与重组只能在源与目的地上执行，不允许在中间路由器进行&lt;/li&gt;
&lt;li&gt;头部校验：使用认证扩展头AH，进行报文验证和完整性检查，并且在TCP和UDP报文中都已经有了16位的校验字段&lt;/li&gt;
&lt;li&gt;选项字段：使用扩展头来扩展功能，不再需要选项字段&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;增加的内容&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;流标签：使用流标签标识流的好处如下
&lt;ol&gt;
&lt;li&gt;更加方便的标识流：通过流标签、源地址、目的地址三元组方式就可以唯一标识一条通信流，而IPv4需要使用五元组&lt;/li&gt;
&lt;li&gt;降低转发路由器负担：因为不需要端口号来确定流，也就不需要解析传输层协议&lt;/li&gt;
&lt;li&gt;便于对IPSec报文做QoS处理：流标签在IPv6基本头中，使用IPSec时对转发路由器可见，因此转发路由器可以在使用IPv6报文IPSec的情况下仍然可以通过三元组针对特定的流进行QoS处理，而ipv4中使用ipsec时由于其上层数据被加密，转发路由器无法解析，从而无法进行QoS&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;继承的内容&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;版本&lt;/li&gt;
&lt;li&gt;服务类型TOS=流量类别Traffic Class：基本相同，标识对应的通信流类别，或者说是优先级别&lt;/li&gt;
&lt;li&gt;总长度--&amp;gt;净载荷长度：ipv4中的总长度包含头部&lt;code&gt;MTU定义不同：ipv4的MTU=ipv4头部+净载荷；ipv6的MTU=ipv6头部+扩展头+净载荷&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;协议=下一个头部：两者功能类似，ipv4协议字段规定了净载荷交由哪种协议来处理，ipv6中的Next Header字段可选择性的指向下一个扩展头部或者协议&lt;/li&gt;
&lt;li&gt;TTL=Hop Limit：最初的IPv4的TTL协议规定的是分段传输的最大时间，但实际上，所有的操作都用跳数来取代了时间，因此，IPv6直白的使用Hop Limit来限定传输时间。当然两者功能相同，都有效的阻止了数据分段在网络停留太久时间而陷入无限循环的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;三层交换机和路由器收到未知表项如何处理&#34;&gt;三层交换机和路由器收到未知表项如何处理&lt;/h1&gt;
&lt;h2 id=&#34;转发原理的区别&#34;&gt;转发原理的区别&lt;/h2&gt;
&lt;h3 id=&#34;1-路由器&#34;&gt;1. 路由器&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;路由器由&lt;strong&gt;基于软件路由引擎执行数据包交换&lt;/strong&gt;，而路由器的转发&lt;strong&gt;采用最长匹配的方式，转发效率较低&lt;/strong&gt;&lt;code&gt;即利用IP地址来确定转发的地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当路由器收到单播报文，会查找FIB
&lt;ol&gt;
&lt;li&gt;如果FIB中有对应表项则按照对应表项进行转发&lt;/li&gt;
&lt;li&gt;如果没有表项则丢弃报文&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当路由器收到组播报文
&lt;ol&gt;
&lt;li&gt;若未开启组播路由功能则丢弃&lt;/li&gt;
&lt;li&gt;如果开启组播路由功能，则按照组播路由表项进行转发；如果没有表项，则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当路由器收到广播报文（目的地址为255.255.255.255）接收处理，不往外转发和泛洪&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-交换机&#34;&gt;2. 交换机&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;三层交换机通过&lt;strong&gt;硬件执行交换&lt;/strong&gt;，其三层功能是通过划分不同的Vlan实现的，配置vlan之后会分配相应的IP，自动生成mac&lt;code&gt;即利用MAC地址来确定转发数据的目的地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当三层交换机收到一单播，判断此以太网帧的目的MAC地址是否为自己
&lt;ol&gt;
&lt;li&gt;如果不是自己，查看MAC地址表
&lt;ol&gt;
&lt;li&gt;如果MAC地址表中有对应表项则按照对应表项进行转发&lt;/li&gt;
&lt;li&gt;如果没有表项则在同一广播域中泛洪&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果目的MAC为自己则三层转发，三层交换机在对第一个数据流进行路由后，将产生一个MAC地址与IP地址的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过，从而消除网络延迟，提高数据包转发的效率。同时，三层交换机的路由查找是针对数据流的，它利用缓存技术，实现快速转发。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当交换机收到组播报文或广播报文就在同一广播域中泛洪处理，同时泛洪的接口包括vlanif接口，交由三层转发引擎进行基于IP的处理
&lt;ol&gt;
&lt;li&gt;若未开启组播路由功能则丢弃，如果开启组播路由功能，则按照组播路由表项进行转发，如果没有表项，则丢弃&lt;/li&gt;
&lt;li&gt;若收到广播报文，会把ARP二层解封装，查看ARP里面的内容，看一下请求的ip地址是不是三层交换机vlan interface的IP地址，如果是就回复，否则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;处理流程区别&#34;&gt;处理流程区别&lt;/h2&gt;
&lt;h3 id=&#34;1-路由器-2&#34;&gt;1. 路由器&lt;/h3&gt;
&lt;p&gt;首先查看mac地址第8比特：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果为0，说明是&lt;strong&gt;单播报文&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;如果mac地址不是路由器本身接口的mac，直接丢弃&lt;/li&gt;
&lt;li&gt;如果mac地址是路由器本身接口的mac，则解封装查看三层目的IP地址
&lt;ol&gt;
&lt;li&gt;如果目的IP是接口IP，则交给接口处理&lt;/li&gt;
&lt;li&gt;如果目的IP不是接口IP，则去查找路由表，如果有相应表项则重新封装转发出去，否则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果为1，说明是&lt;strong&gt;组播和广播报文&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;如果mac地址不是全1，说明是&lt;strong&gt;组播报文&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;未开启组播功能则丢弃&lt;/li&gt;
&lt;li&gt;开启组播功能，如果有相应的组播表项，则按照组播表项转发；否则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果mac地址全为1，说明是广播报文（ARP请求报文），然后进行解封装，查看ARP请求的IP地址
&lt;ol&gt;
&lt;li&gt;如果是路由器的接口地址则进行回应&lt;/li&gt;
&lt;li&gt;如果不是路由器的接口地址，则查看是否开启ARP代理
&lt;ol&gt;
&lt;li&gt;如果没有开启，则直接丢弃&lt;/li&gt;
&lt;li&gt;如果开启了，则判断有没有去往目的IP的路由，有则去做代理，否则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-交换机-2&#34;&gt;2. 交换机&lt;/h3&gt;
&lt;p&gt;首先查看mac地址第8比特：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果为0，说明是&lt;strong&gt;单播报文&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;如果目的mac是交换机的mac，则解封装之后交给三层处理&lt;br&gt;
在对第一个数据流进行路由后，将产生一个MAC地址与IP地址的映射表，当同样的数据流再次通过时，将根据此表直接从二层通过&lt;/li&gt;
&lt;li&gt;如果目的mac不是交换机的mac，查看mac地址表项
&lt;ol&gt;
&lt;li&gt;如果存在则直接进行二层转发&lt;/li&gt;
&lt;li&gt;如果没有，则进行未知单播帧的泛洪&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果为1，说明是组播和广播报文
&lt;ol&gt;
&lt;li&gt;如果mac地址不是全1，则为&lt;strong&gt;组播报文&lt;/strong&gt;，&lt;strong&gt;首先&lt;/strong&gt;同一vlan内进行泛洪，&lt;strong&gt;其次&lt;/strong&gt;交给三层处理
&lt;ol&gt;
&lt;li&gt;如果未开启组播功能则丢弃&lt;/li&gt;
&lt;li&gt;如果开启组播功能，则按照组播路由表项进行转发，如果没有表项，则丢弃&lt;br&gt;
&lt;code&gt;只有PIM和IGMP组播报文才会交给CPU处理，即MAC是01-00-5E的报文一律交给CPU处理，主要是为了减轻CPU负担&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果mac地址全是1，则为ARP请求报文，&lt;strong&gt;首先&lt;/strong&gt;在同一vlan内进行泛洪，&lt;strong&gt;其次&lt;/strong&gt;交给三层解封状处理
&lt;ol&gt;
&lt;li&gt;如果请求的IP为交换机vlan的IP，则进行回应&lt;/li&gt;
&lt;li&gt;如果不是则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;补充&#34;&gt;补充&lt;/h2&gt;
&lt;h3 id=&#34;如何区别单播还是组播&#34;&gt;如何区别单播还是组播？&lt;/h3&gt;
&lt;p&gt;根据数据帧中的目的MAC进行识别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果MAC地址的第8bit为1则为广播或者组播，进行泛洪处理；&lt;/li&gt;
&lt;li&gt;如果为0则为单播，根据mac地址表信息进行转发、泛洪或者丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;未知单播帧和广播帧泛洪的区别&#34;&gt;未知单播帧和广播帧泛洪的区别？&lt;/h3&gt;
&lt;p&gt;未知单播帧泛洪：数据帧的目的mac不在本地mac地址表中，则进行泛洪处理&lt;br&gt;
广播帧泛洪：数据帧的目的mac全为1，则进行泛洪处理&lt;/p&gt;
&lt;h3 id=&#34;二层广播和三层广播的区别&#34;&gt;二层广播和三层广播的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;产生原因&lt;/strong&gt;：二层广播是由于不知道目的mac而产生的，而三层广播是由于应用层协议的需求产生的，例如DHCP的发现报文、RIP的请求报文等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理方式&lt;/strong&gt;：交换机对于二层或者三层广播报文都是在广播域内泛洪；而路由器对于三层广播目的地址255.255.255.255的数据是交给CPU处理的，对于二层ARP广播可以开启ARP代理来处理。也就是说二层交换机隔离了冲突域，但是没有隔离广播域，而三层路由器可以终结广播，但是仍然可以处理广播&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;交换机处理数据的行为&#34;&gt;交换机处理数据的行为：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;泛洪：收到未知单播帧、组播帧、广播帧时会进行泛洪处理&lt;/li&gt;
&lt;li&gt;转发：收到已知单播帧&lt;/li&gt;
&lt;li&gt;丢弃：单播帧的入接口和出接口相同时则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;交换机和路由器的流量整形出接口的区别&#34;&gt;交换机和路由器的流量整形出接口的区别&lt;/h1&gt;
&lt;h2 id=&#34;1-路由器整形&#34;&gt;1. 路由器整形&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1617602693660.png&#34; alt=&#34;路由器整形场景&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;整形一般在&lt;strong&gt;出方向&lt;/strong&gt;上做，原因如下：
&lt;ol&gt;
&lt;li&gt;入方向没有缓存队列&lt;/li&gt;
&lt;li&gt;假如上游设备出方向做了整形，即数据来源方向做了整形，那么下游设备的入方向就不会出现超出流量了&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在路由器上整形如何配置？
&lt;ol&gt;
&lt;li&gt;基于接口整形&lt;code&gt;qos gts cir cbs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基于队列整形&lt;code&gt;qos queue-profile&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;基于MQC实现流量整形&lt;code&gt;traffic behavior gts cir cbs&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;令牌桶使用单速单桶&lt;br&gt;
&lt;code&gt;gts只能用在路由器接口，交换机做不了GTS，交换机的接口为二层接口，而二层接口无法配置GTS，因为GTS是针对三层流量&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-交换机整形&#34;&gt;2. 交换机整形&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1617603003957.png&#34; alt=&#34;交换机整形&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;也是在出方向上整形&lt;/li&gt;
&lt;li&gt;交换机的整形配置：
&lt;ol&gt;
&lt;li&gt;基于队列&lt;code&gt;qos queue cir cbs pir pbs&lt;/code&gt;，加入pir=cir&lt;sub&gt;即P桶=C桶&lt;/sub&gt;那么相当于效果是单速单通一样的&lt;/li&gt;
&lt;li&gt;基于接口，使用接口限速&lt;code&gt;qos lr outbound&lt;/code&gt;，但此种情况限速的cir必须大于等于队列整形的cir之和&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;令牌桶使用双速双桶&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;路由器使用的是单速单通，交换机使用的是双速双桶&lt;/li&gt;
&lt;li&gt;路由器可以基于队列、MQC和接口；而交换机只能基于队列和接口做qos lr限速&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;什么是令牌桶技术&lt;br&gt;
单速单桶，cir cbs，承诺信息速率。若一个数据包大于C桶中令牌，则为红色不通过；小于C桶令牌，则通过标记绿色&lt;br&gt;
单速双桶，cir cbs ebs，承诺突发。若一个数据包小于C桶中令牌标记为绿色，减少C桶令牌数量；若大于C桶令牌，小于E桶令牌，则为黄色，减少E桶令牌数量；若大于CE中令牌，则标记红色&lt;br&gt;
双速双桶，cir pir cbs pbs，峰值突发。若一个数据包小于C桶P桶，则为绿色，同时减少CP两桶令牌，标记为绿色；若大于C小于P，则标记黄色，只减少P桶令牌；若大于P则报文标记为红色&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## 三层交换机和路由器的区别
`交换谋快，路由谋转`
### 1. 硬件
`三层交换机在网络收敛上慢于路由器并且抵抗网络震荡的能力也弱`
三层交换机是通过交换芯片转发数据的，路由器则是通过cpu转发数据的
### 2. 数据的处理方式
`三层交换机在数据转发上的速度要优于路由器`
三层交换机的首包通过cpu转发，同时通过arp协议建立交换芯片硬件表项（mac地址与ip地址的映射表），后续报文通过交换芯片直接硬件转发，即`一次路由，多次交换`，交换机的硬件三层表项中只包含了目的地址、目的ip对应的mac地址、出口vlan及端口。
路由器通过路由表选择路由后，将该路由下发到FIB（转发信息表）表中，数据到达路由器时，通过FIB表的最长匹配原则查表转发。
## 3. 功能
路由器提供包括分组过滤、分组转发、优先级、复用、加密、 压缩和防火墙等功能，并且接口类型丰富，支持的三层功能强大，支持负载分担、链路备份、nat转换等，路由器在大型网络中的协议计算，路由表大小，收敛时间等都优于三层交换机。
三层交换机的优点在于可以加快局域网内数据的交换，并且加入路由功能也是为这个目的服务的。一般将三层交换机运用于网络的核心层和汇聚层。
## 处理报文的区别
对于路由器来讲，是一个三层设备，当然兼具二层的功能；
三层交换机**配置vlan interface接口，配完后就会有一个IP地址，同时有一个IP地址所对应的mac地址**
### 1. 单播
1. 路由器：
若收到一个二层单播帧，要判断这个帧的**目的mac地址是不是接口的mac地址**：
    1. 如果目的mac**不是接口的mac地址**，直接丢掉
    2. 如果是，解封装去看**三层目的ip地址**，再看三层**目的ip地址是不是接口的ip地址**：
        1. 如果是，交给接口处理
        2. 如果不是，去查找路由表，然后重新去做一个二层帧的封装，继续往下查找
2. 交换机：
    1. 如果**不是交换机的mac地址**，去看mac地址转发表
        1. 如果有，直接二层转发，不需要上送到三层
        2. 如果没有，未知单播泛洪
    2. 如果收到的**目的mac地址是交换机的mac地址**的话，先把二层帧解封装，把它送给三层处理，去查找路由表
### 2. 组播
1. 路由器：
若收到一个二层组播帧，要看路由器的接口有没有加入这个组
    1. 缺省情况下，路由器接口加入了224.0.0.1、224.0.0.2（使能了组播功能就加入了）
    2. 如果路由器接口没有加入到这个组播组，那么丢弃
2. 交换机：
    1. 若收到一个二层组播帧，朝着所有端口泛洪
    2. 并且把组播帧解封装，送到vlan interface接口，看一下接口有没有加入到这个组，如果加入了要去响应或者处理， 否则不会响应也不会处理
### 3. 广播
1. 路由器
    1. 如果是arp广播，它就会解封装，**看arp信息里请求的ip地址是谁**
        1. 如果请求的**是路由器所在接口的IP地址**，则进行响应
        2. 如果说请求的IP地址**不是路由器接口的IP地址**
            1. 路由器**没有开启ARP代理**，则丢弃
            2. 开启了ARP代理，路由器去判断有没有去往目标网段的路由，如果有，就去做代理
2. 交换机
    1. 若收到一个二层广播帧，比如ARP广播，那么这种情况下，会朝着所有接口去泛洪
    2. 除此之外，因为是三层交换机，会把ARP二层解封装，查看ARP里面的内容，看一下**请求的ip地址是不是三层交换机vlan interface的IP地址**，如果是就回复，否则丢弃
&lt;/code&gt;&lt;/pre&gt;
">面试题目补充</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/qos/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#3%E7%A7%8D%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B&#34;&gt;3种服务模型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%B0%BD%E5%8A%9B%E8%80%8C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B&#34;&gt;1. 尽力而为服务模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BB%BC%E5%90%88%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B&#34;&gt;2. 综合服务模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%8C%BA%E5%88%86%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E6%9C%80%E5%B9%BF&#34;&gt;3. 区分服务模型（应用最广）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB%E4%B8%8E%E6%A0%87%E8%AE%B0&#34;&gt;分类与标记&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#qos%E6%8A%A5%E6%96%87%E5%88%86%E7%B1%BB%E6%96%B9%E5%BC%8F&#34;&gt;QoS报文分类方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%A4%8D%E6%9D%82%E6%B5%81%E5%88%86%E7%B1%BBmqc%E6%B5%81%E5%88%86%E7%B1%BB&#34;&gt;1. 复杂流分类（MQC流分类）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%AE%80%E5%8D%95%E6%B5%81%E5%88%86%E7%B1%BBqos%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%B1%BB&#34;&gt;2. 简单流分类（QoS优先级分类）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#phb&#34;&gt;PHB&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-be000-000%E5%B0%BD%E5%8A%9B%E8%80%8C%E4%B8%BAbest-effort&#34;&gt;1. BE(000 000)（尽力而为，Best-effort）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-afxxx-xx-0%E7%A1%AE%E4%BF%9D%E8%BD%AC%E5%8F%91assured-forwarding&#34;&gt;2. AF(xxx xx 0)（确保转发，Assured Forwarding）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-ef101-11-0%E5%BF%AB%E9%80%9F%E8%BD%AC%E5%8F%91expedited-forwarding&#34;&gt;3. EF(101 11 0)（快速转发，Expedited Forwarding）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-cs&#34;&gt;4. CS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dscp%E5%B7%AE%E5%88%86%E6%9C%8D%E5%8A%A1%E4%BB%A3%E7%A0%81%E7%82%B9%E5%92%8Cippip%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;DSCP（差分服务代码点）和IPP（ip优先级）的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95&#34;&gt;配置方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cos%E5%92%8Ctos%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;COS和TOS的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F&#34;&gt;优先级映射方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D&#34;&gt;拥塞避免&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%BC%A0%E7%BB%9F%E7%9A%84%E5%B0%BE%E9%83%A8%E4%B8%A2%E5%8C%85%E7%AD%96%E7%95%A5&#34;&gt;1. 传统的尾部丢包策略&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#tcp%E5%85%A8%E5%B1%80%E5%90%8C%E6%AD%A5&#34;&gt;TCP全局同步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mss%E5%92%8Cmtu%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;MSS和MTU的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-wred&#34;&gt;2. WRED&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95-2&#34;&gt;配置方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8B%A5%E5%A1%9E%E7%AE%A1%E7%90%86&#34;&gt;拥塞管理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E7%9A%84%E6%8B%A5%E5%A1%9E%E7%AE%A1%E7%90%86&#34;&gt;1. 基于队列的拥塞管理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B0%83%E5%BA%A6%E6%96%B9%E6%B3%95%E5%88%86%E7%B1%BB&#34;&gt;调度方法分类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-fifo%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E5%B0%BD%E5%8A%9B%E8%80%8C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%A8%A1%E5%9E%8B%E4%BD%BF%E7%94%A8&#34;&gt;1. FIFO（先进先出，尽力而为服务模型使用）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-pq%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97&#34;&gt;2. PQ（优先级队列）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-rr%E8%BD%AE%E8%AF%A2&#34;&gt;3. RR（轮询）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-wrr%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2%E9%98%9F%E5%88%97&#34;&gt;4. WRR（加权轮询队列）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-fq%E5%85%AC%E5%B9%B3%E9%98%9F%E5%88%97&#34;&gt;5. FQ（公平队列）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-drr%E5%B7%AE%E9%A2%9D%E8%BD%AE%E8%AF%A2%E8%B0%83%E5%BA%A6&#34;&gt;6. DRR（差额轮询调度）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-wfq%E5%8A%A0%E6%9D%83%E5%85%AC%E5%B9%B3%E9%98%9F%E5%88%97&#34;&gt;7. WFQ（加权公平队列）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E7%BB%84%E5%90%88%E9%98%9F%E5%88%97&#34;&gt;6. 组合队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95-3&#34;&gt;配置方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%9F%BA%E4%BA%8E%E7%B1%BB%E7%9A%84%E6%8B%A5%E5%A1%9E%E7%AE%A1%E7%90%86&#34;&gt;2. 基于类的拥塞管理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%9F%E5%88%97%E5%88%86%E7%B1%BB&#34;&gt;队列分类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ef%E9%98%9F%E5%88%97&#34;&gt;1. EF队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-af%E9%98%9F%E5%88%97&#34;&gt;2. AF队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-be%E9%98%9F%E5%88%97&#34;&gt;3. BE队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95-4&#34;&gt;配置方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86&#34;&gt;流量管理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%B5%81%E9%87%8F%E7%9B%91%E7%AE%A1tp&#34;&gt;1. 流量监管TP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E7%82%B9&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8&#34;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2ts&#34;&gt;2. 流量整形TS&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E7%82%B9-2&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86-2&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2%E7%9A%84%E6%96%B9%E6%B3%95&#34;&gt;流量整形的方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-lr%E6%8E%A5%E5%8F%A3%E9%99%90%E9%80%9F&#34;&gt;1. LR（接口限速）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-gts%E9%80%9A%E7%94%A8%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2&#34;&gt;2. GTS（通用流量整形）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-frts%E5%B8%A7%E4%B8%AD%E7%BB%A7%E6%B5%81%E9%87%8F%E6%95%B4%E5%BD%A2&#34;&gt;3. FRTS（帧中继流量整形）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E4%BB%A4%E7%89%8C%E6%A1%B6%E6%8A%80%E6%9C%AF&#34;&gt;3. 令牌桶技术&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8-2&#34;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB&#34;&gt;分类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%8D%95%E9%80%9F%E5%8D%95%E6%A1%B6&#34;&gt;1. 单速单桶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%8D%95%E9%80%9F%E5%8F%8C%E6%A1%B6&#34;&gt;2. 单速双桶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%8F%8C%E9%80%9F%E5%8F%8C%E6%A1%B6&#34;&gt;3. 双速双桶&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615205982393.png&#34; alt=&#34;QoS业务的处理流程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;3种服务模型&#34;&gt;3种服务模型&lt;/h1&gt;
&lt;h2 id=&#34;1-尽力而为服务模型&#34;&gt;1. 尽力而为服务模型&lt;/h2&gt;
&lt;p&gt;传统的&lt;strong&gt;先进先出&lt;/strong&gt;转发即Best-Effort（尽力而为）服务模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Best-Effort是一个单一的服务模型，也是最简单的服务模型。应用程序可以在任何时候，发出任意数量的报文，而且不需要事先获得批准，也不需要通知网络。&lt;/li&gt;
&lt;li&gt;应用Best-Effort服务模型的网络尽最大的可能性来发送报文，但对时延、可靠性等性能不提供任何保证，但它适用于绝大多数网络应用，如FTP、E-Mail等。&lt;/li&gt;
&lt;li&gt;Best-Effort服务是现在Internet的&lt;strong&gt;缺省服务模型&lt;/strong&gt;，它是通过&lt;strong&gt;先入先出&lt;/strong&gt;（FIFO）队列来实现的。&lt;/li&gt;
&lt;li&gt;在尽力而为的服务模型下，可通过增大网络带宽和升级网络设备来提高端到端通信质量&lt;/li&gt;
&lt;li&gt;优缺点：
&lt;ul&gt;
&lt;li&gt;优点：实现机制简单，不需要配置&lt;/li&gt;
&lt;li&gt;缺点：优先级高的流量得不到优先转发；如果需要升级网络则成本大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-综合服务模型&#34;&gt;2. 综合服务模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用到RSVP协议（资源预留协议），该服务模型在发送报文前，需要向网络申请特定的服务。&lt;/li&gt;
&lt;li&gt;这个请求是通过信令（signal）来完成的，应用程序首先&lt;strong&gt;通知网络它自己的流量参数和所需的特定服务质量的请求&lt;/strong&gt;，包括带宽、时延等。&lt;/li&gt;
&lt;li&gt;应用程序一般在收到网络的确认信息后，即认为网络已经为这个应用程序的报文发送预留了资源，然后立即发送报文。&lt;/li&gt;
&lt;li&gt;利用RSVP在源和目的之间预留一条数据通道，可保障高优先级的流量有足够的带宽&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;优点：可保障高优先级流量带宽&lt;/li&gt;
&lt;li&gt;缺点：实现较复杂；当无流量发送时，仍然独占带宽，使用率较低；该方案要求端到端所有节点设备都支持并运行RSVP协议&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-区分服务模型应用最广&#34;&gt;3. 区分服务模型（应用最广）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;业务流分类和标记由边缘路由器来完成，DiffServ是&lt;strong&gt;一种基于报文流的QoS模型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;边界路由器可以通过多种条件（比如报文的源地址和目的地址、ToS 域中的优先级、协议类型等）灵活地对报文进行分类，然后对不同类型的报文设置不同的标记字段，而其他路由器只需要简单地识别报文中的这些标记，然后对其进行相应的资源分配和流量控制&lt;/li&gt;
&lt;li&gt;特点：
&lt;ul&gt;
&lt;li&gt;优点：不同业务可以得到不同的服务质量；可对流量加于区分对待，高优先级流量可得到高的服务，且线路利用率高&lt;/li&gt;
&lt;li&gt;缺点：对人员要求较高；数据包过了路由器以后，先对数据包进行分类，分类后可以进行相应的标记，标记完可以进行流量管理，然后是流量的拥塞管理，还有个拥塞避免（平行关系）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分类与标记&#34;&gt;分类与标记&lt;/h1&gt;
&lt;p&gt;把报文分为不同的类别，然后打上一个标记，后期转发则根据不同的标记来判定报文的优先级，不同优先级则有不同的转发行为&lt;/p&gt;
&lt;h2 id=&#34;qos报文分类方式&#34;&gt;QoS报文分类方式&lt;/h2&gt;
&lt;h3 id=&#34;1-复杂流分类mqc流分类&#34;&gt;1. 复杂流分类（MQC流分类）&lt;/h3&gt;
&lt;p&gt;复杂流分类即采用复杂的规则，如由五元组（源地址、源端口号、协议号码、目的地址、目的端口号）对报文进行精细的分类，通过将某些具有相同特征的报文划分为一类，并为这一类报文提供相同的QoS服务。&lt;br&gt;
复杂流分类可以通过模块化QoS命令行MQC中的流分类实现。&lt;br&gt;
MQC包含三个要素，分别是&lt;strong&gt;流分类、流行为和流策略&lt;/strong&gt;，三要素通过下面的方式配合使用完成对流量的处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置流分类，定义报文匹配规则&lt;/li&gt;
&lt;li&gt;配置流行为，确定报文处理动作，根据不同的流行为，可以实现不同的QoS功能&lt;/li&gt;
&lt;li&gt;配置流策略，将配置好的流分类和流行为绑定到一起后在指定视图下应用流策略&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-简单流分类qos优先级分类&#34;&gt;2. 简单流分类（QoS优先级分类）&lt;/h3&gt;
&lt;p&gt;简单流分类就是指采用简单的规则，根据报文中的某个优先级字段，对报文进行粗略的分类&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;外部优先级&lt;/strong&gt;（报文优先级、QoS优先级）&lt;br&gt;
使用报文中&lt;code&gt;某些特定字段&lt;/code&gt;，需要注意的是，&lt;strong&gt;设备只可以根据设备内部优先级处理收到的报文&lt;/strong&gt;，为不同的业务提供不同的QoS服务，所以上述&lt;strong&gt;外部优先级在进入设备后会映射为设备内部的优先级&lt;/strong&gt;。特定字段（即分类依据）如下：
&lt;ol&gt;
&lt;li&gt;802.1Q VLAN tag中PRI（priority）字段，3比特，取值0-7&lt;/li&gt;
&lt;li&gt;mpls格式中的EXP（experimental）字段，3比特，取值0-7&lt;/li&gt;
&lt;li&gt;IPv4头部中TOS（type of server）字段，8比特
&lt;ol&gt;
&lt;li&gt;前3比特，叫IPP（IP precedence，IP优先级），取值0-7&lt;/li&gt;
&lt;li&gt;后期发现不够用，所有用了前6位，叫DSCP（区分服务代码点），取值0-63&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内部优先级&lt;/strong&gt;（服务等级CoS、&lt;strong&gt;PHB行为(每一跳行为)&lt;/strong&gt;、本地优先级）&lt;br&gt;
支持8种取值，即8个队列优先级，&lt;strong&gt;优先级从高到低依次为CS7、CS6、EF、AF4、AF3、AF2、AF1、BE&lt;/strong&gt;，与出端口的8个队列从高到低依次对应，因此&lt;strong&gt;内部优先级决定了报文在设备内部所属的队列&lt;/strong&gt;&lt;br&gt;
当针对某一个队列配置QoS业务时，即对所有通过该队列转发的报文都设置了相同的QoS服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;丢弃优先级&lt;/strong&gt;（颜色）&lt;br&gt;
报文在设备内部的&lt;strong&gt;丢弃优先级&lt;/strong&gt;，用于决定&lt;strong&gt;当一个队列发生拥塞时报文的丢弃顺序&lt;/strong&gt;，丢弃优先级有3种取值，&lt;strong&gt;从低到高依次为Green、Yellow、Red&lt;/strong&gt;。&lt;strong&gt;缺省情况下，丢弃优先级越高&lt;/strong&gt;，则队列发生拥塞时，对应优先级的报文会被优先丢弃。&lt;br&gt;
&lt;strong&gt;报文是否会被优先丢弃实际取决于参数的配置&lt;/strong&gt;，例如配置WRED丢弃模板中Green最大只能使用50%缓存，Red最大可以使用100%缓存，则队列发生拥塞时，标记为Green的报文将比标记为Red的报文优先丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;复杂流分类与简单流分类的关系&lt;/strong&gt;：&lt;br&gt;
通过复杂流分类也可以对特定的QoS优先级报文进行识别，只是需要以MQC流分类的方式去实现&lt;br&gt;
需要配置MQC流分类去实现的报文分类都属于复杂流分类&lt;br&gt;
不需要配置MQC流分类，直接根据报文中的外部优先级映射的内部优先级和丢弃优先级去进行报文分类的就是简单流分类&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;phb&#34;&gt;PHB&lt;/h4&gt;
&lt;p&gt;每一跳行为，即设备对报文的处理，只定义了一些外部可见的转发行为，并没有指定特定的实现方式。&lt;br&gt;
&lt;strong&gt;PHB体现的是等级的高低，而不是服务质量QoS的好坏&lt;/strong&gt;，即CS的等级最高不代表服务质量最好、BE的等级最低不代表服务质量最差。PHB只是逐跳行为，而服务质量是端到端的。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617775795416.png&#34; alt=&#34;PHB1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615214475383.png&#34; alt=&#34;PHB2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
简而言之，PHB根据可见的服务特征（例如时延、抖动或丢包率）将各种行为概括成4类，每类PHB都对应一组DSCP：&lt;/p&gt;
&lt;h5 id=&#34;1-be000-000尽力而为best-effort&#34;&gt;1. BE(000 000)（尽力而为，Best-effort）&lt;/h5&gt;
&lt;p&gt;BE默认全0就是没有打标&lt;br&gt;
没有质量保证，一般对应于传统的IP分组投递服务，只关注可达性，其他方面不做要求。IP网络中，&lt;strong&gt;缺省的PHB就是BE，任何路由器都必须支持BE PHB&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;2-afxxx-xx-0确保转发assured-forwarding&#34;&gt;2. AF(xxx xx 0)（确保转发，Assured Forwarding）&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;代表带宽有保证、时延可控的服务&lt;/strong&gt;，适应于视频、语音、企业VPN等业务&lt;br&gt;
适应业务细分如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AF1x：重要数据&lt;/li&gt;
&lt;li&gt;AF2x：视频点播流量&lt;/li&gt;
&lt;li&gt;AF3x：直播流量&lt;/li&gt;
&lt;li&gt;AF4x：语音的信令流量&lt;/li&gt;
&lt;li&gt;EF：语音流量&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;AF（4类 AF11 21 31 41 ），AF11又分了AF 11 12 13，&lt;strong&gt;后面数据值表示丢弃的优先级，值越大丢弃的可能性就越高&lt;/strong&gt;&lt;code&gt;即前面的值越大越优，后面的值越小越优&lt;/code&gt;例如AF11比AF13中重要、AF21比AF11重要&lt;/p&gt;
&lt;h5 id=&#34;3-ef101-11-0快速转发expedited-forwarding&#34;&gt;3. EF(101 11 0)（快速转发，Expedited Forwarding）&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;低时延、低抖动、低丢包率&lt;/strong&gt;，应用于要求比较高的语音、视频、会议电视等&lt;br&gt;
EF代表&amp;quot;确保转发&amp;quot;，dscp值为46，&lt;strong&gt;即比AF的数值最大值AF43再大一点，即AF53，即DSCP(5&lt;em&gt;8+3&lt;/em&gt;2)=DSCP46&lt;/strong&gt;&lt;br&gt;
举例DSCP数转换十进制：&lt;code&gt;DSCP 32 = 3*8+2*2 = 28&lt;/code&gt;，&lt;code&gt;DSCP 56 = 5*8+3*2 = 46&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;4-cs&#34;&gt;4. CS&lt;/h5&gt;
&lt;p&gt;因为现网有些存量设备不支持差分服务，只解析DSCP的前3比特，为了兼容这部分设备，标准预留了所有格式为xxx000的DSCP值，这类值就对应CS PHB&lt;br&gt;
因此CS的值包含前面BE、AF和EF的所有值，但是只看前3位。&lt;/p&gt;
&lt;h4 id=&#34;dscp差分服务代码点和ippip优先级的区别&#34;&gt;DSCP（差分服务代码点）和IPP（ip优先级）的区别&lt;/h4&gt;
&lt;p&gt;都为ip报文中的TOS的一部分：&lt;br&gt;
IPP是TOS前3bit&lt;br&gt;
DSCP是TOS前6bit：前3bit代表优先级，后3bit代表D延迟、T吞吐、R可靠性&lt;/p&gt;
&lt;h4 id=&#34;配置方法&#34;&gt;配置方法&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;用MQC(Modular QoS ，模块化QoS命令行接口，配置 QOS 的工具）配置
&lt;ol&gt;
&lt;li&gt;流分类，可用ACL匹配源目IP、端口、优先级等&lt;/li&gt;
&lt;li&gt;流行为，例如&lt;code&gt;remark 8021p dscp mpls-exp&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;流策略&lt;/li&gt;
&lt;li&gt;接口下应用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/meili333/p/14100821.html&#34;&gt;用&lt;code&gt;class-map&lt;/code&gt;命令来配置&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;定义分类： &lt;code&gt;class-map 名字&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;匹配流：&lt;code&gt;match protocol 协议 或者 match access-group 访问控制列表&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;执行动作：&lt;code&gt;set ip dscp或者ip precedence等&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;cos和tos的区别&#34;&gt;COS和TOS的区别&lt;/h4&gt;
&lt;p&gt;COS指的是二层和2.5层中的优先级字段，分别为vlan-tag中的PRI（802.1p）和mpls报头中EXP&lt;br&gt;
TOS指的是三层ip报头中的优先级字段，前3bit为IPP，前6bit为DSCP&lt;/p&gt;
&lt;h2 id=&#34;优先级映射方式&#34;&gt;优先级映射方式&lt;/h2&gt;
&lt;p&gt;在处理QoS业务时，在端口&lt;strong&gt;入方向&lt;/strong&gt;将报文的&lt;strong&gt;外部优先级映射到合适的内部优先级和丢弃优先级&lt;/strong&gt;，在端口&lt;strong&gt;出方向&lt;/strong&gt;将&lt;strong&gt;内部优先级和丢弃优先级映射到外部优先级&lt;/strong&gt;。&lt;br&gt;
外部与内部优先级的映射关系：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;报文重标记配置&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;基于MQC方式&lt;/strong&gt;，在流行为中使用重标记行为，将报文的优先级或者标志位进行设置，重新定义报文的外部优先级&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级映射配置&lt;/strong&gt;：&lt;br&gt;
在&lt;strong&gt;DiffServ模型&lt;/strong&gt;中，设备定义了DiffServ域来管理和记录外部优先级与内部优先级、丢弃优先级之间的映射关系，不同DiffServ域允许有不同的优先级映射关系。&lt;strong&gt;优先级映射通过配置DiffServ域来设定不同的优先级映射关系&lt;/strong&gt;，从而实现不同的QoS服务&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;拥塞避免&#34;&gt;拥塞避免&lt;/h1&gt;
&lt;p&gt;指通过监视网络资源的使用情况，在拥塞发生或有加剧的&lt;strong&gt;趋势&lt;/strong&gt;时主动丢弃报文，通过调整网络的流量来解除网络过载的一种流控机制。拥塞避免常用的两种丢弃报文方式为：尾部丢包策略和WRED。&lt;/p&gt;
&lt;h2 id=&#34;1-传统的尾部丢包策略&#34;&gt;1. 传统的尾部丢包策略&lt;/h2&gt;
&lt;p&gt;传统的丢包策略采用尾部丢弃的方法，当队列的长度达到最大值后，所有新入队列的报文都将被丢弃&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615294351266.png&#34; alt=&#34;传统的尾部丢包策略&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这种丢弃策略会&lt;strong&gt;引发TCP全局同步&lt;/strong&gt;现象，导致TCP连接始终无法建立。所谓TCP全局同步现象如图，三种颜色表示三条TCP连接，当&lt;strong&gt;同时丢弃多个TCP连接的报文&lt;/strong&gt;时，将造成多个TCP连接同时&lt;strong&gt;进入拥塞避免和慢启动状态&lt;/strong&gt;而导致流量降低，&lt;strong&gt;之后又会在某个时间同时出现流量高峰&lt;/strong&gt;，如此反复，使网络流量忽大忽小。&lt;br&gt;
&lt;strong&gt;出现的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TCP同步（没有充分利用链路带宽）&lt;/li&gt;
&lt;li&gt;TCP饿死（UDP没有TCP那种滑动窗口）&lt;/li&gt;
&lt;li&gt;无差别的丢弃&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615294435734.png&#34; alt=&#34;出现的问题&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcp全局同步&#34;&gt;TCP全局同步&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;TCP拥塞控制
&lt;ol&gt;
&lt;li&gt;慢启动：建立连接时将拥塞窗口设置为一个 MSS（536B）大小，即开始传输时速率很慢，但按指数方式增长，达到慢启动阈值（默认56636B）时停下，进入拥塞避免状态&lt;/li&gt;
&lt;li&gt;拥塞避免：拥塞窗口按加法规律增长，每次发送的所有报文都被确认，拥塞窗口就增大一个MSS，此阶段持续增长，直到拥塞被检测到&lt;/li&gt;
&lt;li&gt;拥塞检测：如果检测到拥塞，窗口必须减小。检测到拥塞的方法，发送方发生重传事件，即RTO计时器超时或收到3个重复的ACK报文，慢启动的阈值下降一半
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;发生超时&lt;/strong&gt;，出现拥塞&lt;strong&gt;可能性较大&lt;/strong&gt;，&lt;strong&gt;阀值减半&lt;/strong&gt;，&lt;strong&gt;拥塞窗口设置为一个MSS大小&lt;/strong&gt;，开始一个慢启动阶段&lt;/li&gt;
&lt;li&gt;如果收到3个ACK报文，出现拥塞&lt;strong&gt;可能性较小&lt;/strong&gt;，阀值减半，&lt;strong&gt;拥塞窗口设置为阀值&lt;/strong&gt;，&lt;strong&gt;再开始一个拥塞避免阶段&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;TCP重传机制
&lt;ol&gt;
&lt;li&gt;超时重传：TCP为每一个发送的报文段设置一个超时重传计时器（RTO），计时器到时则重传&lt;/li&gt;
&lt;li&gt;快重传：接受方发现一部分报文丢失，&lt;strong&gt;立即连续发送3个ACK（重复）报文&lt;/strong&gt;，发送方立即重发丢失的报文段&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mss和mtu的区别&#34;&gt;MSS和MTU的区别&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MTU = MSS + TCP Header + IP Header&lt;/code&gt;&lt;br&gt;
mtu是网络传输最大报文包。最大传输单元，由硬件规定，如以太网的MTU为1500字节【1518B=1500B+14B二层头+4B尾部校验】&lt;br&gt;
mss是网络传输数据最大值。最大分节大小，为TCP数据包每次传输的最大数据分段大小，一般由发送端向对端TCP通知对端在每个分节中能发送的最大TCP数据&lt;code&gt;UDP不会分段，就由IP来分。TCP会分段，当然就不用IP来分了。即TCP分段的原因是MSS，IP分片的原因是MTU&lt;/code&gt;&lt;br&gt;
MSS值太小或太大都是不合适。太小，例如MSS值只有1byte，那么为了传输这1byte数据，至少要消耗20字节IP头部+20字节TCP头部=40byte，这还不包括其二层头部所需要的开销，显然这种数据传输效率是很低的。MSS过大，导致数据包可以封装很大，那么在IP传输中分片的可能性就会增大，接受方在处理分片包所消耗的资源和处理时间都会增大，如果分片在传输中还发生了重传，那么其网络开销也会增大。&lt;br&gt;
合理的MSS是至关重要的，MSS的合理值应为保证数据包不分片的最大值，对于以太网MSS可以达到1460B，而Internet上标准的MTU（最小的MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536B。很多时候，MSS的值最好取512的倍数，&lt;strong&gt;因为TCP报文段的分段与重组是在传输层完成的&lt;/strong&gt;&lt;code&gt;IP层的重组是发生在目的地的IP层，TCP的重组是发生在目的地的传输层中&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-wred&#34;&gt;2. WRED&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LAN侧接口板不支持WRED&lt;/code&gt;&lt;br&gt;
在CBQ中，&lt;strong&gt;EF队列和LLQ队列不能使用丢弃策略&lt;/strong&gt;，&lt;strong&gt;只能尾丢弃&lt;/strong&gt;。为避免TCP全局同步现象，出现了RED（随机早期检测）技术。&lt;strong&gt;RED通过随机地丢弃数据报文，让多个TCP连接不同时降低发送速度&lt;/strong&gt;，从而避免了TCP的全局同步现象，使TCP速率及网络流量都趋于稳定&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615294517757.png&#34; alt=&#34;RED技术原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
基于RED技术，设备实现了WRED（权重随机早期检测），&lt;strong&gt;流队列支持基于DSCP或IP优先级进行WRED丢弃&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615295244502.png&#34; alt=&#34;WRED技术原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;每一种优先级都可以独立设置报文丢包的上下门限及丢包率&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当队列的长度小于阈值下限时，不丢弃报文&lt;/li&gt;
&lt;li&gt;当队列的长度大于阈值上限时，丢弃所有新收到的报文&lt;/li&gt;
&lt;li&gt;当队列的长度在阈值下限和阈值上限之间时，开始随机丢弃新收到的报文。方法是为每个新收到的报文赋予一个随机数，并用该随机数与当前队列的丢弃概率比较，如果大于丢弃概率则报文被丢弃。队列越长，报文被丢弃的概率越高&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：可尽量缓解TCP全局同步的到来&lt;br&gt;
&lt;strong&gt;缺点&lt;/strong&gt;：不加区分丢包和TCP流量饿死无法缓解&lt;/p&gt;
&lt;h3 id=&#34;配置方法-2&#34;&gt;配置方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;基于队列的WRED：
&lt;ol&gt;
&lt;li&gt;先定义丢弃模板&lt;/li&gt;
&lt;li&gt;用queue-profile绑定丢弃模板&lt;/li&gt;
&lt;li&gt;在接口下调用&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;基于MQC实现
&lt;ol&gt;
&lt;li&gt;先定义丢弃模板&lt;/li&gt;
&lt;li&gt;用MQC模型，流行为与丢弃模板绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;拥塞管理&#34;&gt;拥塞管理&lt;/h1&gt;
&lt;p&gt;拥塞管理即收到数据包&lt;strong&gt;在转发出去的时候进行的动作&lt;/strong&gt;，总的可以分为两大类，基于队列的拥塞管理和基于类的拥塞管理，&lt;strong&gt;基于队列的即按照队列的方式转发&lt;/strong&gt;，&lt;strong&gt;基于类的即按照分类的方式转发&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-基于队列的拥塞管理&#34;&gt;1. 基于队列的拥塞管理&lt;/h2&gt;
&lt;p&gt;收到报文，会&lt;strong&gt;根据标记字段把报文映射进不同的队列&lt;/strong&gt;，分别是0-7号队列，之后再把报文转发出去的这个过程叫拥塞管理&lt;/p&gt;
&lt;h3 id=&#34;调度方法分类&#34;&gt;调度方法分类&lt;/h3&gt;
&lt;h4 id=&#34;1-fifo先进先出尽力而为服务模型使用&#34;&gt;1. FIFO（先进先出，尽力而为服务模型使用）&lt;/h4&gt;
&lt;p&gt;优点：默认，配置简单&lt;br&gt;
缺点：发生拥塞情况下，高优先级得不到优先转发&lt;/p&gt;
&lt;h4 id=&#34;2-pq优先级队列&#34;&gt;2. PQ（优先级队列）&lt;/h4&gt;
&lt;p&gt;高优先级先转发，低优先级后转发&lt;br&gt;
优点：高优先级可得到优先转发&lt;br&gt;
缺点：低优先级流量饿死&lt;/p&gt;
&lt;h4 id=&#34;3-rr轮询&#34;&gt;3. RR（轮询）&lt;/h4&gt;
&lt;p&gt;每个周期内，每个队列都调度一个数据包&lt;br&gt;
优点：不会出现低优先级流量饿死&lt;br&gt;
缺点：高优先级得不到高带宽&lt;/p&gt;
&lt;h4 id=&#34;4-wrr加权轮询队列&#34;&gt;4. WRR（加权轮询队列）&lt;/h4&gt;
&lt;p&gt;加权循环调度在RR调度的基础上演变而来，根据每个队列的权重来轮流调度各队列中的报文流&lt;br&gt;
优点：避免了PQ调度的“饿死”现象。&lt;br&gt;
缺点：基于报文个数来调度，容易出现包长尺寸不同的报文出现不平等调度&lt;sub&gt;从用户侧来看，加大报文长度就到表者加大带宽&lt;/sub&gt;；低时延业务得不到及时调度&lt;/p&gt;
&lt;h4 id=&#34;5-fq公平队列&#34;&gt;5. FQ（公平队列）&lt;/h4&gt;
&lt;p&gt;目的是尽可能公平地分享网络资源，使所有流的延迟和抖动达到最优。&lt;br&gt;
不同的队列获得公平的调度机会，从总体上均衡各个流的延迟。&lt;br&gt;
短报文和长报文获得公平的调度：如果不同队列间同时存在多个长报文和短报文等待发送，&lt;strong&gt;让短报文优先获得调度&lt;/strong&gt;，从而在总体上减少各个流的报文间的抖动&lt;br&gt;
缺点：长报文容易出现饿死现象&lt;/p&gt;
&lt;h4 id=&#34;6-drr差额轮询调度&#34;&gt;6. DRR（差额轮询调度）&lt;/h4&gt;
&lt;p&gt;优点：解决了WRR只关心报文，&lt;strong&gt;同等调度机会下大尺寸报文获得的实际带宽要大于小尺寸报文获得的带宽的问题&lt;/strong&gt;，在调度过程中考虑包长的因素以达到调度的速率公平性&lt;br&gt;
缺点：没有解决WRR调度中低延时需求业务得不到及时调度的问题&lt;/p&gt;
&lt;h4 id=&#34;7-wfq加权公平队列&#34;&gt;7. WFQ（加权公平队列）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;前面5种模式总是在&amp;quot;低优先级队列和长报文饿死&amp;quot; 与 &amp;quot;高优先级和低延时得不到相应的待遇&amp;quot;之间徘徊，其本质原因是高低优先级数据采用同一个队列&lt;/code&gt;&lt;br&gt;
WFQ调度在&lt;strong&gt;报文入队列之前，先对流量进行分类&lt;/strong&gt;，有两种分类方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按流的会话信息分类&lt;br&gt;
根据报文的五元组、ToS域中的优先级等自动进行流分类，并且尽可能多地提供队列，以将每个流均匀地放入不同队列中&lt;br&gt;
在出队列的时候，WFQ&lt;strong&gt;按流的优先级来分配每个流应占有带宽&lt;/strong&gt;，优先级越小带宽越少，优先级越大带宽越大，这种方式只有CBQ的default-class支持&lt;/li&gt;
&lt;li&gt;按优先级分类&lt;br&gt;
&lt;strong&gt;通过优先级映射把流量标记为本地优先级，每个本地优先级对应一个队列号&lt;/strong&gt;&lt;br&gt;
每个接口预分配8个队列，报文根据队列号进入队列&lt;br&gt;
默认情况，队列的WFQ权重相同，流量平均分配接口带宽&lt;br&gt;
用户可以通过配置修改权重，高优先权和低优先权按权重比例分配带宽&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：可完全按照权重分配带宽，自动分类，配置简单&lt;br&gt;
缺点：低时延业务仍得不到及时调度，无法实现用户自定义分类规则&lt;/p&gt;
&lt;h4 id=&#34;6-组合队列&#34;&gt;6. 组合队列&lt;/h4&gt;
&lt;p&gt;PQ+WFQ/WRR/RR&lt;br&gt;
可保证低延时业务得到优先转发，其余业务再用其余调度机制&lt;/p&gt;
&lt;h3 id=&#34;配置方法-3&#34;&gt;配置方法&lt;/h3&gt;
&lt;p&gt;LAN口支持PQ、DRR、WRR、PQ+DRR、PQ+WRR&lt;code&gt;优先级队列和轮询的组合&lt;/code&gt;&lt;br&gt;
WAN口支持PQ、WFQ、PQ+WFQ&lt;code&gt;优先级队列和加权公平队列的组合&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用queue-profile创建队列模板&lt;/li&gt;
&lt;li&gt;各个队列指定用何种调度机制&lt;/li&gt;
&lt;li&gt;在接口调用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-基于类的拥塞管理&#34;&gt;2. 基于类的拥塞管理&lt;/h2&gt;
&lt;p&gt;CBQ，基于类的队列&lt;/p&gt;
&lt;h3 id=&#34;队列分类&#34;&gt;队列分类&lt;/h3&gt;
&lt;h4 id=&#34;1-ef队列&#34;&gt;1. EF队列&lt;/h4&gt;
&lt;p&gt;满足&lt;strong&gt;低时延&lt;/strong&gt;业务。&lt;br&gt;
EF队列拥有&lt;strong&gt;绝对优先级&lt;/strong&gt;，&lt;strong&gt;采用PQ调度机制&lt;/strong&gt;，仅当EF队列中的报文调度完毕后，才会调度其他队列中的报文，所以配置其带宽为最大带宽&lt;br&gt;
还有一个特殊的EF队列LLQ队列，即低延时队列，LLQ队列较EF队列而言，时延更低，为时延敏感的应用（如VoIP业务）提供了良好的服务质量保证&lt;/p&gt;
&lt;h4 id=&#34;2-af队列&#34;&gt;2. AF队列&lt;/h4&gt;
&lt;p&gt;满足需要带宽保证的&lt;strong&gt;关键数据&lt;/strong&gt;业务。&lt;br&gt;
使用WRR的调度机制，每个AF队列分别对应一类报文，用户可以设定每类报文占用的带宽。当系统调度报文出队的时候，会按用户为各类报文设定的带宽将报文进行出队发送，可实现各个类的队列的公平调度，所以需要配置其带宽为最小带宽&lt;br&gt;
对于AF队列，当队列的长度达到队列的最大长度时，缺省采用尾丢弃的策略，但用户还可以选择用WRED丢弃策略&lt;/p&gt;
&lt;h4 id=&#34;3-be队列&#34;&gt;3. BE队列&lt;/h4&gt;
&lt;p&gt;满足不需要严格QoS保证的尽力发送业务。&lt;br&gt;
当报文不匹配用户设定的所有类别时，报文会被送入系统定义的缺省BE（尽力传送）类，BE队列使用接口剩余带宽和WFQ调度方式进行发送&lt;br&gt;
对于BE队列，当队列的长度达到队列的最大长度时，缺省采用尾丢弃的策略，但用户还可以选择用WRED丢弃策略&lt;/p&gt;
&lt;h3 id=&#34;配置方法-4&#34;&gt;配置方法&lt;/h3&gt;
&lt;p&gt;使用MQC来配置&lt;/p&gt;
&lt;h1 id=&#34;流量管理&#34;&gt;流量管理&lt;/h1&gt;
&lt;p&gt;流量监管和流量整形就是一种通过对流量规格的监督，来限制流量及其资源使用的流控策略。&lt;br&gt;
&lt;strong&gt;流量整形与流量监管的主要区别&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;流量监管直接丢弃不符合速率要求的报文；&lt;br&gt;
流量整形将不符合速率要求的报文先行缓存，当令牌桶有足够的令牌时，再均匀的向外发送这些被缓存的报文&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615300770875.png&#34; alt=&#34;区别1&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;流量监管支持对流量重新打标记，不需要额外的缓冲，但是会丢弃较多报文而导致重传；&lt;br&gt;
流量整形很少丢弃报文，但是会引入时延和抖动，需要缓存资源来缓存报文&lt;/li&gt;
&lt;li&gt;运营商一侧使用流量监管TP，用户或者公司一侧使用流量整形TS&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1-流量监管tp&#34;&gt;1. 流量监管TP&lt;/h2&gt;
&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615298981790.png&#34; alt=&#34;流量监管TP&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;strong&gt;入和出方向的流量&lt;/strong&gt;进行监控，对超出规定速率的流量进行惩罚（降低优先级转发/默认丢弃）&lt;/li&gt;
&lt;li&gt;没有缓存机制，不会引入额外延时&lt;/li&gt;
&lt;li&gt;属于&lt;strong&gt;削峰不填谷&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;会增加丢包率，而且在链路空闲时的链路利用率低&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615299719768.png&#34; alt=&#34;原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;流量监管由三部分组成&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Meter：通过令牌桶机制对网络流量进行度量，向Marker输出度量结果&lt;/li&gt;
&lt;li&gt;Marker：根据Meter的度量结果&lt;strong&gt;对报文进行染色&lt;/strong&gt;，报文会被染成green（转发）、yellow（降低优先级后转发）、red（丢弃）三种颜色&lt;/li&gt;
&lt;li&gt;Action：根据Marker对报文的染色结果，对报文进行处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应用&#34;&gt;应用&lt;/h3&gt;
&lt;p&gt;CAR：双速双桶或单速双桶实现&lt;br&gt;
可以在路由器和交换机上配置，&lt;br&gt;
1. 在路由器上可以在接口下和MQC中inbound和outbound使用&lt;br&gt;
2. 在交换机上只能在MQC下的inbound和outbound配置&lt;/p&gt;
&lt;h2 id=&#34;2-流量整形ts&#34;&gt;2. 流量整形TS&lt;/h2&gt;
&lt;h3 id=&#34;特点-2&#34;&gt;特点&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615299362443.png&#34; alt=&#34;流量整形TS&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;对&lt;strong&gt;出方向流量&lt;/strong&gt;进行监控，输出一条比较平整的流量，即以比较均匀的速度向外发送&lt;/li&gt;
&lt;li&gt;对超出速率的流量进行缓存，等到链路空闲时发送&lt;/li&gt;
&lt;li&gt;会引入缓存机制，属于&lt;strong&gt;削峰填谷&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由于引入了缓存机制所以会产生额外的延时，但是提升了链路利用率&lt;br&gt;
&lt;code&gt;流量整形为什么不能在入方向配置：因为入方向没有队列（没有缓存机制）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原理-2&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;报文处理流程&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615301275524.gif&#34; alt=&#34;原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当报文到来的时候，首先对报文进行分类，使报文进入不同的队列：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;若报文进入的队列&lt;strong&gt;没有配置队列整形&lt;/strong&gt;功能，则&lt;strong&gt;直接发送该队列的报文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若报文进入的队列&lt;strong&gt;配置队列整形&lt;/strong&gt;功能，则&lt;strong&gt;按用户设定的队列整形速率向令牌桶中放置令牌&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;如果令牌桶中有&lt;strong&gt;足够的令牌&lt;/strong&gt;可以用来发送报文，则&lt;strong&gt;报文直接被发送&lt;/strong&gt;，在报文被发送的同时，&lt;strong&gt;令牌做相应的减少&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果令牌桶中&lt;strong&gt;没有足够的令牌&lt;/strong&gt;，则将报文&lt;strong&gt;放入缓存队列&lt;/strong&gt;，如果报文放入缓存队列时，缓存队列&lt;strong&gt;已满，则丢弃报文&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缓存队列中有报文时&lt;/strong&gt;，系统按一定的周期&lt;strong&gt;从缓存队列中取出报文进行发送&lt;/strong&gt;，直到令牌桶中没有令牌或缓存队列中没有报文为止&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;流量整形的方法&#34;&gt;流量整形的方法&lt;/h3&gt;
&lt;h4 id=&#34;1-lr接口限速&#34;&gt;1. LR（接口限速）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;针对&lt;strong&gt;所有流量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;只能基于&lt;strong&gt;接口做整形&lt;/strong&gt;，也就是&lt;strong&gt;出接口的所有流量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果用在&lt;strong&gt;路由器&lt;/strong&gt;接口，&lt;strong&gt;只是用于限速&lt;/strong&gt;，配置接口速率百分比，必须&lt;strong&gt;结合队列&lt;/strong&gt;使用才能生效&lt;/li&gt;
&lt;li&gt;如果在&lt;strong&gt;交换机&lt;/strong&gt;接口使用，接口&lt;strong&gt;出方向做整形&lt;/strong&gt;，在接口&lt;strong&gt;入方向做监管&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2-gts通用流量整形&#34;&gt;2. GTS（通用流量整形）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;针对IP流量 ，&lt;strong&gt;只能用于出方向&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;实现方式有以下三种：
&lt;ol&gt;
&lt;li&gt;基于接口：针对接口下的所有&lt;strong&gt;三层流量进行整形&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;基于队列：使用队列模板对&lt;strong&gt;针对接口下的某一个队列&lt;/strong&gt;中的&lt;strong&gt;三层流量进行整形&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;基于类：&lt;strong&gt;使用MQC&lt;/strong&gt;的配置模式，针对不同的业务流量进行整形&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只能用在路由器接口&lt;/strong&gt; ，交换机做不了GTS，&lt;strong&gt;交换机的接口为二层接口&lt;/strong&gt;，而二层接口无法配置GTS，因为GTS是针对三层流量&lt;/li&gt;
&lt;li&gt;缓存队列会周期和令牌桶进行比较，当令牌桶中的令牌存在空闲时，缓存队列中的数据发送出去&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3-frts帧中继流量整形&#34;&gt;3. FRTS（帧中继流量整形）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;针对&lt;strong&gt;FR的接口使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;跟GTS的算法是一样的，只是用于帧中继接口&lt;/li&gt;
&lt;li&gt;可以针对接口或者针对pvc（如果两者同时启用，cir小的配置生效）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3-令牌桶技术&#34;&gt;3. 令牌桶技术&lt;/h2&gt;
&lt;p&gt;令牌桶可以看作是一个存放一定数量令牌的容器，系统按设定的速度向桶中放置令牌，当桶中令牌满时，多出的令牌溢出，桶中令牌不再增加&lt;br&gt;
华为设备&lt;strong&gt;默认支持单速双桶(单速率三色标记)和双速双桶(双速率三色标记)，单速单桶（只有红绿两色）使用双速双桶实现&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;参数解释&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C桶：
&lt;ul&gt;
&lt;li&gt;CIR：承诺信息速率，表示向C桶中投放令牌的速率，即C桶允许传输或转发报文的平均速率&lt;/li&gt;
&lt;li&gt;CBS：承诺突发尺寸，表示C桶的容量，即C桶瞬间能够通过的承诺突发流量&lt;/li&gt;
&lt;li&gt;Tc：C桶中令牌数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;P桶：
&lt;ul&gt;
&lt;li&gt;PIR：峰值信息速率，表示向P桶中投放令牌的速率，即P桶允许传输或转发报文的峰值速率，PIR大于CIR&lt;code&gt;即P桶&amp;gt;C桶&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PBS：峰值突发尺寸，表示P桶的容量，即P桶瞬间能够通过的峰值突发流量&lt;/li&gt;
&lt;li&gt;Tp：P桶中令牌数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;E桶：
&lt;ul&gt;
&lt;li&gt;EBS：超额突发尺寸，表示E桶的容量，即E桶瞬间能够通过的超出突发流量&lt;/li&gt;
&lt;li&gt;Te：E桶中令牌数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用-2&#34;&gt;应用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615304604371.png&#34; alt=&#34;应用&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;
&lt;p&gt;单速双桶模式中，如果EBS等于 0，其效果和单速单桶是一样的&lt;br&gt;
双速双桶模式中，如果PIR等于CIR，其效果和单速单桶是一样的&lt;/p&gt;
&lt;h4 id=&#34;1-单速单桶&#34;&gt;1. 单速单桶&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;关键参数：CIR、CBS（只有C桶）&lt;/li&gt;
&lt;li&gt;令牌投放：以CIR速率向C桶投放令牌，C桶满时令牌溢出&lt;/li&gt;
&lt;li&gt;流量突发：&lt;strong&gt;不允许流量突发&lt;/strong&gt;，报文的处理以C桶中是否有足够令牌为依据&lt;/li&gt;
&lt;li&gt;颜色标记：绿色、红色&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 系统按照CIR速率向桶中投放令牌：
    1. 当Tc&amp;lt;CBS，Tc增加，否则不增加
2. 对于到达的报文，用B表示报文的大小：
    1. 若B≤Tc，报文被标记为绿色，且Tc减少B
    2. 若B&amp;gt;Tc，报文被标记为红色，且Tc不减少
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-单速双桶&#34;&gt;2. 单速双桶&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;关键参数：CIR、CBS、EBS（C桶和E桶）&lt;/li&gt;
&lt;li&gt;令牌投放：C桶满时令牌投放到E桶，C桶和E桶都不满时，只向C桶投放令牌&lt;/li&gt;
&lt;li&gt;流量突发：允许&lt;strong&gt;报文尺寸&lt;/strong&gt;的突发。先使用C桶中的令牌，C桶中令牌数量不够时，使用E桶中的令牌&lt;/li&gt;
&lt;li&gt;颜色标记：绿色、黄色或红色&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 系统按照CIR速率向桶中投放令牌：
    1. 当Tc&amp;lt;CBS，Tc增加，否则不增加
    2. 当Te&amp;lt;EBS，Te增加，否则不增加
2. 对于到达的报文，用B表示报文的大小：
    1. 若B≤Tc，报文被标记为绿色，且Tc减少B
    2. 若Tc&amp;lt;B≤Te，报文被标记为黄色，且Te减少B
    3. 若Tc&amp;lt;B并且Te&amp;lt;B，报文被标记为红色，且Tc和Te都不减少
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-双速双桶&#34;&gt;3. 双速双桶&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;关键参数：CIR、CBS、PIR 、PBS（C桶和P桶）&lt;/li&gt;
&lt;li&gt;令牌投放：以CIR速率向C桶投放令牌，以PIR速率向P桶中投放令牌，&lt;code&gt;两个桶相对独立&lt;/code&gt;，桶中令牌满时令牌溢出&lt;/li&gt;
&lt;li&gt;流量突发：允许&lt;strong&gt;报文速率&lt;/strong&gt;的突发。C桶和P桶中的令牌足够时，两个桶中的令牌都使用。C桶中令牌不够时，只使用P桶中的令牌&lt;/li&gt;
&lt;li&gt;颜色标记：绿色、黄色或红色&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 系统按照PIR速率向P桶中投放令牌，按照CIR速率向C桶中投放令牌：
    1. 当Tp&amp;lt;PBS时，P桶中令牌数增加，否则不增加
    2. 当Tc&amp;lt;CBS时，C桶中令牌数增加，否则不增加
2. 对于到达的报文，用B表示报文的大小：
    1. 若B≤Tp并且B≤Tc，报文被标记为绿色，且Tp和Tc都减少B
    2. 若Tc&amp;lt;B≤Tp，报文被标记为黄色，且Tp减少B
    3. 若B&amp;gt;Tp，报文被标记为红色；
&lt;/code&gt;&lt;/pre&gt;
">QoS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/xiang-mu/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3&#34;&gt;边缘端口&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%89%B9%E7%82%B9&#34;&gt;1. 特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%B8%8D%E8%B6%B3&#34;&gt;2. 不足&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%85%8D%E5%90%88%E6%8A%80%E6%9C%AF&#34;&gt;3. 配合技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&#34;&gt;4. 使用场景&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ping%E4%B8%A2%E5%8C%85%E8%AF%A5%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%87%BA%E7%8E%B0%E4%B8%A2%E5%8C%85%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5&#34;&gt;Ping丢包该如何排查？网络中出现丢包，应该如何进行故障排查？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ping%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D%E6%80%9D%E8%B7%AF%E6%95%85%E9%9A%9C%E5%88%86%E6%9E%90&#34;&gt;1. Ping丢包故障定位思路故障分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-ping%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E9%87%8D%E7%8E%B0&#34;&gt;2. Ping丢包故障重现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-ping%E4%B8%A2%E5%8C%85%E6%95%85%E9%9A%9C%E5%AE%9A%E4%BD%8D&#34;&gt;3.  Ping丢包故障定位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E6%95%85%E9%9A%9C%E8%A7%A3%E5%86%B3&#34;&gt;4. 故障解决&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%89%A9%E7%90%86%E9%93%BE%E8%B7%AF%E6%95%85%E9%9A%9C%E5%BC%95%E8%B5%B7ping%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90&#34;&gt;1. 物理链路故障引起ping丢包分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BD%91%E7%BB%9C%E7%8E%AF%E8%B7%AF%E6%95%85%E9%9A%9C%E5%BC%95%E8%B5%B7ping%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90&#34;&gt;2. 网络环路故障引起ping丢包分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-arp%E9%97%AE%E9%A2%98%E6%95%85%E9%9A%9C%E5%BC%95%E8%B5%B7ping%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90&#34;&gt;3. ARP问题故障引起ping丢包分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-icmp%E9%97%AE%E9%A2%98%E6%95%85%E9%9A%9C%E5%BC%95%E8%B5%B7ping%E4%B8%A2%E5%8C%85%E5%88%86%E6%9E%90&#34;&gt;4. ICMP问题故障引起ping丢包分析&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6%E5%8F%B0%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;6台路由器&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E6%98%AF%E4%BC%81%E4%B8%9A&#34;&gt;1. 如果客户是企业&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E6%98%AF%E6%94%BF%E5%BA%9C&#34;&gt;2. 如果客户是政府&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%A6%82%E6%9E%9C%E5%AE%A2%E6%88%B7%E6%98%AF%E4%BF%9D%E5%AF%86%E8%A6%81%E6%B1%82%E6%AF%94%E8%BE%83%E9%AB%98%E7%9A%84%E5%8D%95%E4%BD%8D&#34;&gt;3. 如果客户是保密要求比较高的单位&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%AD%E5%8C%BA%E7%BD%91%E6%89%93%E5%8D%B0%E6%9C%BA%E5%A6%82%E4%BD%95%E9%83%A8%E7%BD%B2&#34;&gt;园区网打印机如何部署&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-vlaneth-trunk&#34;&gt;1. VLAN+Eth-Trunk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BD%91%E5%85%B3rstp&#34;&gt;2. 网关+RSTP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-dhcp%E4%BB%A5%E5%8F%8A%E9%98%B2%E6%8A%A48021x&#34;&gt;3. DHCP以及防护+802.1x&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-natpppoe&#34;&gt;4. NAT+PPPoE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%89%93%E5%8D%B0%E6%9C%BA%E9%85%8D%E7%BD%AE&#34;&gt;5. 打印机配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%AF%E5%BD%A2%E7%BD%91%E5%92%8C%E6%98%9F%E5%BD%A2%E7%BD%91%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%85%B7%E4%BD%93%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&#34;&gt;环形网和星形网的优缺点？具体应用场景？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E7%BC%BA%E7%82%B9&#34;&gt;优缺点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%AD%E5%8C%BA%E7%BD%91&#34;&gt;园区网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#100%E5%8F%B0%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;100台路由器&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%80%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2%E8%80%83%E8%99%91%E5%BA%94%E7%94%A8%E9%82%A3%E7%A7%8Digp%E5%8D%8F%E8%AE%AE&#34;&gt;1. 通过哪些方面考虑应用那种IGP协议？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%80%E5%AE%9A%E8%A6%81%E4%BD%BF%E7%94%A8isis&#34;&gt;2. 什么情况下一定要使用ISIS？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%A7%E5%9E%8B%E5%89%B2%E6%8E%A5&#34;&gt;大型割接&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%B2%E6%8E%A5%E6%B5%81%E7%A8%8B&#34;&gt;割接流程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%89%8D%E6%9C%9F%E8%B0%83%E7%A0%94%E9%98%B6%E6%AE%B5&#34;&gt;1. 前期调研阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%89%B2%E6%8E%A5%E5%89%8D%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5&#34;&gt;2. 割接前准备阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%89%B2%E6%8E%A5%E5%AE%9E%E6%96%BD%E9%98%B6%E6%AE%B5&#34;&gt;3. 割接实施阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%89%B2%E6%8E%A5%E5%90%8E%E4%BF%9D%E9%9A%9C%E9%98%B6%E6%AE%B5&#34;&gt;4. 割接后保障阶段&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%B2%E6%8E%A5%E8%BF%87%E7%A8%8B%E4%B8%AD%E6%B6%89%E5%8F%8A%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9&#34;&gt;割接过程中涉及的知识点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%AF%E5%89%B2%E6%8E%A5%E4%B8%8E%E7%A1%AC%E5%89%B2%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;软割接与硬割接的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E4%B8%8E%E5%89%B2%E6%8E%A5%E6%97%B6%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;时间窗口与割接时间的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%B2%E8%A1%8C%E5%89%B2%E6%8E%A5%E4%B8%8E%E5%B9%B6%E8%A1%8C%E5%89%B2%E6%8E%A5&#34;&gt;串行割接与并行割接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9E%E9%80%80%E6%96%B9%E6%A1%88%E4%B8%8E%E5%BA%94%E6%80%A5%E6%96%B9%E6%A1%88%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;回退方案与应急方案的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%80%BC%E5%AE%88%E5%AE%88%E5%B1%80%E4%B8%80%E8%88%AC%E9%9C%80%E8%A6%81%E5%A4%9A%E9%95%BF%E6%97%B6%E9%97%B4&#34;&gt;什么是值守（守局），一般需要多长时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E7%85%A7&#34;&gt;什么是快照&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%89%B2%E6%8E%A5%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%E4%BB%80%E4%B9%88%E6%98%AF%E5%89%B2%E6%8E%A5&#34;&gt;割接的目的是什么（什么是割接）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E9%9C%80%E8%A6%81%E5%9B%9E%E9%80%80%E5%9B%9E%E9%80%80%E6%97%B6%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88&#34;&gt;如何判断需要回退，回退时应该注意什么&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%BB%93%E6%9E%84&#34;&gt;网络拓扑结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%84%E7%A7%8D%E6%8B%93%E6%89%91%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9&#34;&gt;各种拓扑的优缺点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91%E5%8D%95%E6%98%9F%E5%9E%8B&#34;&gt;1. 星型拓扑（单星型）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BD%91%E7%8A%B6%E6%8B%93%E6%89%91&#34;&gt;2. 网状拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%83%A8%E5%88%86%E7%BD%91%E7%8A%B6%E6%8B%93%E6%89%91&#34;&gt;3. 部分网状拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%8F%8C%E6%98%9F%E5%9E%8B%E6%8B%93%E6%89%91&#34;&gt;4. 双星型拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%A0%91%E5%BD%A2%E6%8B%93%E6%89%91&#34;&gt;5. 树形拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E6%80%BB%E7%BA%BF%E5%9E%8B%E6%8B%93%E6%89%91&#34;&gt;6. 总线型拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%E7%8E%AF%E5%9E%8B%E6%8B%93%E6%89%91&#34;&gt;7. 环型拓扑&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;边缘端口&#34;&gt;边缘端口&lt;/h1&gt;
&lt;h2 id=&#34;1-特点&#34;&gt;1. 特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;接入设备后直接进入forwarding状态，避免等地30秒转发延迟&lt;/li&gt;
&lt;li&gt;边缘端口变为forwarding状态的时候不产生TC报文&lt;/li&gt;
&lt;li&gt;不转发TC报文&lt;/li&gt;
&lt;li&gt;收到TC不删除本接口的MAC表&lt;/li&gt;
&lt;li&gt;P/A收敛时，不会进入阻塞状态&lt;/li&gt;
&lt;li&gt;收到BPDU报文，变普通端口，执行STP计算&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-不足&#34;&gt;2. 不足&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;临时环路&lt;br&gt;
（2个端口直接连起来，或者下游接入的交换机不支持生成树）&lt;br&gt;
临时环路持续0-2秒，收到对方端口发出的BPDU后同时进入阻塞状态，进行生成树的选举，决出一个DP和一个BP，DP在30秒之后进入转发状态，BP维持阻塞状态。&lt;/li&gt;
&lt;li&gt;当边缘端口收到BPDU后，会丧失边缘端口的特性，变成普通端口并进行生成树计算，引起网络震荡。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-配合技术&#34;&gt;3. 配合技术&lt;/h2&gt;
&lt;p&gt;BPDU保护&lt;br&gt;
正常情况下，边缘端口接用户终端，不会收到BPDU报文。假如有人恶意攻击，伪造BPDU报文，那么边缘端口收到BPDU报文之后变为普通端口，引起生成树计算，导致网络震荡。&lt;br&gt;
此时需要在边缘端口上配置BPDU保护功能，如果边缘端口再收到BPDU报文，此时边缘端口并不会变为普通端口，而是error-down，然后通知网管系统，如果想要恢复转发状态，可以手动&lt;code&gt;shutdown/undo shutdown&lt;/code&gt;，或者配置自动恢复&lt;code&gt;error-down auto-recovery cause bpdu-protection interval 时长&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-使用场景&#34;&gt;4. 使用场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;大型公司内网有很多电脑，上下班时产生大量的TC，造成所有交换机的MAC地址表频繁删除，以至于持续泛洪所有的数据帧，启用边缘端口可以改善网络品质&lt;/li&gt;
&lt;li&gt;接DHCP客户端的端口，否则DHCP获取地址比较慢&lt;/li&gt;
&lt;li&gt;接重要服务器和IP电话接口，否则在生成树拓扑发生变化时，将被阻塞掉，30秒后才能再次提供服务&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ping丢包该如何排查网络中出现丢包应该如何进行故障排查&#34;&gt;Ping丢包该如何排查？网络中出现丢包，应该如何进行故障排查？&lt;/h1&gt;
&lt;h2 id=&#34;1-ping丢包故障定位思路故障分析&#34;&gt;1. Ping丢包故障定位思路故障分析&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Ping丢包是指Ping报文在网络中传输，由于各种原因（如线路过长、网络拥塞等）而产生部分Ping报文丢弃的现象。在使用Ping命令，出现Ping丢包的现象时，第一步需要&lt;strong&gt;确定Ping丢包的网络位置&lt;/strong&gt;，其次是&lt;strong&gt;确定Ping丢包的故障原因和设备&lt;/strong&gt;，然后依据定位的故障原因再进行解决。
&lt;ol&gt;
&lt;li&gt;确认Ping丢包的&lt;strong&gt;网络位置时&lt;/strong&gt;一般采用&lt;strong&gt;逐段Ping的方法&lt;/strong&gt;，可以将Ping丢包故障最终确定在直连网段之间&lt;/li&gt;
&lt;li&gt;确认Ping丢包的&lt;strong&gt;故障原因&lt;/strong&gt;一般采用&lt;strong&gt;流量统计的方法&lt;/strong&gt;，通过流量统计可以知道丢弃报文的&lt;strong&gt;具体位置、判断故障原因&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;导致Ping丢包的原因非常多，也非常复杂，比如物理环境故障、网络环路、ARP问题、ICMP问题等，当然，并不是Ping丢包就一定表示网络质量差，某些情况下虽然Ping丢包，但是业务是正常的。&lt;/li&gt;
&lt;li&gt;分析Ping丢包时注意以下两点：
&lt;ol&gt;
&lt;li&gt;当设备对报文进行硬件转发，速度非常快，就不会丢包，例如Ping设备端口下挂的电脑。当报文需要CPU进行处理时，CPU繁忙就会丢包，例如Ping设备上的IP地址。&lt;/li&gt;
&lt;li&gt;为了防止网络攻击对设备造成影响，设备具有CPU保护功能，对于超过CPCAR值的ARP、ICMP等报文进行丢弃，造成Ping丢包现象，此种现象不影响业务的正常运行。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-ping丢包故障重现&#34;&gt;2. Ping丢包故障重现&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1616895461793.png&#34; alt=&#34;Ping测试组网图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在PC上执行&lt;code&gt;ping -n 100 192.168.4.41&lt;/code&gt;，发现有20%的报文丢失&lt;/p&gt;
&lt;h2 id=&#34;3-ping丢包故障定位&#34;&gt;3.  Ping丢包故障定位&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;缩小故障范围&lt;br&gt;
当在PC上直接Ping IP地址192.168.4.41丢包时，直接判定故障出现的原因将非常的困难。此时可以先缩小故障范围，在PC上分别Ping SwitchA、SwitchB、SwitchC和SwitchD，通过Ping结果可以判断出哪一段网络出现故障。假设PC上Ping SwitchB时也出现丢包，则可以初步判断丢包发生在SwitchA和SwitchB直连网段之间&lt;/li&gt;
&lt;li&gt;配置Ping多包&lt;br&gt;
为了持续复现丢包现象，以便于故障处理，需要持续发送Ping报文。交换机可以配置Ping的-c count参数，发送多个Ping报文。&lt;/li&gt;
&lt;li&gt;配置流量统计&lt;br&gt;
通过缩小故障范围最终将故障定位在SwitchA和SwitchB之间，为了进一步确认故障点，需要在SwitchA和SwitchB上配置流量统计功能，观察丢包情况，配置方法如下：
&lt;ol&gt;
&lt;li&gt;先通过高级acl配置流规则&lt;code&gt;acl 3000 ; rule 5 permit icmp source 192.168.1.5 0 destination 192.168.2.21 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后根据acl配置流策略，主要是配置
&lt;ol&gt;
&lt;li&gt;traffic classifier命中流&lt;code&gt;if-match acl 3000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;traffic behavior流行为&lt;code&gt;statiatic enable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用traffic policy将流和行为绑定&lt;code&gt;claffifier huawei behavior huawei&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在接口下使能策略&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;查看流量统计命令为&lt;code&gt;display traffic policy statistics interface {接口} inbound或者outbound verbose rule-based class huawei&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;清空流量统计命令为&lt;code&gt;reset traffic policy statistics interface {接口} inbound或者outbound&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分析统计结果&lt;br&gt;
在SwitchA上持续Ping SwitchB
&lt;ol&gt;
&lt;li&gt;如果离开SwitchA的报文数目 &lt;code&gt;&amp;lt;&lt;/code&gt; Ping发送的报文数目，说明SwitchA上丢包，引起SwitchA丢包可能原因分为&lt;strong&gt;网络环路和ARP问题&lt;/strong&gt;。登陆设备SwitchA
&lt;ol&gt;
&lt;li&gt;查看CPU和接口利用率的情况，查看是否出现MAC地址漂移&lt;/li&gt;
&lt;li&gt;查看是否有ARP报文被丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果离开SwitchA的报文数目 &lt;code&gt;&amp;gt;&lt;/code&gt; 进入SwitchB的报文数目，说明传输链路上存在丢包，后面介绍的物理链路故障引起ping丢包如何处理&lt;/li&gt;
&lt;li&gt;如果离开SwitchA的报文数目 &lt;code&gt;=&lt;/code&gt; 进入SwitchB的报文数目，但是离开SwitchB的报文数目 &lt;code&gt;&amp;lt;&lt;/code&gt; 进入SwitchB报文数目，说明SwitchB上存在丢包，引起SwitchB设备丢包可能原因分为&lt;strong&gt;网络环路和ICMP问题&lt;/strong&gt;。登录设备SwitchB：
&lt;ol&gt;
&lt;li&gt;查看CPU和接口利用率是否很高、查看是否出现MAC地址漂移&lt;/li&gt;
&lt;li&gt;查看是否有ICMP报文被丢弃、查看ICMP报文限速的配置是否过小&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-故障解决&#34;&gt;4. 故障解决&lt;/h2&gt;
&lt;h3 id=&#34;1-物理链路故障引起ping丢包分析&#34;&gt;1. 物理链路故障引起ping丢包分析&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;物理链路故障常见以下原因：
&lt;ol&gt;
&lt;li&gt;计算机网卡有问题&lt;/li&gt;
&lt;li&gt;线缆接头接触不良或松脱&lt;/li&gt;
&lt;li&gt;网线出现问题，可以使用精明鼠查看是否有网线中断线情况&lt;/li&gt;
&lt;li&gt;光纤弯曲度过大或者损坏导致光纤功率过低，PC和服务器上的可以使用光功率计测量，交换机上可以使用命令&lt;code&gt;display transceiver interface gigabitethernet 0/0/1 verbose&lt;/code&gt;查看，一般光功率大于-15db为正常可用的，小于-40db无法使用，当然光功率也不是越大越好，过大容易导致光模块损坏。如果是对光信号进行放大，被放大的信号如果信噪比比较低的情况，被放大之后的信号的失步更加严重。&lt;/li&gt;
&lt;li&gt;如果是光纤问题，比较容易损坏的是lc头&lt;sub&gt;lc小方头（直接连接光模块）、fc大圆头、sc大方头、st小圆头&lt;/sub&gt;，如果是远距离传输，可以使用otdr&lt;sub&gt;光时域反射仪&lt;/sub&gt;定位大概的光纤故障地理位置&lt;/li&gt;
&lt;li&gt;除了网络设备直接相关的物理因素，还有以下因素：
&lt;ol&gt;
&lt;li&gt;在实际环境中设备未接地导致静电不能释放&lt;/li&gt;
&lt;li&gt;风扇损坏导致设备过热等物理环境问题也会引起Ping丢包&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;物理链路故障可以通过观察发现，如光纤弯曲度过大、物理连接线过长、设备或者电脑网卡指示灯显示不正常等&lt;/li&gt;
&lt;li&gt;针对物理链路故障，故障的解决的办法一般是更换物理器件，器件更换后故障即可恢复。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-网络环路故障引起ping丢包分析&#34;&gt;2. 网络环路故障引起ping丢包分析&lt;/h3&gt;
&lt;p&gt;以太网交换网络中为了进行链路备份，提高网络可靠性，通常会使用冗余链路，但是使用冗余链路会在交换网络上产生环路，引发广播风暴以及MAC地址表不稳定等故障现象，从而导致用户通信质量较差，甚至通信中断。&lt;br&gt;
网络环路会导致设备CPU和端口利用率高，Ping报文被丢弃。&lt;br&gt;
当设备处于存在环路的网络中，设备的反应速度比较缓慢，环路问题判断方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;display interface brief | include up&lt;/code&gt;命令，查看所有UP接口下的流量，存在环路的接口上&lt;code&gt;InUti和OutUti&lt;/code&gt;两个计数会逐步增加，甚至到接近100%，远远超过业务流量&lt;/li&gt;
&lt;li&gt;检查CPU的利用率&lt;br&gt;
通过命令&lt;code&gt;display cpu-usage&lt;/code&gt;查看CPU的利用率&lt;br&gt;
网络环路会导致CPU利用率一直很高，Ping报文未来得及处理就被丢弃。&lt;/li&gt;
&lt;li&gt;判断交换机是否存在MAC地址漂移
&lt;ol&gt;
&lt;li&gt;可以执行&lt;code&gt;display trapbuffer&lt;/code&gt;命令，查看MAC地址漂移的日志来判断&lt;/li&gt;
&lt;li&gt;可以多次执行&lt;code&gt;display mac-address&lt;/code&gt;来观察，若MAC地址在交换机不同的接口学习到，则存在mac地址漂移&lt;/li&gt;
&lt;li&gt;可以执行&lt;code&gt;mac-address flapping detection&lt;/code&gt;命令配置MAC地址漂移检测功能，然后通过&lt;code&gt;display mac-address flapping record&lt;/code&gt;命令来判断是否出现MAC地址漂移&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决此种Ping丢包问题的方法是破除网络环路，可以在设备上部署STP/RSTP/MSTP~或者Smart Link~等协议，对环路进行处理&lt;/p&gt;
&lt;h3 id=&#34;3-arp问题故障引起ping丢包分析&#34;&gt;3. ARP问题故障引起ping丢包分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;常见ARP攻击：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ARP泛洪攻击（拒绝服务攻击Dos），攻击者发送大量的ARP报文，侵占设备ARP表项资源，导致系统资源耗尽。可以通过配置ARP表项限制、ARP Miss消息限速、ARP表项严格学习、ARP报文限速来&lt;/li&gt;
&lt;li&gt;ARP欺骗攻击（中间人攻击），攻击者通过发送伪造的ARP报文，恶意修改设备或网络内其他用户主机的ARP表项。可以通过配置ARP表项固化、ARP表项严格学习、发送免费ARP报文、DAI来防止ARP欺骗攻击。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;ARP问题常见故障现象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刚开始由于ARP学习失败出现Ping丢包&lt;/li&gt;
&lt;li&gt;然后学习到ARP后一段时间内（ARP表项老化时间，默认20分钟）无丢包现象&lt;/li&gt;
&lt;li&gt;之后再出现ARP学习失败会继续出现丢包&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常见ARP问题有以下两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备配置了ARP安全功能，如ARP Miss的源抑制、ARP速率抑制等，会导致ARP学习很慢，Ping丢包&lt;/li&gt;
&lt;li&gt;设备受到ARP报文攻击，上送CPU的ARP报文数超过CPCAR值，导致部分ARP报文被丢弃，Ping丢包&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常见问题判断及解决方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;code&gt;display arp packet statistics&lt;/code&gt;命令，查看是否有ARP报文被丢弃，分析设备上ARP安全的配置情况，从而判断问题的原因。对于该问题需要重新配置ARP安全，使设备能够正常的处理ARP报文。&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;display cpu-defend statistics&lt;/code&gt;命令，查看CPU对于ARP报文处理情况，是否存在报文丢弃。对于该问题需要检查设备是否受到ARP攻击，正确配置ARP安全来防范攻击，同时增加ARP报文的CPCAR值。配置样例如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cpu-defend policy arp
car packet-type arp-reply cir 32
car packet-type arp-request cir 32
quit
cpu-defend-policy arp global
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;4-icmp问题故障引起ping丢包分析&#34;&gt;4. ICMP问题故障引起ping丢包分析&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;常见ICMP攻击：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ICMP泛洪攻击，发送速度极快的ping报文，导致被攻击者疲于应付，CPU使用率过高。可以设置CPCAR值，保证设备CPU不被攻击&lt;/li&gt;
&lt;li&gt;发送长度超过65535B的报文，导致被攻击者组报之后内存溢出。可以设置ping的报文长度，超过长度的报文直接丢弃&lt;/li&gt;
&lt;li&gt;发送的报文长度没有超过65535B，但是会分片，导致被攻击者频繁的组报，CPU使用率过高。可以设置丢弃ICMP分片的报文&lt;/li&gt;
&lt;li&gt;发送icmp不可达报文，干扰被攻击者的路由信息，影响正常报文的转发。可以开启ICMP不可达报文攻击防范功能，收到ICMP不可达报文将直接忽略&lt;/li&gt;
&lt;li&gt;跨越网段向被攻击者发送虚假的重定向报文，以改变目标主机的路由表，影响正常报文的转发。可以启动ICMP重定向攻击防范后，设备将对ICMP重定向报文进行丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;ICMP问题常见故障现象：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Ping设备时，一旦Ping速度比较快就会丢包，速度慢下来就不会丢包&lt;/li&gt;
&lt;li&gt;Ping大包时出现规律性丢包&lt;/li&gt;
&lt;li&gt;Ping设备时，会出现Ping通几个报文后Ping不通，大约两分钟左右又可以Ping通，Ping通几个报文后又Ping不通&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常见ICMP问题有以下三种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备配置ICMP限速功能，超过速度限制的ICMP报文被丢弃&lt;/li&gt;
&lt;li&gt;设备配置ICMP攻击防范，超过速度限制的ICMP报文被丢弃&lt;/li&gt;
&lt;li&gt;设备受到ICMP报文攻击，上送CPU的ICMP报文数超过CPCAR值，导致部分ICMP报文被丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;常见问题判断及解决方法如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查&lt;code&gt;icmp rate-limit total threshold threshold-value&lt;/code&gt;命令的配置情况，了解ICMP流量限速的阈值。如果阈值过小，则可通过&lt;code&gt;icmp rate-limit total threshold threshold-value&lt;/code&gt;命令进行修改，使其允许更多的ICMP报文通过。配置如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;icmp rate-limit enable
icmp rate-limit total threshold 500
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;通过&lt;code&gt;display icmp statistics&lt;/code&gt;和&lt;code&gt;display anti-attack statistics icmp-flood&lt;/code&gt;命令查看是否有ICMP报文被丢弃。对于该问题需要重新配置ICMP安全，使设备能够正常的处理ICMP报文&lt;/li&gt;
&lt;li&gt;通过&lt;code&gt;display cpu-defend statistics packet-type icmp all&lt;/code&gt;命令，查看CPU对于ICMP报文处理情况，是否存在报文丢弃。对于该问题需要检查设备是否受到ICMP攻击，正确配置ICMP安全来防范攻击，同时增加ICMP报文的CPCAR值。ICMP报文的CPCAR值配置样例如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cpu-defend policy icmp
car packet-type icmp cir 256
quit
cpu-defend-policy icmp global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以通过&lt;code&gt;icmp-reply fast&lt;/code&gt;命令使能Ping快回功能来解决CPU丢弃ICMP报文故障&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;6台路由器&#34;&gt;6台路由器&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;给你6台路由器，2台高性能，2台中等性能，2台低性能，构思两种拓扑，你怎么规划？有什么区别？&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614860816612.png&#34; alt=&#34;6台路由器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
拓扑如何规划需要考虑到用户关心的核心问题：&lt;/p&gt;
&lt;h2 id=&#34;1-如果客户是企业&#34;&gt;1. 如果客户是企业&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;可能最关心的是成本开销问题&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从设备角度考虑：&lt;br&gt;
使用交叉型连接，会需要更多的端口、光纤&lt;sub&gt;单模光纤比多模光纤贵，但是传输距离远&lt;/sub&gt;、光模块&lt;sub&gt;一个万兆光模块一千多&lt;/sub&gt;、板卡&lt;sub&gt;更贵&lt;/sub&gt;、，需要增加采购成本&lt;/li&gt;
&lt;li&gt;从线路角度考虑：&lt;br&gt;
若节点和节点之间距离较远，在不同的城市中，租用运营商长途专线互联，日字型一般情况下，可以满足互联互通的需求，也提供基本的冗余能力，但要追求更高的冗余性则可以使用交叉型。&lt;br&gt;
运营商租用线路是按照每纤每公里每月来计费的，比如移动裸纤市场价是每纤每公里每月400元。&lt;br&gt;
租用专线，比如在同一个城市不同的区，之前单位办理10M的专线一月是3500，后来租用的200M的，一年就是40万。&lt;br&gt;
因此，租用线路成本有可能高于设备采购成本&lt;/li&gt;
&lt;li&gt;对于运营商：&lt;br&gt;
由于其拥有传输资源，成本不会过多造成压力，设计网络主要从冗余、性能等角度去考虑，一般在&lt;strong&gt;核心层和汇聚层之间&lt;/strong&gt;多采用交叉型，&lt;strong&gt;汇聚层和接入层之间&lt;/strong&gt;多采用日字形&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-如果客户是政府&#34;&gt;2. 如果客户是政府&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;这类客户不差钱，可能最关心的是冗余、网络品质以及后期维护的问题&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;冗余：&lt;br&gt;
物理层面分为设备冗余和链路冗余，日字型和交叉型都满足设备和链路冗余，都不存在单点故障，但是交叉型较日字型冗余性更高&lt;/li&gt;
&lt;li&gt;网络品质角度：&lt;br&gt;
日字型设计由于互联线路较少，所以在节点和节点之间（特别是斜对角）访问的时候，网络品质不是最优，且当中经过的线路和设备较多，任意一点出现问题都会导致网络品质下降，所以健壮度不高。特别是在上行链路中断的情况下，流量将走中间平行的互联链路，极易对旁路造成干扰。&lt;br&gt;
交叉型设计由于互联线路多，任意节点之间互访都是最优路径，且在一条上行线路故障的情况下，整体网络品质几乎不受影响&lt;/li&gt;
&lt;li&gt;后期维护：&lt;br&gt;
&lt;code&gt;普通的一个政府部门，比如一个处，很少招收专门的网络运维人员，基本都是兼职&lt;/code&gt;&lt;br&gt;
对于IGP协议，交叉型在路由设计上比日字型邻居数量成倍增加，故障定位和排障难度增大&lt;br&gt;
日字形比交叉型拓扑简单，邻居较少，流量走向清晰，在日常管理运维方面更有优势。如果出现故障，排障比较快；如果日后增加节点进行扩容，也更容易实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-如果客户是保密要求比较高的单位&#34;&gt;3. 如果客户是保密要求比较高的单位&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;可能更关系的是流量和路由的控制问题&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络流量&lt;br&gt;
分为主备方式和负载均衡方式，日字型比较适合设计为主备方式，流量走向比较清晰明了；交叉型比较适合设计为负载均衡方式，但设计不好容易出现来回路径不一致现象，保密单位一般部署加密机和防火墙，如果采用来回路径不一致&lt;sub&gt;URPF，单播反向路径转发&lt;/sub&gt;的情况下，可能造成网络互访有问题&lt;/li&gt;
&lt;li&gt;路由控制问题：&lt;br&gt;
交叉型下游设备均是双上联，这种情况下对于路由的控制需要配置更多的规则，并且路由的走向的过多，不利于严格控制流量的走向&lt;br&gt;
日字型只有一个上联线路，为了实现所有的流量都经过核心交换机，实现流量精确控制，只需要配置策略的策略阻断接入和汇聚两层的横线连接的链路即可&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;园区网打印机如何部署&#34;&gt;园区网打印机如何部署&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615043377401.png&#34; alt=&#34;园区网打印机如何部署&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-vlaneth-trunk&#34;&gt;1. VLAN+Eth-Trunk&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;这是两个部门，需要划分vlan进行隔离&lt;/li&gt;
&lt;li&gt;SW1和SW2创建相应的vlan之后，将与终端相连的接口添加进入vlan，上行接口放行所有的vlan&lt;/li&gt;
&lt;li&gt;在配置vlan时，与打印机和终端相连的下行端口配置成access，交换机与交换机之间配置成trunk&lt;/li&gt;
&lt;li&gt;双上行链路，很明显需要配置成eth-trunk，然后配置成trunk口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 下行端口配置
# SW1
vlan 10 
port link-type access
port default vlan 10
port g0/0/1 to g0/0/10

# SW2
vlan 20
port link-type access
port default vlan 20
port g0/0/1 to g0/0/10

# 上行端口配置
int eth-trunk 1
trunkport g0/0/11 0/0/12
port link-type trunk
port trunk allow-pass vlan all   # 或者10 20
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;为什么接口模式不使用hybrid？因为hybrid配置比较麻烦，不仅需要配置PVID，还需要配置untag-list等；其次hybrid一般用在接入像华为FusionComputer、VMware的EXSi或者开源的PVE这类虚拟化平台设备，因为这类设备中有虚拟交换机，可以划分vlan，此接口下可能接收到带有vlan的数据&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-网关rstp&#34;&gt;2. 网关+RSTP&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;这属于办公网络，只有两个接入和一个汇聚，为了方便流量控制，同时减少在接入交换机上划分过多的vlan，&lt;strong&gt;建议将网关部署在汇聚交换机上&lt;/strong&gt;，同时需要在汇聚交换机上配置所有的vlan&lt;/li&gt;
&lt;li&gt;还需要在交换机上配置RSTP，通过修改优先级将汇聚交换机配置为根桥&lt;/li&gt;
&lt;li&gt;为了防止上下班高峰期时频繁的开关机导致的拓扑频繁变化，此时可以将与终端相连的端口配置成边缘端口&lt;/li&gt;
&lt;li&gt;正常情况下边缘端口与终端相连并不会收到BPDU报文，但是如果有人恶意攻击，仿造BPDU报文，导致边缘端口收到BPDU报文之后变成普通端口，重新进行生成树计算，导致网络震荡，这时候可以配置BPDU保护。开启BPDU保护之后，边缘端口收到BPDU报文之后并不会变为普通端口，而是error-down，此时需要进行手动恢复，即&lt;code&gt;shutdown/undo shutdown&lt;/code&gt;，当然也可以配置自动恢复&lt;code&gt;error-down auto-recovery cause bpdu-protection interval 时长&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;因为接口交换机配置边缘端口较多，为了方便配置，一般采用在全局下开启边缘端口&lt;code&gt;stp edged-port default&lt;/code&gt;，此时需要注意的是，需要将与上游汇聚交换机相连的eth-trunk接口从边缘端口中解放出来，即在此接口下配置&lt;code&gt;stp edged-port disable&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置vlan
vlan batch 10 20
int vlan 10
ip addr 10.1.1.254 255.255.255.0
int vlan 20
ip addr 20.1.1.254 255.255.255.0

# 当然也需要配置eth-trunk，配置方法与接入交换机相同

# 配置rstp
stp mode rstp
stp root primary
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-dhcp以及防护8021x&#34;&gt;3. DHCP以及防护+802.1x&lt;/h2&gt;
&lt;p&gt;为了能够使终端自动获取到IP地址，需要在汇聚上配置DHCP服务器。&lt;br&gt;
由于打印机要配置固定的IP，有两种方法可以实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在DHCP中使用Mac与IP地址绑定的方式实现&lt;/li&gt;
&lt;li&gt;在打印机上配置静态IP之后，在DHCP地址池中将其exclude掉&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;全局地址池和接口地址池的区别：接口地址池只能使用接口地址作为网关，全局地址池可以单独配置网关&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ip pool hcie
gateway-list 10.1.1.254
network 10.1.1.0 mask 255.255.255.0
exclude-ip-address 10.1.1.100   # 排除打印机静态配置的地址
static-bind ip-address 10.1.1.100 mac-address 0001-0002-0003
dns-list 114.114.114.114
quit
dhcp enable
int eth-trunk 1
dhcp select global
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;配置了DHCP之后，还需要配置响应的防护功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了防止有人冒充DHCP服务器为终端分配地址（DHCP仿冒者攻击），需要配置信任端口，即将连接DHCP服务器的端口配置成信任端口，这样就保证客户端不会收到仿冒者发送的DHCP offer报文&lt;/li&gt;
&lt;li&gt;为了防止中间人攻击，即ARP欺骗，攻击者发送一个ARP报文给接入交换机，将ARP报文中的sender IP改为客户端的IP，但是sender mac却是攻击者的mac，这就导致DHCP服务器上和客户端上的ARP表项中的mac地址不是对方的，而是攻击者的，造成DHCP服务器和客户端之间的数据全部转发给攻击者。为了防止这种攻击，可以开启一下功能：
&lt;ol&gt;
&lt;li&gt;部署DHCP snooping，配置信任端口，创建绑定表，绑定表中包含MAC地址、IP地址、租约时间、VlanID、接口信息，如果报文中跟绑定表中记录内容的不一致则会丢弃报文&lt;/li&gt;
&lt;li&gt;DAI，动态ARP检测，当设备收到ARP报文时，将此ARP报文对应的源IP、源MAC、VLAN以及接口信息和绑定表的信息进行比较，如果信息匹配，说明发送该ARP报文的用户是合法用户，否则丢弃报文。可以使用命令&lt;code&gt;dai enable&lt;/code&gt;开启DAI功能&lt;/li&gt;
&lt;li&gt;IPSG，IP源防攻击，防止IP盗用的行为，同样是利用绑定表来检查二层接口上收到的IP报文，只有与绑定表中信息一致才通过，否则丢弃。可以使用命令&lt;code&gt;ip source check user-bind enable&lt;/code&gt;开启IPSG共呢个&lt;br&gt;
&lt;code&gt;DAI和IPSG启用之前必须配置DHCP Snooping，因为这两个功能都依赖DHCP Snooping的绑定表&lt;/code&gt;&lt;br&gt;
&lt;code&gt;DAI和IPSG的区别：DAI是利用绑定表对ARP报文进行过滤，防止中间人攻击；IPSG是利用绑定表对IP报文进行过滤，防止IP地址欺骗攻击&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;option43选项是告诉AP，AC的IP地址，让AP寻找AC进行注册&lt;br&gt;
option82实现dhcp客户端和dhcp中继设备的地址信息记录在dhcp服务器上，实现dhcp分配的限制和计费功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为了防止有人随意上网，可以使用802.1x对接入的终端进行认证，通过授权来指定用户所能访问的资源。802.1x是一种基于端口的网络接入控制协议，因为是二层协议，所以对接入设备的性能要求不高，同时认证报文和数据报文通过逻辑接口分离，安全性比较高。&lt;br&gt;
802.1x由三部分组成，客户端、接入设备和认证服务器（AAA），在此园区网中，客户端即PC、接入设备即接入层交换机、认证服务器即汇聚层交换机。客户端需要安装802.1x认证的终端，并且支持EAPoL（EAL over LANs，可扩展认证协议）&lt;br&gt;
客户端分为两个逻辑接口，一个是用来传输认证数据的非受控端口，另一个是用来传输传输业务数据的受控端口，受控端口只有在授权状态下才会进行业务数据的传输。&lt;br&gt;
认证触发方式主要分为客户端触发和认证服务器触发。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端可以发送EAPoL-start报文来进行认证触发，该报文的组播mac为01-80-C2-00-00-03，除此之外，还可以发送DHCP/ARP/DHCPv6/ND等报文触发认证；&lt;/li&gt;
&lt;li&gt;而认证服务器端则是周期性的发送EAPoL-request/identity来触发认证，用来支持不能主动发送EAPoL-start报文的终端设备。&lt;/li&gt;
&lt;li&gt;假如设备无法安装802.1x终端，可以使用MAC旁路认证，例如打印机、摄像头等设备，终端使用mac地址作为用户名和密码进行认证。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-natpppoe&#34;&gt;4. NAT+PPPoE&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果该公司想要访问运营商网络，可以采用NAT的方式
&lt;ol&gt;
&lt;li&gt;NAT分为Basic NAT和NAPT。Basic NAT仅仅是IP地址的一对一的转换，不处理端口；而NAPT可以把多个内网地址映射到一个公网地址的不同端口上，实现多个私网用户共用一个公网IP访问互联网的目的&lt;/li&gt;
&lt;li&gt;因为配置NAT是在路由器上配置，用户流量最终汇聚到汇聚交换机上，为了引导用户流量进入路由器，然后进入运营商网络，在这种场景下，最简单的方式是配置默认路由，一条是在汇聚交换机上配置的指向路由器的默认路由，另外一条是路由器上配置的指向运行商的默认路由&lt;/li&gt;
&lt;li&gt;如果是单纯的是公司访问互联网，则可以配置Easy IP，原理跟NAPT相同，都是使用&lt;code&gt;IP地址+端口&lt;/code&gt;的方式进行映射；如果该公司还对外提供网络服务，例如HTTP，这时候需要配置NAT Server，在路由器上配置&lt;code&gt;公网IP地址+端口号&lt;/code&gt;与&lt;code&gt;私网IP地址+端口号&lt;/code&gt;之间的映射关系，从而实现公网用户能够访问内网提供给的http服务等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;除了使用NAT上网，还可以采用PPPoE的上网方式
&lt;ol&gt;
&lt;li&gt;配置PPPoE的客户端，在路由器上，首先创建dialer接口，在该接口下配置链路封装协议为ppp、IP地址为ppp自动协商，同时指定dialer接口拨号所使用的账号和认证方式等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-打印机配置&#34;&gt;5. 打印机配置&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果打印机有网口，可以配置成网络打印机，将打印机直接接入交换机即可
&lt;ol&gt;
&lt;li&gt;如果打印机不支持DHCP，可以直接配置固定的IP之后，在DHCP服务器的地址池中将这个IP排除掉&lt;/li&gt;
&lt;li&gt;如果打印机支持DHCP，可以在DHCP服务器的地址池中，通过打印机的MAC绑定一个固定的IP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果打印机没有网口，只能配置成共享打印机的方式，使用一台主机（打印服务器）的usb连接打印机，当需要打印东西的时候，访问打印服务器即可，打印服务器IP的配置方式和网络打印机的方式相同&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;环形网和星形网的优缺点具体应用场景&#34;&gt;环形网和星形网的优缺点？具体应用场景？&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615019200988.png&#34; alt=&#34; 环形网和星形网的优缺点&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;优缺点&#34;&gt;优缺点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;冗余性和成本&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;任一节点到其他节点都有两条路径，双星型和环型都具有冗余性和可靠性。但是双星型比环型冗余度更高，两个接入层之间的互访，环型只有2条链路，星型有4条。&lt;/li&gt;
&lt;li&gt;双星型冗余度更高，成本也会增加很多，比如在汇聚层，环型只需要2个接口，双星型却需要4个接口，成本会显著增加，比如万兆光模块一个千把块钱、40G的光模块更贵、40G的光纤也是按米计价。这仅仅只是设备成本，搭建网络租用运营商的线路成本可能要远远高于设备成本，目前移动光纤市场价是400元/纤/千米/月&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载分担和网络品质&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;双星型可以实现双链路负载分担，任意节点之间互访，仅经过汇聚节点，出现故障后，故障影响范围较小&lt;/li&gt;
&lt;li&gt;环型路径节点数量不一致，很难实现负载分担，无论走哪条路径都进过很多节点，网络品质很难保证，当出现多个故障点时，会导致大面积业务中断&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由控制和破环&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;双星型，因为访问必经过2个汇聚，更好控制，流量路径相对环形网络有更多路径的可能，流量统一通过汇聚交换机转发，方便实现流量管理，方便安全设备部署实施以及无线设备的部署以及QOS相关优化，破环可以使用VRRP+MSTP、smart-link+monitor-link或者堆叠&lt;/li&gt;
&lt;li&gt;环型，任意2个节点之间互访可能性很多，只能在各自节点做路径控制，接入设备之间直接走流量，汇聚设备性能无法充分利用，并增加接入设备的流量负担，不利于流量集中管理和部署网络安全相关的策略，网络管理难度大，破环可以使用MSTP破二层环路、ospf破三层环路&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网关部署&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;双星型中网关部署在汇聚和接入均可，一般简单局域网中，汇聚性能高，网关部署在汇聚更合适，更加方便路由控制和流量管理，并且能充分发挥汇聚层设备高性能的优势，同时也能减少在接入层设备上划分过多的vlan&lt;/li&gt;
&lt;li&gt;环型，因为各节点都存在用户终端，一般是物理距离特别远时选择环型网络，网关建议分布式部署，每个节点部署自己的网关即可，如果需要同一个网关，可以使用super VLAN，即vlan聚合；更高级一些的，可以部署Vxlan，即三层网关，采用分布式网关的部署方式，将汇聚层设备堆叠后做为spine节点，将接入层设备作为leaf节点，但需要注意的是，使用VXLAN技术也会带来一些新的问题，比如数据传输开销增加的问题，因为Vxlan采用Ethernet over UDP的方式，仅仅Vxlan报文的头部就50字节【=2层14B+IP头20B+UDP头8B+VXLAN头8B】，容易造成分片，建议使用Vxlan的时候修改MTU&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩展性和运维&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;环型扩容会影响当前的拓扑，需要将环型网络拆开，这种情况下会导致冗余性的暂时丢失，同时也会造成拓扑变化比较大，IGP协议需要重新针对环型网路做路由收敛，代价比较大，在割接过程中需要谨慎&lt;/li&gt;
&lt;li&gt;双星型扩容，只是增加设备和相应链路，不破坏原有的拓扑，扩展性比较强，适合规模化、模块化部署，新加入的设备和原有的接入层设备的冗余能力相同，并且对于IGP协议来说，原有的拓扑并不会改变，只是新增一部分路由，在割接过程中，风险可控，操作难度大大降低&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;适用场景&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;环型，一般用于广域网组网或者传输网组网或者骨干网，并且设备性能差别不太大的情况下，因为所有机器要承载网络中的所有路由，比如有4太S5700EI、两台S5700HI&lt;/li&gt;
&lt;li&gt;双星型，常用于中小型企业总部园区网络或大型分支网络或者数据中心网络中，性能较好的设备放在汇聚层，性能逊色一些的设备放在接入层，比如两台S9700HI，4台S5700EI&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;园区网&#34;&gt;园区网&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;园区网的网关部署在接入层还是汇聚层？&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;放在汇聚层有优势
&lt;ol&gt;
&lt;li&gt;从&lt;strong&gt;成本&lt;/strong&gt;角度去分析：对接入设备性能要求比较低，成本减少（接入交换机可以只要求2层，版本可以是简化版LI），看接入交换机的数量，数量越大成本优势越明显&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;网关冗余&lt;/strong&gt;的角度分析：可以在2台汇聚之间运行VRRP等技术实现网关冗余，如放接入需要采用堆叠等技术实现，扩展性差&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;业务部署和管理&lt;/strong&gt;角度分析：所有核心网关配置可以远程配置，现场工程师只需要把接口划入指定VLAN，测试电脑配置指定IP，PING通网关即可，现场不需要考虑路由协议问题&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;业务局部迁移&lt;/strong&gt;角度分析：因为不同接入交换机上的相同VLAN是互相通的，所以物理位置的迁移（比如机房的搬迁等情况下）不需要重新部署新的IP地址段&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;IP资源&lt;/strong&gt;角度分析：不同接入交换机上的VLAN使用相同的IP地址段，避免浪费，减少接入和汇聚之间的互联地址段，减少路由协议的邻居数目&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;放在接入层有优势
&lt;ol&gt;
&lt;li&gt;从&lt;strong&gt;隔离广播域&lt;/strong&gt;的角度分析：可以分割广播域，当局域网出现类似ARP病毒之类的问题，受影响的范围可控&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;故障定位&lt;/strong&gt;的角度分析：哪个网段出现问题，直接能够根据拓扑图找到物理位置&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;选路控制&lt;/strong&gt;角度分析：接入和汇聚间跑路由协议，可以有多种方式操控流量走向（比如OSPF选路为O&amp;gt;OIA&amp;gt;OE1&amp;gt;OE2、策略路由等技术）&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;规避环路&lt;/strong&gt;角度分析：不需要运行生成树或者SMART-LINK等技术&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;线路效率&lt;/strong&gt;角度分析：路由协议可以实现负载分担（逐流或者逐包），而二层协议只能实现主备或者实现异组负载分担，同属于一台交换机的不同网段之间的业务互访，不需要经过汇聚交换机，所以提高了访问效率&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;风险&lt;/strong&gt;的角度分析：要实现同网段必须连同一台接入交换机，物理位置隔离，风险小，如部署在汇聚，则不同接入交换机上同VLAN可互通，风险大&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;从项目的角度分析
&lt;ol&gt;
&lt;li&gt;考虑成本因素，要确定接入交换机的型号，是否支持3层功能（纯2层接入成本有优势&lt;code&gt;网关放在汇聚层&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;要考虑同IP段的使用人员分布位置，集中式适合部署在接入，分布式适合部署在汇聚&lt;/li&gt;
&lt;li&gt;要考虑流量模型，横向流量高适合部署在接入（同交换机转发快），纵向流量高适合部署在汇聚（减少路由查找次数）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;100台路由器&#34;&gt;100台路由器&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;在一个自治系统中100台路由器，性能差异较大，选择哪种IGP协议？&lt;/strong&gt;&lt;br&gt;
IGP协议有三种，RIP、OSPF、ISIS，首先来分析RIP特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RIP每30S更新所有路由表，链路开销大，特别是在广域网链路上&lt;/li&gt;
&lt;li&gt;RIP收敛慢，如主备切换需要180秒&lt;/li&gt;
&lt;li&gt;16跳，对网络直径有限制，不适合大型网络。在设计网络时可以让100台的网络直径小于16跳，但是在后期维护以及控制路由选路会改动开销，开销由原来的1跳改为多跳，这样就会严重限制网络直径的大小&lt;/li&gt;
&lt;li&gt;基于跳数选路，计算开销比较简单，无法根据带宽大小选择最优路径，而路由器在传输数据的时候，传递快慢都是与带宽挂钩的&lt;/li&gt;
&lt;li&gt;扁平化网络结构，不能分为多个区域，即代表整个网络中每台路由器需要维护相同的路由条目，承受相同的数据装发流量，对于性能较差的设备可能承受不了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;从RIP的特点可以看出其不适合在 100 台这种大型网络里面&lt;/strong&gt;，接下来分析OSPF和ISIS协议。&lt;br&gt;
OSPF和ISIS支持路由条目数较大，在1-3万条之间&lt;sub&gt;isis一个虚拟系统最多携带路由3万左右，最多可以配置50个虚拟系统；一个ospf路由表不要装载超过3万条路由&lt;/sub&gt;，可以层次化设计，网络规模可以很大，使用哪种协议看具体组网需求和场合：&lt;br&gt;
&lt;strong&gt;共同点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;都是链路状态路由协议，都要求区域内的路由器交换链路状态信息，链路状态信息被收集到链路状态数据库中&lt;/li&gt;
&lt;li&gt;都是基于链路状态库中的信息，采用几乎相同的SPF算法来计算最佳路由&lt;/li&gt;
&lt;li&gt;都在广播网络中选择指定路由器来控制扩散并降低这类介质中多对多邻接的系统资源需求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;不同点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;OSPF
&lt;ol&gt;
&lt;li&gt;支持的网络类型丰富，广播、NBMA、P2P、P2MP&lt;/li&gt;
&lt;li&gt;LAS种类多，路由控制精细，分为域内&amp;gt;域间&amp;gt;外部1类&amp;gt;外部2类&lt;/li&gt;
&lt;li&gt;OSPF区域类型丰富，骨干、普通、STUB、NSSA&lt;/li&gt;
&lt;li&gt;OSPF有区分内部和外部路由，根据需要可以配置不同的优先级&lt;/li&gt;
&lt;li&gt;有虚链路提供备份、冗余、优选链路的功能&lt;/li&gt;
&lt;li&gt;人员熟悉度，企业网络工程师熟悉OSPF、不熟悉ISIS，在设计网络和后期运维的时候更有优势&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;ISIS
&lt;ol&gt;
&lt;li&gt;人员熟悉度：当前在运营商环境中使用较多&lt;/li&gt;
&lt;li&gt;收敛速度快，路由变化都是PRC&lt;/li&gt;
&lt;li&gt;扩展性强，采用TLV结构，支持IPV6&lt;/li&gt;
&lt;li&gt;运行在数据链路层，抗攻击能力强&lt;/li&gt;
&lt;li&gt;可以支持非IP网络&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;br&gt;
可以选用ISIS或OSPF&lt;br&gt;
OSPF的选路更灵活，路由操控手段更丰富，更适合层次化划分，可以考虑将性能好的设备放在OSPF骨干区域，性能差的放到NSSA、STUB区域等，有更多的特殊区域可供选择，当前实际应用多在企业网中&lt;br&gt;
ISIS收敛速度更快，扩展性强，网络稳定性更好，当前实际多应用于运营商网络中，多采用网络扁平化设计。ISIS虽然也可以支持划分多区域，但功能比较单一，并且只有level-1区域，可能会造成路径选择不优，如果想要优选又必须得做level-2到level-1的路由泄漏，存在隐患。但在极端情况下，ISIS能承载的路由条目比OSPF更多&lt;/p&gt;
&lt;h2 id=&#34;追问&#34;&gt;追问&lt;/h2&gt;
&lt;h3 id=&#34;1-通过哪些方面考虑应用那种igp协议&#34;&gt;1. 通过哪些方面考虑应用那种IGP协议？&lt;/h3&gt;
&lt;p&gt;如果客户是运营商核心，特别是MPLS VPN的核心，一般低层用ISIS，企业网多数使用OSPF。&lt;br&gt;
ISIS一般用在网络结构比较平坦的ISP核心网络，配置简单效率高。OSPF的相关特性比较多，比较适合逻辑上层次结构比较复杂的网络，并且OSPF是基于IP的，大多数人能够比较方便的理解其原理，便于实施和运维，企业用OSPF比较好。&lt;/p&gt;
&lt;h3 id=&#34;2-什么情况下一定要使用isis&#34;&gt;2. 什么情况下一定要使用ISIS？&lt;/h3&gt;
&lt;p&gt;一般现网情况下，ISP网络逻辑结构比较平坦的核心部分会使用ISIS。理论上说，必须使用ISIS而不能使用OSPF的情况，只有网络不是用IP，比如IPX、appletalk。OSPFv2设计的时候只支持IPv4，而ISIS从理论上来说都可以，只要使用新的TLV来携带路由信息即可。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;大型割接&#34;&gt;大型割接&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;总体分为四个阶段：前期调研阶段、割接前准备阶段、割接实施阶段、割接后保障阶段&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;割接流程&#34;&gt;割接流程&lt;/h2&gt;
&lt;h3 id=&#34;1-前期调研阶段&#34;&gt;1. 前期调研阶段&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需了解用户的背景和需求、业务类型和特点、变更的目的&lt;/li&gt;
&lt;li&gt;调研现网的网络情况、拓扑情况、流量走向、路由规划等，了解变更后目的网络情况、拓扑情况，流量走向、路由规划等&lt;/li&gt;
&lt;li&gt;变更过程中人员职责安排及联系方式&lt;/li&gt;
&lt;li&gt;变更计划制定，需精确到每一步操作的时间点和操作完成时间点
&lt;ol&gt;
&lt;li&gt;变更前测试方案和变更后测试方案，变更前对重点业务和应用进行测试，变更后进行第二次测试，通过两次测试结果来判断割接后现网业务是否得到恢复&lt;/li&gt;
&lt;li&gt;回退方案制定，当在规定时间点无法按照割接计划完成相应内容或者割接完成后业务无法恢复，则认为割接失败，进行回退。回退过程中按照回退方案操作，移除新增或改变的线缆，恢复原设备配置和连线，恢复后还需对业务进行再次测试，已判断回退成功&lt;/li&gt;
&lt;li&gt;割接失败后信息采集，按照职责划分，采集各自负责设备的日志信息进行分析总结，避免再次割接失败&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-割接前准备阶段&#34;&gt;2. 割接前准备阶段&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;割接前方案评审&lt;/li&gt;
&lt;li&gt;设备登录方式、软件版本确认&lt;/li&gt;
&lt;li&gt;割接涉及设备的健康检查和新设备的稳定性测试&lt;/li&gt;
&lt;li&gt;割接涉及改动的线缆标签制作，以便回退使用&lt;/li&gt;
&lt;li&gt;对割接人员培训和工作职责划分&lt;/li&gt;
&lt;li&gt;割接前需对现网业务进行测试&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-割接实施阶段&#34;&gt;3. 割接实施阶段&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;对现网设备进行备份存档，以便割接失败回退使用，同时做好状态检查和快照，以便操作后前后对比&lt;/li&gt;
&lt;li&gt;按照割接方案中割接步骤，按计划实施，每完成一步需对配置和状态进行检查，以确定操作生效和状态正常&lt;/li&gt;
&lt;li&gt;割接过程记录操作日志&lt;/li&gt;
&lt;li&gt;割接完成后按照测试方案进行割接后测试&lt;/li&gt;
&lt;li&gt;如割接失败则按照退回方案进行割接退回，回退后需按照测试方案进行业务测试&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-割接后保障阶段&#34;&gt;4. 割接后保障阶段&lt;/h3&gt;
&lt;p&gt;割接完成后，一般需对割接后新网络进行&lt;strong&gt;守局保障&lt;/strong&gt;，万一割接后业务异常时，可以第一时间进行排查和定位，及时恢复。割接后如果客户有要求，可对运维人员进行关于新网络的培训，让客户的维护人员对新网络&lt;br&gt;
更了解&lt;/p&gt;
&lt;h2 id=&#34;割接过程中涉及的知识点&#34;&gt;割接过程中涉及的知识点&lt;/h2&gt;
&lt;h3 id=&#34;软割接与硬割接的区别&#34;&gt;软割接与硬割接的区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;业务层面：不影响业务的称为软割接，影响业务的称为硬割接&lt;/li&gt;
&lt;li&gt;时间层面：超过时间窗口的称为硬割接，没有超过的称为软割接&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;时间窗口与割接时间的区别&#34;&gt;时间窗口与割接时间的区别&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;时间窗口&lt;/strong&gt;是指我们在写割接方案时规定的具体割接时长，是&lt;strong&gt;计划性的时间&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;割接时间&lt;/strong&gt;是指具体在&lt;strong&gt;实施割接时所用的时间&lt;/strong&gt;，&lt;strong&gt;割接时间应该控制在时间窗口内&lt;/strong&gt;（否则就变成硬割接）&lt;/p&gt;
&lt;h3 id=&#34;串行割接与并行割接&#34;&gt;串行割接与并行割接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;网络设计层面：从核心到汇聚再到接入或者反之，则称为串行割接；并行割接就是不分层进行&lt;/li&gt;
&lt;li&gt;实施节点层面：如果割接是按照不同的节点之间依次割接，则称为串行割接；如果多个地点同时割接则为并形割接&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;回退方案与应急方案的区别&#34;&gt;回退方案与应急方案的区别&lt;/h3&gt;
&lt;p&gt;回退方案是指当割接时，遇到了无法解决的故障，应该采用的办法，例如在升级设备时，所升级的版本导致用户业务无法访问，并且暂时没有解决方案，此时就需要回退到之前版本&lt;br&gt;
应急方案是指当割接过程中，遇到了紧急事件的处理方式，例如在升级设备时，因设备重启导致板卡故障，此时应该在应急方案中写明需要事先准备备件&lt;/p&gt;
&lt;h3 id=&#34;什么是值守守局一般需要多长时间&#34;&gt;什么是值守（守局），一般需要多长时间&lt;/h3&gt;
&lt;p&gt;值守与守局是同一个概念，指的是当割接完成时，需要观察的时间&lt;br&gt;
时间的长短是&lt;strong&gt;根据项目情况及客户情况共同商定的&lt;/strong&gt;，大部分情况值守一天，如果割接影响的范围很大，可能会加长值守时间，也有可能需要定期回访&lt;/p&gt;
&lt;h3 id=&#34;什么是快照&#34;&gt;什么是快照&lt;/h3&gt;
&lt;p&gt;快照是指对当前设备所运行状态（数据）的一个副本，说白了就是备份。作用是方便恢复及数据备份&lt;/p&gt;
&lt;h3 id=&#34;割接的目的是什么什么是割接&#34;&gt;割接的目的是什么（什么是割接）&lt;/h3&gt;
&lt;p&gt;目的是根据具体割接内容来定的，也就是我们需要完成的工作&lt;/p&gt;
&lt;h3 id=&#34;如何判断需要回退回退时应该注意什么&#34;&gt;如何判断需要回退，回退时应该注意什么&lt;/h3&gt;
&lt;p&gt;回退是指出现了无法解决的问题，并且对现网业务有了一定的影响，作为一名前线的工程师，我们只能给出技术上的判断，具体回退与否应该第一时间与项目经理商定，由项目经理与客户共同决定是否回退&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;网络拓扑结构&#34;&gt;网络拓扑结构&lt;/h1&gt;
&lt;h2 id=&#34;各种拓扑的优缺点&#34;&gt;各种拓扑的优缺点&lt;/h2&gt;
&lt;p&gt;局域网内部常见的网络拓扑有：星型拓扑、双星型拓扑、网状拓扑、部分网状拓扑、总线型拓扑&lt;/p&gt;
&lt;h3 id=&#34;1-星型拓扑单星型&#34;&gt;1. 星型拓扑（单星型）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615011430476.png&#34; alt=&#34;星型拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
星型拓扑是由中央节点和通过点到点通信链路接到中央节点的各个站点组成。&lt;br&gt;
&lt;strong&gt;中央节点&lt;/strong&gt;执行集中式&lt;strong&gt;通信控制策略&lt;/strong&gt;，因此中央节点相当复杂，而各个站点的通信处理负担都很小。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优点：
&lt;ol&gt;
&lt;li&gt;结构简单，连接方便，管理和维护都相对容易，而且扩展性强&lt;/li&gt;
&lt;li&gt;网络延迟时间较小，传输误差低&lt;/li&gt;
&lt;li&gt;在同一网段内支持多种传输介质，&lt;strong&gt;除非中央节点故障，否则网络不会轻易瘫痪&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每个节点直接连到中央节点，&lt;strong&gt;故障容易检测和隔离&lt;/strong&gt;，可以很&lt;strong&gt;方便地排除有故障的节点&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ol&gt;
&lt;li&gt;安装和维护的费用较高&lt;/li&gt;
&lt;li&gt;共享资源的能力较差&lt;/li&gt;
&lt;li&gt;一条通信线路只被该线路上的&lt;strong&gt;中央节点和边缘节点&lt;/strong&gt;使用，&lt;strong&gt;通信线路利用率不高&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;对中央节点要求相当高&lt;/strong&gt;，一旦中央节点出现故障，则整个网络将瘫痪&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-网状拓扑&#34;&gt;2. 网状拓扑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615012045778.png&#34; alt=&#34;网状拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
网型拓扑的一个应用是在BGP协议中。为保证IBGP对等体之间的连通性，需要在IBGP对等体之间建立全连接关系，即网状网络。假设在一个AS内部有n台路由器，那么应该建立的IBGP连接数就为n(n-1)/2 个&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优点
&lt;ol&gt;
&lt;li&gt;节点间路径多，碰撞和阻塞减少&lt;/li&gt;
&lt;li&gt;局部故障不影响整个网络，可靠性高&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ol&gt;
&lt;li&gt;网络关系复杂，建网较难，不易扩充&lt;/li&gt;
&lt;li&gt;网络控制机制复杂，必须采用路由算法和流量控制机制&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-部分网状拓扑&#34;&gt;3. 部分网状拓扑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615012446011.png&#34; alt=&#34;部分网状拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
部分网状拓扑，在容错能力与成本之间寻求平衡&lt;/p&gt;
&lt;h3 id=&#34;4-双星型拓扑&#34;&gt;4. 双星型拓扑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615011928760.png&#34; alt=&#34;双星型拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双星型的结构&lt;strong&gt;综合了单星型结构和网状结构的好处&lt;/strong&gt;，即节省了链路，&lt;strong&gt;又能起到网状结构的路由冗余和备份的作用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-树形拓扑&#34;&gt;5. 树形拓扑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615012754497.png&#34; alt=&#34;树形拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
树型拓扑是&lt;strong&gt;多级星型结构&lt;/strong&gt;组成的，自上而下呈三角形分布的，就像一颗树一样。&lt;br&gt;
最顶端的枝叶少，中间的多，而最下面的枝叶最多。&lt;br&gt;
树的最下端相当于边缘层，树中间相当于汇聚层，而树顶端则相当于核心层。&lt;br&gt;
采用分级的集中控制方式，其传输介质可有多条分支，但不形成闭合回路，每条通信线路都必须支持双向传输。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优点
&lt;ol&gt;
&lt;li&gt;易于扩展。这种结构可以延伸出很多分支和子分支，这些新节点和新分支都能容易地加入网内&lt;/li&gt;
&lt;li&gt;故障隔离较容易。如果某一分支的节点或线路发生故障，很容易将故障分支与整个系统隔离开来&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点&lt;br&gt;
各个节点对根的依赖性太大，如果根发生故障，则全网不能正常工作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6-总线型拓扑&#34;&gt;6. 总线型拓扑&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615017274593.png&#34; alt=&#34;总线型拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;优点
&lt;ol&gt;
&lt;li&gt;所需要的电缆数量少，线缆长度短，易于布线和维护&lt;/li&gt;
&lt;li&gt;结构简单，有较高的可靠性，传输速率高&lt;/li&gt;
&lt;li&gt;易于扩充，增加或减少用户比较方便&lt;/li&gt;
&lt;li&gt;多个节点共用一条传输信道，信道利用率高&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ol&gt;
&lt;li&gt;传输距离有限，通信范围受到限制&lt;/li&gt;
&lt;li&gt;故障诊断和隔离较困难&lt;/li&gt;
&lt;li&gt;分布式协议不能保证信息的及时传送，不具有实时功能&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-环型拓扑&#34;&gt;7. 环型拓扑&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615018165593.png&#34; alt=&#34;环型拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;优点
&lt;ol&gt;
&lt;li&gt;电缆长度短&lt;/li&gt;
&lt;li&gt;增加或减少工作站时，仅需简单的连接操作&lt;/li&gt;
&lt;li&gt;可使用光纤，光纤的传输速率很高，十分适合于环型拓扑的单方向传输&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缺点
&lt;ol&gt;
&lt;li&gt;节点的故障会引起全网故障&lt;/li&gt;
&lt;li&gt;故障检测困难&lt;/li&gt;
&lt;li&gt;环型拓扑结构的媒体访问控制协议都采用令牌传递的方式，在负载很轻时信道利用率&lt;br&gt;
相对来说就比较低&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
">项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/da-er-ceng/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#vxlan&#34;&gt;VXLAN&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF&#34;&gt;产生背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&#34;&gt;基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vxlan%E7%BD%91%E5%85%B3%E5%88%92%E5%88%86&#34;&gt;VXLAN网关划分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91&#34;&gt;报文转发&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-bum%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91&#34;&gt;1. BUM报文转发&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%8D%95%E6%92%AD%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F%E6%B3%9B%E6%B4%AA%E5%A4%B4%E7%AB%AF%E5%A4%8D%E5%88%B6&#34;&gt;1. 单播路由方式泛洪（头端复制）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F%E6%B3%9B%E6%B4%AA%E6%A0%B8%E5%BF%83%E5%A4%8D%E5%88%B6&#34;&gt;2. 组播路由方式泛洪（核心复制）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%8D%95%E6%92%AD%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91&#34;&gt;2. 单播报文转发&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%90%8Cvni%E5%8D%95%E6%92%AD%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91&#34;&gt;1. 同VNI单播报文转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E8%B7%A8vni%E5%8D%95%E6%92%AD%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91&#34;&gt;2. 跨VNI单播报文转发&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;vxlan&#34;&gt;VXLAN&lt;/h1&gt;
&lt;p&gt;VXLAN（虚拟扩展局域网）&lt;code&gt;基于IP网络，采用MAC in UDP封装方式，源端口随机，目标端口为4789（可修改），并且UDP头部的校验和必须为0&lt;/code&gt;，是NVO3（数据中心虚拟化技术框架）中的一种网络虚拟化技术&lt;/p&gt;
&lt;h2 id=&#34;产生背景&#34;&gt;产生背景&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615384769028.png&#34; alt=&#34;现存网络的问题&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;虚拟机规模受网络规格限制&lt;/strong&gt;&lt;br&gt;
在传统二层网络环境下，数据报文是通过查询MAC地址表进行二层转发，而MAC地址表的容量限制了虚拟机的数量&lt;br&gt;
VXLAN&lt;strong&gt;将虚拟机发出的数据包封装在UDP中，并使用物理网络的IP、MAC地址作为外层头进行封装&lt;/strong&gt;，对网络只表现为封装后的参数，除VXLAN网络边缘设备，网络中的其他设备不需要识别虚拟机的MAC地址，极大&lt;strong&gt;降低了大二层网络对MAC地址规格的需求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;网络隔离能力限制&lt;/strong&gt;&lt;br&gt;
当前主流的网络隔离技术是VLAN，但是VLAN最多只能划分4096个，无法满足标识大量租户的需求，并且无法满足网络动态调整的需求&lt;br&gt;
VXLAN引入了类似VLAN ID的用户标识，称为&lt;strong&gt;VXLAN网络标识VNI&lt;/strong&gt;，由&lt;strong&gt;24比特&lt;/strong&gt;组成，支持多达&lt;strong&gt;16M&lt;/strong&gt;的VXLAN段，从而满足了大量的用户标识&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟机迁移范围受网络架构限制&lt;/strong&gt;&lt;br&gt;
虚拟机启动后，可能由于服务器资源等问题（如CPU过高，内存不够等），需要将虚拟机迁移到新的服务器上，需要保证虚拟机的IP地址保持不变，这就&lt;strong&gt;要求业务网络是一个二层网络&lt;/strong&gt;，且要求网络本身具备多路径的冗余备份和可靠性&lt;br&gt;
VXLAN通过采用&lt;code&gt;MAC in UDP&lt;/code&gt;封装来延伸二层网络，实现了物理网络和虚拟网络解耦，将以太报文封装在IP报文之上，通过路由在网络中传输，&lt;strong&gt;无需关注虚拟机的MAC地址&lt;/strong&gt;，且路由网络无网络结构限制，具备大规模扩展能力、故障自愈能力、负载均衡能力，虚拟机迁移不受网络架构限制，租户也可以规划自己的虚拟网络，不需要考虑物理网络IP地址和广播域的限制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;BUM（广播、未知单播、组播）泛洪问题，如ARP泛洪学习MAC，&lt;strong&gt;开销大&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;隧道建立，VTEP数量过多导致&lt;strong&gt;静态部署困难&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615385782683.png&#34; alt=&#34;基本概念&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Underlay网络和Overlay网络
&lt;ul&gt;
&lt;li&gt;将已有的物理网络作为Underlay网络，在其上构建出虚拟的二层或三层网络，即Overlay网络&lt;/li&gt;
&lt;li&gt;Overlay网络通过封装技术、利用Underlay网络提供的三层转发路径，实现租户报文在不同站点间传递&lt;/li&gt;
&lt;li&gt;对于租户来说，Underlay网络是透明的，只能感知到Overlay网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NVE（网络虚拟边缘节点）
&lt;ul&gt;
&lt;li&gt;实现网络虚拟化功能的网络实体，报文经过NVE封装转换后，NVE间就可基于三层基础网络建立二层虚拟化网络&lt;/li&gt;
&lt;li&gt;设备和服务器上的虚拟交换机vSwitch都可以作为NVE&lt;/li&gt;
&lt;li&gt;部署方式：
&lt;ul&gt;
&lt;li&gt;硬件模式：所有的NVE都部署在支持NVE的设备上&lt;/li&gt;
&lt;li&gt;软件模式：所有的NVE都部署在vSwitch上&lt;/li&gt;
&lt;li&gt;混合模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VTEP（VXLAN隧道端点）
&lt;ul&gt;
&lt;li&gt;封装在NVE中，用于VXLAN报文的封装和解封装&lt;/li&gt;
&lt;li&gt;VTEP与物理网络相连，分配有物理网络的IP地址，&lt;strong&gt;该地址与虚拟网络无关&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;VXLAN报文中&lt;strong&gt;源IP地址为本节点的VTEP地址&lt;/strong&gt;，VXLAN报文中目的IP地址为对端节点的VTEP地址，一对VTEP地址就对应着一个VXLAN隧道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VNI（VXLAN网络标识）
&lt;ul&gt;
&lt;li&gt;用于区分VXLAN段，不同VXLAN段的虚拟机不能直接二层相互通信&lt;/li&gt;
&lt;li&gt;一个VNI表示一个租户，即使多个终端用户属于同一个VNI，也表示一个租户，由24比特组成，支持租户数量为16M&lt;/li&gt;
&lt;li&gt;在分布式网关部署场景下，VNI分为二层VNI和三层VNI
&lt;ul&gt;
&lt;li&gt;二层VNI是普通的VNI，以1：1方式映射到广播域BD，实现VXLAN报文同子网的转发&lt;/li&gt;
&lt;li&gt;三层VNI和VPN实例进行关联，用于VXLAN报文跨子网的转发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BD
&lt;ul&gt;
&lt;li&gt;BD是VXLAN网络中转发数据报文的二层广播域&lt;/li&gt;
&lt;li&gt;在VXLAN网络中，将VNI以1:1方式映射到广播域BD，BD成为VXLAN网络转发数据报文的实体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VBDIF接口
&lt;ul&gt;
&lt;li&gt;基于BD创建的三层逻辑接口&lt;/li&gt;
&lt;li&gt;通过VBDIF接口配置IP地址可实现不同网段的VXLAN间，及VXLAN和非VXLAN的通信，也可实现二层网络接入三层网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VAP虚拟接入点
&lt;ul&gt;
&lt;li&gt;VXLAN业务接入点，可以是二层子接口或VLAN
&lt;ul&gt;
&lt;li&gt;二层子接口时，通过在二层子接口上配置流封装类型实现不同的接口接入不同的数据报文，将二层子接口关联广播域BD后，可实现数据报文通过BD转发&lt;/li&gt;
&lt;li&gt;VLAN时，需要将VLAN绑定到广播域BD，也可以实现数据报文通过BD转发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网关
&lt;ul&gt;
&lt;li&gt;不同VNI之间的VXLAN，及VXLAN和非VXLAN之间不能直接相互通信，为了使VXLAN之间，以及VXLAN和非VXLAN之间能够进行通信，VXLAN引入了VXLAN网关
&lt;ul&gt;
&lt;li&gt;二层网关：用于解决租户接入VXLAN虚拟网络的问题，也可用于同一VXLAN虚拟网络的子网通信&lt;/li&gt;
&lt;li&gt;三层网关：用于VXLAN虚拟网络的跨子网通信以及外部网络的访问&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;报文格式&#34;&gt;报文格式&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615390480064.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;因报文增加了50B【=2层14B+IP头20B+UDP头8B+VXLAN头8B】开销，容易造成分片问题，建议在L2GW修改MTU&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Outer Ethernet header&lt;code&gt;只跟VTEP&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;目的MAC、源MAC：发送报文的虚拟机所属VTEP的MAC、接收报文的虚拟机所属的VTEP的MAC&lt;/li&gt;
&lt;li&gt;802.1Q Tag：&lt;code&gt;可选字段&lt;/code&gt;，该字段为报文中携带的VLAN Tag&lt;/li&gt;
&lt;li&gt;Ethernet Type：以太报文类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Outer IP header&lt;code&gt;只跟VTEP&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;源目IP为VXLAN隧道本端、远端VTEP的IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Outer UDP header
&lt;ul&gt;
&lt;li&gt;目的UDP端口号是4789，源端口号是内层报文通过哈希算法计算后的值&lt;/li&gt;
&lt;li&gt;校验和为0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;VXLAN header
&lt;ul&gt;
&lt;li&gt;VXLAN Flags：8比特，取值为0x08&lt;/li&gt;
&lt;li&gt;VNI：VXLAN网络标识，24比特，用于区分VXLAN段&lt;/li&gt;
&lt;li&gt;Reserved：0&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vxlan网关划分&#34;&gt;VXLAN网关划分&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;二层网关&lt;br&gt;
用于解决租户接入VXLAN虚拟网络的问题，也可用于同一VXLAN虚拟网络的子网通信。&lt;/li&gt;
&lt;li&gt;三层网关&lt;br&gt;
用于VXLAN虚拟网络的跨子网通信以及外部网络的访问
&lt;ol&gt;
&lt;li&gt;集中式网关&lt;br&gt;
将三层网关集中部署在一台设备上，所有跨子网的流量都经过三层网关进行转发。能够对跨子网流量的集中管理，但是存在次优路径和ARP表项数目限制的缺点&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615390956658.png&#34; alt=&#34;集中式网关&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;分布式网关&lt;br&gt;
在典型的“Spine-Leaf”组网结构下，将Leaf节点作为VXLAN隧道端点VTEP，每个Leaf节点都可作为VXLAN三层网关，Spine节点不感知VXLAN隧道，只作为VXLAN报文的转发节点&lt;br&gt;
&lt;strong&gt;Leaf节点&lt;/strong&gt;：&lt;br&gt;
作为二层网关，与物理服务器或VM对接，用于解决终端租户接入VXLAN虚拟网络的问题&lt;br&gt;
作为三层网关，进行VXLAN报文封装/解封装，实现跨子网的终端租户通信，以及外部网络的访问&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615391165257.png&#34; alt=&#34;分布式网关&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;报文转发&#34;&gt;报文转发&lt;/h2&gt;
&lt;h3 id=&#34;1-bum报文转发&#34;&gt;1. BUM报文转发&lt;/h3&gt;
&lt;p&gt;根据对泛洪流量的复制方式不同可分为单播路由方式（头端复制）和组播路由方式（核心复制）两种&lt;br&gt;
&lt;code&gt;为了避免环路，远端VTEP从VXLAN隧道上接收到报文后，不会再将其泛洪到其他的VXLAN隧道&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-单播路由方式泛洪头端复制&#34;&gt;1. 单播路由方式泛洪（头端复制）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615391413442.jpg&#34; alt=&#34;头端复制&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
VTEP负责复制报文，采用单播方式将复制后的报文，通过本地接口发送给本地站点，通过VXLAN隧道发送给VXLAN内的所有远端VTEP&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当VTEP 1上的VM 1发出BUM报文后，VTEP 1判断数据所属的VXLAN，通过&lt;strong&gt;该VXLAN内所有本地接口和VXLAN Tunnel&lt;/strong&gt;转发报文&lt;/li&gt;
&lt;li&gt;通过VXLAN Tunnel转发报文时，封装VXLAN头、UDP头、IP头和二层头，将泛洪报文封装于单播报文中，&lt;strong&gt;发送到VXLAN内的所有远端VTEP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;远端VTEP收到VXLAN报文后，解封装报文，将原始数据&lt;strong&gt;在本地站点的VXLAN内泛洪&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-组播路由方式泛洪核心复制&#34;&gt;2. 组播路由方式泛洪（核心复制）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615391663157.jpg&#34; alt=&#34;核心复制&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
组播路由方式的组网中&lt;strong&gt;同一个VXLAN内的所有VTEP都加入同一个组播组&lt;/strong&gt;，利用组播路由协议（如PIM）在IP网络上为该组播建立组播转发表项，&lt;strong&gt;VTEP上相应生成一个组播隧道&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当VTEP 1上的VM 1发出BUM报文后，VTEP 1不仅在本地站点内泛洪，还会为其&lt;strong&gt;封装组播目的IP地址&lt;/strong&gt;，封装后的报文&lt;strong&gt;根据已建立的组播转发表项转发到IP网络&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在组播报文到达IP网络中的中间设备时，该设备根据已建立的组播表项对报文进行复制并转发&lt;/li&gt;
&lt;li&gt;远端VTEP（VTEP 2和VTEP 3）接收到报文后，解封装报文，将原始的数据帧在本地站点的指定VXLAN泛洪&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-单播报文转发&#34;&gt;2. 单播报文转发&lt;/h3&gt;
&lt;p&gt;参考&lt;a href=&#34;http://www.h3c.com/cn/d_201811/1131076_30005_0.htm&#34;&gt;http://www.h3c.com/cn/d_201811/1131076_30005_0.htm&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-同vni单播报文转发&#34;&gt;1. 同VNI单播报文转发&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;ARP请求报文转发流程&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615472290260.jpg&#34; alt=&#34;ARP请求报文转发流程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;ARP应答报文转发流程&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615472318734.jpg&#34; alt=&#34;ARP应答报文转发流程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;同VNI单播报文转发流程&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615472420111.jpg&#34; alt=&#34;同VNI单播报文转发流程&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;在进行ARP报文的交互后，VM 1上已经存在VM 3的ARP表项，VM 3上也有VM 1的ARP表项。之后，VM 1和VM 3的通信就走单播报文转发流程了。&lt;/li&gt;
&lt;li&gt;VM 1将发给VM 3的单播报文发送出去。Leaf A收到VM 1发来的报文，发现其目的MAC为MAC 3，在VXLAN 10中查找到MAC 3后，进行VXLAN封装后通过Tunnel 1发送出去。&lt;/li&gt;
&lt;li&gt;Leaf B收到Leaf A发来的报文，解封装后在VXLAN 10中找到MAC 3表项，将其在对应的本地端口和VLAN中发出去。&lt;/li&gt;
&lt;li&gt;VM 3收到报文后，往VM 1发送单播报文的流程相同&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-跨vni单播报文转发&#34;&gt;2. 跨VNI单播报文转发&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615472559408.jpg&#34; alt=&#34;跨VNI单播报文转发&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;跨VNI的流量需要经过VXLAN L3 Gateway来转发&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VM 1先将报文发送给网关。报文的源MAC是VM 1的MAC，目的MAC是网关VSI-Interface 10的MAC，源IP是VM 1的IP，目的IP是VM 4的IP。&lt;/li&gt;
&lt;li&gt;Leaf A收到VM 1发来的报文，识别此报文属于VXLAN 10，查找目的MAC G10的表项，就报文进行VXLAN封装后从Tunnel 2发送出去。其中，VXLAN头中的VNI为10；外层源IP地址为Leaf A的IP，外层目的IP地址为Spine C的IP；外层源MAC地址为Leaf A的MAC，而外层目的MAC地址为去往目的IP的网络中下一跳设备的MAC地址。封装后的报文，根据外层MAC和IP信息，在IP网络中进行传输，直至到达对端VTEP。&lt;/li&gt;
&lt;li&gt;Spine C收到Leaf A发来的报文，发现外层目的IP是自己，于是对报文进行解封装。
&lt;ol&gt;
&lt;li&gt;解完封装后，Spine C发现原始二层报文的目的MAC为本机VSI-interface 10的MAC，目的IP是IP4，于是根据路由表查找IP 4的下一跳。&lt;/li&gt;
&lt;li&gt;发现一下跳为Leaf B，出接口为VSI-Interface 20。&lt;/li&gt;
&lt;li&gt;再查询ARP表项，并将原始二层报文的源MAC修改为VSI-interface 20的MAC，将目的MAC修改为VM 4的MAC。&lt;/li&gt;
&lt;li&gt;报文到达VSI-interface 20接口时，识别到需要进入VXLAN 20隧道，所以根据MAC表对报文进行封装。这里封装的VXLAN头中的VNI为20，外层源IP地址为Spine C的IP地址，外层目的IP地址为Leaf B的IP地址；外层源MAC地址为Spine C的MAC地址，而外层目的MAC地址为去往目的IP的网络中下一跳设备的MAC地址。&lt;/li&gt;
&lt;li&gt;封装后的报文，根据外层MAC和IP信息，在IP网络中进行传输，直至到达对端VTEP。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Leaf B收到Spine C发来的报文后，解封装，得到原始二层报文。在VXLAN 20内找到目的MAC为MAC 4的表项，并将报文从对应的接口和VLAN中发送出去。最终VM 4收到了来自VM 1的报文。&lt;/li&gt;
&lt;li&gt;VM 4发送给VM 1的过程与此类似&lt;/li&gt;
&lt;/ol&gt;
">大二层（EVPN和SDN暂不整理）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/dui-die/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#istack%E6%99%BA%E8%83%BD%E5%A0%86%E5%8F%A0&#34;&gt;iStack（智能堆叠）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#istack%E4%B8%AD%E4%BA%A4%E6%8D%A2%E6%9C%BA%E7%9A%84%E8%A7%92%E8%89%B2-%E5%A0%86%E5%8F%A0id%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;iStack中交换机的角色、堆叠ID和优先级&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%A7%92%E8%89%B2&#34;&gt;1. 角色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%A0%86%E5%8F%A0id&#34;&gt;2. 堆叠ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;3. 优先级&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E5%8F%A0istack%E7%9A%84%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F&#34;&gt;堆叠iStack的连接方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E5%8F%A0istack%E8%BF%9E%E6%8E%A5%E6%8B%93%E6%89%91&#34;&gt;堆叠iStack连接拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E5%8F%A0istack%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B&#34;&gt;堆叠iStack建立的过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%B8%BB%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%80%89%E4%B8%BE&#34;&gt;1. 主交换机选举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%8B%93%E6%89%91%E6%94%B6%E9%9B%86%E5%92%8C%E5%A4%87%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%80%89%E4%B8%BE&#34;&gt;2. 拓扑收集和备交换机选举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%A8%B3%E5%AE%9A%E8%BF%90%E8%A1%8C&#34;&gt;3. 稳定运行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E5%8F%A0%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5%E5%92%8C%E9%80%80%E5%87%BA%E8%BF%87%E7%A8%8B&#34;&gt;堆叠成员加入和退出过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5&#34;&gt;成员加入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%88%90%E5%91%98%E9%80%80%E5%87%BA&#34;&gt;成员退出&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E5%8F%A0%E5%88%86%E8%A3%82&#34;&gt;堆叠分裂&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A0%86%E5%8F%A0%E5%88%86%E8%A3%82%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3mad%E5%A4%9A%E4%B8%BB%E6%A3%80%E6%B5%8Bdad%E5%8F%8C%E4%B8%BB%E6%A3%80%E6%B5%8B&#34;&gt;堆叠分裂会有什么问题？如何解决？（MAD多主检测，DAD双主检测）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%9B%B4%E8%BF%9E%E6%A3%80%E6%B5%8B&#34;&gt;1. 直连检测&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B&#34;&gt;2. 代理检测&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mad%E5%86%B2%E7%AA%81%E5%8F%8A%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D%E5%90%8E%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86&#34;&gt;MAD冲突及故障恢复后如何处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dad%E5%8F%8C%E4%B8%BB%E6%A3%80%E6%B5%8B&#34;&gt;DAD双主检测&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%B8%9A%E5%8A%A1%E5%8F%A3%E7%9B%B4%E8%BF%9E%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F&#34;&gt;1. 业务口直连检测方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-eth-trunk%E4%BB%A3%E7%90%86%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F&#34;&gt;2. Eth-trunk代理检测方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%AE%A1%E7%90%86%E5%8F%A3%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F&#34;&gt;3. 管理口检测方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%A0%86%E5%8F%A0%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F%E4%BB%85ce1280012800e%E6%94%AF%E6%8C%81&#34;&gt;4. 堆叠端口检测方式（仅CE12800&amp;amp;12800E支持）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#css%E9%9B%86%E7%BE%A4&#34;&gt;CSS（集群）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#css%E9%9B%86%E7%BE%A4%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F&#34;&gt;CSS集群连接方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9B%86%E7%BE%A4%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5%E4%B8%8E%E5%90%88%E5%B9%B6-%E9%9B%86%E7%BE%A4%E5%88%86%E8%A3%82&#34;&gt;集群成员加入与合并、集群分裂&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5-2&#34;&gt;成员加入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%88%90%E5%91%98%E5%90%88%E5%B9%B6&#34;&gt;成员合并&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9B%86%E7%BE%A4%E5%88%86%E8%A3%82&#34;&gt;集群分裂&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
CSS和iStack的区别：CSS是框式堆叠，iStack是盒式堆叠。两者只是叫法和实现有些差异，但是功能是一样的&lt;/p&gt;
&lt;h1 id=&#34;istack智能堆叠&#34;&gt;iStack（智能堆叠）&lt;/h1&gt;
&lt;p&gt;指将多台支持堆叠特性的交换机设备组合在一起，从逻辑上组合成一台交换设备&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615118963933.png&#34; alt=&#34;iStack&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;目的&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高了可靠性：堆叠系统多台成员交换机之间冗余备份，同时利用跨设备的Eth-Trunk实现跨设备的链路冗余备份&lt;/li&gt;
&lt;li&gt;强大的网络扩展能力：通过组建堆叠，可以在不改变网络拓扑的情况下，轻松地扩展端口数、带宽和处理能力&lt;/li&gt;
&lt;li&gt;简化配置和管理：
&lt;ol&gt;
&lt;li&gt;用户可以通过任何一台成员交换机登录堆叠系统，对堆叠系统所有成员交换机进行统一配置和管理&lt;/li&gt;
&lt;li&gt;堆叠形成后，不需要配置复杂的二层破环协议（如MSTP）和三层保护倒换协议（如VRRP），简化了网络配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;istack中交换机的角色-堆叠id和优先级&#34;&gt;iStack中交换机的角色、堆叠ID和优先级&lt;/h2&gt;
&lt;h3 id=&#34;1-角色&#34;&gt;1. 角色&lt;/h3&gt;
&lt;p&gt;角色：包括&lt;strong&gt;一台&lt;/strong&gt;主交换机（master）、&lt;strong&gt;一台&lt;/strong&gt;备交换机（standby）和从交换机（slave）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一台主交换机（master）：负责管理整个堆叠；&lt;strong&gt;主交换机不抢占&lt;/strong&gt;，&lt;strong&gt;最先完成启动的交换机会成为主交换机&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一台备交换机（standby）：主交换机故障时，接替主交换机的所有业务&lt;/li&gt;
&lt;li&gt;从交换机（slave）：除主交换机和备交换机外，堆叠中&lt;strong&gt;其他所有的成员交换机都是从交换机&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-堆叠id&#34;&gt;2. 堆叠ID&lt;/h3&gt;
&lt;p&gt;堆叠ID：&lt;strong&gt;成员交换机的槽位号&lt;/strong&gt;（Slot ID），用来标识和管理成员交换机，&lt;strong&gt;默认为0，堆叠中所有成员交换机的堆叠ID都是唯一的&lt;/strong&gt;&lt;br&gt;
堆叠前：槽位号/子卡号/端口号（&lt;strong&gt;槽位号统一取值为0&lt;/strong&gt;）如：GigabitEthernet0/0/1&lt;br&gt;
堆叠后：堆叠ID/子卡号/端口号，例如堆叠ID为2，编号变为GigabitEthernet2/0/1&lt;br&gt;
如果设备&lt;strong&gt;曾加入过堆叠，在退出堆叠后&lt;/strong&gt;，仍然会&lt;strong&gt;使用组成堆叠时的堆叠ID&lt;/strong&gt;作为自身的槽位号&lt;/p&gt;
&lt;h3 id=&#34;3-优先级&#34;&gt;3. 优先级&lt;/h3&gt;
&lt;p&gt;堆叠优先级：默认100&lt;br&gt;
堆叠优先级是成员交换机的一个属性，主要用于角色选举过程中确定成员交换机的角色，优先级值越大表示优先级越高，&lt;strong&gt;优先级越高当选为主交换机的可能性越大&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;堆叠istack的连接方式&#34;&gt;堆叠iStack的连接方式&lt;/h2&gt;
&lt;p&gt;交换机组建堆叠根据堆叠口的不同，可以分为两种方式：&lt;strong&gt;堆叠卡堆叠和业务口堆叠&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆叠卡堆叠又分为以下两种情况：
&lt;ol&gt;
&lt;li&gt;交换机之间通过专用的堆叠插卡及专用的堆叠线缆连接&lt;/li&gt;
&lt;li&gt;堆叠卡集成到了交换机后面板上，交换机通过集成的堆叠端口及专用的堆叠线缆连接&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;业务口堆叠指的是交换机之间通过与逻辑堆叠端口绑定的物理成员端口相连，不需要专用的堆叠插卡&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615621977646.png&#34; alt=&#34;堆叠iStack的连接方式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;建议用户优先采用主控板直连方式，使管理链路和转发链路分离，以保证堆叠系统的高可靠性&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;堆叠istack连接拓扑&#34;&gt;堆叠iStack连接拓扑&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;链形连接：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615122203239.png&#34; alt=&#34;链形连接&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;优点：首尾不需要连接，适合长距离&lt;/li&gt;
&lt;li&gt;缺点：可靠性低，容易堆叠分裂，带宽利用率低&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;环形连接：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615122215564.png&#34; alt=&#34;环形连接&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;优点：可靠性高，环形变链形不影响工作，带宽利用率高&lt;/li&gt;
&lt;li&gt;缺点：首尾需要连接，不适合长距离&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;堆叠istack建立的过程&#34;&gt;堆叠iStack建立的过程&lt;/h2&gt;
&lt;p&gt;系统自动完成堆叠分为三步：&lt;/p&gt;
&lt;h3 id=&#34;1-主交换机选举&#34;&gt;1. 主交换机选举&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;运行状态比较，已经运行的交换机比处于启动状态的交换机优先竞争为主交换机&lt;/li&gt;
&lt;li&gt;堆叠优先级高的交换机优先竞争为主交换机&lt;/li&gt;
&lt;li&gt;堆叠优先级相同时，MAC地址小的交换机优先竞争为主交换机&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-拓扑收集和备交换机选举&#34;&gt;2. 拓扑收集和备交换机选举&lt;/h3&gt;
&lt;p&gt;主交换机选举完成后，主交换机会&lt;strong&gt;收集&lt;/strong&gt;所有成员交换机的&lt;strong&gt;拓扑信息&lt;/strong&gt;，&lt;strong&gt;根据拓扑信息&lt;/strong&gt;计算出堆叠&lt;strong&gt;转发表项和破环点信息&lt;/strong&gt;下发给堆叠中的所有成员交换机，并向所有成员交换机&lt;strong&gt;分配堆叠ID&lt;/strong&gt;。之后进行备交换机的选举，作为主交换机的备份交换机&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆叠优先级最高的设备成为备交换机&lt;/li&gt;
&lt;li&gt;堆叠优先级相同时，MAC地址最小的成为备交换机&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-稳定运行&#34;&gt;3. 稳定运行&lt;/h3&gt;
&lt;p&gt;其他成员交换机作为从交换机加入堆叠，所有成员交换机会自动同步主交换机的系统软件和配置文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;备交换机或从交换机与主交换机的软件版本不一致时，备交换机或从交换机会自动从主交换机下载系统软件，然后使用新系统软件重启，并重新加入堆叠&lt;/li&gt;
&lt;li&gt;备交换机或从交换机会将主交换机的配置文件同步到本设备并执行，以保证堆叠中的多台设备能够像一台设备一样在网络中工作，并且在主交换机出现故障之后，其余交换机仍能够正常执行各项功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;堆叠成员加入和退出过程&#34;&gt;堆叠成员加入和退出过程&lt;/h2&gt;
&lt;h3 id=&#34;成员加入&#34;&gt;成员加入&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;即向已经稳定运行的堆叠系统添加一台新的交换机&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592554993280.png&#34; alt=&#34;堆叠成员加入&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;使能堆叠并配置好SWD的堆叠参数&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;如果是&lt;strong&gt;业务口堆叠&lt;/strong&gt;，新加入的交换机需要配置物理成员端口加入逻辑堆叠端口&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;堆叠卡堆叠&lt;/strong&gt;，新加入的成员交换机需要使能堆叠功能&lt;br&gt;
&lt;code&gt;为了便于管理，建议新加入的交换机配置堆叠ID，如果不配置，堆叠系统会为其分配一个堆叠ID&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将SWD连接到堆叠系统&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;如果是&lt;strong&gt;链型连接&lt;/strong&gt;，新加入的交换机建议添加到链型的两端，这样对现有的业务影响最小&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;环型连接&lt;/strong&gt;，需要把当前环型拆成链型，然后在链型的两端添加设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统完成堆叠&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;新加入的交换机连线上电启动后，&lt;strong&gt;进行角色选举，新加入的交换机会选举为从交换机&lt;/strong&gt;，堆叠系统中原有的主备从角色不变&lt;/li&gt;
&lt;li&gt;角色选举结束后，主交换机更新堆叠拓扑信息，同步到其他成员交换机上，并向新加入的交换机分配堆叠ID（在新成员未配置或配置冲突时）&lt;/li&gt;
&lt;li&gt;新加入的交换机更新堆叠ID，并同步主交换机的配置文件和系统软件，之后进入稳定运行状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;成员退出&#34;&gt;成员退出&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当&lt;strong&gt;主交换机退出&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;备升为主，重新计算拓扑并进行同步到其他成员交换机&lt;/li&gt;
&lt;li&gt;指定新的备交换机，之后进入稳定运行状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;备交换机退出&lt;/strong&gt;：&lt;br&gt;
主交换机重新指定备交换机，重新计算拓扑并同步，之后进入稳定运行状态&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;从交换机&lt;/strong&gt;退出：&lt;br&gt;
主交换机重新计算堆叠拓扑并同步，之后进入稳定运行状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;堆叠成员交换机退出的过程，主要就是拆除堆叠线缆和移除交换机的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于&lt;strong&gt;环形堆叠&lt;/strong&gt;：成员交换机退出后，为保证网络的可靠性还需要把退出交换机连接的两个端口通过堆叠线缆进行连接&lt;/li&gt;
&lt;li&gt;对于链形堆叠：拆除中间交换机会造成堆叠分裂。这时需要在拆除前进行业务分析，尽量减少对业务的影响。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;堆叠分裂&#34;&gt;堆叠分裂&lt;/h4&gt;
&lt;p&gt;指稳定运行的堆叠系统中带电移出部分成员交换机，或堆叠线缆多点故障导致一个堆叠系统变成多个堆叠系统，堆叠分裂分为以下两类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;原主备&lt;/strong&gt;交换机被分裂到&lt;strong&gt;同一个堆叠系统&lt;/strong&gt;中&lt;br&gt;
&lt;strong&gt;原主交换机会重新计算堆叠拓扑&lt;/strong&gt;，将移出的成员交换机的拓扑信息删除，并将新的拓扑信息同步给其他成员交换机&lt;br&gt;
而移出的成员交换机检测到堆叠协议报文超时，将自行复位，&lt;strong&gt;重新进行选举&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;原主备交换机被分裂到&lt;strong&gt;不同的堆叠系统&lt;/strong&gt;中&lt;br&gt;
原主交换机所在堆叠系统重新指定备交换机，重新计算拓扑信息并同步给其他成员交换机&lt;br&gt;
原备交换机所在堆叠系统将发生备升主，原备交换机升级为主交换机，重新计算堆叠拓扑并同步到其他成员&lt;br&gt;
交换机，并指定新的备交换机&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;堆叠分裂会有什么问题如何解决mad多主检测dad双主检测&#34;&gt;堆叠分裂会有什么问题？如何解决？（MAD多主检测，DAD双主检测）&lt;/h4&gt;
&lt;p&gt;由于堆叠系统中所有成员交换机都使用同一个IP地址和MAC地址（堆叠系统 MAC），一个堆叠分裂后，可能产生多个具有相同IP地址和MAC地址的堆叠系统，引起网络故障，因此必须进行IP地址和MAC地址的冲突检查。&lt;br&gt;
&lt;strong&gt;多主检测MAD&lt;/strong&gt;是一种检测和处理堆叠分裂的协议。链路故障导致堆叠系统分裂后，MAD可以实现堆叠分裂的检测、冲突处理和故障恢复，降低堆叠分裂对业务的影响。&lt;br&gt;
MAD检测方式有两种：直连检测方式和代理检测方式&lt;code&gt;两种检测方式互斥，不可以同时配置&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;1-直连检测&#34;&gt;1. 直连检测&lt;/h5&gt;
&lt;p&gt;直连检测方式又分为通过中间设备直连和Full-mesh方式直连&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过&lt;strong&gt;中间设备&lt;/strong&gt;直连&lt;br&gt;
堆叠系统的所有成员交换机之间至少有一条检测链路与中间设备相连&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615125694086.png&#34; alt=&#34;通过中间设备直连&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Full-mesh&lt;/strong&gt;方式直连&lt;br&gt;
堆叠系统的各成员交换机之间通过检测链路建立Full-mesh&lt;strong&gt;全连接&lt;/strong&gt;，即每两台成员交换机之间至少有一条检测链路&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615125773507.png&#34; alt=&#34;Full-mesh方式直连&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过中间设备直连可以实现通过中间设备&lt;strong&gt;缩短堆叠成员交换机之间的检测链路长度&lt;/strong&gt;，适用于成员交换机相距较远的场景；&lt;br&gt;
Full-mesh方式直连可以&lt;strong&gt;避免由中间设备故障导致的MAD检测失败&lt;/strong&gt;，但是每两台成员交换机之间都建立全连接会&lt;strong&gt;占用较多的接口&lt;/strong&gt;，所以该方式适用于&lt;strong&gt;成员交换机数目较少&lt;/strong&gt;的场景&lt;/p&gt;
&lt;h5 id=&#34;2-代理检测&#34;&gt;2. 代理检测&lt;/h5&gt;
&lt;p&gt;代理检测方式是&lt;strong&gt;在堆叠系统Eth-Trunk上启用代理检测&lt;/strong&gt;，在代理设备上启用MAD检测功能。&lt;br&gt;
&lt;strong&gt;此种检测方式要求堆叠系统中的所有成员交换机都与代理设备连接&lt;/strong&gt;，&lt;strong&gt;并将这些链路加入同一个Eth-Trunk内&lt;/strong&gt;。&lt;br&gt;
与直连检测方式相比，代理检测方式无需占用额外的接口，Eth-Trunk接口可同时运行MAD代理检测和其他业务。在代理检测方式中，堆叠系统正常运行时，堆叠成员交换机&lt;strong&gt;以30s为周期&lt;/strong&gt;通过检测链路发送MAD报文。&lt;br&gt;
堆叠成员交换机对在正常工作状态下收到的MAD文不做任何处理；堆叠分裂后，分裂后的两台交换机&lt;strong&gt;以1s为周期&lt;/strong&gt;通过检测链路发送MAD报文以&lt;strong&gt;进行多主冲突处理&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;mad冲突及故障恢复后如何处理&#34;&gt;MAD冲突及故障恢复后如何处理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;MAD冲突处理&lt;br&gt;
堆叠分裂后，MAD冲突处理机制会使分裂后的堆叠系统处于Detect状态或Recovery状态&lt;sub&gt;Detect状态表示堆叠正常工作状态，Recovery状态表示堆叠禁用状态&lt;/sub&gt;
&lt;ol&gt;
&lt;li&gt;MAD分裂检测机制会检测到网络中存在多个处于Detect状态的堆叠系统&lt;/li&gt;
&lt;li&gt;这些堆叠系统之间相互竞争，竞争成功的堆叠系统保持Detect状态，竞争失败的堆叠系统会转入Recovery状态&lt;/li&gt;
&lt;li&gt;在 Recovery状态堆叠系统的所有成员交换机上，关闭除保留端口以外的其它所有物理端口，以保证该堆叠系统不再转发业务报文&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;MAD故障恢复&lt;br&gt;
通过修复故障链路，分裂后的堆叠系统重新合并为一个堆叠系统。重新合并的方式有以下两种：
&lt;ol&gt;
&lt;li&gt;堆叠链路修复后，处于Recovery状态的堆叠系统重新启动，与Detect状态的堆叠系统合并，同时将被关闭的业务端口恢复Up，整个堆叠系统恢复&lt;/li&gt;
&lt;li&gt;如果故障链路修复前，承载业务的Detect状态的堆叠系统也出现了故障。此时，可以先将Detect状态的堆叠系统从网络中移除，再通过命令行启用Recovery状态的堆叠系统，接替原来的业务，然后再修复原Detect状态堆叠系统的故障及链路故障。故障修复后，重新合并堆叠系统&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;dad双主检测&#34;&gt;DAD双主检测&lt;/h4&gt;
&lt;p&gt;检测方式如下：&lt;/p&gt;
&lt;h5 id=&#34;1-业务口直连检测方式&#34;&gt;1. 业务口直连检测方式&lt;/h5&gt;
&lt;p&gt;堆叠成员交换机间通过业务口连接的专用链路进行双主检测&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615622908795.png&#34; alt=&#34;业务口直连检测方式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;2-eth-trunk代理检测方式&#34;&gt;2. Eth-trunk代理检测方式&lt;/h5&gt;
&lt;p&gt;通过堆叠与代理设备相连的跨设备Eth-Trunk链路进行双主检测，代理设备需要启动DAD代理功能&lt;br&gt;
与业务口直连检测方式相比，Eth-Trunk口代理检测方式&lt;strong&gt;无需占用额外的接口&lt;/strong&gt;，&lt;strong&gt;Eth-Trunk接口可以同时运行DAD代理检测和其他业务&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615622987419.png&#34; alt=&#34;Eth-trunk代理检测方式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;3-管理口检测方式&#34;&gt;3. 管理口检测方式&lt;/h5&gt;
&lt;p&gt;通过堆叠成员交换机的管理网口链路进行双主检测。当所有堆叠成员交换机的管理网口都连接至管理网络时，可以使用该方式进行双主检测，不需要占用额外的接口，也不需要使用代理设备。&lt;br&gt;
&lt;code&gt;在管理网口检测方式中，要求堆叠系统的管理网口必须配置IP地址&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615623139795.png&#34; alt=&#34;管理口检测方式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;4-堆叠端口检测方式仅ce1280012800e支持&#34;&gt;4. 堆叠端口检测方式（仅CE12800&amp;amp;12800E支持）&lt;/h5&gt;
&lt;p&gt;通过堆叠物理成员端口之间的链路进行双主检测，该方式直接使用堆叠连接链路进行检测，不需要占用额外的接口&lt;br&gt;
&lt;code&gt;只有当堆叠连接方式为主控板直连时，才可以使用堆叠端口检测方式&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615623217916.png&#34; alt=&#34;堆叠端口检测方式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;css集群&#34;&gt;CSS（集群）&lt;/h1&gt;
&lt;h2 id=&#34;css集群连接方式&#34;&gt;CSS集群连接方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;集群卡集群方式&lt;br&gt;
集群成员交换机之间通过主控板上专用的集群卡及专用的集群线缆连接&lt;/li&gt;
&lt;li&gt;业务口集群方式&lt;br&gt;
集群成员交换机之间通过业务板上的普通业务口连接，不需要专用的集群卡&lt;br&gt;
同iStack，业务口集群一样涉及两种端口的概念：物理成员端口和逻辑集群端口&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;集群成员加入与合并-集群分裂&#34;&gt;集群成员加入与合并、集群分裂&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;使能了集群功能的单台交换机即为单框集群&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;成员加入-2&#34;&gt;成员加入&lt;/h3&gt;
&lt;p&gt;集群成员加入是指向稳定运行的单框集群系统中添加一台新的交换机，原单框集群的交换机成为主交换机，新加入的交换机成为备交换机&lt;/p&gt;
&lt;h3 id=&#34;成员合并&#34;&gt;成员合并&lt;/h3&gt;
&lt;p&gt;集群合并是指稳定运行的两个单框集群系统合并成一个新的集群系统。&lt;br&gt;
两个单框集群系统将&lt;strong&gt;自动选出一个更优的作为合并后集群系统的主交换机&lt;/strong&gt;。被选为主交换机的配置不变，业务也不会受到影响，&lt;strong&gt;框内的备用主控板将重启&lt;/strong&gt;。而&lt;strong&gt;备交换机将整框重启&lt;/strong&gt;，以集群备的角色加入新的集群系统，并将同步主交换机的配置，该交换机原有的业务也将中断&lt;/p&gt;
&lt;h3 id=&#34;集群分裂&#34;&gt;集群分裂&lt;/h3&gt;
&lt;p&gt;系统主用主控板和系统备用主控板定时发送心跳报文来维护集群系统的状态。&lt;br&gt;
当两台交换机之间的&lt;strong&gt;心跳报文超时&lt;/strong&gt;（超时时间为8秒）时，集群系统将分裂为两个单框集群系统。&lt;br&gt;
集群分裂后，由于成员交换机运行着相同的配置文件，就会产生两个具有相同IP和MAC的集群系统，为防止由此引起网络故障，必须进行IP地址和MAC地址的冲突检查&lt;br&gt;
&lt;code&gt;集群的多主检测MAD和堆叠相同&lt;/code&gt;&lt;/p&gt;
">堆叠</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/mpls/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%AF%E8%AF%AD%E6%A6%82%E5%BF%B5&#34;&gt;术语概念&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%AF%E8%AF%AD&#34;&gt;术语&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E5%BF%B5&#34;&gt;概念&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97&#34;&gt;MPLS标签嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#php%E6%AC%A1%E6%9C%AB%E8%B7%B3%E5%BC%B9%E5%87%BA%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%B7%B3%E5%BC%B9%E5%87%BA&#34;&gt;PHP次末跳弹出（倒数第二跳弹出）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#php%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E6%B2%A1%E6%9C%89php%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E5%BD%B1%E5%93%8D&#34;&gt;PHP的作用及没有PHP会有什么影响&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%A4%9A%E6%A0%87%E7%AD%BE%E4%BA%A4%E6%8D%A2&#34;&gt;MPLS多标签交换&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8mpls&#34;&gt;为什么需要使用MPLS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E7%9A%84%E6%8A%A5%E6%96%87%E5%B0%81%E8%A3%85%E4%BD%8D%E7%BD%AE%E5%8F%8A%E6%A0%BC%E5%BC%8F&#34;&gt;MPLS的报文封装位置及格式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A7%E6%A8%A1%E5%BC%8Fmpls&#34;&gt;帧模式MPLS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%A4%B4&#34;&gt;MPLS头&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E4%B8%AD%E7%9A%84%E8%BD%AC%E5%8F%91%E8%A1%A8%E9%A1%B9&#34;&gt;MPLS中的转发表项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B&#34;&gt;MPLS数据包的转发过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E5%8D%95%E6%B5%81%E7%A8%8B&#34;&gt;简单流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B&#34;&gt;详细过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls-ldp&#34;&gt;MPLS LDP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E7%9A%84%E6%B6%88%E6%81%AF%E7%B1%BB%E5%9E%8B&#34;&gt;LDP的消息类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E6%A0%87%E7%AD%BE%E7%9A%84%E5%8F%91%E5%B8%83%E4%B8%8E%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F&#34;&gt;LDP标签的发布与管理方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%A0%87%E7%AD%BE%E5%88%86%E9%85%8D%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F&#34;&gt;1. 标签分配控制方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%A0%87%E7%AD%BE%E5%8F%91%E5%B8%83%E6%96%B9%E5%BC%8F&#34;&gt;2. 标签发布方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E6%A0%87%E7%AD%BE%E4%BF%9D%E6%8C%81%E6%96%B9%E5%BC%8F&#34;&gt;3. 标签保持方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E9%82%BB%E5%B1%85%E5%BB%BA%E7%AB%8B%E7%9A%84%E8%BF%87%E7%A8%8B&#34;&gt;LDP邻居建立的过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6&#34;&gt;LDP发现机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E9%82%BB%E5%B1%85%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8Bldp%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B&#34;&gt;LDP邻居建立过程（LDP工作过程）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ldp%E4%BC%9A%E8%AF%9D%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%BC%9A%E8%AF%9D%E5%BB%BA%E7%AB%8B%E9%98%B6%E6%AE%B5&#34;&gt;1. LDP会话的建立（会话建立阶段）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-ldp-lsp%E7%9A%84%E5%BB%BA%E7%AB%8B%E9%80%9A%E5%91%8A%E9%98%B6%E6%AE%B5&#34;&gt;2. LDP LSP的建立（通告阶段）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls-vpn&#34;&gt;MPLS VPN&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A7%81%E7%BD%91%E6%A0%87%E7%AD%BE%E5%88%86%E9%85%8D&#34;&gt;私网标签分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A7%81%E7%BD%91%E8%B7%AF%E7%94%B1%E4%BA%A4%E5%8F%89&#34;&gt;私网路由交叉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AC%E7%BD%91%E9%9A%A7%E9%81%93%E8%BF%AD%E4%BB%A3%E9%9A%A7%E9%81%93%E8%BF%AD%E4%BB%A3%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8&#34;&gt;公网隧道迭代（隧道迭代是什么意思，以及作用）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A7%81%E7%BD%91%E8%B7%AF%E7%94%B1%E7%9A%84%E9%80%89%E6%8B%A9%E8%A7%84%E5%88%99&#34;&gt;私网路由的选择规则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%91%E5%B8%83&#34;&gt;路由发布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91&#34;&gt;报文转发&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85%E6%8F%90%E9%97%AE&#34;&gt;补充提问&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2pe-ce%E8%B7%AF%E7%94%B1%E7%9A%84%E5%B0%8F%E6%8F%90%E7%A4%BA&#34;&gt;部署PE-CE路由的小提示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E7%BB%84%E7%BD%91&#34;&gt;基本组网&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-intranet-vpn&#34;&gt;1. Intranet VPN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-extranet-vpn&#34;&gt;2. Extranet VPN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-hub-and-spoke%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8rt%E5%80%BC%E6%9D%A5%E6%90%AD%E5%BB%BAhub-spork%E7%9A%84%E7%BD%91%E7%BB%9C%E7%8E%AF%E5%A2%83&#34;&gt;3. Hub and Spoke（如何使用RT值来搭建Hub-Spork的网络环境）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rt%E4%B8%8Erd%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;RT与RD的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%98%AFvpnv4%E8%B7%AF%E7%94%B1&#34;&gt;什么是VPNv4路由&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%89%A9%E5%B1%95%E5%9B%A2%E4%BD%93%E5%B1%9E%E6%80%A7%E6%9C%89%E5%93%AA%E4%BA%9B&#34;&gt;常见的扩展团体属性有哪些&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#soo&#34;&gt;SoO&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E&#34;&gt;举例说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4policy-vpn-target%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;命令policy-vpn-target的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8C%E6%A0%87%E7%AD%BE%E7%9A%84%E4%BD%9C%E7%94%A8%E7%94%B1%E5%93%AA%E7%A7%8D%E5%8D%8F%E8%AE%AE%E5%88%86%E9%85%8D&#34;&gt;双标签的作用，由哪种协议分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%9F%9F%E5%86%85%E6%B1%87%E6%80%BB%E4%BC%9A%E4%BA%A7%E7%94%9F%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98&#34;&gt;MPLS域内汇总会产生什么问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%92%88%E5%AF%B9%E5%86%85%E9%83%A8%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E6%B1%87%E6%80%BBlsp%E4%B8%AD%E6%96%AD&#34;&gt;1. 针对内部路由进行汇总（LSP中断）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E9%92%88%E5%AF%B9%E6%89%80%E6%9C%89%E8%B7%AF%E7%94%B1%E8%BF%9B%E8%A1%8C%E6%A0%87%E7%AD%BE%E5%88%86%E9%85%8Dlsp%E4%B8%8D%E8%BF%9E%E7%BB%AD&#34;&gt;2. 针对所有路由进行标签分配（LSP不连续）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%92%88%E5%AF%B9bgp%E8%B7%AF%E7%94%B1%E8%B7%AF%E7%94%B1%E9%BB%91%E6%B4%9E&#34;&gt;3. 针对BGP路由（路由黑洞）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E9%92%88%E5%AF%B9%E7%A7%81%E7%BD%91%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB&#34;&gt;4. 针对私网路由汇总&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls-vpn%E4%B8%AD%E7%9A%84%E9%98%B2%E7%8E%AF%E6%8A%80%E6%9C%AF&#34;&gt;MPLS VPN中的防环技术&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E5%B1%9E%E6%80%A7%E5%80%BC%E4%B8%BA16%E7%9A%84%E6%89%A9%E5%B1%95%E5%B1%9E%E6%80%A7%E4%BC%9A%E6%90%BA%E5%B8%A6%E4%BA%9B%E4%BB%80%E4%B9%88%E4%B8%9C%E8%A5%BF%E5%8D%B3bgp%E7%9A%84%E6%89%A9%E5%B1%95%E5%9B%A2%E4%BD%93%E5%B1%9E%E6%80%A7%E4%BC%9A%E6%90%BA%E5%B8%A6%E4%BB%80%E4%B9%88&#34;&gt;BGP属性值为16的扩展属性会携带些什么东西（即BGP的扩展团体属性会携带什么）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ce%E5%8F%8C%E5%BD%92%E5%B1%9E%E6%97%B6%E4%B8%8Epe%E9%97%B4%E5%AE%9E%E4%BE%8B%E8%BF%90%E8%A1%8Cisis%E4%BC%9A%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98&#34;&gt;CE双归属时与PE间实例运行ISIS会有什么问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E4%B8%ADlsp%E7%9A%84%E5%A4%87%E4%BB%BD%E6%96%B9%E5%BC%8F&#34;&gt;MPLS中LSP的备份方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ip%E7%9A%84frr&#34;&gt;1. IP的FRR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-ldp%E7%9A%84frr&#34;&gt;2. LDP的FRR&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%A8%E5%9F%9Fvpn&#34;&gt;跨域VPN&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#optiona&#34;&gt;OptionA&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92&#34;&gt;1. 路由传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;2. 数据转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%89%B9%E7%82%B9&#34;&gt;3. 特点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optionb&#34;&gt;OptionB&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92-2&#34;&gt;1. 路由传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91-2&#34;&gt;2. 数据转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%89%B9%E7%82%B9-2&#34;&gt;3. 特点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optionc&#34;&gt;OptionC&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%A1%88%E4%B8%80&#34;&gt;方案一&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92-3&#34;&gt;1. 路由传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91-3&#34;&gt;2. 数据转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%89%B9%E7%82%B9optionc%E6%96%B9%E6%A1%88%E7%9A%84%E7%89%B9%E7%82%B9&#34;&gt;3. 特点（OptionC方案的特点）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%A1%88%E4%BA%8C&#34;&gt;方案二&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92-4&#34;&gt;1. 路由传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E5%92%8C%E6%96%B9%E6%A1%88%E4%B8%80%E7%9B%B8%E5%90%8C&#34;&gt;2. 数据转发（和方案一相同）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;术语概念&#34;&gt;术语概念&lt;/h1&gt;
&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;设备
&lt;ol&gt;
&lt;li&gt;CE：客户边界设备&lt;/li&gt;
&lt;li&gt;PE：运营商边界设备&lt;/li&gt;
&lt;li&gt;P：运营商内部的设备&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由器
&lt;ol&gt;
&lt;li&gt;LSR：标签交换路由器&lt;/li&gt;
&lt;li&gt;LER：标签边缘路由器（PE）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由器角色
&lt;ol&gt;
&lt;li&gt;Ingress：第一个压入标签的路由器&lt;/li&gt;
&lt;li&gt;Transit：只负责传输标签，标签交换&lt;/li&gt;
&lt;li&gt;Egress：标签弹出的路由器（不考虑PHP，即Egress PE向倒数第二跳节点分配隐式空标签，值为3）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;标签动作
&lt;ol&gt;
&lt;li&gt;push：标签压入&lt;/li&gt;
&lt;li&gt;swap：标签交换&lt;/li&gt;
&lt;li&gt;pop：标签弹出&lt;/li&gt;
&lt;li&gt;UNTAG/No label(没有标签)出现问题，在MPLS VPN的环境中只能丢弃报文&lt;code&gt;关于标签断裂：所有的环回口配置32位主机路由，核心网不许聚合&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Aggregate（聚合），把报文拿掉MPLS之后转发给一个vpn-instance接口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;数据库
&lt;ol&gt;
&lt;li&gt;RIB：路由信息表&lt;code&gt;控制层面，通过路由协议生成，用于选择路由，存储路由条目信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LIB：标签信息表，由标签协议根据路由产生的&lt;strong&gt;标签和路由的对应关系&lt;/strong&gt;&lt;code&gt;控制层面，通过LDP生成，用于管理标签信息，存储的是路由器邻居发给他的标签、以及自身对分配给某个目的IP网络的标签，用于管理标签信息&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;FIB：转发信息表，来自路由表拷贝&lt;code&gt;转发层面，通过路由协议生成，存储路由条目与出接口的对应关系&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LFIB：标签转发信息表，&lt;strong&gt;把FIB和LIB两者结合在一起&lt;/strong&gt;&lt;code&gt;通过LDP生成，负责带MPLS标签报文的转发，LIB只保存有标签信息，并没有出接口和下一跳信息，但LFIB有下一跳和出接口信息&lt;/code&gt;&lt;br&gt;
&lt;code&gt;LFIB中包含两张表，ILM和NHLFE。数据进入路由器查询ILM，数据出路由器查询的是NHLFE。这些表都是通过Tunnel ID来相互关联的&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;NHLFE：&lt;strong&gt;下一跳标签转发表&lt;/strong&gt;，用于指导MPLS报文的转发，包括Tunnel ID、出接口、下一跳、出标签、标签操作类型等信息。FEC到一组NHLFE的映射称为FTN（FEC-to-NHLFE），通过查看FIB表中Tunnel ID值不为0x0的表项，能够获得FTN的详细信息，FTN只在Ingress存在&lt;/li&gt;
&lt;li&gt;ILM：&lt;strong&gt;入标签映射表&lt;/strong&gt;，入标签到一组下一跳标签转发表项的映射，ILM包括Tunnel ID、入标签、入接口、标签操作类型等信息。ILM在Transit节点的作用是将标签和NHLFE绑定。通过标签索引ILM表，就相当于使用目的IP地址查询FIB，能够得到所有的标签转发信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Tunnel ID：&lt;code&gt;这不是数据库，是数据库之间的关联键值&lt;/code&gt;为了给使用隧道的上层应用（如VPN、路由管理）提供统一的接口，系统自动为隧道分配了一个ID，也称为Tunnel ID。该Tunnel ID的长度为32比特，只是本地有效&lt;code&gt;在MPLS转发过程中，FIB、ILM和NHLFE是通过Tunnel ID关联的&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;CPE：运营商三巨头中两个互联，为同一个客户服务&lt;/li&gt;
&lt;li&gt;MCE：MCE功能是Multi-CE的简称，具有MCE功能的交换机可以在BGP/MPLS VPN组网应用中承担多个VPN实例的CE功能，减少用户网络设备的投入&lt;/li&gt;
&lt;li&gt;vpn instance：&lt;strong&gt;在PE设备上起到隔离作用&lt;/strong&gt;，每一个vpn实例提供一个独立的路由表，同时甚至能够提供独立的路由协议进程&lt;/li&gt;
&lt;li&gt;LSP：标签交换通道，&lt;strong&gt;LSP是单向通道，与数据流的方向一致，用来交换Label/FEC映射信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;LDP：标签分发协议，相当于传统网络中的信令协议，负责&lt;strong&gt;转发等价类FEC的分类、标签的分配以及标签交换路径LSP的建立和维护&lt;/strong&gt;等操作&lt;/li&gt;
&lt;li&gt;FEC：转发等价类。MPLS将&lt;strong&gt;具有相同特征的报文&lt;/strong&gt;归为一类，称为转发等价类FEC，属于相同FEC的报文在转发过程中被LSR以相同方式处理。FEC可以根据&lt;strong&gt;源地址、目的地址、源端口、目的端口、VPN、隧道、QoS等要素&lt;/strong&gt;进行划分。例如，在传统的采用最长匹配算法的IP转发中，到同一条路由的所有报文就是一个转发等价类
&lt;ul&gt;
&lt;li&gt;一组或者一系列沿着相同路径转发的，且都按照相同的规则执行的数据流&lt;/li&gt;
&lt;li&gt;相同的转发方式、相同的转发路径LSP、相同的转发待遇&lt;/li&gt;
&lt;li&gt;同属一个FEC的报文拥有相同的标签，&lt;strong&gt;拥有相同标签的报文不一定同属一个FEC&lt;/strong&gt;，由入站LSR决定报文属于哪一个FEC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;种类&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;属于某特定组的组播报文&lt;/li&gt;
&lt;li&gt;目的IP地址匹配了某一个特定前缀的报文&lt;/li&gt;
&lt;li&gt;根据DCSP字段，有相同的QoS策略的报文&lt;/li&gt;
&lt;li&gt;MPLS VPN中，属于同一个VPN的报文&lt;/li&gt;
&lt;li&gt;报文的目的IP地址数据BGP学习到的路由，并且该路由的下一跳地址相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LDP邻接体：当一台LSR接收到&lt;strong&gt;对端发送过来的Hello消息&lt;/strong&gt;后LDP邻接体建立
&lt;ol&gt;
&lt;li&gt;本地邻接体：以&lt;strong&gt;组播&lt;/strong&gt;形式发送Hello消息（即链路hello消息）发现的邻接体&lt;code&gt;基本发现机制&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;远端邻接体：以&lt;strong&gt;单播&lt;/strong&gt;形式发送Hello消息（即目标Hello消息）发现的邻接体&lt;code&gt;扩展发现机制&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;LDP对等体：指相互之间存在LDP会话、使用LDP来交换标签消息的两个LSR&lt;code&gt;LDP通过邻接体来维护对等体的存在，对等体的类型取决于维护它的邻接体的类型。一个对等体可以由多个邻接体来维护，如果由本地邻接体和远端邻接体两者来维护，则对等体类型为本远共存对等体&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LDP会话：用于LSR之间交换标签映射、释放等消息。&lt;strong&gt;只有存在对等体才能建立LDP会话&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;本地LDP会话：建立会话的两个LSR之间是直连的&lt;/li&gt;
&lt;li&gt;远端LDP会话：建立会话的两个LSR之间可以是直连的，也可以是非直连的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;h3 id=&#34;mpls标签嵌套&#34;&gt;MPLS标签嵌套&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内层标签（栈底标签）&lt;/strong&gt;：靠近用户数据，&lt;strong&gt;MP-BGP分配&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;外层标签&lt;/strong&gt;：靠近二层头，&lt;strong&gt;LDP分配&lt;/strong&gt;，作为MP-BGP路由的下一跳地址&lt;br&gt;
&lt;code&gt;一般情况为2层，跨域的一般3层标签，CSC架构一般4层标签&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597620314374.png&#34; alt=&#34;MPLS标签嵌套&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID标识二层头部后面的报文类型
&lt;ul&gt;
&lt;li&gt;Ethernet
&lt;ul&gt;
&lt;li&gt;0x0800 IPv4&lt;/li&gt;
&lt;li&gt;0x8847 MPLS单播报文&lt;/li&gt;
&lt;li&gt;0x8848 MPLS多播报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PPP
&lt;ul&gt;
&lt;li&gt;0x8021 IPv4&lt;/li&gt;
&lt;li&gt;0x8281 MPLS单播报文&lt;/li&gt;
&lt;li&gt;0x8283 MPLS多播报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;S标识是否是栈底标签&lt;/li&gt;
&lt;li&gt;标签嵌套应用
&lt;ul&gt;
&lt;li&gt;MPLS VPN&lt;/li&gt;
&lt;li&gt;MPLS TE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;php次末跳弹出倒数第二跳弹出&#34;&gt;PHP次末跳弹出（倒数第二跳弹出）&lt;/h3&gt;
&lt;p&gt;在LSP的最后一跳节点，已不再需要在进行标签交换，此时，可以配置倒数第二跳弹出特性PHP，在倒数第二跳节点处将标签弹出，最后一跳节点直接进行IP转发或者下一层标签转发，减少最后一跳标签交换负担。&lt;br&gt;
&lt;strong&gt;Egress PE向倒数第二跳节点分配隐式空标签，值为3&lt;/strong&gt;。&lt;br&gt;
在次末跳交换为隐式空标签&lt;sub&gt;默认是隐式空标签，如果设计流量工程则需要使用显示空标签&lt;/sub&gt;，意味着应当弹掉这层标签，如果只有一层标签，则变成IP报文了，同时请注意，该转发决策由LFIB决定，转发出接口、二层重写信息已经就绪。&lt;/p&gt;
&lt;h4 id=&#34;php的作用及没有php会有什么影响&#34;&gt;PHP的作用及没有PHP会有什么影响&lt;/h4&gt;
&lt;p&gt;次末跳弹出机制中的两种标签类型：隐式空标签（默认）和显式空标签&lt;br&gt;
始发路由器给上游分配一个3号标签，使标签在倒数第二跳被弹出，最后一跳节点直接进行IP转发或者下一层标签转发，减少最后一跳标签交换负担&lt;br&gt;
如果没有PHP需要先查LFIB，将标签弹出，然后再查FIB表，将数据转发出去；如果使用PHP，则减少一次查表次数，PHP后只查FIB，&lt;strong&gt;不需要再查LFIB&lt;/strong&gt;，节省开销&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;有隐式空标签3了，为什么还需要显示空标签0呢？&lt;/strong&gt;&lt;br&gt;
IP数据包中有一个字段是服务类型，主要用于流量工程QoS，如果在MPLS环境中，使用默认的PHP机制，将无法部署QoS，因为隐式空标签中将不会显示服务类型这一项（需使用标签包中的EXP字段），当A收到B发给它的标签值为3时，那么A收到转发给B的数据时，将直接执行弹出动作。&lt;br&gt;
但是显示空标签不同，其在LDP中的标签值为0，A针对本地产生的路由条目发送给LDP邻居时会携带这一值，即A转发给B数据时是将标签交换为0，而不是直接弹出。&lt;br&gt;
即如果想要部署MPLS-TE（流量工程），则必须使用显示空标签的PHP&lt;br&gt;
&lt;strong&gt;如果收到一个标签包，标签为0，则直接弹出标签&lt;/strong&gt;，并将数据交给FIB进行查找，不需要查找LFIB，即不会有两次查找的损耗&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;mpls多标签交换&#34;&gt;MPLS多标签交换&lt;/h1&gt;
&lt;h2 id=&#34;为什么需要使用mpls&#34;&gt;为什么需要使用MPLS&lt;/h2&gt;
&lt;p&gt;由于路由器的转发效率较慢，开发MPLS主要是为了加快数据的转发。MPLS封装在二层与三层之间，在&lt;br&gt;
路径转发时，不需要查三层的IP，只需要查找到2.5层&lt;sub&gt;解决了每个数据包都要进行头部分析或者运算的问题，不再对IP报文做分析&lt;/sub&gt;，所以可以提高了转发效率，&lt;code&gt;但同时它将消耗更多带宽资源&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;mpls的报文封装位置及格式&#34;&gt;MPLS的报文封装位置及格式&lt;/h2&gt;
&lt;h3 id=&#34;帧模式mpls&#34;&gt;帧模式MPLS&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597565321121.png&#34; alt=&#34;帧模式MPLS&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MPLS&lt;strong&gt;帧模式&lt;/strong&gt;封装在2、3层之间，&lt;strong&gt;信元模式的MPLS已经淘汰&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;mpls头&#34;&gt;MPLS头&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;MPLS头部总长度为4bytes (32bits)&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597565565322.png&#34; alt=&#34;MPLS头&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Label：标签
&lt;ol&gt;
&lt;li&gt;0～15：特殊标签
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;0&lt;/strong&gt;：IPv4显示空标签，&lt;strong&gt;表示该标签必须被弹出&lt;/strong&gt;，且报文的&lt;strong&gt;转发必须基于IPv4&lt;/strong&gt;。一般倒数第二跳LSR压入标签0，最后一条LSR将标签0弹出&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;1&lt;/strong&gt;：警告标签，只有出现在&lt;strong&gt;非栈底时才有效&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;2&lt;/strong&gt;：IPv6显示空标签，表示该标签必须被弹出，且报文的转发必须基于IPv6&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3&lt;/strong&gt;：隐式空标签，倒数&lt;strong&gt;第二跳LSR进行标签交换&lt;/strong&gt;时，如果发现交换后的标签值为3，则&lt;strong&gt;将标签弹出&lt;/strong&gt;，&lt;strong&gt;并将报文发给最后一跳&lt;/strong&gt;，最后一跳收到该报文直接进行IP转发或下一层标签转发&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4～13和15&lt;/strong&gt;：保留&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;14&lt;/strong&gt;：OAM路由器警告标签，MPLS OAM通过发送OAM报文检测和通告LSP故障，OAM报文使用MPLS承载，&lt;strong&gt;对于Transit LSR和倒数第二跳LSR是透明的&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;16～1023：静态LSP和静态CR-LSP共享的标签空间&lt;/li&gt;
&lt;li&gt;1024及以上：LDP、RSVP-TE、MP-BGP等动态信令协议的标签空间&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;EXP：通常用做CoS，当设备阻塞时，优先发送优先级高的报文&lt;/li&gt;
&lt;li&gt;S：栈底标识，MPLS支持多层标签，即标签嵌套，S值为1时表明为最底层标签&lt;/li&gt;
&lt;li&gt;TTL：和IP报文中的TTL（Time To Live）意义相同&lt;br&gt;
&lt;strong&gt;关于TTL的处理有两种方式&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;统一模式（Uniform）：IP的TTL和MPLS的TTL相互拷贝，保持IP和MPLS的TTL值相同，可以统计MPLS中有多少个路由器，每经过一台路由器TTL值减 1，无论是MPLS还是IP&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597849957948.png&#34; alt=&#34;统一模式&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;在入口PE&lt;code&gt;减1之后&lt;/code&gt;，把IP的TTL拷贝到MPLS的TTL&lt;/li&gt;
&lt;li&gt;在MPLS区域按照外层的TTL进行转发，在次末跳上把MPLS的TTL&lt;code&gt;减1之后&lt;/code&gt;拷贝回IP&lt;/li&gt;
&lt;li&gt;多层标签默认只处理外层标签，只有外层标签弹出之后再处理内层标签&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;管道模式（Pipe）：IP分组经过MPLS网络时，无论经过多少跳，IP的TTL只有在入接点和出节点时分别减1，即&lt;strong&gt;核心网对用户是透明的，整个MPLS区域被看做一个设备&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597850414609.png&#34; alt=&#34;管道模式&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;在入接点，IP的TTL值&lt;code&gt;减1&lt;/code&gt;，&lt;strong&gt;MPLS的TTL字段为固定值&lt;/strong&gt;&lt;code&gt;如果需要隐藏MPLS核心网，则强制把进入MPLS核心网的报文的TTL设置为255&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;报文在MPLS网络中按照标准的TTL处理方式处理，每过一跳，MPLS的TTL减1，但是IP的TTL不变&lt;/li&gt;
&lt;li&gt;在出节点会将IP的TTL字段的值&lt;code&gt;减1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mpls中的转发表项&#34;&gt;MPLS中的转发表项&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597619000162.png&#34; alt=&#34;MPLS体系结构&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597620255352.png&#34; alt=&#34;MPLS结构&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;控制平面&lt;/strong&gt;：负责产生和维护路由信息以及标签信息
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RIB&lt;/strong&gt;：路由表，控制层面，由IP路由协议生成，用于选择路由，RIB中&lt;strong&gt;有递归过程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LIB&lt;/strong&gt;：标签信息表，控制层面，由标签分配协议生成，包含标签与FEC的对应关系，LIB包含所有的标签，&lt;strong&gt;无论是优的还是次优的&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;转发平面&lt;/strong&gt;：即&lt;strong&gt;数据平面&lt;/strong&gt;，负责普通IP报文的转发以及带MPLS标签报文的转发
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;FIB&lt;/strong&gt;：转发信息表，转发层面，数据包到达设备后查找FIB，从而知道如何转发。FIB里&lt;strong&gt;没有递归&lt;/strong&gt;&lt;code&gt;当去往目标路由的下一跳不是直连下一跳时，会产生递归&lt;/code&gt;过程&lt;code&gt;如果Tunnel ID值为0，则进入正常的IP转发流程；如果Tunnel ID值不为0，则进入MPLS转发流程&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;LFIB&lt;/strong&gt;：标签转发表，转发层面，标签与FEC的对应关系，&lt;strong&gt;只有最优的标签&lt;/strong&gt;，指导标签数据包转发&lt;code&gt;如果标签中的栈底标识S=1，表明该标签是栈底标签，直接进行IP转发；如果标签中的栈底标识S=0，表明还有下一层标签，继续进行下一层标签转发&lt;/code&gt;&lt;br&gt;
&lt;code&gt;LFIB中包含两张表，ILM和NHLFE。数据进入路由器查询ILM，数据出路由器查询的是NHLFE。这些表都是通过Tunnel ID来相互关联的&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MPLS VPN中的数据转发模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP报文入站：通过&lt;strong&gt;路由表&lt;/strong&gt;做转发决策，出方向的路由上&lt;strong&gt;有标签转发信息&lt;/strong&gt;，则可以&lt;strong&gt;选择压入标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;标签报文入站：通过&lt;strong&gt;标签转发表&lt;/strong&gt;做出转发决策，出方向如果&lt;strong&gt;有标签则执行标签交换&lt;/strong&gt;，然后转发，如果出方向&lt;strong&gt;没有标签&lt;/strong&gt;，则&lt;strong&gt;移除标签然后路由转发&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mpls数据包的转发过程&#34;&gt;MPLS数据包的转发过程&lt;/h2&gt;
&lt;h3 id=&#34;简单流程&#34;&gt;简单流程&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;CE伦敦--&amp;gt;Ingress PE--&amp;gt;Egress PE--&amp;gt;CE巴黎&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597587418563.png&#34; alt=&#34;从CE到Ingress PE&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597590091682.png&#34; alt=&#34;从Ingress PE到CE&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CE将报文发给其相连的VRF接口，PE在本VRF的路由表中进行查找，得到了该路由的&lt;strong&gt;公网下一跳地址&lt;/strong&gt;和&lt;strong&gt;私网标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PE把该报文封装一层私网标签后，在&lt;strong&gt;公网的标签转发表中查找下一跳地址&lt;/strong&gt;，在&lt;strong&gt;封装一层公网标签&lt;/strong&gt;后，交予MPLS转发&lt;/li&gt;
&lt;li&gt;该报文在公网上沿着LSP转发，并根据途径的每一台设备的标签转发表进行标签交换&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;倒数第二跳&lt;/strong&gt;处，将&lt;strong&gt;外层的公网标签弹出&lt;/strong&gt;，交给目的的PE（PE-1）设备&lt;/li&gt;
&lt;li&gt;PE设备根据&lt;strong&gt;内层的私网标签判断该报文属于哪一个VRF&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弹出内层私网标签&lt;/strong&gt;，在目的VRF中查找路由表，根据下一跳&lt;strong&gt;发给相应的CE&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;详细过程&#34;&gt;详细过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613836690430.png&#34; alt=&#34;MPLS数据包的转发过程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;当&lt;strong&gt;IP报文进入MPLS域&lt;/strong&gt;时，首先查看FIB表，检查目的IP地址对应的Tunnel ID值是否为0x0
&lt;ol&gt;
&lt;li&gt;如果Tunnel ID值为0x0，则进入正常的IP转发流程&lt;/li&gt;
&lt;li&gt;如果Tunnel ID值不为0x0，则进入MPLS转发流程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ingress&lt;/strong&gt;，通过查询FIB表和NHLFE表指导报文的转发
&lt;ol&gt;
&lt;li&gt;查看FIB表，根据目的IP地址找到对应的Tunnel ID&lt;/li&gt;
&lt;li&gt;根据Tunnel ID找到对应的NHLFE表项，查看NHLFE表项，可以得到&lt;strong&gt;出接口、下一跳、出标签和标签操作类型&lt;/strong&gt;，标签操作类型为Push&lt;/li&gt;
&lt;li&gt;在IP报文中&lt;strong&gt;压入出标签&lt;/strong&gt;，并根据QoS策略处理EXP，同时处理TTL，然后将封装好的MPLS报文发送给下一跳&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Transit&lt;/strong&gt;，通过查询ILM表和NHLFE表指导MPLS报文的转发
&lt;ol&gt;
&lt;li&gt;根据MPLS的标签值查看对应的ILM表，可以得到Tunnel ID&lt;/li&gt;
&lt;li&gt;根据Tunnel ID找到对应的NHLFE表项，查看NHLFE表项，可以得到&lt;strong&gt;出接口、下一跳、出标签和标签操作类型&lt;/strong&gt;，MPLS报文的处理方式根据不同的标签值而不同：
&lt;ol&gt;
&lt;li&gt;如果&lt;strong&gt;标签值&amp;gt;＝16或者=0或者=2&lt;/strong&gt;，则用新标签替换MPLS报文中的旧标签，同时处理EXP和TTL，然后将替换完标签的MPLS报文发送给下一跳&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;标签值为3&lt;/strong&gt;&lt;code&gt;即隐式空标签，支持PHP&lt;/code&gt;，则直接弹出标签，同时处理EXP和TTL，然后进行IP转发或下一层标签转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Egress&lt;/strong&gt;，通过查询ILM表指导MPLS报文的转发或查询路由表指导IP报文转发&lt;code&gt;先查LFIB，再查FIB&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;如果收到IP报文，则查看路由表，进行IP转发&lt;/li&gt;
&lt;li&gt;如果 收到MPLS报文，则查看ILM表获得标签操作类型，同时处理EXP和TTL
&lt;ol&gt;
&lt;li&gt;如果标签中的&lt;strong&gt;栈底标识S=1&lt;/strong&gt;，表明该标签是栈底标签，直接进行IP转发&lt;/li&gt;
&lt;li&gt;如果标签中的&lt;strong&gt;栈底标识S=0&lt;/strong&gt;，表明还有下一层标签，继续进行下一层标签转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mpls-ldp&#34;&gt;MPLS LDP&lt;/h1&gt;
&lt;p&gt;标签分发协议，自动分配标签，自动构建LSP（标签交换隧道）&lt;br&gt;
LDP&lt;strong&gt;默认只会为IGP分配标签，而且只为32位主机路由分配标签&lt;/strong&gt;，可使用命令：&lt;code&gt;lsp-trigger&lt;/code&gt;修改&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;思科和华为区别：&lt;br&gt;
华为只为32位主机路由分配标签&lt;code&gt;修改命令lsp-trigger [host | ip-prefix | all]&lt;/code&gt;，但是思科只要满足2个分配条件就可以为FIB表中每条IGP路由单独分配一个标签，条件是开启cef和在物理接口下激活LDP，也就是说思科会为所有的IGP路由分配标签&lt;br&gt;
对于默认的方式，个人觉得华为的操作更好一些。原因：个人觉得实际对互联链路分配标签没有什么用处，只会增大标签信息库的容量，MPLS在现阶段来说，对于IGP加快转发速度的作用几乎没有，主要在BGP或MPLS VPN部署时有更好的作用（当然MPLS还有其他应用），可以使核心路由器不要承载所有路由，而在部署BGP的时候，通常使用lo0建立iBGP邻居，所以LSP沿路设备只需要为BGP路由下一跳的lo0路由分配标签就可以了，互联链路的路由完全是没有作用的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;LSP形成方式：静态LSP（手动配置）和动态LSP（LDP协议生成）&lt;br&gt;
静态LSP不能使用标签发布协议动态建立，需要由管理员手工配置，适用于拓扑结构简单并且稳定的网络或者某些关键数据或重要业务&lt;br&gt;
静态LSP不使用标签发布协议，不需要交互控制报文，资源消耗比较小，但通过静态方式建立的LSP不能根据网络拓扑变化动态调整，需要管理员干预，所以适用于拓扑结构简单并且稳定的网络&lt;br&gt;
配置静态LSP时，管理员需要为&lt;strong&gt;各LSR手工分配标签&lt;/strong&gt;，需要遵循的原则是：&lt;strong&gt;前一节点出标签的值等于下一个节点入标签的值&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ldp的消息类型&#34;&gt;LDP的消息类型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597668635041.png&#34; alt=&#34;LDP消息类型&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597671143763.png&#34; alt=&#34;格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597671149312.png&#34; alt=&#34;字段含义&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发现消息（Discovery）：宣告和维护网络中一个LSR的存在
&lt;ol&gt;
&lt;li&gt;只有发现消息使用UDP承载，目的端口为646，消息中的transport address默认为LSR-ID，LSR-ID必须手动配置，且必须为路由器上某个接口地址，且必须宣告进底层路由协议进程中&lt;/li&gt;
&lt;li&gt;链路Hello消息&lt;code&gt;用于本地邻接体，即建立会话的两个LSR之间是直连的&lt;/code&gt;：组播地址为224.0.0.2&lt;code&gt;hello默认5秒，holdtime默认15秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;目标Hello消息&lt;code&gt;用于远端邻接体，即建立会话的两个LSR之间可以是直连的，也可以是非直连的&lt;/code&gt;：单播&lt;code&gt;hello默认15秒，holdtime默认45秒&lt;/code&gt;&lt;br&gt;
&lt;code&gt;本地邻接体和远端邻接体可以共存&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;会话消息（Session）：建立、维护和终止LDP邻居之间的LDP会话&lt;/li&gt;
&lt;li&gt;通告消息（Advertisement）：生成、改变和删除FEC的标签映射&lt;/li&gt;
&lt;li&gt;通知消息（Notification）：宣告告警和错误信息&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613878517929.png&#34; alt=&#34;LDP消息作用&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ldp标签的发布与管理方式&#34;&gt;LDP标签的发布与管理方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;保守标签保持方式通常与DoD方式一起，用于标签空间有限的LSR&lt;/code&gt;&lt;br&gt;
目前设备支持如下组合方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下游自主方式(DU)＋有序标签分配控制方式(Ordered)＋自由标签保持方式(Liberal)（默认方式）&lt;/li&gt;
&lt;li&gt;下游自主方式(DU)＋独立标签分配控制方式(Independent)＋自由标签保持方式(Liberal)&lt;/li&gt;
&lt;li&gt;下游按需方式(DoD)＋有序标签分配控制方式(Ordered)＋保守标签保持方式(Conservative)&lt;/li&gt;
&lt;li&gt;下游按需方式(DoD)＋独立标签分配控制方式(Independent)＋保守标签保持方式(Conservative)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-标签分配控制方式&#34;&gt;1. 标签分配控制方式&lt;/h3&gt;
&lt;p&gt;标签分配控制方式是指在LSP的建立过程中，LSR分配标签时采用的处理方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;独立标签分配控制方式&lt;/strong&gt;（Independent）：本地LSR可以&lt;strong&gt;自主地分配一个标签绑定到某个FEC，并通告给上游LSR&lt;/strong&gt;，而无需等待下游的标签&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序标签分配控制方式&lt;/strong&gt;（Ordered）：对于LSR上某个FEC的标签映射，&lt;strong&gt;只有当该LSR已经具有此FEC下一跳的标签映射消息、或者该LSR就是此FEC的出节点时&lt;/strong&gt;，该LSR才可以向上游发送此FEC的标签映射&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;思科默认标签发布方式为独立分配，但是华为默认采用有序分配的方式&lt;br&gt;
思科只要满足标签分配条件，就立即分配标签，而华为是需要等。为什么要等，因为这样能保证LSP不是断裂的，保证下游路由器分配、分布完标签后，上游路由器才能分配、分布，保证去往目的的数据包沿路都是有标签的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-标签发布方式&#34;&gt;2. 标签发布方式&lt;/h3&gt;
&lt;p&gt;由下游LSR决定将标签分配给特定FEC，再通知上游LSR，&lt;strong&gt;即标签由下游指定&lt;/strong&gt;，&lt;strong&gt;标签的分配按从下游到上游的方向分发&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613883311568.png&#34; alt=&#34;标签发布方式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;下游自主方式DU&lt;/strong&gt;：对于一个特定的FEC，LSR&lt;strong&gt;无需从上游获得标签请求消息&lt;/strong&gt;即进行标签分配与分发&lt;code&gt;标签发布方式为DU时，系统默认支持LDP为所有对等体分标签，即每个节点都可以向所有的对等体发送标签映射消息，不再区分上下游关系&lt;/code&gt;&lt;br&gt;
对于目的地址为192.168.1.1/32的FEC，下游（Egress）通过标签映射消息主动向上游（Transit）通告自己的主机路由192.168.1.1/32的标签&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;下游按需方式DoD&lt;/strong&gt;：对于一个特定的FEC，LSR&lt;strong&gt;获得标签请求消息之后&lt;/strong&gt;才进行标签分配与分发&lt;br&gt;
对于目的地址为192.168.1.1/32的FEC，上游（Ingress）向下游发送标签请求消息，下游（Egress）收到标签请求消息后，才会向上游发送标签映射消息&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-标签保持方式&#34;&gt;3. 标签保持方式&lt;/h3&gt;
&lt;p&gt;标签保持方式是指LSR对收到的、&lt;strong&gt;但目前暂时不需要的标签映射的处理方式&lt;/strong&gt;，LSR收到的标签映射可能来自下一跳，也可能来自非下一跳。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自由标签保持方式&lt;/strong&gt;（Liberal）：对于从邻居LSR收到的标签映射，无论邻居LSR是不是自己的下一跳都保留&lt;code&gt;LSR可以直接利用原来非下一跳邻居发来的标签，迅速重建LSP，但需要更多的内存和标签空间&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;保守标签保持方式&lt;/strong&gt;（Conservative）：对于从邻居LSR收到的标签映射，只有当邻居LSR是自己的下一跳时才保留&lt;code&gt;节省了内存和标签空间，但LSP的重建会比较慢&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ldp邻居建立的过程&#34;&gt;LDP邻居建立的过程&lt;/h2&gt;
&lt;h3 id=&#34;ldp发现机制&#34;&gt;LDP发现机制&lt;/h3&gt;
&lt;p&gt;LDP&lt;strong&gt;发现机制用于LSR发现潜在的LDP对等体&lt;/strong&gt;。LDP有两种发现机制：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基本发现机制：用于发现链路上&lt;strong&gt;直连的LSR&lt;/strong&gt;，LSR通过周期性地组播发送LDP&lt;strong&gt;链路Hello消息&lt;/strong&gt;，实现LDP基本发现机制，建立本地LDP会话&lt;/li&gt;
&lt;li&gt;扩展发现机制：用于发现链路上&lt;strong&gt;非直连LSR&lt;/strong&gt;，LSR周期性地单播发送LDP&lt;strong&gt;目标Hello消息&lt;/strong&gt;到指定IP地址，实现LDP扩展发现机制，建立远端LDP会话。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ldp邻居建立过程ldp工作过程&#34;&gt;LDP邻居建立过程（LDP工作过程）&lt;/h3&gt;
&lt;h4 id=&#34;1-ldp会话的建立会话建立阶段&#34;&gt;1. LDP会话的建立（会话建立阶段）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613882654331.png&#34; alt=&#34;LDP邻居建立过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;UDP ，646，大主动，Keeplive周期15秒、holdtime为45秒&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两个LSR之间互相发送Hello消息，携带传输地址（即设备的IP地址），双方使用传输地址建立LDP会话，传输地址较大的一方作为主动方发起建立TCP连接，即LSR_1作为主动方发起建立TCP连接&lt;/li&gt;
&lt;li&gt;TCP连接建立成功后，由主动方LSR_1发送初始化消息Init，协商建立LDP会话的相关参数，包括LDP协议版本、标签分发方式、Keepalive保持定时器的值、最大PDU长度和标签空间等&lt;/li&gt;
&lt;li&gt;被动方LSR_2收到初始化消息后，
&lt;ol&gt;
&lt;li&gt;接受相关参数，则发送初始化消息Init和Keepalive消息给主动方LSR_1&lt;/li&gt;
&lt;li&gt;不能接受相关参数，则发送Notification消息终止LDP会话的建立&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;主动方LSR_1收到初始化消息后，
&lt;ol&gt;
&lt;li&gt;接受相关参数，则发送Keepalive消息给被动方LSR_2&lt;/li&gt;
&lt;li&gt;不能接受相关参数，则发送Notification消息终止LDP会话的建立&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当双方都收到对端的Keepalive消息后，LDP会话建立成功&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-ldp-lsp的建立通告阶段&#34;&gt;2. LDP LSP的建立（通告阶段）&lt;/h4&gt;
&lt;p&gt;使用&lt;strong&gt;下游自主标签发布方式+有序标签控制方式+自由标签保持方式&lt;/strong&gt;(默认方式)举例&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613886357255.png&#34; alt=&#34;LDP LSP的建立&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先发Address消息，携带本地开启LDP协议的接口地址，且只通告给邻居，邻居收到不再扩散&lt;/li&gt;
&lt;li&gt;分发标签，使用label mapping消息&lt;code&gt;含有三要素：label+FEC+LSR-ID&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;网络的路由改变时，如果有一个边缘节点（Egress）发现自己的路由表中出现了&lt;strong&gt;新的32位主机路由&lt;/strong&gt;，&lt;strong&gt;并且这一路由不属于任何现有的FEC&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;该边缘节点需要为这一路由建立一个新的FEC，为FEC分配标签，并主动向上游发出标签映射消息，标签映射消息中包含分配的标签和绑定的FEC等信息&lt;/li&gt;
&lt;li&gt;Transit收到标签映射消息后，则在其标签转发表LFIB中增加相应的条目，然后主动向上游LSR发送该FEC的标签映射消息&lt;/li&gt;
&lt;li&gt;Ingress收到标签映射消息后，在标签转发表LFIB中增加相应的条目，LSP建立完成，接下来就可以对该FEC对应的数据报文进行标签转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;路由器收到label mapping消息后的处理方式：路由器收到label mapping消息后，首先查看FEC，根据FEC查FIB表找到最优的直连下一跳，然后根据下一跳查看address消息，对应到其中的LSR-ID，然后再根据此LSR-ID查看label mapping消息中的LSR-ID，对应选用其中的label，把此label放入LFIB&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;mpls-vpn&#34;&gt;MPLS VPN&lt;/h1&gt;
&lt;h2 id=&#34;私网标签分配&#34;&gt;私网标签分配&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;MP-BGP为私网路由分配标签的前提是PE上使能MPLS功能&lt;/code&gt;&lt;br&gt;
PE通过MP-BGP发布私网路由给骨干网的其他相关的PE前，需要为私网路由分配MPLS标签（私网标签），&lt;strong&gt;当数据包在骨干网传输时，需要携带私网标签&lt;/strong&gt;&lt;code&gt;MPLS网络无法转发IP数据，如果没有私网标签，在PHP后会导致数据被丢弃&lt;/code&gt;，PE上分配私网标签的方法有如下两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基于路由的MPLS标签分配&lt;/strong&gt;：为VPN路由表的每一条路由分配一个标签，这种方式的缺点是：&lt;strong&gt;当路由数量比较多时，设备入标签映射表ILM需要维护的表项也会增多&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;基于VPN实例的MPLS标签分配&lt;/strong&gt;：为整个VPN实例分配一个标签，该VPN实例里的所有路由都共享一个标签，使用这种分配方法的好处是节约了标签&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;私网路由交叉&#34;&gt;私网路由交叉&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;用来解决进入VPN实例之前的路由的筛选和优选&lt;/code&gt;&lt;br&gt;
在BGP/MPLS IP VPN组网中，PE设备从CE设备&lt;strong&gt;收到BGP私网路由&lt;/strong&gt;或&lt;strong&gt;从其他PE设备收到BGP VPNv4路由&lt;/strong&gt;后，这些收到的路由需要&lt;strong&gt;经过筛选才能够复制到PE设备上对应的VPN实例并发送给对应的私网站点&lt;/strong&gt;，完成BGP/MPLS IP VPN组网的路由学习过程。其中这个对路由的筛选和复制到VPN实例的过程被称作路由交叉。根据路由来源不同，可以分为远端交叉和本地交叉：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;远端交叉&lt;/strong&gt;：从&lt;strong&gt;远端PE设备学习到的BGP VPNv4路由&lt;/strong&gt;，根据其携带的ERT（Export Target）属性值，逐个与本地的VPN实例下配置的IRT（Import Target）进行匹配。如果能够匹配则将这条BGP VPNv4路由转换成BGP私网路由，然后复制一份到该VPN实例路由表中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;本地交叉&lt;/strong&gt;：&lt;strong&gt;将PE上某一个VPN实例下的路由&lt;/strong&gt;根据ERT、IRT的匹配规则（和远端交叉的规则一样）复制到其他VPN实例路由表中，&lt;strong&gt;本地交叉的路由包括本地引入的路由和从私网邻居学到的路由&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617369324026.png&#34; alt=&#34;私网路由交叉&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1617369396380.png&#34; alt=&#34;远端交叉&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;如果远端PE发来的两条BGP VPNv4路由的RD值相同，则会由于这两条路由无法同时交叉进入BGP VPN实例，而导致无法实现VPN FRR功能或PE间的私网路由负载分担功能&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PE1从PE2、PE3和PE4收到BGP VPNv4路由后会将这些路由存放至BGP VPNv4路由表中&lt;/li&gt;
&lt;li&gt;由于PE2和PE3上VPN实例的RD值相同，因此PE2和PE3发来的BGP VPNv4路由也是相同的，所以PE1将会从这两条路由中选择出最优路由（本例中最优路由为PE3发来的路由）。这条最优路由将会和PE4发来的路由&lt;strong&gt;一起转换成不带RD值的BGP私网路由并交叉进入到BGP VPN实例路由表中&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PE3和PE4发来的BGP VPNv4路由在&lt;strong&gt;去掉RD值后，将转换成两条相同的BGP私网路由&lt;/strong&gt;，这两条BGP私网路由将继续进行选路，即&lt;strong&gt;选择出一条最优BGP私网路由下发至私网IP路由表中&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;公网隧道迭代隧道迭代是什么意思以及作用&#34;&gt;公网隧道迭代（隧道迭代是什么意思，以及作用）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;运营商并不想用其核心路由器承载所有的路由，即对于用户的公网IP（或者私网）不是通过IGP路由传递，那么可以采用隧道迭代来实现使用隧道来传递用户的公网IP（或者私网）的数据。即运行商通过LSP来传递用户流量，从而达到不用学习用户路由的目的&lt;/code&gt;&lt;br&gt;
&lt;code&gt;本质：为远端交叉的路由分配一条LSP，用来承载远端交叉成功的路由的数据&lt;/code&gt;&lt;br&gt;
为了将私网流量通过公网传递到另一端，需要有一条公网隧道承载这个私网流量，因此私网路由交叉完成后，需要&lt;strong&gt;根据目的IPv4前缀进行路由迭代&lt;/strong&gt;，查找合适的隧道（本地交叉的路由除外&lt;code&gt;非标签的公网路由和静态路由不会进行隧道迭代&lt;/code&gt;），&lt;strong&gt;只有隧道迭代成功，该路由才被放入对应的VPN实例路由表&lt;/strong&gt;。将路由迭代到相应的隧道的过程叫做隧道迭代。&lt;br&gt;
隧道迭代成功后，&lt;strong&gt;保留该隧道的标识符（Tunnel ID）&lt;/strong&gt;，供后续转发报文时使用。Tunnel ID用于唯一标识一条隧道，VPN报文转发时根据Tunnel ID查找对应的隧道，然后从隧道上发送出去&lt;br&gt;
&lt;strong&gt;隧道迭代可用来解决路由黑洞&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614162331482.png&#34; alt=&#34;解决路由黑洞&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
40.0.0.0地址被network到BGP中，40.0.0.0的路由是没有标签的，所以40.0.0.0的路由无法通过LSP传递到R1上，需要使用一条命令&lt;code&gt;route recursive-lookup tunnel&lt;/code&gt;使能迭代隧道功能， 把所有的路由都迭代到LSP中，那么40.0.0.0的路由就可以通过4.4.4.4的LSP进行转发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置&lt;code&gt;route recursive-lookup tunnel&lt;/code&gt;命令之后,&lt;br&gt;
非标签公网路由既可以迭代到有LSP隧道的路由并且继承这条LSP隧道，也可以迭代到IP路由，这样迭代结果就会出现两条等价路由，两者形成负载分担，一条走LSP隧道转发，一条走IP转发。&lt;br&gt;
如果两条链路中IP转发的链路不通，走IP转发的流量会被丢弃，导致业务中断。&lt;br&gt;
为了解决上述问题，可以指定参数only，使非标签公网路由只迭代有LSP隧道的路由，如果LSP隧道路由不存在，则迭代不成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;私网路由的选择规则&#34;&gt;私网路由的选择规则&lt;/h2&gt;
&lt;p&gt;经过路由交叉和隧道迭代的路由并不是全部被放入VPN实例路由表。从本地CE收到的路由和本地交叉路由也不是全部被放入VPN实例路由表。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于到&lt;strong&gt;同一目的地址的多条路由&lt;/strong&gt;，如果&lt;strong&gt;不进行路由的负载分担&lt;/strong&gt;，则选路的优先级：&lt;code&gt;从CE收到的路由&amp;gt;本地交叉的路由&amp;gt;从其他PE接收并交叉成功的路由&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于到同一目的地址的多条路由，如果&lt;strong&gt;进行路由的负载分担&lt;/strong&gt;，则：&lt;code&gt;负载分担的AS_PATH属性必须完全相同&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优先选择从本地CE收到的路由&lt;/strong&gt;，只有一条从本地CE收到的路由而有多条交叉路由的情况下，也只选择从本地CE收到的路由&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只在从本地CE收到的路由之间分担或只在交叉路由之间分担&lt;/strong&gt;，不会在本地CE收到的路由和交叉路由之间分担&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;路由发布&#34;&gt;路由发布&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;VPN路由信息的发布涉及CE和PE，P设备只维护骨干网的路由，不需要了解任何VPN路由信息，PE设备一般维护所有VPN路由&lt;/code&gt;&lt;br&gt;
VPN路由信息的发布过程包括&lt;strong&gt;三部分&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本地CE到入口PE
&lt;ol&gt;
&lt;li&gt;CE与直接相连的PE建立邻居或对等体关系后，把本站点的IPv4路由发布给PE，CE与PE之间可以使用静态路由、RIP、OSPF、IS-IS或BGP，无论使用哪种路由协议，CE发布给PE的都是标准的IPv4路由&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;入口PE到出口PE
&lt;ol&gt;
&lt;li&gt;PE从CE学到VPN路由信息后，存放到VPN实例中，同时，为这些标准IPv4路由&lt;strong&gt;增加RD&lt;/strong&gt;，形成VPN-IPv4路由&lt;/li&gt;
&lt;li&gt;入口PE通过MP-BGP的Update报文把VPN-IPv4路由发布给出口PE，Update报文中携带&lt;strong&gt;Export VPN Target（RT）属性及MPLS标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;出口PE收到VPN-IPv4路由后，在下一跳可达的情况下进行&lt;strong&gt;路由交叉、隧道迭代和路由优选&lt;/strong&gt;，然后决定是否将该路由加入到VPN实例的路由表，被加入到VPN路由表的路由，本地PE为其&lt;strong&gt;保留MPLS标签值和Tunnel ID&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;出口PE到远端CE
&lt;ol&gt;
&lt;li&gt;远端CE有多种方式可以从出口PE学习VPN路由，包括静态路由、RIP、OSPF、IS-IS和BGP，与本地CE到入口PE的路由信息交换相同&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613996455022.png&#34; alt=&#34;路由发布&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在CE2的BGP IPv4单播地址族下引入IGP路由&lt;/li&gt;
&lt;li&gt;CE2将该路由随EBGP的Update消息一起发布给Egress PE，Egress PE从连接CE2的接口收到Update消息，把该路由转化为VPN IPv4路由，加入对应的VPN实例路由表&lt;/li&gt;
&lt;li&gt;Egress PE为该路由分配MPLS标签，并将标签和VPN IPv4路由信息加入MP-IBGP的Update消息中的NLRI字段中，Export-RT属性加入MP-BGP Update消息的扩展团体属性字段中，将Update消息发送给Ingress PE&lt;/li&gt;
&lt;li&gt;Ingress PE对该路由进行路由交叉，交叉成功则根据路由目的IPv4地址进行隧道迭代，查找合适的隧道，如果迭代成功，则保留该隧道的Tunnel ID和标签，并将路由加入该VPN实例路由表&lt;/li&gt;
&lt;li&gt;Ingress PE把该路由通过BGP Update消息发布给CE1，此时路由是普通IPv4路由，CE1收到该路由后，把该路由加入BGP路由表，通过&lt;strong&gt;在IGP中引入BGP路由的方法可使CE1把该路由加入IGP路由表&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;报文转发&#34;&gt;报文转发&lt;/h2&gt;
&lt;p&gt;VPN报文转发采用&lt;code&gt;两层&lt;/code&gt;标签方式：&lt;br&gt;
&lt;strong&gt;第一层&lt;/strong&gt;（公网）标签在骨干网内部进行交换，指示&lt;strong&gt;从PE到对端PE的一条LSP&lt;/strong&gt;。VPN报文利用这层标签，可以沿LSP到达对端PE&lt;br&gt;
&lt;strong&gt;第二层&lt;/strong&gt;（私网）标签在从&lt;strong&gt;对端PE到达CE&lt;/strong&gt;时使用，指示报文应被送到哪个Site，或者到达哪一个CE，即对端PE根据内层标签可以找到转发报文的接口&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614000916529.png&#34; alt=&#34;报文转发&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CE1发送一个VPN报文&lt;/li&gt;
&lt;li&gt;Ingress PE从绑定了VPN实例的接口上&lt;strong&gt;接收VPN数据包后&lt;/strong&gt;进行如下操作：
&lt;ol&gt;
&lt;li&gt;先&lt;strong&gt;根据&lt;/strong&gt;绑定的VPN实例的&lt;strong&gt;RD&lt;/strong&gt;查找对应&lt;strong&gt;VPN的转发表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;匹配目的IPv4前缀，&lt;strong&gt;查找对应的Tunnel ID&lt;/strong&gt;&lt;code&gt;即根据目标IP地址查找LFIB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将报文&lt;strong&gt;打上&lt;/strong&gt;对应的&lt;strong&gt;私网标签&lt;/strong&gt;（I-L），&lt;strong&gt;根据Tunnel-ID找到隧道&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将报文从隧道发送出去&lt;/strong&gt;，此例的隧道是LSP，则打上&lt;strong&gt;公网（外层）MPLS标签头&lt;/strong&gt;（O-L1）&lt;code&gt;接着，该报文携带两层MPLS标签穿越骨干网，骨干网的每台P设备都对该报文进行外层标签交换&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Egress PE收到&lt;/strong&gt;该携带两层标签的报文，交给MPLS协议处理，MPLS协议将&lt;strong&gt;去掉外层标签&lt;/strong&gt;&lt;code&gt;此例最后的外层标签是O-L2，但如果应用了倒数第二跳弹出，则此标签会在到达Egress PE之前的一跳弹出，Egress PE只能收到带有内层标签的报文&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Egress PE看见内层标签后，&lt;strong&gt;发现该标签处于栈底，将内层标签剥离&lt;/strong&gt;&lt;code&gt;即内层标签用于数据到达远端之后，决定转发至哪个接口（vrf里面）；外层标签用于在MPLS核心网中转发数据&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Egress PE将报文从&lt;strong&gt;对应出接口发送给CE2&lt;/strong&gt;，此时报文是个&lt;strong&gt;纯IP报文&lt;/strong&gt;，报文就成功地从CE1传到CE2了，CE2按照普通的IP转发过程将报文传送到目的地&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;补充提问&#34;&gt;补充提问&lt;/h3&gt;
&lt;h3 id=&#34;部署pe-ce路由的小提示&#34;&gt;部署PE-CE路由的小提示&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果使用静态，则PE需要在vrf下写静态&lt;/li&gt;
&lt;li&gt;如果使用IGP，则需要双向重分布&lt;/li&gt;
&lt;li&gt;如果是BGP，则不需要重分布，但PE在vrf地址族下做配置：
&lt;ol&gt;
&lt;li&gt;内层标签由PE MP-BGP分配，标识报文到达本PE后转发至哪个出接口或者vrf&lt;/li&gt;
&lt;li&gt;外层标签由LDP分配，在核心网依据外层标签转发&lt;/li&gt;
&lt;li&gt;标签在产生VPNv4路由时，由MP-BGP分配，同时标签将跟随路由更新给对等体&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本组网&#34;&gt;基本组网&lt;/h2&gt;
&lt;h3 id=&#34;1-intranet-vpn&#34;&gt;1. Intranet VPN&lt;/h3&gt;
&lt;p&gt;一个VPN中的所有用户形成闭合用户群，相互之间能够进行流量转发，VPN中的用户不能与任何本VPN以外的用户通信&lt;br&gt;
需要为每个VPN分配一个VPN Target，作为该VPN的Export Target和Import Target，并且，此VPN Target不能被其他VPN使用&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614003682689.png&#34; alt=&#34;Intranet VPN&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PE上为VPN1分配的VPN Target值为100:1，为VPN2分配的VPN Target值为200:1，VPN1的两个Site之间可以互访，VPN2的两个Site之间也可以互访，但VPN1和VPN2的Site之间不能互访&lt;/p&gt;
&lt;h3 id=&#34;2-extranet-vpn&#34;&gt;2. Extranet VPN&lt;/h3&gt;
&lt;p&gt;某个VPN需要访问共享站点，则该VPN的Export Target必须包含在共享站点的VPN实例的Import Target中，而其Import Target必须包含在共享站点VPN实例的Export Target中&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614003780250.png&#34; alt=&#34;Extranet VPN&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PE3能够接收PE1和PE2发布的VPN-IPv4路由，同时PE3发布的VPN-IPv4路由能够被PE1和PE2接收，因此，VPN1的Site1和Site3之间能够互访，VPN2的Site2和VPN1的Site3之间能够互访&lt;br&gt;
PE3不把从PE1接收的VPN-IPv4路由发布给PE2，也不把从PE2接收的VPN-IPv4路由发布给PE1，因此，VPN1的Site1和VPN2的Site2之间不能互访&lt;/p&gt;
&lt;h3 id=&#34;3-hub-and-spoke如何使用rt值来搭建hub-spork的网络环境&#34;&gt;3. Hub and Spoke（如何使用RT值来搭建Hub-Spork的网络环境）&lt;/h3&gt;
&lt;p&gt;在VPN中设置中心访问控制设备，其它用户的互访都通过中心访问控制设备进行&lt;br&gt;
中心访问控制设备所在站点称为Hub站点，其他用户站点称为Spoke站点，Spoke站点需要把路由发布给Hub站点，再通过Hub站点发布给其他Spoke站点，Spoke站点之间不直接发布路由，Hub站点对Spoke站点之间的通讯进行集中控制。&lt;br&gt;
对于这种组网情况，需要设置两个VPN Target，一个表示Hub，另一个表示Spoke&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614004586160.png&#34; alt=&#34;Hub and Spoke&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
各Site在PE上的VPN实例的VPN Target设置规则为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Spoke-PE：Export Target为Spoke，Import Target为Hub，任意Spoke-PE的Import Route Target属性不与其它Spoke-PE的Export Route Target属性相同；&lt;/li&gt;
&lt;li&gt;Hub-PE：Hub-PE上需要使用两个接口或子接口：
&lt;ol&gt;
&lt;li&gt;一个用于接收Spoke-PE发来的路由，其VPN实例的Import Target为Spoke&lt;/li&gt;
&lt;li&gt;一个用于向Spoke-PE发布路由，其VPN实例的Export Target为Hub&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;rt与rd的作用&#34;&gt;RT与RD的作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;VRF&lt;/strong&gt;&lt;br&gt;
目的是&lt;strong&gt;解决不同企业私网地址段相同而冲突的问题&lt;/strong&gt;，采用将相同私网地址放到不同的VRF表中。VRF区分不同CE端进来边界PE的相同私网路由，路由器的每一个VRF都自动生成相应VRF表，&lt;strong&gt;每张VRF表都具有路由区分符RD和路由目标RT两大属性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RD&lt;/strong&gt;&lt;code&gt;区分实例，标记路由，本地有效，区分不同站点的相同路由，但不具有选路能力，也不影响路由接收和优选&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;8个字节的RD&lt;/strong&gt;+4个字节的IPv4地址组成&lt;strong&gt;96位VPNv4路由&lt;/strong&gt;，&lt;strong&gt;使不唯一的IPv4地址转化为唯一的VPN-IPv4地址&lt;/strong&gt;，该VPNv4路由在ISP域内传递（区分），&lt;code&gt;RD与路由一起被携带在BGP Update报文中发布给对端&lt;/code&gt;RD给某VRF里面的路由打上标签，进而实现地址的复用而不产生冲突。&lt;strong&gt;RD用来区分本地VRF，该属性仅本地有效&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RT&lt;/strong&gt;&lt;code&gt;对路由进行控制，控制路由的导入与导出&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;BGP的扩展团体属性&lt;/strong&gt;，它分成Import RT和Export RT，分别&lt;strong&gt;用于路由的导入、导出策略&lt;/strong&gt;，即&lt;code&gt;RT是控制一个VRF里面可以发出和接受什么样的路由&lt;/code&gt;，RT具有&lt;strong&gt;全局唯一性&lt;/strong&gt;，并且&lt;strong&gt;只能被一个VPN使用&lt;/strong&gt;。通过配置import和export RT，来控制收发路由：
&lt;ol&gt;
&lt;li&gt;当从VRF表中导出VPN路由时，要用Export RT对VPN路由进行标记&lt;/li&gt;
&lt;li&gt;当往VRF表中导入VPN路由时，只有所带RT标记与VRF表中任意一个Import RT相符的路由才会被导入到VRF表中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么是vpnv4路由&#34;&gt;什么是VPNv4路由&lt;/h2&gt;
&lt;p&gt;通过把&lt;strong&gt;64bit的RD值+32bit0的IPv4&lt;/strong&gt;的路由就形成了96bit的VPNv4路由&lt;/p&gt;
&lt;h2 id=&#34;常见的扩展团体属性有哪些&#34;&gt;常见的扩展团体属性有哪些&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;RT&lt;/li&gt;
&lt;li&gt;cost-community&lt;/li&gt;
&lt;li&gt;SoO&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;soo&#34;&gt;SoO&lt;/h3&gt;
&lt;p&gt;SoO用于在多出口情况下阻止环路，唯一的SoO值必须为每个VPN站点配置，应用于PE-CE连接的接口下，其本质是&lt;code&gt;不把收到的路由再传给客户站点&lt;/code&gt;，&lt;strong&gt;部署在PE的vrf接口下&lt;/strong&gt;，其值一般为&lt;code&gt;ASN:nn&lt;/code&gt;或者&lt;code&gt;IP-address:nn&lt;/code&gt;&lt;br&gt;
【注意】：SOO的防环机制，是在PE传递路由给CE的时候，检查出接口配置的SOO值是否与从其他MP-BGP邻居收到的VPNv4路由的SOO值一致，如果一致，就不传给CE，&lt;strong&gt;而不是PE不接收从CE或者其他设备发来的和SoO值相同的路由&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;从CE收到的路由引入MP-BGP，增加扩展团体属性值自定义SoO&lt;/li&gt;
&lt;li&gt;其它PE设备不将携带特定SoO属性值的路由传递给同站点的CE&lt;/li&gt;
&lt;li&gt;相同SoO值，被PE认为是同站点&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;举例说明&#34;&gt;举例说明&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1598626932182.png&#34; alt=&#34;举例说明&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在PE1上针对CE1对等体指定SoO属性，该属性相当于标识了CE1所在Site&lt;/li&gt;
&lt;li&gt;当CE1发布路由给PE1时，PE1为这些路由携带上该SoO属性&lt;/li&gt;
&lt;li&gt;PE1通过骨干网将这些路由发布给PE2时也将携带此SoO属性&lt;/li&gt;
&lt;li&gt;PE2将这些路由发布给自己的CE2对等体时，如果PE2发现路由中携带的SoO属性与其上针对CE2对等体配置的SoO属性相同，说明这些路由就是由该Site（CE1所在的site）发出的，从而拒绝将路由发布给CE2对等体，从而避免了VPN site内路由环路的产生&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;命令policy-vpn-target的作用&#34;&gt;命令policy-vpn-target的作用&lt;/h2&gt;
&lt;p&gt;收到一条VPNv4路由，要查看RT值是否和自己的import方向的RT值是否相同，如果不同则不收。&lt;br&gt;
如果undo掉这个功能，那么收到了一条VPNv4的路由首先会收入自己的VPNv4路由表，再查看是否对应自己的RT值，如果不匹配则只存在于自己的VPNv4路由表中，不会放入实例路由表。&lt;/p&gt;
&lt;h2 id=&#34;双标签的作用由哪种协议分配&#34;&gt;双标签的作用，由哪种协议分配&lt;/h2&gt;
&lt;p&gt;公网标签负责数据在公网的传输，私网标签指导数据进入相应的实例&lt;br&gt;
公网标签由LDP分配，私网标签由MP-BGP分配。&lt;br&gt;
如果只有公网标签的话，由于LDP分配的3号标签会进行次末跳弹出，进行IPV4转发，但是在MPLS VPN中并不识别IPV4的路由，就无法转发数据包而丢弃，所以这时需要通过内层标签，进行转发，通过标签与实例的对应关系，就知道转发到哪个实例。&lt;/p&gt;
&lt;h2 id=&#34;mpls域内汇总会产生什么问题&#34;&gt;MPLS域内汇总会产生什么问题&lt;/h2&gt;
&lt;h3 id=&#34;1-针对内部路由进行汇总lsp中断&#34;&gt;1. 针对内部路由进行汇总（LSP中断）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;隧道中断，但是报文依旧能到达&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617376975690.png&#34; alt=&#34;针对内部路由进行汇总&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在R3上针对R1的1.1.1.1/32的路由进行汇总，汇总成1.1.1.0/24位并抑制了1.1.1.1/32，此时由于不是32位的主机路由，R3将汇总后的路由通过IGP协议通告给其他路由器之后，其他路由器并不会给这个汇总路由分配标签，造成在R3、R4、R5上没有1.1.1.0/24路由的标签，导致LSP断裂&lt;br&gt;
此时数据转发流程：R5访问1.1.1.1时，R5上没有1.1.1.1/32，只有汇总后的路由，所以在R3到R5之间进行IGP转发；当数据到达R3时，命中更加精确的路由1.1.1.1/32，然后在R1到R3之间通过标签转发，走LSP通道&lt;/p&gt;
&lt;h3 id=&#34;2-针对所有路由进行标签分配lsp不连续&#34;&gt;2. 针对所有路由进行标签分配（LSP不连续）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;内部路由汇总之后导致LSP中断，究其原因是LDP不为非主机路由分配标签，如果通过修改标签分配方式使其能为汇总路由分配标签，则会导致隧道不连续，即针对两条路由生成两条不相干的LSP，但是报文依旧能够到达，并且都是通过标签交换&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617377600510.png&#34; alt=&#34;针对所有路由进行标签分配&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
即在R3、R4、R5使用命令&lt;code&gt;lsp-trigger all（或者配置ip-prefix）&lt;/code&gt;来为汇总路由分配标签，从而在R3到R5之间为汇总路由重新生成一条LSP，数据在R1与R3之间走隧道1，在R3与R5之间走隧道2&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;lsp-trigger&lt;/code&gt;命令和&lt;code&gt;lsp-trigger bgp-label-route&lt;/code&gt;命令都用于配置LDP LSP的触发建立策略，前者适用于静态路由和IGP路由；后者仅适用于带标签的公网BGP路由&lt;br&gt;
&lt;strong&gt;不推荐配置lsp-trigger all命令&lt;/strong&gt;，因为配置该命令后，&lt;strong&gt;所有IGP路由会触发LDP建立LSP，导致LSP数量庞大&lt;/strong&gt;，占用过多的系统资源。如果需要配置该命令，可以先配置路由过滤策略，减少路由数量，从而减少路由触发LDP建立的LSP的数量，节约系统资源&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-针对bgp路由路由黑洞&#34;&gt;3. 针对BGP路由（路由黑洞）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;客户的路由时100.1.1.1，另一个R6想要访问100.1.1.1，运行商不想让其核心路由器承担过多的路由，此时可以使用隧道来传输用户的数据，也就是在R1和R5上开启隧道迭代功能&lt;/code&gt;&lt;br&gt;
&lt;code&gt;汇总导致BGP路由没有隧道迭代，且运营商设备无用户路由导致丢包&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1617378988864.png&#34; alt=&#34;针对BGP路由&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在R1和R5上使用命令&lt;code&gt;route recursive-lookup tunnel&lt;/code&gt;开启路由的迭代隧道的功能，此时R6可以通过运营商建立的LSP访问到100.1.1.1&lt;br&gt;
但是刚才在R3上做了域内路由的汇总导致标签断裂，&lt;strong&gt;汇总导致BGP路由没有隧道迭代&lt;/strong&gt;，就会去根据下一跳去转发，R5发送给R4，R4查路由表没有100.1.1.1的路由，R4会进行丢包&lt;br&gt;
虽然之后又对汇总路由分配了标签，但LSP依然是不连续的，会在R3上进行丢包，因为在R3上剥离了标签3000之后露出的是目的IP 100.1.1.1，R3上也没有此路由，又会导致丢包&lt;/p&gt;
&lt;h3 id=&#34;4-针对私网路由汇总&#34;&gt;4. 针对私网路由汇总&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1617379967569.png&#34; alt=&#34;针对私网路由汇总&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;R2、R3、R4只运行IGP协议，不运行BGP协议&lt;/code&gt;&lt;br&gt;
VPN路由，下一跳对应的隧道必须是32位的，在R5上做了汇总之后就不是32位，无法加入到VRF路由表，直接在始发节点丢包，因为没有路由&lt;/p&gt;
&lt;h2 id=&#34;mpls-vpn中的防环技术&#34;&gt;MPLS VPN中的防环技术&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;OSPF防环&lt;code&gt;本质是只接收不选路&lt;/code&gt;：通过DN位防止3类LSA环路&lt;sub&gt;但DN位可用于所有LSA防环&lt;/sub&gt;，即不接收DN位置位的LSA；通过TAG防止5类LSA（和7类）的环路，即在TAG中包含BGP的AS号，如果在TAG中包含本地的AS号，5类LSA不接收&lt;code&gt;OSPF接入MPLS VPN之后的防环机制：内部路由up/down比特设置、外部路由利用TAG防环(CE双归属等)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BGP防环&lt;code&gt;本质是入方向路由标记、然后对标记的路由在出方向进行过滤，即对从CE收到的路由进行标记，PE之间可以传递，但其他PE不会再传递给CE&lt;/code&gt;：使用SoO进行防环&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614170477955.png&#34; alt=&#34;BGP防环&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PE3传递路由给PE1，引进后发给CE，再转发给PE2，PE2经骨干网再传递给PE1，从而产生路由震荡或环路&lt;br&gt;
&lt;strong&gt;解决方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PE-CE之间运行OSPF，PE1传递给CE时D/N位置位或打上tag（tag用AS号标识），PE2接收但不计算，从而防环&lt;/li&gt;
&lt;li&gt;PE-CE之间运行bgp，在BGP中的VPN下配置SoO值（PE1和PE2的值必须相同），PE2发现路由中携带的SoO属性，与其针对CE配置的SoO属性相同，则不会将路由发布给CE，从而防环&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bgp属性值为16的扩展属性会携带些什么东西即bgp的扩展团体属性会携带什么&#34;&gt;BGP属性值为16的扩展属性会携带些什么东西（即BGP的扩展团体属性会携带什么）&lt;/h2&gt;
&lt;p&gt;详情请参考&lt;a href=&#34;http://www.h3c.com/cn/d_201010/922164_30005_0.htm&#34;&gt;http://www.h3c.com/cn/d_201010/922164_30005_0.htm&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Export RT值携带于此扩展属性中&lt;/li&gt;
&lt;li&gt;如果PE与CE之间运行ospf协议还会携带DomainID、LsaType、RouterID、AreaID
&lt;ol&gt;
&lt;li&gt;DomainID 的作用：
&lt;ol&gt;
&lt;li&gt;用于还原ospf原来的&lt;strong&gt;一些属性&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;在DomainID相同的时候，原来的1/2/3类lsa传入对端CE之后变为3类lsa，5 类还是5类，7类还是7 类；&lt;/li&gt;
&lt;li&gt;DomainID不同的时候，原来的1/2/3/5类lsa都变为5类lsa，7 类还是7类&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;sham-link可以还原原来&lt;strong&gt;所有的属性值&lt;/strong&gt;：在传递VPNv4路由的时候用属性值为14和15的传递VPNv4路由，RD值以及私网标签，14传递可达路由，15传递需要撤销的路由&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ce双归属时与pe间实例运行isis会有什么问题&#34;&gt;CE双归属时与PE间实例运行ISIS会有什么问题&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;可能会产生路由不稳定和环路问题&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614174601680.png&#34; alt=&#34;运行ISIS会有什么问题&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
CE1双归属到PE2和PE3，且CE1、PE2、PE3之间运行ISIS。&lt;br&gt;
CE2上的10.1.2.0/24的路由通过PE4传递到PE2和PE3。PE2 将实例中的BGP路由引入到ISIS中，该路由通过CE1传递到PE3上，由于ISIS路由的优先级为15，高于PE3的实例中10.1.2.0/24的BGP的路由。（PE3访问CE2走的是PE3--CE1--PE2--PE4--CE2）&lt;br&gt;
此时，&lt;strong&gt;在PE3上如果把实例中的ISIS路由引到BGP中&lt;/strong&gt;，该路由会成为VPNv4的路上传递给PE4和PE2，造成&lt;strong&gt;路由环路&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;解决方法&lt;/strong&gt;：&lt;br&gt;
在PE2将实例中的BGP的路由引入到ISIS中时为路由打上Tag，在对端的PE3上的ISIS进程下使用filter-policy过滤到该tag对应的路由条目，防止它出现在PE3实例的路由表中，同时在PE3上引入BGP路由时也采取相同的措施。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于PE把BGP路由引入到了ISIS，因此PE上ISIS能把这些路由发布出去，并通过CE让对方ISIS学习到路由，且该路由的属性是ISIS路由。默认情况下，ISIS路由优先级比BGP路由优先级高，因此在路由选择时，ISIS路由被优选。&lt;br&gt;
由于BGP路由变成 Inactive，导致PE上不能引入该BGP路由，于是产生了路由不稳定。&lt;br&gt;
在防环上，ISIS不像OSPF那样完善，ISIS协议本身不防环路，因此需要在PE的ISIS在引入BGP路由时，给路由打上tag标记。对端PE学习到路由后，通过策略过滤这些路由，使它不进入另一个PE实例下的路由表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;mpls中lsp的备份方式&#34;&gt;MPLS中LSP的备份方式&lt;/h1&gt;
&lt;h2 id=&#34;1-ip的frr&#34;&gt;1. IP的FRR&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614177594588.png&#34; alt=&#34;IP的FRR&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R3有个30网段，默认情况下R2优选1号链路到30网段，当链路断掉后再通过R1到30网段，设备上会有个路由表RIB，RIB存放的是去往目的网段最优的，数据转发的时候用的FIB表，FIB是根据RIB生成的。&lt;br&gt;
当R2与R3之间的链路断掉后，FIB、RIB里都没了，所以需要路由收敛，路由收敛是有一定时间的，会重新计算RIB，R2去往30网段的下一跳会变成R1，根据新的RIB生成FIB，然后数据才能转发，所以无论什么协议如果一直有连续的数据过来的话，那么&lt;strong&gt;肯定会有丢包&lt;/strong&gt;了，所以IP的FRR就是来解决这个问题。&lt;br&gt;
&lt;strong&gt;IP的FRR解决思路&lt;/strong&gt;：&lt;br&gt;
去往30网段有2条路径，可以&lt;strong&gt;在FIB表里形成一条备份的路径&lt;/strong&gt;，配置方法很简单，只需要在&lt;code&gt;route-policy ip_frr_rp permit xxx&lt;/code&gt;中&lt;strong&gt;指定备份出接口和备份下一跳&lt;/strong&gt;，并在系统试图下或者VPN实例中使能&lt;code&gt;ip frr route-policy ip_frr_rp&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-ldp的frr&#34;&gt;2. LDP的FRR&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614178062354.png&#34; alt=&#34;LDP的FRR&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认情况R2去往40网段的下一跳还是R3，MPLS中有4张表，分别是RIB、FIB、LIB和LFIB，其中LFIB是根据FIB和LIB组合成LFIB，所以在MPLS中数据转发就看LFIB，所以R2去往40网段肯定会对应一个LFIB。&lt;br&gt;
假设R3给R2分发的是3000，也就是说在R2的FLIB表中，肯定有一个3000标签对应40网段，如果访问40 网段就用标签3000转发出去。&lt;br&gt;
R3给R2分配的3000标签，也肯定会给R1分配，假设分配的是4000，R1也要针对40网段给R2分标签，假设分配5000，所以R2针对40网段可以收到2个标签：一个R3分配的3000，一个R1分配的5000。&lt;br&gt;
标签保持方式有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自由标签保持方式，即R2把5000和3000都放进LIB中，但是5000标签会被标记不是最优的&lt;/li&gt;
&lt;li&gt;保守标签保持方式，即R2只保留最优的，只会将3000放进LIB，5000则会被丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标签发布方式也有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自主发布方式，即对R4来说，不管有没有设备访问40网段，都会给40网段分配标签&lt;/li&gt;
&lt;li&gt;按需发布方式，即R4虽然有40网段，但是R3不去访问这个网段，R4不会分配标签&lt;code&gt;如果R4的路由表非常庞大，为每个路由都分配一条标签就会占用系统资源以及标签资源，为了节省资源可以采用按需发布和保守标签保持方式相结合&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;标签分配方式也有两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;独立标签分配方式，即R3不管R4有没有给40网段分配标签，R3都会给40网段分配标签&lt;/li&gt;
&lt;li&gt;有序标签分配方式，即R3如果没有收到R4给40网段分配的标签，那么R3也不会分配给40标签&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;R2去往40有两个标签，3000和5000，由于3000的标签更优，所以会把3000的标签加到LFIB表里，假如R2-R3之间的链路断掉以后，4个表都没了，这个时候有数据过来的时候肯定会造成丢包，这时候就可以用到LDP的FRR的技术。&lt;br&gt;
&lt;strong&gt;LDP的FRR解决思路&lt;/strong&gt;：&lt;br&gt;
R2会把5000也放入LFIB，但会标明是一个备份的标签，当3000标签失效后，立马切换到5000，这就可以避免数据包的丢包&lt;br&gt;
&lt;strong&gt;配置时分为两种办法&lt;/strong&gt;：&lt;br&gt;
&lt;code&gt;在手工配置的LDP FRR和LDP Auto FRR同时满足创建条件的时候，优先建立手工配置的 LDP FRR&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动&lt;br&gt;
指定建立的备份LSP的&lt;strong&gt;出接口和下一跳&lt;/strong&gt;，当Liberal Label的来源匹配到指定的出接口和下一跳的时候，就能够建立备份LSP并下发转发表项&lt;/li&gt;
&lt;li&gt;自动&lt;br&gt;
LDP Auto FRR依赖IP FRR来实现&lt;code&gt;即需要使能IGP协议与LDP之间的同步功能&lt;/code&gt;，LDP Auto FRR策略默认是32位的备份路由触发LDP建立备份LSP
&lt;ol&gt;
&lt;li&gt;在R1、R2、R3上配置ospf，实现骨干网的IP连通性&lt;/li&gt;
&lt;li&gt;配置LDP，实现LDP LSP承载网络业务（准备工作）&lt;/li&gt;
&lt;li&gt;在R2和R3上配置静态BFD，实现快速检测LSP故障&lt;/li&gt;
&lt;li&gt;在R2上配置LDP Auto FRR，实现主备切换时尽可能避免流量丢失&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ospf配置（接口视图）
ospf timer ldp-sync hold-down 时间(默认10秒)

# isis配置（进程下）
timer ldp-sync hold-down 时间(默认10秒)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;跨域vpn&#34;&gt;跨域VPN&lt;/h1&gt;
&lt;h2 id=&#34;optiona&#34;&gt;OptionA&lt;/h2&gt;
&lt;p&gt;需要跨域的VPN在ASBR间&lt;strong&gt;通过专用的接口管理自己的VPN路由&lt;/strong&gt;，也称为&lt;strong&gt;VRF-to-VRF&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614261374015.png&#34; alt=&#34;OptionA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614264524271.png&#34; alt=&#34;OptionA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;两个AS的边界ASBR直接相连，ASBR同时也是各自所在自治系统的PE，两个ASBR都把对端ASBR看作自己的CE设备，将会为每一个VPN创建VPN实例，使用EBGP方式向对端发布IPv4路由&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-路由传递&#34;&gt;1. 路由传递&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614264564832.png&#34; alt=&#34;路由传递&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;配置：
&lt;ol&gt;
&lt;li&gt;各AS内部正常建立IGP邻居关系并且运行MPLS LDP&lt;/li&gt;
&lt;li&gt;各PE上创建VPN实例，并与接口相绑定&lt;/li&gt;
&lt;li&gt;R2与R3、R4与R5分别建立VPNv4邻居关系&lt;code&gt;即区域内PE之间建立VPNv4邻居&lt;/code&gt;，R3与R4的两个实例之间建立IPv4的邻居关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由传递：
&lt;ol&gt;
&lt;li&gt;R1上的IPv4路由传递到R2，R2将其引入VPNv4路由表后，携带私网标签L1、RT、下一跳等传递给R3&lt;/li&gt;
&lt;li&gt;R3收到之后，匹配RT值，剥离RD和私网标签引入实例2中，以IPv4路由传递给R4&lt;/li&gt;
&lt;li&gt;R4从实例3收到IPv4路由，将其引入VPNv4路由表后，携带私网标签L2、RT、下一跳等传递给R5，R5 匹配RT值后，剥离RD和私网标签引入实例4中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-数据转发&#34;&gt;2. 数据转发&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614264594520.png&#34; alt=&#34;数据转发&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;R6封装正常IPv4数据包转发给R5&lt;/li&gt;
&lt;li&gt;R5收到数据包查实例的FIB，先封装私网标签L2，再封装去往R4的公网标签Lx，然后转发出去&lt;/li&gt;
&lt;li&gt;R4收到数据包后，查找标签转发表，找到对应实例3，剥离私网标签L2后转发给R3&lt;/li&gt;
&lt;li&gt;R3收到数据包查实例的FIB，先封装私网标签L1，再封装去往R2的公网标签Ly，然后转发出去&lt;/li&gt;
&lt;li&gt;R2收到数据包后，查找标签转发表，找到对应实例1，剥离私网标签L1后转发给R1&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-特点&#34;&gt;3. 特点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在需要跨域的VPN数量比较少的情况，可以优先考虑使用&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：配置简单，由于ASBR之间不需要运行MPLS，也不需要为跨域进行特殊配置&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;可扩展性差：由于ASBR需要管理所有VPN路由，为每个VPN创建VPN实例，这将导致ASBR上的VPN-IPv4路由数量过大&lt;/li&gt;
&lt;li&gt;对PE（ASBR）设备要求高：由于ASBR间是普通的IP转发，要求为每个跨域的VPN使用不同的接口，从而提高了对PE设备的要求&lt;/li&gt;
&lt;li&gt;对中间域影响大：如果跨越多个自治域，中间域必须支持VPN业务，不仅配置量大，而且对中间域影响大。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;optionb&#34;&gt;OptionB&lt;/h2&gt;
&lt;p&gt;ASBR间&lt;strong&gt;通过MP-EBGP发布标签VPN-IPv4路由&lt;/strong&gt;，也称为EBGP redistribution of labeled VPN-IPv4 routes&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614263451029.png&#34; alt=&#34;OptionB&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614264718816.png&#34; alt=&#34;OptionB&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ASBR接收本域内和域外传过来的所有跨域VPN-IPv4路由，通过&lt;code&gt;undo policy vpn-target&lt;/code&gt;，让ASBR不进行VPN Target匹配把收到的VPN路由全部保存下来，而不管本地是否有和它匹配的VPN实例。这种方案的优点是所有的流量都经过ASBR转发，使流量具有良好的可控性，但ASBR的负担重。&lt;br&gt;
可以同时使用BGP路由策略（如对RT的过滤），使ASBR上只保存部分VPN-IPv4路由。&lt;/p&gt;
&lt;h3 id=&#34;1-路由传递-2&#34;&gt;1. 路由传递&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614264916939.png&#34; alt=&#34;路由传递&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;配置：
&lt;ol&gt;
&lt;li&gt;各AS内部正常建立IGP邻居关系并且运行MPLS LDP，R3与R4之间运行MPLS即可&lt;/li&gt;
&lt;li&gt;各PE上创建VPN实例，并与接口相绑定&lt;/li&gt;
&lt;li&gt;R2与R3、R4与R5分别建立 IBGP VPNv4邻居关系，R3与R4之间建立EBGP VPNv4邻居关系且 R3和R4上需要&lt;code&gt;undo policy vpn-target&lt;/code&gt;（保留所有VPN路由），并且在R3与R4上都对VPNv4路由交换内层标签，&lt;strong&gt;域间的标签由BGP携带&lt;/strong&gt;，因此&lt;strong&gt;ASBR之间不需要运行LDP&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由传递：
&lt;ol&gt;
&lt;li&gt;R1上的IPv4路由传递到R2，R2将其引入VPNv4路由表后，携带私网标签L1、RT、下一跳等传递给R3&lt;/li&gt;
&lt;li&gt;R3重新为该路由分发私网标签L2，然后携带私网标签L2、RT、下一跳等传递给R4&lt;code&gt;由于MP-EBGP在传递路由时，需要改变路由的下一跳，所以ASBR向外发布VPNv4路由时会分配新标签&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;R4重新为该路由分发私网标签L3，然后携带私网标签L3、RT、下一跳等传递给R5&lt;code&gt;R4和R5向域内的MP-IBGP对等体发布路由时，将下一跳改为自己&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;R5匹配RT值后，剥离RD和私网标签引入实例2中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-数据转发-2&#34;&gt;2. 数据转发&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614266224355.png&#34; alt=&#34;数据转发&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;R6封装正常IPv4数据包转发给R5，R5收到数据包查实例的FIB，先封装私网标签L3，再封装去往R4的公网标签Lx，然后转发出去&lt;/li&gt;
&lt;li&gt;R4收到数据包后，根据私网标签L3查找标签转发表，找到对应的出标签私网标签L2，然后封装私网标签L2，&lt;strong&gt;不封装公网标签&lt;/strong&gt;，直接转发给R3&lt;/li&gt;
&lt;li&gt;R3收到数据包后，根据私网标签L2查找标签转发表，找到对应的出标签私网标签L1，然后封装私网标签L1，再封装去往R2的公网标签Ly，之后转发出去&lt;/li&gt;
&lt;li&gt;R2收到数据包后，查找标签转发表，找到对应实例1，剥离私网标签L1后转发给R1&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-特点-2&#34;&gt;3. 特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优点&lt;/strong&gt;：不受ASBR之间互连链路数目的限制&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;ASBR负担重：由于VPN的路由信息是通过AS之间的ASBR来保存和扩散的，当VPN路由较多时，ASBR负担重，容易成为故障点。因此在MP-EBGP方案中，需要维护VPN路由信息的ASBR一般不再负责公网IP数据转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;optionc&#34;&gt;OptionC&lt;/h2&gt;
&lt;p&gt;PE间&lt;strong&gt;通过Multi-hop MP-EBGP发布标签VPN-IPv4路由&lt;/strong&gt;，也称为Multihop EBGP redistribution of labeled VPN-IPv4&lt;br&gt;
&lt;strong&gt;OptionA和OptionB存在的共同问题&lt;/strong&gt;：&lt;br&gt;
都需要ASBR参与VPN-IPv4路由的维护和发布，当有大量的VPN路由需要交换时，ASBR负担过重，可能成为故障点&lt;br&gt;
&lt;strong&gt;解决上述问题的方案是&lt;/strong&gt;：ASBR不维护或发布VPN-IPv4路由，PE之间直接交换VPN-IPv4路由&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ASBR通过MP-IBGP&lt;strong&gt;向各自AS内的PE设备发布标签IPv4路由&lt;/strong&gt;，并将&lt;strong&gt;到达本AS内PE的标签IPv4路由&lt;/strong&gt;通告给它在&lt;strong&gt;对端AS的ASBR对等体&lt;/strong&gt;，过渡AS中的ASBR也通告带标签的IPv4路由。这样，&lt;strong&gt;在入口PE和出口PE之间建立一条LSP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不同AS的PE之间建立Multihop方式的EBGP连接，交换VPN-IPv4路由&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ASBR上不保存VPN-IPv4路由，相互之间也不通告VPN-IPv4路由&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;方案一&#34;&gt;方案一&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614267464835.png&#34; alt=&#34;方案一&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614267524499.png&#34; alt=&#34;方案一&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-路由传递-3&#34;&gt;1. 路由传递&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614267560841.png&#34; alt=&#34;路由传递&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;配置：
&lt;ol&gt;
&lt;li&gt;各AS内部正常建立IGP邻居关系并且运行MPLS LDP，R3与R4之间运行MPLS即可&lt;/li&gt;
&lt;li&gt;各PE上创建VPN实例，并与接口相绑定&lt;/li&gt;
&lt;li&gt;R2与R3、R4与R5分别建立IBGP IPv4邻居关系&lt;sub&gt;方案二不需要此配置&lt;/sub&gt;，R3与R4之间建立EBGP IPv4邻居关系&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASBR上的重点配置&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;将域内设备（&lt;strong&gt;主要是PE设备&lt;/strong&gt;）的环回口路由引入进BGP，方法是通过前缀列表的方式在BGP中引入域内的IGP路由&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由传递：
&lt;ol&gt;
&lt;li&gt;在R3上&lt;strong&gt;把R2的loopback的32位地址宣告进BGP&lt;/strong&gt;，并为其分配公网标签L9，然后传递给EBGP IPv4邻居R4&lt;/li&gt;
&lt;li&gt;R4收到路由后为该32位loopback地址分配公网标签L10，然后单播传递给IBGP IPv4邻居R5&lt;/li&gt;
&lt;li&gt;同理，R4上宣告R5的loopback地址进BGP，然后传递给R3，之后传递给R2。至此，R2和R5上相互知道对端loopback地址后建立EBGP VPNv4邻居关系&lt;/li&gt;
&lt;li&gt;R1上的IPv4路由传递到R2，R2将其引入VPNv4路由表后，携带私网标签L3、RT、下一跳等单播传递给R5&lt;/li&gt;
&lt;li&gt;R5匹配RT值后，剥离RD和私网标签引入实例2中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-数据转发-3&#34;&gt;2. 数据转发&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614270602164.png&#34; alt=&#34;数据转发&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;R6封装正常IPv4数据包转发给R5，R5收到数据包查实例的FIB，先封装私网标签L3，再封装去往R2的公网标签L10，最后封装去往R4的公网标签Lx，之后转发出去&lt;/li&gt;
&lt;li&gt;R4收到数据包后，根据公网标签L10查找标签转发表，找到对应的出标签公网标签L9，然后封装公网标签L9，转发给R3&lt;/li&gt;
&lt;li&gt;R3收到数据包后，根据公网标签L9查找标签转发表，找到对应的出标签公网标签Ly，然后封装私网标签Ly，之后转发出去&lt;/li&gt;
&lt;li&gt;R2收到数据包后，查找标签转发表，找到对应实例1，剥离私网标签后转发给R1&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;3-特点optionc方案的特点&#34;&gt;3. 特点（OptionC方案的特点）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;VPN路由在入口PE和出口PE之间直接交换，&lt;strong&gt;不需要中间设备的保存和转发&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;VPN的&lt;strong&gt;路由信息只出现在PE设备上&lt;/strong&gt;，而P和ASBR只负责报文的转发，使得中间域的设备可以不支持MPLS VPN业务，只需支持MPLS转发，ASBR设备不再成为性能瓶颈，因此&lt;strong&gt;更适合在跨越多个AS时使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;更适合&lt;strong&gt;支持MPLS VPN的负载分担&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;缺点是&lt;strong&gt;维护一条端到端的PE连接管理代价较大&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;方案二&#34;&gt;方案二&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614271464218.png&#34; alt=&#34;方案二&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;AS内的PE和ASBR之间不再需要建立IBGP邻居&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;1-路由传递-4&#34;&gt;1. 路由传递&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;配置：
&lt;ol&gt;
&lt;li&gt;各AS内部正常建立IGP邻居关系并且运行MPLS LDP，R3与R4之间运行MPLS即可&lt;/li&gt;
&lt;li&gt;各PE上创建VPN实例，并与接口相绑定&lt;/li&gt;
&lt;li&gt;R3与R4之间建立EBGP IPv4邻居关系&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ASBR上的重点配置&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;需要在mpls中配置&lt;code&gt;lsp-trigger bgp-label-route&lt;/code&gt;，为标签数据再分配一层标签&lt;/li&gt;
&lt;li&gt;需要将BGP的路由引入IGP，同时修改IBGP的路由的优先级小于IGP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由传递：
&lt;ol&gt;
&lt;li&gt;在R3上把R2的loopback的32位地址宣告进BGP，并为其分配公网标签L9，然后传递给EBGP IPv4邻居R4&lt;/li&gt;
&lt;li&gt;R4收到路由后&lt;strong&gt;将该32位loopback地址引入进IGP中&lt;/strong&gt;，然后逐跳传递到R5&lt;code&gt;方案二因为AS内没有IBGP邻居关系，所以需要将该路由引入IGP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同理，R4上宣告R5的loopback地址进BGP，然后传递给R3，之后引入到IGP中，然后逐跳传递到R2。至此，R2和R5上相互知道对端loopback地址后建立EBGP VPNv4邻居关系&lt;/li&gt;
&lt;li&gt;R1上的IPv4路由传递到R2，R2将其引入VPNv4路由表后，携带私网标签L3、RT、下一跳等单播传递给R5&lt;/li&gt;
&lt;li&gt;R5匹配RT值后，剥离RD和私网标签引入实例2中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-数据转发和方案一相同&#34;&gt;2. 数据转发（和方案一相同）&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;R6封装正常IPv4数据包转发给R5，R5收到数据包查实例的FIB，先封装私网标签L3，再封装去往R4的下一跳的公网标签Lx，之后转发出去&lt;/li&gt;
&lt;li&gt;R4收到数据包后，根据公网标签L10查找标签转发表，找到对应的出标签公网标签L9，然后封装公网标签L9，直接转发给R3&lt;/li&gt;
&lt;li&gt;R3收到数据包后，根据公网标签L9查找标签转发表，找到对应的出标签公网标签Ly，然后封装私网标签 Y，之后转发出去&lt;/li&gt;
&lt;li&gt;R2收到数据包后，查找标签转发表，找到对应实例 1，剥离私网标签后转发给R1&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;# 草稿备份
## MPLS域内汇总会产生什么问题
### 1. 对MPLS LDP路由进行汇总：标签断裂，可正常访问
4台路由器IGP运行RIP，**互联接口和环回接口**都发布在RIP中，全部运行MPLS，建立LDP邻居。
**汇总点**在AR3上把去往10.4.4.4/32的环回接口汇总为10.4.4.0/24发送给AR2和AR1。
![对MPLS LDP路由进行汇总](https://fqj-web.github.io/post-images/1614164171707.png)
R4给10.4.4.4这条FEC分发3号标签给R3，R3收到给R2分发1024的标签。R2收10.4.4.4/32到后，因为其路由表中只有10.4.4.0/24这条路由，没有10.4.4.4/32这条路由，**所以会闲置此标签（1024）**，并不会继续给R1分标签。导致R1到R3之间**只能正常IP包转发**，R3收到后会查标签转发表。
**解决方法**：
R3上为10.4.4.0/24指静态路由，指向null 0，且使用`lsp-trigger all`。R3会开始为10.4.4.0/24这条路由分发标签，且R2会继续为10.4.4.0/24给R1分发标签。**R1去访问10.4.4.4/32会匹配到 10.4.4.0/24这条路由，然后进行标签转发**，**到达R3之后匹配到10.4.4.4/32这条路由，先查FIB，再查LFIB表**，形成**标签断裂**

&amp;gt; `lsp-trigger`命令和`lsp-trigger bgp-label-route`命令都用于配置LDP LSP的触发建立策略，前者适用于静态路由和IGP路由；后者仅适用于带标签的公网BGP路由
&amp;gt; **不推荐配置lsp-trigger all命令**，因为配置该命令后，**所有IGP路由会触发LDP建立LSP，导致LSP数量庞大**，占用过多的系统资源。如果需要配置该命令，可以先配置路由过滤策略，减少路由数量，从而减少路由触发LDP建立的LSP的数量，节约系统资源

### 2. 对BGP路由的下一跳进行汇总：LSP断裂，形成黑洞
在AS20中，AR1和AR4建立BGP邻居，AR2和AR3不运行BGP。
AR5、AR6的环回口地址发布在BGP中，分别传入AS20中，要求AR5和AR6的环回口地址互访
![对BGP路由的下一跳进行汇总](https://fqj-web.github.io/post-images/1614165428913.png)
首先在AR1和AR4上使用`route recursive-lookup tunnel`使能隧道迭代功能，非标签公网BGP路由或者静态路由将优先迭代到LSP隧道，如果没有LSP隧道，上述路由也可以迭代到出接口和下一跳。
1. 在没有汇总的情况下，在AR5上以自身的环回口地址为源ping AR6的环回口可以ping通，**数据包可以通过标签交换穿过AR2和AR3的BGP路由黑洞**
2. 在AR3上路由汇总后（汇总10.4.4.4/32为10.4.4.0/24），上述访问不通，故障原因：
    1. 由于在AR1上对应下一跳10.4.4.4的LSP，所以AR1发给AR2的数据包不带标签，AR2收到数据包后目的地没有对应路由(无BGP路由)，数据包丢弃
    2. 在AR3上做静态路由10.4.4.0/24指向null0后，AR1发出的数据帧携带标签，**在AR3上收到标签为R2发出的带1035的数据帧后，先执行标签弹出，后查找数据包目的IP不可达(无BGP路由)**，数据包被丢弃
3. 对MPLS/VPN的路由下一跳进行汇总，会造成路由不进VPN实例的路由表。
    1. 当PE收到一条VPNv4的路由，**首先需要查看下一跳是否存在对应的LSP**，如果不存在则直接不装进VPN实例的路由表中，所以在汇总后的情况下，PE的实例路由表下无对方的路由。
    2. 如果在汇总点添加一条汇总后的静态路由指向null0，结果还是不装入VPN实例下的路由表，因为 **PE只信任关于下一跳的32位路由的LSP**，汇总后是关于24位路由的LSP，所以还是不装表
&lt;/code&gt;&lt;/pre&gt;
">MPLS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/ipv6/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#ipv6%E5%9C%B0%E5%9D%80%E5%9F%BA%E7%A1%80&#34;&gt;IPv6地址基础&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E7%82%B9&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%93%E6%9E%84&#34;&gt;结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E7%A4%BA%E6%96%B9%E6%B3%95&#34;&gt;表示方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB&#34;&gt;地址分类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80&#34;&gt;1. 单播地址&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E5%8F%AF%E8%81%9A%E5%90%88%E5%85%A8%E7%90%83%E5%8D%95%E6%92%AD%E5%9C%B0%E5%9D%80%E5%B8%B8%E8%A7%8120003&#34;&gt;1.1 可聚合全球单播地址（常见2000::/3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E9%93%BE%E8%B7%AF%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80fe8010&#34;&gt;1.2 链路本地地址（FE80::/10）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%8F%A3%E6%A0%87%E8%AF%86%E7%94%9F%E6%88%90%E6%96%B9%E6%B3%95&#34;&gt;接口标识生成方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E5%94%AF%E4%B8%80%E6%9C%AC%E5%9C%B0%E5%9C%B0%E5%9D%80fc007&#34;&gt;1.3 唯一本地地址（FC00::/7）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80%E5%B8%B8%E8%A7%81ff018%E5%92%8Cff028&#34;&gt;2. 组播地址（常见FF01::/8和FF02::/8）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80%E7%9A%84mac%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84&#34;&gt;组播地址的MAC地址映射&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%B7%E6%B1%82%E8%8A%82%E7%82%B9%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80solicited-node&#34;&gt;请求节点组播地址（Solicited-Node）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E4%BB%BB%E6%92%AD%E5%9C%B0%E5%9D%80&#34;&gt;3. 任播地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%86%85%E5%B5%8Cipv4%E5%9C%B0%E5%9D%80%E7%9A%84ipv6%E5%9C%B0%E5%9D%80&#34;&gt;4. 内嵌IPv4地址的IPv6地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%B0%E5%9D%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95&#34;&gt;地址配置方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%89%8B%E5%8A%A8%E9%85%8D%E7%BD%AE&#34;&gt;1. 手动配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%97%A0%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D&#34;&gt;2. 无状态自动地址分配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E6%9C%89%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D&#34;&gt;3. 有状态自动地址分配&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8&#34;&gt;报文头部&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%8A%A5%E5%A4%B4&#34;&gt;基本报头&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%A9%E5%B1%95%E6%8A%A5%E5%A4%B4&#34;&gt;扩展报头&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%A9%E5%B1%95%E6%8A%A5%E5%A4%B4%E7%A7%8D%E7%B1%BB&#34;&gt;扩展报头种类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%A9%E5%B1%95%E6%8A%A5%E5%A4%B4%E8%A7%84%E7%BA%A6&#34;&gt;扩展报头规约&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv6%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80&#34;&gt;IPv6协议基础&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#icmpv6&#34;&gt;ICMPv6&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%9F%E8%83%BD&#34;&gt;功能&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%BD%BF%E7%94%A8rsra133134&#34;&gt;1. 使用RS/RA（133/134）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%B7%AF%E7%94%B1%E5%99%A8%E5%8F%91%E7%8E%B0&#34;&gt;1. 路由器发现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%BD%BF%E7%94%A8nsna135136&#34;&gt;2. 使用NS/NA（135/136）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%87%8D%E5%A4%8D%E5%9C%B0%E5%9D%80%E6%A3%80%E6%B5%8Bdad&#34;&gt;1. 重复地址检测DAD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%9C%B0%E5%9D%80%E8%A7%A3%E6%9E%90%E5%8D%B3%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0&#34;&gt;2. 地址解析（即邻居发现）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E8%B7%9F%E8%B8%AA%E9%82%BB%E5%B1%85%E7%8A%B6%E6%80%81&#34;&gt;3. 跟踪邻居状态&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E4%BD%BF%E7%94%A8%E9%87%8D%E5%AE%9A%E5%90%91137&#34;&gt;3. 使用重定向（137）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%87%8D%E5%AE%9A%E5%90%91&#34;&gt;1. 重定向&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv6%E8%BF%87%E6%B8%A1%E6%8A%80%E6%9C%AF&#34;&gt;IPv6过渡技术&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8C%E6%A0%88%E5%8D%8F%E8%AE%AE&#34;&gt;双栈协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv6-over-ipv4%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF&#34;&gt;IPv6 over IPv4隧道技术&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-6over4%E6%89%8B%E5%8A%A8%E9%9A%A7%E9%81%93%E8%BF%87%E6%B8%A1%E5%88%9D%E6%9C%9F%E4%BD%BF%E7%94%A8&#34;&gt;1. 6over4手动隧道（过渡初期使用）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-4over6%E6%89%8B%E5%8A%A8%E9%9A%A7%E9%81%93%E8%BF%87%E6%B8%A1%E5%90%8E%E6%9C%9F%E4%BD%BF%E7%94%A8&#34;&gt;2. 4over6手动隧道（过渡后期使用）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-gre%E6%89%8B%E5%8A%A8%E9%9A%A7%E9%81%93&#34;&gt;3. GRE手动隧道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-ipv4%E5%85%BC%E5%AE%B9ipv6%E7%9B%AE%E5%89%8D%E5%B7%B2%E7%BB%8F%E8%A2%AB6to4%E9%9A%A7%E9%81%93%E6%89%80%E5%8F%96%E4%BB%A3&#34;&gt;4. IPv4兼容IPv6（目前已经被6to4隧道所取代）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-6to4%E9%9A%A7%E9%81%93&#34;&gt;5. 6to4隧道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-isatap%E9%9A%A7%E9%81%93&#34;&gt;6. ISATAP隧道&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-nat64&#34;&gt;7. NAT64&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pmtu%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B&#34;&gt;PMTU的工作过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%A4%E5%8F%B0-ipv6-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E4%BA%92%E8%AE%BF%E8%BF%87%E7%A8%8B&#34;&gt;两台 ipv6 客户端的互访过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv4%E4%B8%8Eipv6-qos%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;IPv4与IPV6 qos的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv6%E5%AF%B9%E7%A7%BB%E5%8A%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E6%94%AF%E6%8C%81%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E6%89%A9%E5%B1%95%E6%8A%A5%E5%A4%B4&#34;&gt;ipv6对移动技术的支持用到了哪些扩展报头&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A7%BB%E5%8A%A8%E6%8A%80%E6%9C%AF&#34;&gt;移动技术&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%BA%A7%E7%94%9F%E8%83%8C%E6%99%AF&#34;&gt;1. 产生背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%8A%80%E6%9C%AF%E5%AE%9A%E4%B9%89&#34;&gt;2. 技术定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E7%A7%BB%E5%8A%A8%E6%9C%BA%E5%88%B6&#34;&gt;3. 移动机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-ipv6%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%AA%E6%96%BD&#34;&gt;4. ipv6解决移动问题的措施&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;ipv6地址基础&#34;&gt;IPv6地址基础&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;地址空间巨大&lt;/li&gt;
&lt;li&gt;精简报文结构&lt;/li&gt;
&lt;li&gt;实现自动配置和重新编址&lt;/li&gt;
&lt;li&gt;支持层次化网络结构&lt;/li&gt;
&lt;li&gt;支持端对端安全&lt;/li&gt;
&lt;li&gt;更好的支持QoS&lt;/li&gt;
&lt;li&gt;支持移动特性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IPv6地址分两部分
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;网络前缀&lt;/strong&gt;，n比特，相当于IPv4中的&lt;strong&gt;网络ID&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接口标识&lt;/strong&gt;，128-n比特相当于IPv4中的&lt;strong&gt;主机ID&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;表示方法&#34;&gt;表示方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IPv6地址包括128比特，由冒号分割成8段，每段4个16进制数，例如：2031:0000:130F:0000:0000:09C0:876A:130B&lt;/li&gt;
&lt;li&gt;IPv6压缩格式
&lt;ul&gt;
&lt;li&gt;每组中的前导“0”都可以省略，例如：2031:0:130F:0:0:9C0:876A:130B&lt;/li&gt;
&lt;li&gt;地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替（&lt;strong&gt;一个地址中仅能使用一次&lt;/strong&gt;），例如：2031:0:130F::9C0:876A:130B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;地址分类&#34;&gt;地址分类&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590421077406.png&#34; alt=&#34; IPv6地址分类&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;组播 FF00::/8&lt;/li&gt;
&lt;li&gt;任播地址与单播地址使用同一个地址空间&lt;/li&gt;
&lt;li&gt;未指定地址只能作为源地址使用，并不能被路由器转发&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-单播地址&#34;&gt;1. 单播地址&lt;/h3&gt;
&lt;p&gt;在IPv6中，一个接口拥有多个IPv6地址是非常常见的现象。&lt;br&gt;
&lt;code&gt;对于IPv6单播地址来说，如果地址的前3比特不是000，则接口标识必须为64位；如果地址的前3位是000，则没有此限制&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;11-可聚合全球单播地址常见20003&#34;&gt;1.1 可聚合全球单播地址（常见2000::/3）&lt;/h4&gt;
&lt;p&gt;全球单播地址定义用于IPv6 Internet，是全局唯一的和全局可路由的&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590501843637.png&#34; alt=&#34;可聚合全球单播地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似IPv4的公网地址&lt;/li&gt;
&lt;li&gt;由前缀、子网ID和接口标识组成
&lt;ul&gt;
&lt;li&gt;全局路由前缀：由提供商指定给一个组织机构，一般&lt;strong&gt;至少为48bit&lt;/strong&gt;。目前已经分配的&lt;strong&gt;全局路由前缀的前3bit均为001&lt;/strong&gt;，&lt;strong&gt;因此前缀为2000::/3&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;子网：组织机构可以用子网ID来构建本地网络，与IPv4中的子网号作用相似，子网ID通常&lt;strong&gt;最多分配到第64位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;主机位：用来标识一个设备，与IPv4中的主机ID作用相似&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;12-链路本地地址fe8010&#34;&gt;1.2 链路本地地址（FE80::/10）&lt;/h4&gt;
&lt;p&gt;在一个节点启动IPv6协议栈时，节点的每个接口会自动配置一个链路本地地址，该地址专门用来和相同链路上的其他主机通信&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590502600240.png&#34; alt=&#34;链路本地地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能在连接到同一个本地链路的节点之间使用，广泛应用于&lt;strong&gt;邻居发现、无状态地址&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;链路本地地址前缀FE80::/10，将接口ID添加在后面作为地址的低64位&lt;/li&gt;
&lt;li&gt;每个IPv6接口都必须具备一个链路本地地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;接口标识生成方法&#34;&gt;接口标识生成方法&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;手工配置&lt;/li&gt;
&lt;li&gt;系统通过软件自动生成&lt;/li&gt;
&lt;li&gt;IEEE EUI-64规范自动生成（依据MAC地址生成）
&lt;ol&gt;
&lt;li&gt;将MAC地址中间插入FFFE，例如：00e0-fc4c-5103转换成00e0-fc&lt;strong&gt;ff-fe&lt;/strong&gt;4c-5103&lt;/li&gt;
&lt;li&gt;将&lt;strong&gt;第七位由0变为1，表示该接口标识是全球唯一&lt;/strong&gt;&lt;code&gt;因为Mac地址的第7为0表示全球唯一，1代表本地唯一，这和IPv6相反&lt;/code&gt;，例如&lt;br&gt;
00e0-fcff-fe4c-5103&lt;br&gt;
-----&amp;gt; 00000000-e0-fcff-fe4c-5103&lt;br&gt;
-----&amp;gt; 000000&lt;strong&gt;1&lt;/strong&gt;0-e0-fcff-fe4c-5103&lt;br&gt;
-----&amp;gt; 02e0:fcff:fe4c:5103&lt;br&gt;
-----&amp;gt; &lt;code&gt;FE80::&lt;/code&gt;2E0:FCFF:FE4C:5103（对应的MAC为00e0-fc4c-5103）&lt;/li&gt;
&lt;li&gt;如果接口未配置MAC地址，则接口EUI-64格式地址采用下述规则生成：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;三层物理口及其子接口&lt;/strong&gt;的EUI-64格式地址根据物理口的MAC地址生成，中间填充&lt;strong&gt;接口索引的后两个字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于&lt;strong&gt;LoopBack接口、Tunnel接口&lt;/strong&gt;，EUI-64格式地址根据接口MAC地址生成，中间填充&lt;strong&gt;接口索引的后两个字节&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;对于&lt;strong&gt;Eth-Trunk接口及其子接口、VLANIF接口&lt;/strong&gt;，EUI-64格式地址根据接口MAC地址生成，&lt;strong&gt;中间填充FFFE&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;13-唯一本地地址fc007&#34;&gt;1.3 唯一本地地址（FC00::/7）&lt;/h4&gt;
&lt;p&gt;为了代替站点本地地址的功能，同时为了这样的地址具有唯一性，避免产生像IPv4的私有地址泄露到公网而造成的问题，RFC4193定义了唯一本地地址&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590503134885.png&#34; alt=&#34;唯一本地地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;L：1=在本地网络范围内使用，0=被保留（用于以后扩展）&lt;/li&gt;
&lt;li&gt;Global ID：全球唯一前缀，通过伪随机产生&lt;/li&gt;
&lt;li&gt;Subnet ID：子网ID，用于划分子网&lt;/li&gt;
&lt;li&gt;概念上类似于IPv4的私网地址，仅能够在本地网络使用，在IPv6 Internet上不可被路由&lt;/li&gt;
&lt;li&gt;固定前缀为FC00::/7，分为两块，其中FC00::/8暂未定义，另一块是FD00::/8，其格式如上图&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-组播地址常见ff018和ff028&#34;&gt;2. 组播地址（常见FF01::/8和FF02::/8）&lt;/h3&gt;
&lt;p&gt;标识多个接口，目的地址为组播地址的报文会被送到被标识的所有接口。只有加入相应组播组的设备接口才会侦听发往该组播地址的报文。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590504106960.png&#34; alt=&#34; 组播地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似IPv4组播地址&lt;/li&gt;
&lt;li&gt;由前缀、标志（flag）字段、范围(scope)字段和组播组ID组成
&lt;ul&gt;
&lt;li&gt;Flags：表示临时或者永久
&lt;ul&gt;
&lt;li&gt;前3位设为0&lt;/li&gt;
&lt;li&gt;最后一位定义地址类型
&lt;ul&gt;
&lt;li&gt;0=永久组播地址&lt;/li&gt;
&lt;li&gt;1=临时组播地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scope：表示组播组的范围
&lt;ul&gt;
&lt;li&gt;此字段长度为4位，除了使用组播路由协议提供信息外，路由器还要使用组播范围段来判定组播流量能否发送出去&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590504746433.png&#34; alt=&#34;Scope&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Group ID：组播组ID
&lt;ul&gt;
&lt;li&gt;用于标识组播组，这个值在地址范围内是唯一的，此字段的长度为112位。其中，永久分配的组ID不收当前范围的限制，而临时组ID只能在某个特定的范围内有意义。而FF01::到FF0F::的组播地址数据保留地址段，而且也是永久组播地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预定义组播地址
&lt;ul&gt;
&lt;li&gt;Node-local（节点本地范围）
&lt;ul&gt;
&lt;li&gt;所有节点的组播地址：&lt;code&gt;FF01::1（类似224.0.0.1）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有路由器的组播地址：&lt;code&gt;FF01::2（类似224.0.0.2）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Link-local（链路本地范围）
&lt;ul&gt;
&lt;li&gt;所有节点的组播地址：&lt;code&gt;FF02::1（类似224.0.0.1）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有路由器的组播地址：&lt;code&gt;FF02::2 （类似224.0.0.2）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有OSPF路由器组播地址：&lt;code&gt;FF02::5（类似224.0.0.5）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有OSPF的DR路由器组播地址：&lt;code&gt;FF02::6（类似224.0.0.6）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有RIP路由器组播地址：&lt;code&gt;FF02::9（类似224.0.0.9）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;所有PIM路由器组播地址：&lt;code&gt;FF02::D（类似224.0.0.13）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Solicited-Node组播地址：&lt;code&gt;FF02::1:FFXX:XXXX/104&lt;/code&gt;，请求节点组播地址，类似ARP（x通过映射MAC地址后24位得到，也是链路本地地址的后24位，如果是手动配置的IPv6地址，则x为手动配置地址的后24位）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;站点本地范围
&lt;ul&gt;
&lt;li&gt;所有路由器：&lt;code&gt;FF05::2（类似224.0.0.2）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全局
&lt;ul&gt;
&lt;li&gt;NTP协议：&lt;code&gt;FF0x::101（类似224.0.1.1）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;组播地址的mac地址映射&#34;&gt;组播地址的MAC地址映射&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590505247365.png&#34; alt=&#34;组播地址的MAC地址映射&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;组播IPv6报文的目的IP地址是组播IPv6地址，而目的mac地址则必须是组播mac地址，并且该地址必须与组播IPv6地址对应&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;33-33&lt;/strong&gt;是专门为IPv6组播预留的mac地址前缀，&lt;strong&gt;mac地址的后32bit从对应的组播IPv6地址的后32bit&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;请求节点组播地址solicited-node&#34;&gt;请求节点组播地址（Solicited-Node）&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590505839548.png&#34; alt=&#34;请求节点组播地址&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;IPv6中特有的组播地址
&lt;ul&gt;
&lt;li&gt;每个节点必须为分配给他的每个单播和任播地址加入一个组播地址，用于DAD地址重复检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Solicited-Node组播地址生成过程
&lt;ul&gt;
&lt;li&gt;接口ID(接口IPv6地址)的后24位：xx:xxxx&lt;/li&gt;
&lt;li&gt;前缀：FF02:0:0:0:0:1:FF，例如主机的mac为00-02-b3-&lt;strong&gt;1e-83-29&lt;/strong&gt;，则自动生成的IPv6地址为fe80::0202:b3ff:fe&lt;strong&gt;1e:8329&lt;/strong&gt;，那么请求节点组播地址为ff02::1:ff&lt;strong&gt;1e:8329&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-任播地址&#34;&gt;3. 任播地址&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;作用：为多个主机或节点提供相同的服务的同时，提供冗余和负载分担的功能。目前主要用于移动IPv6，在6to4中继中也使用任播前缀2002:c058:6301::&lt;/li&gt;
&lt;li&gt;任播地址和单播地址使用相同的地址空间&lt;/li&gt;
&lt;li&gt;同一单播地址被分配给多个接口（通常属于不同的节点），仅用于路由器，&lt;strong&gt;不能应用于主机，不能做为IPv6报文的源地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;配置时需明确表示任播地址，用来区别单播和任播&lt;code&gt;ipv6 address 2001:12:1::1/64 anycast&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;发往任播地址的数据包，被路由转发给，分配了任播地址的接口中，距离最近的一个&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-内嵌ipv4地址的ipv6地址&#34;&gt;4. 内嵌IPv4地址的IPv6地址&lt;/h3&gt;
&lt;p&gt;用于与传统网络之间的互联互通，以使IPv4网络和IPv6网络之间能够进行无缝通信，这里使用的是IPv4地址必须是全球唯一的IPv4单播地址&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IPv4兼容的IPv6地址&lt;br&gt;
::ipv4地址/96，例如::1.2.3.4/96&lt;/li&gt;
&lt;li&gt;IPv4映射的IPv6地址&lt;br&gt;
::FFFF:ipv4地址/80，例如::FFFF:1.2.3.4/80&lt;/li&gt;
&lt;li&gt;6to4专用地址，6to4地址可以表示为&lt;code&gt;2002::/16&lt;/code&gt;，而一个6to4网络可以表示为&lt;code&gt;2002:IPv4地址::/48&lt;/code&gt;（属于&lt;strong&gt;全球单播地址&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;地址配置方法&#34;&gt;地址配置方法&lt;/h2&gt;
&lt;h3 id=&#34;1-手动配置&#34;&gt;1. 手动配置&lt;/h3&gt;
&lt;p&gt;手动配置IPv6地址/前缀及其他网络配置参数（DNS、NIS、SNTP服务器地址等参数）&lt;/p&gt;
&lt;h3 id=&#34;2-无状态自动地址分配&#34;&gt;2. 无状态自动地址分配&lt;/h3&gt;
&lt;p&gt;由接口ID生成链路本地地址，再根据路由通告报文RA包含的前缀信息自动配置本机地址。&lt;/p&gt;
&lt;h3 id=&#34;3-有状态自动地址分配&#34;&gt;3. 有状态自动地址分配&lt;/h3&gt;
&lt;p&gt;即DHCPv6方式。DHCPv6又分为如下两种:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DHCPv6有状态自动分配&lt;br&gt;
DHCPv6服务器自动分配IPv6地址/RD前缀及其他网络配置参数（DNS、NIS、SNTP服务器地址等参数）&lt;/li&gt;
&lt;li&gt;DHCPv6无状态自动分配&lt;br&gt;
主机IPv6地址仍然通过路由通告方式自动生成，&lt;strong&gt;DHCPv6服务器只分配除IPv6地址以外的配置参数&lt;/strong&gt;，包括DNS、NIS、SNTP服务器等参数，过程如下：
&lt;ol&gt;
&lt;li&gt;根据接口标识产生链路本地地址（EUI-64）&lt;/li&gt;
&lt;li&gt;发出邻居请求，进行重复地址检测
&lt;ol&gt;
&lt;li&gt;如地址冲突，则停止自动配置，需要手工配置&lt;/li&gt;
&lt;li&gt;如不冲突，链路本地地址生效，节点具备本地链路通信能力
&lt;ol&gt;
&lt;li&gt;主机会发送RS报文（或接收到设备定期发送的RA报文, 最大间隔600秒，最小间隔200秒）&lt;/li&gt;
&lt;li&gt;根据RA报文中的前缀信息和接口标识得到IPv6地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;报文头部&#34;&gt;报文头部&lt;/h2&gt;
&lt;h3 id=&#34;基本报头&#34;&gt;基本报头&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590509355658.png&#34; alt=&#34;基本报头&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;固定40字节&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version：该值为6&lt;/li&gt;
&lt;li&gt;Traffic Class：流类别，等同于IPv4中的TOS字段，表示IPv6数据报的类或优先级，主要应用于QoS&lt;/li&gt;
&lt;li&gt;Flow Label：流标签，IPv6中的新增字段，&lt;strong&gt;用于区分实时流量，不同的流标签+源地址可以唯一确定一条数据流&lt;/strong&gt;&lt;code&gt;IPv4中通过五元组标识一条数据流&lt;/code&gt;，中间网络设备可以根据这些信息更加高效率的区分数据流&lt;/li&gt;
&lt;li&gt;Payload Length：有效载荷长度，指紧跟IPv6报头的数据报的其它部分（即扩展报头和上层协议数据单元）&lt;/li&gt;
&lt;li&gt;Next Header：下一个报头，紧跟在IPv6报头后面的第一个扩展报头（如果存在）的类型，或者上层协议数据单元中的协议类型&lt;/li&gt;
&lt;li&gt;Hop Limit：跳数限制，类似于IPv4中的Time to Live字段，IPv6数据报文所能经过的最跳数&lt;br&gt;
&lt;code&gt;IPv6和IPv4相比，去除了IHL、Identification、Flags、Fragment Offset、Header Checksum、Options、Padding域，只增了流标签域，因此IPv6报文头的处理较IPv4大大简化，提高了处理效率。另外，IPv6为了更好支持各种选项处理，提出了扩展头的概念，新增选项时不必修改现有结构就能做到，扩展性和灵活性更高&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IPv6中没有校验值(Header Checksum)的原因？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果上层承载的是TCP或者UDP，会存在一个伪头部，可以用来校验IPv6&lt;/li&gt;
&lt;li&gt;IPv6可以携带AH扩展头部（即认证扩展报头）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;扩展报头&#34;&gt;扩展报头&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590509989601.png&#34; alt=&#34;扩展报头&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
扩展报头是可选的，只有需要该扩展报头对应的功能时，数据的发送者才会添加相应的扩展报头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将原IPv4选项字段放入扩展报头&lt;/li&gt;
&lt;li&gt;IPv6报文包含0、1或者多个扩展报头&lt;/li&gt;
&lt;li&gt;固定为8字节长度的整数倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;扩展报头种类&#34;&gt;扩展报头种类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;逐跳选项扩展报头0&lt;br&gt;
该选项主要用于为在传送路径上的&lt;strong&gt;每跳转发指定发送参数&lt;/strong&gt;，传送路径上的每台中间节点都要读取并处理该字段。逐跳选项报头目前的主要应用有以下三种：
&lt;ol&gt;
&lt;li&gt;用于巨型载荷（载荷长度超过65535字节）&lt;/li&gt;
&lt;li&gt;用于路由器提示，使路由器检查该选项的信息，而不是简单的转发出去&lt;/li&gt;
&lt;li&gt;用于资源预留（RSVP，主要用于MPLS-TE）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;目的选项扩展报头60&lt;br&gt;
目的选项报头携带了一些&lt;strong&gt;只有目的节点才会处理的信息&lt;/strong&gt;。目前， 目的选项报文头主要应用于&lt;strong&gt;移动IPv6&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;路由扩展报头43&lt;br&gt;
路由报头和IPv4的Loose Source and Record Route选项类似，该报头能够被IPv6源节点用来&lt;strong&gt;强制数据包经过特定的路由器&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;分片扩展报头44&lt;br&gt;
同IPv4一样，IPv6报文发送也受到MTU的限制，当报文长度超过MTU时就需要将报文分段发送，而在IPv6中，分段发送使用的是分段报头&lt;code&gt;使用PMTUD（路径MTU发现）检测转发路径上MTU的最小值。ipv4中想使用此机制，需要将DF位置1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;认证扩展报头51（AH）&lt;br&gt;
该报头由IPsec使用，提供认证、&lt;strong&gt;数据完整性以及重放保护&lt;/strong&gt;，还对IPv6基本报头中的一些字段进行保护&lt;/li&gt;
&lt;li&gt;封装安全有效载荷扩展报头50（ESP）&lt;br&gt;
该报头由IPsec使用，提供认证、数据完整性以及重放保护和IPv6报文的加密，类似于认证报头&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;扩展报头规约&#34;&gt;扩展报头规约&lt;/h4&gt;
&lt;p&gt;当超过一种扩展报头被用在同一个分组里时，报头必须按照下列顺序出现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IPv6基本报头&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逐跳&lt;/strong&gt;选项扩展报头0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;选项扩展报头60&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由&lt;/strong&gt;扩展报头43&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分段&lt;/strong&gt;扩展报头44&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;认证&lt;/strong&gt;扩展报头51&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;封装安全有效载荷&lt;/strong&gt;扩展报头50&lt;/li&gt;
&lt;li&gt;目的选项扩展报头（第2次出现，指哪些被分组报文的最终目的地处理的选项）&lt;/li&gt;
&lt;li&gt;上层协议数据报文&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;路由设备转发时&lt;strong&gt;根据基本报头中的NextHeader值来决定是否要处理扩展头&lt;/strong&gt;，并不是所有的扩展报头都需要被转发路由设备查看和处理的。&lt;br&gt;
&lt;strong&gt;除了目的选项扩展报头可能出现一次或者两次&lt;/strong&gt;（一次在路由扩展报头之前，一次在上层协议数据报文之前），&lt;strong&gt;其余扩展报头只能出现一次&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;ipv6协议基础&#34;&gt;IPv6协议基础&lt;/h1&gt;
&lt;h2 id=&#34;icmpv6&#34;&gt;ICMPv6&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;58（0x3A），即下一个扩展头为58，TCP为6，UDP为17&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;5大功能&lt;/strong&gt;：地址解析、跟踪邻居状态、重复地址检测、路由器发现、重定向&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590591063496.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
报文分类如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;差错报文：8bits类型字段中的最高bit为0，即type=[0,127]
&lt;ol&gt;
&lt;li&gt;type1：目标不可达
&lt;ol&gt;
&lt;li&gt;code0：没有到达目标的路由&lt;/li&gt;
&lt;li&gt;code1：与目标的通信被管理策略禁止&lt;/li&gt;
&lt;li&gt;code2：未指定&lt;/li&gt;
&lt;li&gt;code3：地址不可达&lt;/li&gt;
&lt;li&gt;code4：端口不可达&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;type2：数据包过长
&lt;ol&gt;
&lt;li&gt;只有code0&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;type3：超时
&lt;ol&gt;
&lt;li&gt;code0：在传输中超越了跳数限制&lt;/li&gt;
&lt;li&gt;code1：分片重组超时&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;type4：参数问题
&lt;ol&gt;
&lt;li&gt;code0：遇到错误的报头字段&lt;/li&gt;
&lt;li&gt;code1：遇到无法识别的下一个报头类型&lt;/li&gt;
&lt;li&gt;code2：遇到无法识别的IPv6选项&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;信息报文：8bits类型字段中的最高bit为1，即type=[128,255]&lt;br&gt;
&lt;code&gt;以下报文的code值均为0&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;type128（回显请求报文）和type129（回显应答报文）&lt;/li&gt;
&lt;li&gt;邻居发现NDP
&lt;ol&gt;
&lt;li&gt;type133（路由器请求，RS消息）和type134（路由器公告，RA消息）
&lt;ol&gt;
&lt;li&gt;RS消息：&lt;br&gt;
当主机&lt;strong&gt;刚刚接入网络并被配置为自动获取地址&lt;/strong&gt;发送&lt;br&gt;
源地址为接口的Link Local地址或者未指定地址、目的地址为所有路由器的组播地址（FF02::2） 、数据字段为空、跳数限制255、Code为0、option为自身的mac地址&lt;br&gt;
路由器收到RS消息后立刻回送RA消息给主机，在RA消息中有主机想要的单播地址的前缀及前缀长度等信息&lt;/li&gt;
&lt;li&gt;RA消息：&lt;br&gt;
路由器&lt;strong&gt;周期性（最小200秒，最大600秒）地发送&lt;/strong&gt;RA消息，或者在&lt;strong&gt;收到主机发送的RS消息&lt;/strong&gt;后立刻发送&lt;br&gt;
源地址为接口的Link Local地址，目的地址是&lt;code&gt;FF02::1&lt;/code&gt;或者为收到的RS消息中的源地址，数据包含路由器的MAC地址、MTU值、前缀信息（包含前缀有效时间&lt;code&gt;默认7天&lt;/code&gt;和无效时间&lt;code&gt;默认30天&lt;/code&gt;）、标志位等&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;type135（邻居请求，NS消息）和type136（邻居通告，NA消息）&lt;code&gt;涉及功能有地址解析、跟踪邻居状态和重复地址检测&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;NS消息：
&lt;ol&gt;
&lt;li&gt;地址解析：源地址为自身IPv6地址、目的地址为邻居的请求节点组播地址、数据为自身的MAC地址&lt;/li&gt;
&lt;li&gt;跟踪邻居状态：和地址解析相同，都是ping&lt;/li&gt;
&lt;li&gt;重复地址检测：源地址为未指定地址、目的地址为自身的请求节点组播地址、数据为试验地址（即刚配置的地址）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;NA消息：
&lt;ol&gt;
&lt;li&gt;地址解析：源地址为自身IPv6地址、目的地址为邻居IPv6地址、数据为自身的MAC地址&lt;/li&gt;
&lt;li&gt;跟踪邻居状态：和地址解析相同，都是ping&lt;/li&gt;
&lt;li&gt;重复地址检测：如果冲突则回复，源地址为自身地址、目的地址为所有节点的组播地址（FF02::1）、数据为试验地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;type137（重定向信息）&lt;br&gt;
假设主机A访问主机B：源地址为发送重定向报文的路由器接口地址、目的地址为需要重定向主机A的地址、数据中包含重定向之后的路由器接口地址和主机B的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;多播侦听发现协议MLD&lt;code&gt;=IPv4中的IGMP&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;type130：多播听众查询&lt;/li&gt;
&lt;li&gt;type131：多播听众报告&lt;/li&gt;
&lt;li&gt;type132：多播听众退出&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;功能&#34;&gt;功能&lt;/h3&gt;
&lt;h4 id=&#34;1-使用rsra133134&#34;&gt;1. 使用RS/RA（133/134）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;只有路由器发现&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;1-路由器发现&#34;&gt;1. 路由器发现&lt;/h5&gt;
&lt;p&gt;路由器发现功能是IPv6&lt;strong&gt;地址自动配置功能的基础&lt;/strong&gt;，使用&lt;strong&gt;路由器请求RS133和路由器通告RA134&lt;/strong&gt;实现&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613640339316.png&#34; alt=&#34;路由器发现&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主机对收到的RA报文进行&lt;strong&gt;正确性检查&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IP源地址是link local地址&lt;/li&gt;
&lt;li&gt;Hop Limit（即跳数限制）为255&lt;code&gt;即没有被转发过&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果有认证，则认证需要正确&lt;/li&gt;
&lt;li&gt;ICMP头部的Code为0，校验值有效，且长度至少16字节&lt;/li&gt;
&lt;li&gt;options长度大于0&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RA报文中&lt;strong&gt;标志位&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;M：0表示无状态自动配置生成IPv6地址，1表示需要通过有状态（DHCPv6）方式获取ipv6地址&lt;/li&gt;
&lt;li&gt;O：0表示&lt;strong&gt;除地址以外的其他参数&lt;/strong&gt;需要通过无状态自动配置获取，1表示其它参数需要通过有状态方式进行获取&lt;/li&gt;
&lt;li&gt;Prf：默认路由器优先级，00中（默认）、11低&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-使用nsna135136&#34;&gt;2. 使用NS/NA（135/136）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;重复地址检测DAD、邻居发现、邻居状态跟踪&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;1-重复地址检测dad&#34;&gt;1. 重复地址检测DAD&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;接口使用某个IPv6单播地址之前进行的，主要是为了探测是否有其它的节点使用了该地址，尤其是在地址自动配置的时候&lt;/li&gt;
&lt;li&gt;一个IPv6单播地址在分配给一个接口之后且通过重复地址检测之前称为&lt;strong&gt;试验地址&lt;/strong&gt;，此时该接口不能使用这个试验地址进行单播通信，但是仍然会加入两个组播组：ALL-NODES组播组和试验地址所对应的Solicited-Node组播组&lt;/li&gt;
&lt;li&gt;IPv6重复地址检测技术和IPv4中的免费ARP类似：节点向试验地址所对应的Solicited-Node组播组发送NS报文，NS报文中目标地址即为该试验地址，如果收到某个其他站点回应的NA报文，就证明该地址已被网络上使用&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613636973822.png&#34; alt=&#34;重复地址检测&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;A的IPv6地址FC00::1为新配置地址，即FC00::1为Host A的&lt;strong&gt;试验地址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;A向FC00::1的Solicited-Node组播组发送一个NS报文（&lt;strong&gt;源地址为未指定地址，目标地址为FF02::1:FF00:1，试验地址放在data中&lt;/strong&gt;）进行重复地址检测&lt;/li&gt;
&lt;li&gt;当B收到该NS报文后，有两种处理方法：
&lt;ol&gt;
&lt;li&gt;如果FC00::1是&lt;strong&gt;B的试验地址&lt;/strong&gt;，则B放弃使用这个地址作为接口地址，并且&lt;strong&gt;不会发送NA报文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果B发现FC00::1是&lt;strong&gt;已经正常使用的地址&lt;/strong&gt;，B会向&lt;strong&gt;FF02::1&lt;/strong&gt;发送一个NA报文，该消息中会包含FC00::1&lt;code&gt;如果两端同时配置相同地址，然后均收到NA报文，那么这个地址会被弃用&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;A收到这个消息后就会发现自身的试验地址是重复的，被标识为duplicated状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590677468641.png&#34; alt=&#34;IPv6地址生存时间&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Preferred lifetime（首选存活时间）和Valid lifetime（失效时间）之间为Deprecated状态，当地址处于Deprecated状态，地址不能主动的发起连接只能是被动的接受连接，这也是为了保证上层应用而设计的，但是过了valid lifetime时间，地址就变为invalid，这时任何连接都会down掉&lt;/p&gt;
&lt;h5 id=&#34;2-地址解析即邻居发现&#34;&gt;2. 地址解析（即邻居发现）&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;ND本身基于ICMPv6实现，&lt;strong&gt;以太网协议类型为0x86DD&lt;/strong&gt;（ARP是0x0806），即IPv6报文，&lt;strong&gt;IPv6下一个报头字段值为58&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;地址解析在三层完成，不同的二层介质可以采用相同的地址解析协议&lt;/li&gt;
&lt;li&gt;可以使用三层的安全机制避免地址解析攻击&lt;/li&gt;
&lt;li&gt;使用组播方式（Solicited-Node，FF02::1:FFXX:XXXX/104）发送请求报文，减少了二层网络的性能压力&lt;/li&gt;
&lt;li&gt;使用两种报文：邻居请求NS135（组播发送）、邻居通告NA136（单播回复）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613632815662.png&#34; alt=&#34;地址解析&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;NA报文中使用NS报文中的Host A的链路层地址进行单播&lt;/code&gt;&lt;br&gt;
例如A的地址为2000::1、B的地址为2000::2，&lt;br&gt;
NS报文的源地址为2000::1、目的地址为ff02::1:ff00:2；&lt;br&gt;
NA报文的源地址为2000::2、目的地址为2000::1。&lt;br&gt;
&lt;strong&gt;NA报文中3个标志位&lt;/strong&gt;：R（置位代表路由器）、S（置位代表发送邻居通告是为了响应某个邻居的请求）、O（置位表示邻居通告中的消息覆盖已有的条目信息）&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;3-跟踪邻居状态&#34;&gt;3. 跟踪邻居状态&lt;/h5&gt;
&lt;p&gt;节点需要维护一张邻居表（&lt;strong&gt;邻居表为空则状态显示Empty&lt;/strong&gt;），每个邻居都有相应的状态，状态之间可以迁移，5种邻居状态：未完成（Incomplete）、可达（Reachable）、陈旧（Stale，未知是否可达，即长时间无连接之后的稳定状态）、延迟（Delay）、探查（Probe）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613633782457.png&#34; alt=&#34;跟踪邻居状态&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;以地址解析中，假设A、B之前从未通信&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A先发送NS报文，并生成缓存条目，邻居状态为Incomplete&lt;/li&gt;
&lt;li&gt;若B回复NA报文，则邻居状态由Incomplete变为Reachable，否则固定时间后（10秒）邻居状态由Incomplete变为Empty，即删除表项&lt;/li&gt;
&lt;li&gt;经过邻居可达时间（&lt;strong&gt;30秒&lt;/strong&gt;），邻居状态由Reachable变为Stale&lt;/li&gt;
&lt;li&gt;如果在Reachable状态，&lt;strong&gt;A收到B的非请求NA报文&lt;/strong&gt;，&lt;strong&gt;且报文中携带的B的链路层地址和表项中不同&lt;/strong&gt;，则邻居状态马上变为Stale&lt;/li&gt;
&lt;li&gt;在Stale状态若A要向B发送数据，则邻居状态由Stale变为Delay，并发送NS请求&lt;/li&gt;
&lt;li&gt;在一段固定时间（&lt;strong&gt;5秒&lt;/strong&gt;）内，若无NA应答则变为Probe，若有NA应答则变为Reachable&lt;/li&gt;
&lt;li&gt;在Probe状态，A周期性（&lt;strong&gt;1秒&lt;/strong&gt;）单播NS，发送固定次数（&lt;strong&gt;默认3次&lt;/strong&gt;）后，有应答则邻居状态变为Reachable，否则30秒之后邻居状态变为Empty，即删除表项&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613634516767.jpg&#34; alt=&#34;邻居状态&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;3-使用重定向137&#34;&gt;3. 使用重定向（137）&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;只有重定向&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;1-重定向&#34;&gt;1. 重定向&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;路由器可以发送重定向报文，但是不能处理收到的重定向报文&lt;/code&gt;&lt;br&gt;
网关设备发现报文从其它网关设备转发更好时，就会发送重定向报文给发送者，让报文发送者选择另一个网关设备。Type=137，报文中携带&lt;strong&gt;更好的路径下一跳地址和需要重定向转发的报文的目的地址&lt;/strong&gt;等信息。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613643421910.png&#34; alt=&#34;重定向&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
HostA和HostB通信，HostA的默认网关设备是RouterA。&lt;br&gt;
RouterA接收到HostA发送的报文以后会发现实际上HostA直接发送给RouterB更好，它将发送一个重定向报文给主机A，其中报文中&lt;strong&gt;更好的路径下一跳地址为RouterB，DestinationAddress为HostB&lt;/strong&gt;。&lt;br&gt;
HostA接收到了重定向报文之后，会在默认路由表中添加一个主机路由，以后发往HostB的报文就直接发送给RouterB&lt;/p&gt;
&lt;p&gt;当设备收到一个报文后，只有在如下情况下，设备会&lt;strong&gt;向报文发送者发送重定向报文（触发重定向报文的条件）&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;报文的目的地址不是一个组播地址&lt;/li&gt;
&lt;li&gt;报文并非通过路由转发给设备&lt;code&gt;即主机邻居发送的&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文的下一跳出接口是接收该报文的接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文的最佳下一跳IP地址和报文的源IP地址处于同一网段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;设备检查报文的源地址，发现自身的邻居表项中有用该地址作为全球单播地址或链路本地地址的邻居存在&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;数据包从同接口进又从该接口出，并满足如下条件（数据报文是主机邻居发送的，目的地址不是组播）就会触发路由器发送重定向报文，第一份数据依旧会由路由器转发，后续的报文就直接通过最优路径访问了&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;ipv6过渡技术&#34;&gt;IPv6过渡技术&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590939623986.png&#34; alt=&#34;IPv6过渡技术&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;IPv6与IPv4共存技术：
&lt;ul&gt;
&lt;li&gt;双协议栈：节点需要同时支持IPv6和IPv4协议栈。&lt;/li&gt;
&lt;li&gt;隧道：IPv6报文作为IPv4的载荷，在IPv4网络中连接多个IPv6孤岛&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IPv6与IPv4互通技术：提供IPv6与IPv4互相访问的技术，适用于IPv6与IPv4共存，而两者又有互相通讯的需求&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;双栈协议&#34;&gt;双栈协议&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940226124.png&#34; alt=&#34;双栈协议&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所有设备必须支持IPv4/IPv6协议栈，连接双栈网络的接口必须同时配置IPv4地址和IPv6地址&lt;/p&gt;
&lt;h2 id=&#34;ipv6-over-ipv4隧道技术&#34;&gt;IPv6 over IPv4隧道技术&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940296740.png&#34; alt=&#34; IPv6 over IPv4隧道技术&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过隧道技术，使IPv6报文在IPv4网络中传输，实现IPv6网络之间的孤岛互连&lt;br&gt;
&lt;strong&gt;IPv6 over IPv4隧道分类&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;手动隧道&lt;/strong&gt;包括6over4手动隧道和GRE隧道；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自动隧道&lt;/strong&gt;包括IPv4兼容IPv6自动隧道（已经弃用）、6to4隧道和ISATAP隧道&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-6over4手动隧道过渡初期使用&#34;&gt;1. 6over4手动隧道（过渡初期使用）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940506925.png&#34; alt=&#34;6over4手动隧道&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;特别注意：在IPv4数据中承载IPv6数据，上层协议号为41&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-4over6手动隧道过渡后期使用&#34;&gt;2. 4over6手动隧道（过渡后期使用）&lt;/h3&gt;
&lt;p&gt;使IPv4报文在IPv6网络中传输&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613657187996.png&#34; alt=&#34;4over6&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-gre手动隧道&#34;&gt;3. GRE手动隧道&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940749643.png&#34; alt=&#34;GRE隧道&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6over4手动隧道的一种，手工指定隧道的端点地址，GRE承载IPv6协议&lt;br&gt;
&lt;code&gt;GRE协议号为47；GRE头部不带认证4字节，带认证则8字节；GRE使用协议ID来标识上层封装（0x0800为以太网）&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-ipv4兼容ipv6目前已经被6to4隧道所取代&#34;&gt;4. IPv4兼容IPv6（目前已经被6to4隧道所取代）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940839043.png&#34; alt=&#34;IPv4兼容IPv6&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
采用IPv4兼容地址，即&lt;code&gt;::IPv4/96&lt;/code&gt;，要求每台主机须有合法的IP地址，即唯一的单播地址&lt;/p&gt;
&lt;h3 id=&#34;5-6to4隧道&#34;&gt;5. 6to4隧道&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941496380.png&#34; alt=&#34;6to4隧道1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6over4自动隧道的一种，&lt;strong&gt;采用6to4专用地址&lt;/strong&gt;，6to4地址可以表示为&lt;code&gt;2002::/16&lt;/code&gt;，而一个6to4网络可以表示为&lt;code&gt;2002:IPv4地址::/48&lt;/code&gt;，&lt;strong&gt;用IPv4地址作为网络标识&lt;/strong&gt;，例如：&lt;code&gt;1.2.3.10&lt;/code&gt;对应的地址是&lt;code&gt;2002:102:3a::/48&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;地址格式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FP：可聚合全球单播地址的格式前缀，其值为&lt;code&gt;001&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;TLA：顶级聚合标识符，有13个比特位，其二进制值为&lt;code&gt;0.0000.0000.0010&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SLA：站点级聚合标识符&lt;code&gt;16bit，由用户自己定义，可用于划分子网&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果连接多个6to4网络，&lt;strong&gt;通过SLA区分&lt;/strong&gt;，共用一个隧道&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941788338.png&#34; alt=&#34;6to4隧道2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;6to4中继&lt;/strong&gt;，实现6to4网络和IPv6普通网络互通。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941840050.png&#34; alt=&#34;6to4隧道3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6to4中继，就是通过6to4隧道转发的IPv6报文的&lt;strong&gt;目的地址不是6to4地址&lt;/strong&gt;，但&lt;strong&gt;转发的下一跳是6to4地址&lt;/strong&gt;&lt;code&gt;本质是通过静态路由的方式指定下一跳为6to4地址&lt;/code&gt;，该下一跳为路由器我们称之为&lt;strong&gt;6to4中继&lt;/strong&gt;，隧道的IPv4目的地址依然从下一跳的6to4地址中获得。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613652483059.png&#34; alt=&#34;中继&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R1上挂的IPv6孤岛使用6to4地址空间，R3上的IPv6孤岛也是6to4空间，而R2这台因特网上的6to4路由器同时也连接到了IPv6的因特网和IPv4因特网，因此他具有IPv6公网的路由。&lt;br&gt;
所以，R1、R3下的两个6to4孤岛的互相访问通过6to4地址进行，但是R1或R3如果需要访问非6to4的IPv6网络就需要R2了，R2此时是一台6to4中继路由器。&lt;br&gt;
&lt;strong&gt;R2通过其自身的一个IPv4公网IP，得到一个6to4的IPv6全球可聚合单播地址，这个IPv6地址用于响应其他6to4路由器的隧道建立请求&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-isatap隧道&#34;&gt;6. ISATAP隧道&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941979772.png&#34; alt=&#34;ISATAP隧道&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6over4自动隧道的一种&lt;sub&gt;不支持路由器到路由器&lt;/sub&gt;，采用ISATAP隧道专用地址&lt;br&gt;
ISATAP隧道同样使用了&lt;strong&gt;内嵌IPv4地址的特殊IPv6地址形式&lt;/strong&gt;，只是和6to4不同的是，6to4是使用IPv4地址做为网络前缀，而&lt;strong&gt;ISATAP用IPv4地址做为接口标识&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613656445323.png&#34; alt=&#34;ISATAP隧道专用地址&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
u：IPv4地址是全局唯一的，则u位为1&lt;br&gt;
g：IEEE 群体/个体标志&lt;br&gt;
由于ISATAP是通过接口标识来表现的，所以ISATAP地址有全局单播地址、链路本地地址、ULA地址、组播地址等形式。&lt;strong&gt;ISATAP地址的前64位是通过向ISATAP路由器发送请求来得到的&lt;/strong&gt;，它可以进行地址自动配置。在ISATAP隧道的两端设备之间可以运行ND协议。ISATAP隧道&lt;strong&gt;将IPv4网络看作一个非广播的点到多点的链路&lt;/strong&gt;&lt;br&gt;
如图，在IPv4网络内部有两个双栈主机PC2和PC3，它们分别有一个私网IPv4地址，要使其具有ISATAP功能，需要进行如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先配置ISATAP隧道接口，这时会根据IPv4地址生成ISATAP类型的接口ID&lt;/li&gt;
&lt;li&gt;根据接口ID生成一个ISATAP链路本地IPv6地址，生成链路本地地址以后，主机就有了在本地链路上进行IPv6通信的能力&lt;/li&gt;
&lt;li&gt;进行自动配置，主机获得IPv6全球单播地址、ULA地址等&lt;/li&gt;
&lt;li&gt;当主机与其它IPv6主机进行通讯时，从隧道接口转发，将从报文的下一跳IPv6地址中取出IPv4地址作为IPv4封装的目的地址
&lt;ol&gt;
&lt;li&gt;如果目的主机在本站点内，则下一跳就是目的主机本身&lt;/li&gt;
&lt;li&gt;如果目的主机不在本站点内，则下一跳为ISATAP路由器的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;7-nat64&#34;&gt;7. NAT64&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590942107941.png&#34; alt=&#34;NAT64&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
NAT64技术实际上是一种协议转换技术，能够将分组在V4及V6格式之间灵活转换。IPv6过渡中的协议翻译技术就是将IPv6数据包的每个字段与IPv4数据包中的字段建立起一一映射的关系，从而在两个网络的边缘实现数据报文的转换。&lt;/p&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;pmtu的工作过程&#34;&gt;PMTU的工作过程&lt;/h2&gt;
&lt;p&gt;在IPv6中，为了减少中间转发设备的处理压力，中间转发设备不对IPv6报文进行分片，报文的分片将在源节点进行&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613655555458.png&#34; alt=&#34;PMTU的工作过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
整条传输路径需要通过 条链路，每条链路的MTU分别是1500、1500、1400、1300。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当源节点发送一个分片报文的时候，首先按照PMTU为1500进行分片并发送分片报文&lt;/li&gt;
&lt;li&gt;当到达MTU为1400的出接口时，路由器返回Packet Too Big（ICMP，type2）错误，同时携带MTU值为1400的信息&lt;/li&gt;
&lt;li&gt;源节点接收到之后会将报文重新按照PMTU为1400进行分片并再次发送一个分片报文，当分片报文到达 MTU值为1300的出接口时，同样返回Packet Too Big错误，携带MTU值为1300的信息&lt;/li&gt;
&lt;li&gt;之后源节点重新按照PMTU为1300进行分片并发送分片报文，最终到达目的地，这样就找到了该路径的 PMTU&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;两台-ipv6-客户端的互访过程&#34;&gt;两台 ipv6 客户端的互访过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;先检查目标地址与本机地址是否同一网段，如果不在同一网段是否可达（查路由表）&lt;/li&gt;
&lt;li&gt;引入数据的封装，从高往低，封装到二层时需要知道对方的MAC地址&lt;/li&gt;
&lt;li&gt;如果在同一网段直接发送NS请求，请求对方地址的MAC地址，如果不在同一网段，则请求网关的MAC地址&lt;/li&gt;
&lt;li&gt;NS/NA的过程（详细讲解）&lt;/li&gt;
&lt;li&gt;获得MAC地址后完成封装&lt;/li&gt;
&lt;li&gt;封装完后讲数据包的交互过程&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ipv4与ipv6-qos的区别&#34;&gt;IPv4与IPV6 qos的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;traffic-class等同于IPv4中的TOS字段，表示IPv6报文的类或优先级&lt;/li&gt;
&lt;li&gt;ipv6的报文中多了20位的流标签，用于区分实时流量，不同的流标签+源地址可以唯一确定一条数据流，中间网络设备可以根据这些信息更加高效率的区分数据流&lt;/li&gt;
&lt;li&gt;引入QOS（QoS信令扩展）&lt;br&gt;
IPv6可以比较方便地支持QoS信令的实现，具体的做法是，根据IPv6的Hop by Hop扩展头对信令进行定义。由于每个IPv6节点都必须处理Hop by Hop扩展头，这样就可以实现QoS信令。即通过在数据流的第一个数据包中携带有关信息，在经过逐跳处理和预留以后到达接收端，接收端根据情况将有关信息回传发送方，这样就可以进行有QoS保证的数据发送了。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ipv6对移动技术的支持用到了哪些扩展报头&#34;&gt;ipv6对移动技术的支持用到了哪些扩展报头&lt;/h2&gt;
&lt;p&gt;用到了目的选项扩展报头，类型是60&lt;/p&gt;
&lt;h3 id=&#34;移动技术&#34;&gt;移动技术&lt;/h3&gt;
&lt;h4 id=&#34;1-产生背景&#34;&gt;1. 产生背景&lt;/h4&gt;
&lt;p&gt;因特网上的一个节点在改&lt;strong&gt;变了其在网络上的接入点以后&lt;/strong&gt;，如果不重新配置其IP地址，那么路由器就不能识别此节点，它就&lt;strong&gt;不能继续与网上的其它节点进行通信&lt;/strong&gt;，移动IP就是为解决这个问题而提出的&lt;/p&gt;
&lt;h4 id=&#34;2-技术定义&#34;&gt;2. 技术定义&lt;/h4&gt;
&lt;p&gt;移动IP提供了&lt;strong&gt;一种IP路由机制&lt;/strong&gt;，使移动节点可以以一个永久的IP地址连接到任何链路上。移动IP可以看作是一个路由协议，只是与其它路由协议相比，移动IP具有特殊的功能，它的&lt;strong&gt;目的是将数据包路由到那些可能一直在快速地改变位置的移动节点上&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-移动机制&#34;&gt;3. 移动机制&lt;/h4&gt;
&lt;p&gt;Node A到Link 1上，它有一个地址A1，这个地址A1是可以通过Router 1到达的，当Node A没有发生移动时，Node B与Node A通信时，Node B发送的数据包会按照现有的路由方式到达Node A&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613665804019.bmp&#34; alt=&#34;移动前&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当Node A发生了移动，从Link 1移动到Link 2时，如果Node A不改变其IP地址，Node B发送的数据包按照现有的以前缀为基础的路由方式就不能够到达Node A了&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613665871784.bmp&#34; alt=&#34;移动后&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IPv6通过以下步骤解决这个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Router 2会定期广播发送RA消息，带有本地链路上的前缀信息，Node A接收到这个消息后，知道自己发生了移动，它会根据新的前缀信息通过地址自动配置得到一个新的地址A2&lt;/li&gt;
&lt;li&gt;Node A会发送一个信息包M2给Router 1，这个信息包告诉Router 1现在Node A的新地址A2，此后，Router 1再发现有需要送到Node A的原来的地址A1的数据包，它会把这个数据包截获，然后把这个包作为净荷，在其上面再加上一层IPv6报头，把新的数据包发送到Node A的新地址A2，&lt;strong&gt;这个过程应用的是隧道技术&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;假如Node B发送数据包给Node A，它并不知道Node A已经发生了移动，此时它会把这个数据包继续发送给Node A原来的地址A1&lt;/li&gt;
&lt;li&gt;Node B发送的数据包到达Router 1以后，Router 1会截获这个数据包，同时把这个数据包转发到Node A的新地址A2&lt;/li&gt;
&lt;li&gt;Node A收到Router 1转发过来的数据包以后，通过检查这个数据包的源地址，它知道Node B想与它进行通信，于是它会发送一个信息包M3给Node B，告诉自己的新地址A2&lt;/li&gt;
&lt;li&gt;Node B收到这个数据包以后，会记录下Node A的新地址A2，这样如果再有数据包需要发给Node A，它会直接把数据包发给地址A2，至此Node A和Node B之间可以实现双向通信&lt;/li&gt;
&lt;li&gt;若有其余节点想与Node A进行通信，其建立通信的过程与Node B类似&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;4-ipv6解决移动问题的措施&#34;&gt;4. ipv6解决移动问题的措施&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;黑洞检测&lt;/li&gt;
&lt;li&gt;路由报头&lt;/li&gt;
&lt;li&gt;动态家乡代理地址发现机制&lt;/li&gt;
&lt;li&gt;透明性的实现&lt;/li&gt;
&lt;/ol&gt;
">IPv6</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/dhcp-he-ftp/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#dhcp&#34;&gt;DHCP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B&#34;&gt;报文类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&#34;&gt;工作流程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%A6%96%E6%AC%A1%E6%8E%A5%E5%85%A5%E7%BD%91%E7%BB%9C&#34;&gt;首次接入网络&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%97%A0%E4%B8%AD%E7%BB%A7&#34;&gt;1. 无中继&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%9C%89%E4%B8%AD%E7%BB%A7&#34;&gt;2. 有中继&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%87%8D%E6%96%B0%E4%BD%BF%E7%94%A8%E4%B9%8B%E5%89%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E4%BE%8B%E5%A6%82%E5%BC%80%E6%9C%BA&#34;&gt;重新使用之前使用的地址（例如开机）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9B%B4%E6%96%B0%E7%A7%9F%E6%9C%9F&#34;&gt;更新租期&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%97%A0%E4%B8%AD%E7%BB%A7-2&#34;&gt;1. 无中继&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%9C%89%E4%B8%AD%E7%BB%A7-2&#34;&gt;2. 有中继&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dhcp-snooping&#34;&gt;DHCP Snooping&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dhcp-snooping%E7%BB%91%E5%AE%9A%E8%A1%A8&#34;&gt;DHCP Snooping绑定表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%92%88%E5%AF%B9dhcp%E7%9A%84%E6%94%BB%E5%87%BB&#34;&gt;针对DHCP的攻击&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-dhcp%E4%BB%BF%E5%86%92%E8%80%85%E6%94%BB%E5%87%BB&#34;&gt;1.  DHCP仿冒者攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BBipmac-spoofing%E6%94%BB%E5%87%BBarp%E6%AC%BA%E9%AA%97&#34;&gt;2.  中间人攻击（IP/MAC Spoofing攻击，ARP欺骗）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%A5%BF%E6%AD%BB%E6%94%BB%E5%87%BB&#34;&gt;3. 饿死攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E6%94%B9%E5%8F%98chaddr%E5%80%BC%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E9%A5%BF%E6%AD%BB%E6%94%BB%E5%87%BB&#34;&gt;4. 改变CHADDR值（客户端物理地址）的饿死攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-arp%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86&#34;&gt;5. ARP攻击原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ftp&#34;&gt;FTP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F&#34;&gt;工作方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ftp%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B&#34;&gt;FTP连接的建立&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F&#34;&gt;1. 主动模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F&#34;&gt;2. 被动模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B3%E4%BA%8E%E9%98%B2%E7%81%AB%E5%A2%99&#34;&gt;关于防火墙&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#snmp&#34;&gt;SNMP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#snmp%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B&#34;&gt;SNMP管理模型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87&#34;&gt;报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&#34;&gt;工作原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#snmpv3&#34;&gt;SNMPv3&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87-2&#34;&gt;报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#snmp%E5%90%84%E7%89%88%E6%9C%AC%E6%AF%94%E8%BE%83&#34;&gt;SNMP各版本比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#snmp%E4%B8%BB%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8E%E7%BD%91%E7%AE%A1%E8%BF%9E%E6%8E%A5%E6%8E%92%E9%94%99&#34;&gt;SNMP主机无法与网管连接排错&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vrrp%E8%99%9A%E6%8B%9F%E8%B7%AF%E7%94%B1%E5%86%97%E4%BD%99%E5%8D%8F%E8%AE%AE&#34;&gt;VRRP（虚拟路由冗余协议）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0&#34;&gt;基本概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87&#34;&gt;协议报文&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#vrrpv2%E5%92%8Cvrrpv3%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB&#34;&gt;VRRPv2和VRRPv3的主要区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-2&#34;&gt;工作原理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8A%B6%E6%80%81%E6%9C%BA&#34;&gt;状态机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B&#34;&gt;工作过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD1master%E8%AE%BE%E5%A4%87%E7%9A%84%E9%80%89%E4%B8%BE&#34;&gt;重要功能1：Master设备的选举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%87%8D%E8%A6%81%E5%8A%9F%E8%83%BD2master%E8%AE%BE%E5%A4%87%E7%8A%B6%E6%80%81%E7%9A%84%E9%80%9A%E5%91%8A&#34;&gt;重要功能2：Master设备状态的通告&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%9A%E7%BD%91%E5%85%B3%E8%B4%9F%E8%BD%BD%E5%88%86%E6%8B%85&#34;&gt;多网关负载分担&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%91%E6%8E%A7%E4%B8%8A%E8%A1%8C%E9%93%BE%E8%B7%AF%E7%9A%84%E6%96%B9%E6%B3%95&#34;&gt;监控上行链路的方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-vrrp%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%8A%B6%E6%80%81%E8%81%94%E5%8A%A8%E5%AE%9E%E7%8E%B0vrrp%E4%B8%BB%E5%A4%87%E5%88%87%E6%8D%A2&#34;&gt;1. VRRP与接口状态联动实现VRRP主备切换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-vrrp%E4%B8%8E%E8%B7%AF%E7%94%B1%E8%81%94%E5%8A%A8%E7%9B%91%E8%A7%86%E4%B8%8A%E8%A1%8C%E9%93%BE%E8%B7%AF%E5%BF%AB%E6%85%A2%E4%BE%9D%E8%B5%96%E4%BA%8E%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE&#34;&gt;2. VRRP与路由联动监视上行链路（快慢依赖于路由协议）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-vrrp%E4%B8%8Ebfd%E8%81%94%E5%8A%A8%E7%9B%91%E8%A7%86%E4%B8%8A%E8%A1%8C%E9%93%BE%E8%B7%AF%E6%9C%80%E5%BF%AB&#34;&gt;3. VRRP与BFD联动监视上行链路（最快）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-vrrp%E4%B8%8Enqa%E8%81%94%E5%8A%A8%E7%9B%91%E8%A7%86%E4%B8%8A%E8%A1%8C%E9%93%BE%E8%B7%AF%E4%BE%9D%E8%B5%96%E4%B8%8Eping%E7%9A%84%E9%80%9F%E5%BA%A6&#34;&gt;4. VRRP与NQA联动监视上行链路（依赖与ping的速度）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BF%83%E8%B7%B3%E7%BA%BF&#34;&gt;心跳线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vrrp%E5%92%8Ceth-trunk%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;VRRP和Eth-trunk的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bfd%E5%8F%8C%E5%90%91%E8%BD%AC%E5%8F%91%E6%A3%80%E6%B5%8B&#34;&gt;BFD(双向转发检测)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%9C%E7%94%A8&#34;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6&#34;&gt;检测机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A3%80%E6%B5%8B%E7%9A%84%E9%93%BE%E8%B7%AF%E7%B1%BB%E5%9E%8B&#34;&gt;检测的链路类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87-3&#34;&gt;报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%9A%E8%AF%9D%E5%BB%BA%E7%AB%8B%E6%96%B9%E5%BC%8F&#34;&gt;会话建立方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86&#34;&gt;会话管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%81%94%E5%8A%A8%E5%8A%9F%E8%83%BD&#34;&gt;联动功能&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%B8%8E%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1%E7%9A%84%E8%81%94%E5%8A%A8&#34;&gt;1. 与静态路由的联动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%B8%8Eigpospf-isis-rip%E7%9A%84%E8%81%94%E5%8A%A8&#34;&gt;2. 与IGP（ospf、isis、rip）的联动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E4%B8%8Ebgp%E7%9A%84%E8%81%94%E5%8A%A8&#34;&gt;3. 与BGP的联动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E4%B8%8Evrrp%E7%9A%84%E8%81%94%E5%8A%A8&#34;&gt;4. 与VRRP的联动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-bfd%E7%9A%84%E5%8D%95%E8%87%82%E5%9B%9E%E5%A3%B0%E5%8A%9F%E8%83%BDbfd-echo&#34;&gt;5. BFD的单臂回声功能（BFD Echo）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nqa%E7%BD%91%E7%BB%9C%E8%B4%A8%E9%87%8F%E5%88%86%E6%9E%90&#34;&gt;NQA（网络质量分析）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%BF%B0&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E7%82%B9&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&#34;&gt;基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E5%8E%9F%E7%90%86&#34;&gt;测试原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E6%93%8D%E4%BD%9C&#34;&gt;测试操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%8B%E8%AF%95%E7%B1%BB%E5%9E%8B&#34;&gt;测试类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-icmp%E6%B5%8B%E8%AF%95&#34;&gt;1. ICMP测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-trace%E6%B5%8B%E8%AF%95&#34;&gt;2. Trace测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-tcp%E6%B5%8B%E8%AF%95&#34;&gt;3. TCP测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-dns%E6%B5%8B%E8%AF%95&#34;&gt;4. DNS测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-icmpudp-jitter%E6%B5%8B%E8%AF%95&#34;&gt;5. ICMP/UDP Jitter测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-ftp%E6%B5%8B%E8%AF%95&#34;&gt;6. FTP测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-http%E6%B5%8B%E8%AF%95&#34;&gt;7. HTTP测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-dhcp%E6%B5%8B%E8%AF%95&#34;&gt;8. DHCP测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-snmp%E6%B5%8B%E8%AF%95&#34;&gt;9. SNMP测试&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bfd%E4%B8%8Enqa%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;BFD与NQA的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#urpf%E5%8D%95%E6%92%AD%E9%80%86%E5%90%91%E8%B7%AF%E5%BE%84%E8%BD%AC%E5%8F%91&#34;&gt;URPF（单播逆向路径转发）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86-2&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F&#34;&gt;工作模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&#34;&gt;应用场景&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84urpf%E5%BA%94%E7%94%A8&#34;&gt;1. 严格模式下的URPF应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%9D%BE%E6%95%A3%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84urpf%E5%BA%94%E7%94%A8&#34;&gt;2. 松散模式下的URPF应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nat%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2&#34;&gt;NAT（网络地址转换）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB&#34;&gt;分类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-basic-nat%E4%B8%8D%E5%B8%B8%E7%94%A8&#34;&gt;1. Basic NAT（不常用）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-napt&#34;&gt;2. NAPT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-nat-pt&#34;&gt;3. NAT-PT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&#34;&gt;实现方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-easy-ip&#34;&gt;1. Easy IP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-nat-server&#34;&gt;2. NAT Server&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%9D%99%E6%80%81natnapt&#34;&gt;3. 静态NAT/NAPT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nat-alg&#34;&gt;NAT ALG&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9&#34;&gt;其他内容&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-dns-mapping&#34;&gt;1. DNS Mapping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-nat%E5%85%B3%E8%81%94vpn&#34;&gt;2. NAT关联VPN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E4%B8%A4%E6%AC%A1nat&#34;&gt;3. 两次NAT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ntp&#34;&gt;NTP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%BC%94%E8%BF%9B&#34;&gt;演进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&#34;&gt;基本原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84&#34;&gt;网络架构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ntp%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F&#34;&gt;NTP的工作模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%8D%95%E6%92%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A8%A1%E5%BC%8F&#34;&gt;1. 单播服务器/客户端模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%AF%B9%E7%AD%89%E4%BD%93%E6%A8%A1%E5%BC%8F&#34;&gt;2. 对等体模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F&#34;&gt;3. 广播模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E7%BB%84%E6%92%AD%E6%A8%A1%E5%BC%8F%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%92%8C%E5%B9%BF%E6%92%AD%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%90%8C&#34;&gt;4. 组播模式~工作方式和广播模式相同~&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E5%A4%9A%E6%92%AD%E6%A8%A1%E5%BC%8F&#34;&gt;5. 多播模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#netstream&#34;&gt;Netstream&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90&#34;&gt;系统组成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6&#34;&gt;工作机制&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-netstream%E9%87%87%E6%A0%B7&#34;&gt;1. NetStream采样&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-netstream%E6%B5%81&#34;&gt;2. NetStream流&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-netstream%E6%B5%81%E8%80%81%E5%8C%96&#34;&gt;3. NetStream流老化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-netstream%E6%B5%81%E8%BE%93%E5%87%BA&#34;&gt;4. NetStream流输出&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B5%81%E8%BE%93%E5%87%BA%E6%96%B9%E5%BC%8F&#34;&gt;流输出方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BE%93%E5%87%BA%E6%8A%A5%E6%96%87%E7%9A%84%E7%89%88%E6%9C%AC%E6%A0%BC%E5%BC%8F&#34;&gt;输出报文的版本格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;dhcp&#34;&gt;DHCP&lt;/h1&gt;
&lt;p&gt;采用UDP封装，Client（68端口）/Server（67端口）模式，客户端提出配置申请，服务端响应配置请求&lt;/p&gt;
&lt;h2 id=&#34;报文类型&#34;&gt;报文类型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送报文
&lt;ol&gt;
&lt;li&gt;DHCP  Discover（广播）：客户端广播来&lt;strong&gt;查找&lt;/strong&gt;服务器&lt;/li&gt;
&lt;li&gt;DHCP  Request（广播）：客户端发送给服务器&lt;strong&gt;请求配置参数&lt;/strong&gt;或者&lt;strong&gt;请求配置确认&lt;/strong&gt;或者&lt;strong&gt;续借租期&lt;/strong&gt;。使用场景如下：
&lt;ol&gt;
&lt;li&gt;正常的请求消息（华为是单播）&lt;/li&gt;
&lt;li&gt;租约的期限到了50%（单播，进行续约）&lt;/li&gt;
&lt;li&gt;租约的期限到了87.5%（广播，在50%的时候续约不成功，重新进行续约）&lt;/li&gt;
&lt;li&gt;PC重启之后需要重新续约&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;DHCP  Decline：客户端发现&lt;strong&gt;地址已经被使用&lt;/strong&gt;时，用来通知服务器&lt;/li&gt;
&lt;li&gt;DHCP  Inform：客户端&lt;strong&gt;已经有IP地址时用它来向服务器请求其他的配置参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;DHCP  Release：客户端要&lt;strong&gt;释放地址&lt;/strong&gt;时用来通知服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;服务器发送报文
&lt;ol&gt;
&lt;li&gt;DHCP Offer（广播或单播依据flag）：服务器&lt;strong&gt;响应&lt;/strong&gt;客户端的&lt;strong&gt;DHCP DISCOVER报文&lt;/strong&gt;，并&lt;strong&gt;指定相应的配置参数&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;DHCP Ack（广播或单播依据flag）：服务器到客户端，&lt;strong&gt;含有配置参数包括IP地址&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;DHCP Nak：服务器发送给客户端来表明客户端的&lt;strong&gt;地址请求不正确或者租期已过期&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;报文格式&#34;&gt;报文格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592443026859.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;op：报文的类型，取值为1或2，含义如下：
&lt;ul&gt;
&lt;li&gt;1：客户端请求报文&lt;/li&gt;
&lt;li&gt;2：服务器响应报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;htype：硬件类型，以太网的值为1&lt;/li&gt;
&lt;li&gt;hlen：硬件地址长度，以太网的值为6&lt;/li&gt;
&lt;li&gt;hops：当前的DHCP报文经过的DHCP中继的数目。该字段由客户端或服务器设置为0，每经过一个DHCP中继时，该字段加1。&lt;code&gt;服务器和客户端之间的DHCP中继数目不能超过16个，否则DHCP报文将被丢弃&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;xid：DHCP客户端选取的随机数，使DHCP服务器的回复与DHCP客户端的报文相关联&lt;/li&gt;
&lt;li&gt;secs：客户端从开始获取地址或地址续租更新后所用的时间，单位是秒&lt;/li&gt;
&lt;li&gt;flag：标志字段，只有最高位才有意义，其余均被置为0，最高位是单播或广播响应标志位：
&lt;ul&gt;
&lt;li&gt;0：客户端请求服务器以单播形式发送响应报文&lt;/li&gt;
&lt;li&gt;1：客户端请求服务器以广播形式发送响应报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ciaddr：客户端的IP地址&lt;/li&gt;
&lt;li&gt;yiaddr：服务器分配给客户端的IP地址&lt;/li&gt;
&lt;li&gt;siaddr：DHCP客户端获得启动配置信息的服务器的IP地址&lt;/li&gt;
&lt;li&gt;giaddr：表示第一个DHCP中继的IP地址&lt;/li&gt;
&lt;li&gt;chaddr：客户端的MAC地址&lt;/li&gt;
&lt;li&gt;sname：客户端获取配置信息的服务器名字&lt;/li&gt;
&lt;li&gt;file：客户端需要获取的启动配置文件名&lt;/li&gt;
&lt;li&gt;option：采用TLV方式构成
&lt;ul&gt;
&lt;li&gt;type1：设置子网掩码&lt;/li&gt;
&lt;li&gt;type3：设置网关地址&lt;/li&gt;
&lt;li&gt;type6：设置DNS服务器地址&lt;/li&gt;
&lt;li&gt;type12：设置DHCP客户端的主机名&lt;/li&gt;
&lt;li&gt;type50：请求IP地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type43&lt;/code&gt;：DHCP的option 43选项是告诉AP 网络中AC的IP地址，让AP寻找AC进行注册&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type82&lt;/code&gt;：option 82实现dhcp客户端和dhcp中继设备的地址信息记录在dhcp服务器上，实现dhcp分配的限制和计费功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工作流程&#34;&gt;工作流程&lt;/h2&gt;
&lt;h3 id=&#34;首次接入网络&#34;&gt;首次接入网络&lt;/h3&gt;
&lt;h4 id=&#34;1-无中继&#34;&gt;1. 无中继&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613463255504.png&#34; alt=&#34;无中继&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;没有中继时是2个广播+2个单播&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送Discover广播报文即目的地址为255.255.255.255，查找服务器&lt;/li&gt;
&lt;li&gt;收到Discover信息的服务器都会做出响应，它从尚未出租的IP地址中挑选一个分配给客户端，发送一个包含IP地址等信息的Offer&lt;/li&gt;
&lt;li&gt;客户端收到Offer报文之后，因为有多个DHCP服务器，所以客户端以&lt;strong&gt;广播方式&lt;/strong&gt;发送Request报文，除了向选定的服务器请求IP地址其他信息之外，还要通知所有的DHCP服务器，已经选择某台服务器所提供的IP地址&lt;/li&gt;
&lt;li&gt;服务器收到请求之后，给客户端发送ACK响应报文，以后客户端每次重新登录网络时，&lt;strong&gt;只需要发送包含前一次所分配的IP地址的Request请求信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-有中继&#34;&gt;2. 有中继&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613463341801.png&#34; alt=&#34;有中继&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;中继与服务器之间是4个单播报文，客户端会将中继当作服务器，所以客户端与中继之间的报文还是2个广播+2个单播&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;什么时候使用中继？需要跨网段分配IP地址时&lt;/li&gt;
&lt;li&gt;使用中继之后，服务器如何确定给客户端分配哪个网段的地址？Discover报文中的gateway ip address是否被填充，如果被填充则只会分配gateway ip address所在网段的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;重新使用之前使用的地址例如开机&#34;&gt;重新使用之前使用的地址（例如开机）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613464723951.png&#34; alt=&#34;续租&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;客户端广播发送包含前一次分配的IP地址的Request报文，报文中的Option50（请求的IP地址选项）字段填入曾经使用过的IP地址&lt;/li&gt;
&lt;li&gt;服务器根据Request报文中携带的MAC地址来查找有没有相应的租约记录，如果有则返回Ack报文，通知DHCP客户端可以继续使用这个IP地址。否则，保持沉默，等待客户端重新发送Discover报文请求新的IP地址&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;更新租期&#34;&gt;更新租期&lt;/h3&gt;
&lt;h4 id=&#34;1-无中继-2&#34;&gt;1. 无中继&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613464945156.png&#34; alt=&#34;无中继&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;当租期达到50%（T1）时，客户端以单播的方式向服务器发送Request报文，请求更新IP地址租期
&lt;ol&gt;
&lt;li&gt;服务器回应Ack报文，则租期更新成功（即租期从0开始计算）&lt;/li&gt;
&lt;li&gt;服务器回应Nak报文，则客户端重新发送Discover报文请求新的IP地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当租期达到87.5%（T2）时，且仍未收到服务器的应答，则客户端会以广播的方式向服务器发送Request报文，请求更新IP地址租期&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-有中继-2&#34;&gt;2. 有中继&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613465146639.png&#34; alt=&#34;有中继&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;dhcp-snooping&#34;&gt;DHCP Snooping&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;侦听客户端发送的DHCP-REQUEST和信任接口收到的DHCP-ACK报文&lt;/code&gt;&lt;br&gt;
DHCP的一种安全特性，&lt;strong&gt;用于保证DHCP客户端从合法的DHCP服务器获取IP地址&lt;/strong&gt;，通过截获DHCP Client和DHCP Relay之间的DHCP报文并进行分析处理，可以过滤不信任的DHCP报文并建立和维护一个DHCP Snooping绑定表&lt;code&gt;绑定表包括MAC地址、IP地址、租约时间、VlanID、接口信息&lt;/code&gt;，通过对这个绑定表的维护，建立一道在客户端和服务器之间的防火墙，&lt;strong&gt;Request报文中Option82&lt;/strong&gt;记录报文&lt;strong&gt;入端口类型、端口号、VLAN信息以及桥MAC地址&lt;/strong&gt;，是生成绑定表的重要部分。&lt;/p&gt;
&lt;p&gt;DHCP Snooping信任功能将接口分为&lt;strong&gt;信任接口和非信任接口&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;信任接口正常接收DHCP服务器响应的DHCP ACK、DHCP NAK和DHCP Offer报文&lt;code&gt;一般将与合法DHCP服务器直接或间接连接的接口设置为信任接口，其他接口设置为非信任接口&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;非信任接口在接收到DHCP服务器响应的DHCP ACK、DHCP NAK和DHCP Offer报文后，丢弃该报文&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dhcp-snooping绑定表&#34;&gt;DHCP Snooping绑定表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;静态绑定表：按照实际需求在报文入端口手工输入，没有租期限制&lt;br&gt;
&lt;strong&gt;用途&lt;/strong&gt;：一些重要设备（如服务器）和一些高端用户需采用静态方式，一是没有租期限制，二是安全性高且便于管理。&lt;/li&gt;
&lt;li&gt;动态绑定表：客户端在申请IP地址过程中，根据DHCP报文内容在报文入端口自动生成，存在老化时间，有租期限制。&lt;br&gt;
&lt;strong&gt;用途&lt;/strong&gt;：生成方便，常用于非重要设备。不过绑定表存在老化时间，且不便于管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;针对dhcp的攻击&#34;&gt;针对DHCP的攻击&lt;/h3&gt;
&lt;h4 id=&#34;1-dhcp仿冒者攻击&#34;&gt;1.  DHCP仿冒者攻击&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466460979.png&#34; alt=&#34;DHCP仿冒者攻击&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;DHCP仿冒者攻击解决方法&lt;/strong&gt;：一般把通向DHCP Server的接口（连接网络内部的网络侧接口）设成Trusted状态，其它接口（连接网络外部的用户侧接口）都设为Untrusted状态。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466544827.png&#34; alt=&#34;DHCP仿冒者攻击解决方法&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-中间人攻击ipmac-spoofing攻击arp欺骗&#34;&gt;2.  中间人攻击（IP/MAC Spoofing攻击，ARP欺骗）&lt;/h4&gt;
&lt;p&gt;攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为与对方直接对话，但事实上整个会话都被攻击者完全控制，攻击者可以拦截通讯双方的通话并插入新的内容。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466733449.png&#34; alt=&#34;中间人攻击和IP/MAC Spoofing攻击&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中间人同时向DHCP服务器和客户端&lt;strong&gt;单播发送ARP响应&lt;/strong&gt;报文：&lt;code&gt;即需要欺骗服务器，有需要欺骗客户端&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;向服务器发送的报文中IP为客户端的IP 10.1.1.2，但MAC是中间人的mac 1-1-1&lt;/li&gt;
&lt;li&gt;向客户端发送的报文中IP为服务器的IP 10.2.1.1，但MAC还是中间人的mac 1-1-1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;服务器和客户端收到ARP响应报文之后修改ARP表项：
&lt;ol&gt;
&lt;li&gt;服务器将分配给客户端的地址10.1.1.2对应的mac修改为1-1-1&lt;/li&gt;
&lt;li&gt;客户端将DHCP服务器的地址10.2.1.1对应的mac修改为1-1-1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;之后客户端和服务器转发的数据都会到达中间人那里&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;中间人攻击解决方法&lt;/strong&gt;：为了防止中间人攻击或IP/MAC Spoofing攻击，可以在交换机上配置DHCP Snooping功能，使能DHCP Snooping绑定表功能后，只有接收到的报文的信息和绑定表中的内容一致才会被转发，否则报文将被丢弃。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466826858.png&#34; alt=&#34;中间人攻击和IP/MAC Spoofing攻击解决方法&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;DAI（动态ARP检测）是用来检测arp报文的，是用来防止中间人攻击；IPSG（IP源防攻击）是用来检测IP报文的，用来防止盗用IP的&lt;/code&gt;&lt;br&gt;
&lt;code&gt;开启DAI或者IPSG之前必须开启DHCP Snooping&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;DAI原理&lt;/strong&gt;：当设备收到ARP报文时，将此ARP报文对应的源IP、源MAC、VLAN以及接口信息和绑定表的信息进行比较，如果信息匹配，说明发送该ARP报文的用户是合法用户，允许此用户的ARP报文通过，否则就认为是攻击，丢弃该ARP报文。&lt;code&gt;用户防止中间人攻击&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;IPSG原理&lt;/strong&gt;：IPSG功能是基于绑定表（DHCP动态和静态绑定表）对IP报文进行匹配检查。当设备在转发IP报文时，将此IP报文中的源IP、源MAC、接口、VLAN信息和绑定表的信息进行比较，如果信息匹配，表明是合法用户，则允许此报文正常转发，否则认为是攻击报文，并丢弃该IP报文。&lt;code&gt;用来防止对源IP进行攻击的行为&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1618197540704.png&#34; alt=&#34;IP源攻击&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
中间人攻击发送的报文中修改的是MAC地址，给服务器发的报文的IP是客户端的，给客户端发的IP是服务器的，从而达到双向欺骗的目的，影响终端和服务器的ARP表项，导致被攻击者和服务器之间的交互数据被转发到中间人；IP源攻击同时修改报文中的mac和IP为被攻击者的，影响的是交换机的出接口，导致报文不能转发给被攻击者&lt;/p&gt;
&lt;h4 id=&#34;3-饿死攻击&#34;&gt;3. 饿死攻击&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;攻击原理&lt;/strong&gt;：在饿死攻击方式中，攻击者&lt;strong&gt;不断变换物理地址&lt;/strong&gt;，尝试申请地址池中所有的IP 地址，直到&lt;strong&gt;耗尽DHCP Server地址池中的地址&lt;/strong&gt;，导致其他正常用户无法获得地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：通过MAC地址限制功能可以防止饿死攻击。通过限制交换机接口上允许学习到的最多MAC 地址数目，防止用户通过变换MAC地址，大量发送DHCP请求，同时也限制了一个接口上的用户数目。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;4-改变chaddr值客户端物理地址的饿死攻击&#34;&gt;4. 改变CHADDR值（客户端物理地址）的饿死攻击&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;攻击原理&lt;/strong&gt;：在这种攻击方式中，如果攻击者改变的不是数据帧头部的源MAC，而是改变DHCP报文中的CHADDR（Client Hardware Address）值来不断申请IP地址，而交换机仅根据数据帧头部的源MAC来判断该报文是否合法，那么MAC地址限制方案不能起作用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：可以使用DHCP Snooping&lt;strong&gt;检查REQUEST报文中CHADDR字段&lt;/strong&gt;的功能。&lt;strong&gt;如果该字段跟数据帧头部的源MAC相匹配，便转发报文&lt;/strong&gt;；否则，丢弃报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;5-arp攻击原理&#34;&gt;5. ARP攻击原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击方式&lt;/strong&gt;：有针对主机的，也有针对网关的；有地址欺骗型的， 也有野蛮攻击型的；有来自病毒的攻击，也有来自使用非法软件的人为攻击&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击根源&lt;/strong&gt;：ARP协议本身过于简单和开放，没有任何的安全手段&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击危害&lt;/strong&gt;：ARP地址欺骗攻击一般针对个别或一定范围内的主机进行，危害相对较小。但针对网关设备的大流量ARP DDOS攻击，由于其网络位置的特殊性，将造成大面积用户“掉线”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击解决方法&lt;/strong&gt;：在应用DHCP服务器的组网环境下， 建立可信端口（trust Port），通过监控可信端口的DHCP报文获得IP/MAC地址绑定表，过滤掉所有不匹配的IP/ARP报文&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ftp&#34;&gt;FTP&lt;/h1&gt;
&lt;p&gt;仅基于TCP的服务，不支持UDP，端口21（控制）和20（主动模式下服务端数据传输）&lt;/p&gt;
&lt;h2 id=&#34;工作方式&#34;&gt;工作方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;主动和被动是针对服务器来说的，但是设置是在客户端设置，两者的区别在于数据连接是由服务器发起还是由客户端发起&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主动模式：PORT方式，Standard（默认模式）&lt;br&gt;
首先客户端（任意一个非特殊端口&amp;gt;1024，例如N）主动与服务器的21端口建立连接，然后服务器使用任意端口&lt;strong&gt;主动连接客户端的20端口&lt;/strong&gt;&lt;code&gt;即由服务器主动发起数据连接&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;被动模式：PASV方式，Passive&lt;br&gt;
首先客户端主动与服务器的21端口建立连接，然后服务器随机开放一个端口（&amp;gt;1024），通知客户端来连接本端口，最后客户端去连接那个端口进行数据传输&lt;code&gt;即服务端的数据连接是被动的，由客户端主动发起数据连接，服务端通过控制连接告诉客户端用来传输数据的端口&lt;/code&gt;&lt;br&gt;
&lt;code&gt;如果客户端与服务器中间有防火墙，建议服务器使用被动模式&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ftp连接的建立&#34;&gt;FTP连接的建立&lt;/h2&gt;
&lt;p&gt;FTP采用2个TCP连接来传输文件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;控制连接：连接控制端口，传输控制命令&lt;/li&gt;
&lt;li&gt;数据连接：连接数据端口，在控制连接建立后，数据连接通过控制端口的命令建立起连接，进行数据的传输&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-主动模式&#34;&gt;1. 主动模式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613484914410.png&#34; alt=&#34;主动模式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;服务器监听21端口&lt;/li&gt;
&lt;li&gt;客户端向服务器的21端口发起控制连接的建立请求&lt;sub&gt;客户端端口为X(&amp;gt;1024)，然后监听X端口&lt;/sub&gt;&lt;code&gt;SYN&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务器21端口响应连接&lt;sub&gt;服务器连接的是客户端的X端口&lt;/sub&gt;&lt;code&gt;SYN+ACK&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;客户端响应&lt;sub&gt;使用X端口&lt;/sub&gt;服务器21端口，控制连接建立&lt;sub&gt;每60秒发送keeplive报文保持控制层面连接&lt;/sub&gt;&lt;code&gt;ACK，控制层面3次握手，连接建立成功。如果有认证则进行认证&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;客户端通过控制连接发送PORT命令&lt;sub&gt;使用X端口&lt;/sub&gt;，将&lt;strong&gt;客户端数据连接的临时端口号X+1&lt;/strong&gt;告诉服务器。&lt;/li&gt;
&lt;li&gt;服务器的20号端口与客户端建立起数据连接&lt;code&gt;也需要3次握手&lt;/code&gt;&lt;br&gt;
&lt;code&gt;传输完数据之后，数据连接会断开，但是控制层面的连接不会断开。如果再次进行数据传输，则重新通过PORT命令发送临时端口号X+2，即每次数据传输都需要控制层面发送数据端口号，且端口号递增&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-被动模式&#34;&gt;2. 被动模式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613486174049.png&#34; alt=&#34;被动模式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;服务器监听21端口&lt;/li&gt;
&lt;li&gt;客户端发起控制连接的建立请求&lt;sub&gt;使用端口X&lt;/sub&gt;，服务器响应连接，控制连接建立&lt;code&gt;3次握手建立连接&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;客户端通过控制连接发送命令字PASV，告知服务器处于被动模式&lt;/li&gt;
&lt;li&gt;服务器回应，将&lt;strong&gt;服务器数据连接的临时端口号Y&lt;/strong&gt;告诉客户端&lt;/li&gt;
&lt;li&gt;客户端主动&lt;sub&gt;客户端使用端口X+1&lt;/sub&gt;连接服务器的临时数据端口Y进行数据传输&lt;code&gt;数据连接也是3次握手&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;主动模式下，服务器的数据端口号为20，客户端的端口号递增；被动模式下，服务器的数据端口号随机，客户端的端口号递增&lt;/code&gt;&lt;br&gt;
&lt;code&gt;主动模式和被动模式控制连接和数据连接均是3次握手，没有区别，主要区别在于控制连接建立之后协商服务器使用数据端口号为多少时有区别，主动模式固定20，被动模式随机&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于防火墙&#34;&gt;关于防火墙&lt;/h2&gt;
&lt;p&gt;主动模式&lt;strong&gt;对服务器的管理有利，但对客户端的管理不利&lt;/strong&gt;。因为服务器企图与客户端的高位随机端口建立连接，而这个端口很有可能&lt;strong&gt;被客户端的防火墙阻塞掉&lt;/strong&gt;，因此主动模式下要设置客户端的防火墙。&lt;br&gt;
被动模式&lt;strong&gt;对客户端的管理有利，但对服务器端的管理不利&lt;/strong&gt;。因为客户端要与服务器端建立两个连接，其中一个连到一个高位随机端口，而这个端口很有可能&lt;strong&gt;被服务器端的防火墙阻塞掉&lt;/strong&gt;，因此被动模式下要设置服务端的防火墙。&lt;code&gt;服务端可以指定端口范围来减小服务器高位端口的暴露。这样，不在这个范围的任何端口会被服务器的防火墙阻塞，虽然没有消除所有针对服务器的危险，但它大大减少了危险&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;ALG&lt;/strong&gt;：应用层网关，也叫应用层防火墙或应用层代理防火墙&lt;br&gt;
假设客户端在私网，服务器在公网，会有什么情况？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;控制连接建立&lt;/strong&gt;&lt;br&gt;
客户端之后有防火墙，默认是有NAT的功能，NAT最多工作在4层， TCP以上的都不能识别了，防火墙可以把私网的源地址跟端口号转变成公网的，然后跟公网的服务器建立连接，所以&lt;strong&gt;控制连接建立没有问题&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据连接建立&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;2.1 主动模式：&lt;br&gt;
通过Port消息发送给服务器的是私网的IP和端口，这个IP和端口没有做NAT映射，所以服务器无法连接内网客户端。但是在防火墙上开启NAT的ALG后&lt;code&gt;nat alg ftp enable&lt;/code&gt;，就可以识别Port消息的源地址和源端口号，会将该端口号添加到NAT映射表中，服务端主动连接客户端就可以成功建立数据连接&lt;br&gt;
2. 2 被动模式：&lt;br&gt;
被动模式不需要开启ALG，因为服务器是通过控制连接发送的服务器地址和数据端口，然后是客户端主动发起连接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;如果FTP服务器在内网，客户端在公网，那么控制连接建立正常，主动模式数据连接也不会有问题（因为在服务器在防火墙之内主动发起连接）&lt;br&gt;
&lt;strong&gt;但是被动模式数据连接会出现问题&lt;/strong&gt;，因为客户端主动连接服务器的高位端口，这个端口没有在NAT映射表中（服务端没有通过此端口主动发起过连接，所以不再NAT映射表中），或者会被防火墙过滤掉&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;snmp&#34;&gt;SNMP&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;SNMP版本包括SNMPv1、SNMPv2c、SNMPv3&lt;/li&gt;
&lt;li&gt;SNMPv1和SNMPv2c
&lt;ol&gt;
&lt;li&gt;都是使用基于共同体名的认证，并且SNMP消息&lt;strong&gt;未采用加密传输&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SNMPv2c在SNMPv1的基础上增强的功能包括：支持更多的操作、支持更多的数据类型、提供更丰富的错误处理码和多种传输协议的支持&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;SNMPv3
&lt;ol&gt;
&lt;li&gt;包含SNMPv1、SNMPv2所有功能在内的体系框架&lt;/li&gt;
&lt;li&gt;增加包含验证服务和加密服务在内的全新安全机制，SNMPv3的安全性主要体现在数据安全和访问控制上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;snmp管理模型&#34;&gt;SNMP管理模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614422046810.png&#34; alt=&#34;管理模型&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
SNMP系统包括4部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;网络管理系统NMS（华为网管软件Esight作为NMS对设备进行管理）
&lt;ol&gt;
&lt;li&gt;是一个采用SNMP协议对网络设备进行管理/监视的系统，运行在NMS服务器上&lt;/li&gt;
&lt;li&gt;可向设备上的Agent发出请求，查询或修改一个或多个具体的参数值&lt;/li&gt;
&lt;li&gt;也可以接收Agent主动发送的Trap信息，以获知被管理设备当前的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;代理进程Agent
&lt;ol&gt;
&lt;li&gt;是被管理设备中的一个代理进程，用于维护被管理设备的信息数据并响应来自NMS的请求&lt;/li&gt;
&lt;li&gt;接收到NMS的请求信息后，通过MIB表完成相应指令后，并把操作结果响应给NMS&lt;/li&gt;
&lt;li&gt;当设备发生故障或者其它事件时，设备会通过Agent主动发送trap信息给NMS，向NMS报告设备当前的状态变化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;管理信息库MIB
&lt;ol&gt;
&lt;li&gt;指明了被管理设备所维护的变量（即能够被Agent查询和设置的信息）的数据库。MIB在数据库中定义了被管理设备的一系列属性：对象的名称、对象的状态、对象的访问权限和对象的数据类型等&lt;/li&gt;
&lt;li&gt;通过MIB，可以完成以下功能：
&lt;ol&gt;
&lt;li&gt;Agent通过get消息查询MIB，可以获知设备当前的状态信息&lt;/li&gt;
&lt;li&gt;Agent通过set消息修改MIB，可以设置设备的状态参数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;被管对象Management object
&lt;ol&gt;
&lt;li&gt;每一个设备可能包含多个被管理对象，被管理对象&lt;strong&gt;可以是&lt;/strong&gt;设备中的&lt;strong&gt;某个硬件&lt;/strong&gt;（如一块接口板），&lt;strong&gt;也可以是&lt;/strong&gt;某些硬件、软件（如路由选择协议）及其的配置参数的&lt;strong&gt;集合&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;报文&#34;&gt;报文&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Agent监听UDP端口161，NMS监听UDP端口162&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614424443820.png&#34; alt=&#34;SNMPv1/SNMPv2c&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;版本&lt;/strong&gt;：表示SNMP的版本，v1报文则对应字段值为0，v2c则为1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;团体名&lt;/strong&gt;：用于在Agent与NMS之间完成认证&lt;code&gt;团体名包括“可读”和“可写”两种，执行GetRequest、GetNextRequest操作时，采用“可读团体名”进行认证；执行Set操作时，则采用“可写团体名”认证&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;SNMPv1/SNMPv2c &lt;strong&gt;PDU&lt;/strong&gt;：包含PDU类型、请求标识符、变量绑定列表等信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SNMPv1/SNMPv2c规定了&lt;strong&gt;7种操作类型&lt;/strong&gt;，用来完成NMS和Agent之间的信息交换：&lt;br&gt;
&lt;code&gt;SNMPv1版本不支持GetBulk和Inform操作&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Get&lt;/strong&gt;：用于查询一个或多个参数值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GetNext&lt;/strong&gt;：按照字典顺序提取下一个参数值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set&lt;/strong&gt;：设置Agent的一个或多个参数值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Response&lt;/strong&gt;：GetRequest、GetNextRequest、SetRequest和GetBulkRequest四种操作的响应操作。Agent接收到来自NMS的Get/Set指令后，通过MIB完成相应的查询/修改操作，然后利用Response操作将信息回应给NMS&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Trap&lt;/strong&gt;：当被管理设备达到告警的触发条件时，会通过Agent&lt;strong&gt;主动向&lt;/strong&gt;NMS发送Trap消息，告知设备出现的异常情况&lt;code&gt;默认值，Trap报文的消息队列长度为100，Trap报文的生存时间为120秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GetBulk&lt;/strong&gt;：NMS对被管理设备的信息群查询&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Inform&lt;/strong&gt;：被管理设备&lt;strong&gt;主动向&lt;/strong&gt;NMS主动发送告警，与Trap告警不同的是，被管理设备发送Inform告警后，需要NMS回复InformResponse来进行确认&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614430231387.png&#34; alt=&#34;工作原理&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;NMS：向Agent发送Get、GetNext或Set请求报文时，报文中各字段的设置如下：
&lt;ol&gt;
&lt;li&gt;版本号为所使用的SNMP版本&lt;/li&gt;
&lt;li&gt;团体名
&lt;ol&gt;
&lt;li&gt;当请求报文为Get和GetNext时为public&lt;/li&gt;
&lt;li&gt;当请求报文为set时为private&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;PDU：PDU类型为Get、GetNext或Set类型，绑定变量填入MIB节点名sysContact&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Agent：首先对报文中携带版本号和团体名进行认证，认证成功后
&lt;ol&gt;
&lt;li&gt;如果是get或getnext操作，Agent根据请求查询MIB中的sysContact节点，得到sysContact的值并将其封装到Response报文中的PDU，向NMS发送响应&lt;/li&gt;
&lt;li&gt;如果是set操作，Agent根据请求设置管理变量在管理信息库MIB中对应的节点，设置成功后向&lt;br&gt;
NMS发送响应&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;SNMPv2c新增的操作&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614441158918.png&#34; alt=&#34;GetBulk和Inform&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GetBulk操作&lt;br&gt;
基于GetNext实现，相当于连续执行多次GetNext操作，在NMS上可以设置被管理设备在一次GetBulk报文交互时，执行GetNext操作的次数&lt;/li&gt;
&lt;li&gt;Inform操作&lt;br&gt;
Inform操作也是被管理设备向NMS主动发送告警，与trap告警不同的是，被管理设备发送Inform告警后，&lt;strong&gt;需要NMS进行接收确认&lt;/strong&gt;&lt;sub&gt;原因1&lt;/sub&gt;。如果被管设备&lt;strong&gt;没有收到确认&lt;/strong&gt;信息则将告警暂时&lt;strong&gt;保存在Inform缓存中，然后重复发送&lt;/strong&gt;&lt;sub&gt;原因2&lt;/sub&gt;，直到NMS确认收到该告警或重传达到最大次数，并且被管设备上会生成相应的告警日志，    因此，使用Inform告警可能会占用较多的系统资源&lt;code&gt;所以，现网中常用trap，很少用Inform&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;snmpv3&#34;&gt;SNMPv3&lt;/h2&gt;
&lt;h3 id=&#34;报文-2&#34;&gt;报文&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614442220218.png&#34; alt=&#34;SNMPv3&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;版本：SNMPv3对应字段值为2&lt;/li&gt;
&lt;li&gt;报头数据：主要包含消息&lt;strong&gt;发送者所能支持的最大消息尺寸、消息采用的安全模式&lt;/strong&gt;等描述内容&lt;/li&gt;
&lt;li&gt;安全参数：包含SNMP实体引擎的相关信息、&lt;strong&gt;用户名、认证参数、加密参数&lt;/strong&gt;等安全信息&lt;code&gt;v3的实现原理和v1/v2c基本一致，唯一的区别是v3增加了身份验证和加密处理&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;身份验证：身份验证是指Agent或NMS接到信息时首先必须&lt;strong&gt;确认信息是否来自有权限的NMS或Agent并且信息在传输过程中未被改变&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;加密：需要管理端和代理共享同一密钥来实现信息的加密和解密&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;snmp各版本比较&#34;&gt;SNMP各版本比较&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614443062868.png&#34; alt=&#34;SNMP各版本比较&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;snmp主机无法与网管连接排错&#34;&gt;SNMP主机无法与网管连接排错&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;检查主机和网管发送请求报文用的SNMP&lt;strong&gt;版本&lt;/strong&gt;是否相同&lt;code&gt;display snmp-agent sys-info&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;检查主机配置的&lt;strong&gt;团体名&lt;/strong&gt;&lt;code&gt;display snmp-agent commnity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对snmpv3来说，还要检查snmp&lt;strong&gt;用户组和用户信息配置&lt;/strong&gt;&lt;code&gt;display snmp-agent group&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;vrrp虚拟路由冗余协议&#34;&gt;VRRP（虚拟路由冗余协议）&lt;/h1&gt;
&lt;h2 id=&#34;基本概述&#34;&gt;基本概述&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614525687320.png&#34; alt=&#34;基本概述&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;能够在不改变组网的情况下，将多台路由器虚拟成一个虚拟路由备份（热备），通过配置虚拟路由的IP地址为默认网关，实现网关的备份&lt;/li&gt;
&lt;li&gt;VRRPv2仅适应IPv4网络，VRRPv3适应IPv4和IPv6网络&lt;/li&gt;
&lt;li&gt;只有一种报文，Advertisement报文&lt;sub&gt;将Master设备的优先级和状态通告给同一备份组的所有Backup设备&lt;/sub&gt;，其源地址为发送报文接口的主IP地址（不是虚拟IP地址），目的IP地址时224.0.0.18，目的MAC地址是00-00-5e-00-01/02-xx，协议号为112，TTL是255，属于3层协议&lt;/li&gt;
&lt;li&gt;术语：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;VRRP路由器&lt;/strong&gt;：运行VRRP协议的设备，它可能属于一个或多个虚拟路由器，如RouterA和RouterB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟路由器&lt;/strong&gt;：即VRRP备份组，&lt;strong&gt;由一个Master设备和多个Backup设备组成&lt;/strong&gt;，被当作一个共享局域网内主机的缺省网关。如RouterA和RouterB共同组成了一个虚拟路由器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;VRID&lt;/strong&gt;：虚拟路由器的标识。如RouterA和RouterB组成的虚拟路由器的VRID为1&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟IP地址&lt;/strong&gt;：虚拟路由器的IP地址，一个虚拟路由器可以有一个或多个IP地址，由用户配置。如RouterA和RouterB组成的虚拟路由器的虚拟IP地址为10.1.1.10/24&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IP地址拥有者&lt;/strong&gt;：如果一个VRRP设备&lt;strong&gt;将虚拟路由器IP地址作为真实的接口地址&lt;/strong&gt;，则&lt;strong&gt;该设备被称为IP地址拥有者&lt;/strong&gt;。如果IP地址拥有者是可用的，&lt;strong&gt;通常它将成为Master&lt;/strong&gt;。如RouterA，其接口的IP地址与虚拟路由器的IP地址相同，均为10.1.1.10/24，因此它是这个VRRP备份组的IP地址拥有者。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚拟MAC地址&lt;/strong&gt;：虚拟路由器&lt;strong&gt;根据虚拟路由器ID生成的MAC地址&lt;/strong&gt;。一个虚拟路由器拥有一个虚拟MAC地址，格式为：00-00-5E-00-01-{VRID}(VRRP for IPv4)；00-00-5E-00-02-{VRID}(VRRP for IPv6)，&lt;code&gt;Master路由器和Backup设备的组ID必须相同，原因为主设备用虚拟MAC响应ARP请求【STP的根设备==VRRP的Master，即确保VRRP的主和MSTP的主桥为一个设备，否则会造成2层的次优转发】&lt;/code&gt;，而不是接口的真实MAC地址。如RouterA和RouterB组成的虚拟路由器的VRID为1，因此这个VRRP备份组的MAC地址为00-00-5E-00-01-01&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主IP地址&lt;/strong&gt;：从接口的真实IP地址中选出来的一个主用IP地址，通常选择配置的第一个IP地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Master路由器承担转发报文；Backup设备只有在Master设备故障之后才变成Mater，承担转发任务&lt;/li&gt;
&lt;li&gt;主设备（Master路由器）选取原则：优先级越大越优；优先级相同的情况下，先配置的设备会成为Master&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;协议报文&#34;&gt;协议报文&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;v2报文结构&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614604784716.png&#34; alt=&#34;v2报文结构&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;v3报文结构&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614604793488.png&#34; alt=&#34;v3报文结构&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version：v2为2，v3为3&lt;/li&gt;
&lt;li&gt;Type：均为1，表示Advertisement报文&lt;/li&gt;
&lt;li&gt;VRID：虚拟路由器ID，取值范围是1～255&lt;/li&gt;
&lt;li&gt;Priority：Master设备在备份组中的优先级，取值范围是0～255&lt;code&gt;0表示设备停止参与VRRP备份组，用来使备份设备尽快成为Master设备，而不必等到计时器超时；255则保留给IP地址拥有者。缺省值是100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Count IP Addrs/Count IPvX Addr：备份组中虚拟IPv4或虚拟IPv6地址的个数&lt;/li&gt;
&lt;li&gt;Auth Type：VRRP报文的认证类型&lt;code&gt;v2独有字段，是为了兼容早期版本，VRRP认证并不能提高安全性&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;0无认证&lt;/li&gt;
&lt;li&gt;1明文认证&lt;/li&gt;
&lt;li&gt;2MD5认证&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Adver Int/Max Adver Int：VRRP通告报文的发送时间间隔，v2的单位是秒&lt;sub&gt;默认值为1&lt;/sub&gt;，v3的单位厘秒&lt;sub&gt;默认值为100&lt;/sub&gt;&lt;code&gt;但是默认值都是1秒时间&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Checksum：校验和&lt;/li&gt;
&lt;li&gt;IP Address/IPvX Address(es)：VRRP备份组的虚拟IPv4地址或者虚拟IPv6地址，所包含的地址数定义在Count IPvX Addrs字段&lt;/li&gt;
&lt;li&gt;Authentication Data：VRRP报文的认证字。&lt;code&gt;只有明文认证和MD5认证才用到该部分，对于其它认证方式，一律填0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;rsvd：保留字段，必须设置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vrrpv2和vrrpv3的主要区别&#34;&gt;VRRPv2和VRRPv3的主要区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;支持的网络类型不同：VRRPv3适用于IPv4和IPv6两种网络，而VRRPv2仅适用于IPv4网络&lt;/li&gt;
&lt;li&gt;认证功能不同：VRRPv3不支持认证功能，而VRRPv2支持认证功能&lt;/li&gt;
&lt;li&gt;发送通告报文的时间间隔的单位不同：VRRPv3支持的是厘秒级，而VRRPv2支持的是秒级，但默认间隔都是1秒&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工作原理-2&#34;&gt;工作原理&lt;/h2&gt;
&lt;h3 id=&#34;状态机&#34;&gt;状态机&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614607228051.png&#34; alt=&#34;状态机&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Initialize&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;该状态为VRRP&lt;strong&gt;不可用状态&lt;/strong&gt;，在此状态时设备&lt;strong&gt;不会对VRRP报文做任何处理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通常刚配置VRRP时或设备检测到故障时会进入Initialize状态&lt;/li&gt;
&lt;li&gt;收到接口Up的消息后
&lt;ol&gt;
&lt;li&gt;如果设备的&lt;strong&gt;优先级为255，则直接成为Master设备&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果设备的优先级&lt;strong&gt;小于255，则会先切换至Backup状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Backup&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;接收Master设备发送的VRRP通告报文&lt;/strong&gt;，判断Master设备的状态是否正常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不响应&lt;/strong&gt;对虚拟IP地址的ARP请求；&lt;strong&gt;不转发&lt;/strong&gt;目的mac为虚拟mac的报文；&lt;strong&gt;丢弃&lt;/strong&gt;目的IP地址为虚拟IP地址的IP报文&lt;code&gt;备份状态的唯一工作就是时刻监控者Master的状态是否正常，一旦不正常立马切换&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;收到Advertisement报文：
&lt;ol&gt;
&lt;li&gt;如果收到&lt;strong&gt;优先级和自己相同或者比自己大的报文&lt;/strong&gt;，则重置&lt;strong&gt;Master_Down_Interval定时器&lt;/strong&gt;，&lt;strong&gt;不进一步比较IP地址&lt;/strong&gt;。&lt;br&gt;
Master_Down_Interval定时器，Backup设备在该定时器超时后仍未收到通告报文，则会转换为Master状态，计算公式为&lt;code&gt;Master_Down_Interval=(3* Advertisement_Interval) + Skew_time，其中偏移时间（也叫切换时间，是主备切换的时间，优先级越高，切换时间越小）Skew_Time=(256–Priority)/256&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果收到&lt;strong&gt;比自己优先级小的报文&lt;/strong&gt;时，
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;本质是切换&lt;/code&gt;该报文优先级是0，则&lt;strong&gt;定时器时间设置为Skew_time&lt;/strong&gt;（偏移时间）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;本质是抢占或者选举&lt;/code&gt;该报文优先级&lt;strong&gt;不是0&lt;/strong&gt;，丢弃报文，立刻&lt;strong&gt;成为Master&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Master&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定时发送VRRP通告报文&lt;/strong&gt;&lt;code&gt;用来维护自身Master的地位&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;周期性(120秒)发送免费ARP报文， 刷新下游设备的MAC地址表&lt;code&gt;使网络内各主机知道虚拟IP地址所对应的虚拟MAC地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用虚拟mac来响应对虚拟IP的ARP请求；转发目的MAC为虚拟MAC的IP报文；如果它是这个虚拟IP地址的拥有者，则&lt;strong&gt;接收目的IP地址为虚拟IP地址的IP报文&lt;/strong&gt;，否则，丢弃这个IP报文&lt;code&gt;即只有优先级为255时才会接收目的IP为虚拟IP的IP报文&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;收到Advertisement报文：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;本质是抢占&lt;/code&gt;如果收到&lt;strong&gt;比自己优先级大&lt;/strong&gt;的报文，立即&lt;strong&gt;成为Backup&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;本质是选举，此时会比较IP大小&lt;/code&gt;如果收到&lt;strong&gt;与自己优先级相等&lt;/strong&gt;的VRRP报文&lt;strong&gt;且对端接口IP大于本地接口IP地址&lt;/strong&gt;，立即&lt;strong&gt;成为Backup&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;工作过程&#34;&gt;工作过程&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;【重要声明】：优先级0和255是不可以手动设置的，只有虚拟IP和接口IP为同一个IP地址时，该设备的优先级会自动调为255。Master设备要退出该VRRP时，会发送优先级为0的VRRP通告报文&lt;/code&gt;&lt;br&gt;
&lt;code&gt;工作过程的两个重点：1.Master设备的选举；2. Master设备状态的通告&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VRRP备份组中的设备根据优先级选举出Master，
&lt;ol&gt;
&lt;li&gt;Master设备通过&lt;strong&gt;发送免费ARP报文&lt;/strong&gt;，将虚拟MAC地址通知给与它连接的设备或者主机，从而&lt;strong&gt;承担报文转发任务&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Master设备&lt;strong&gt;周期性向&lt;/strong&gt;备份组内&lt;strong&gt;所有Backup设备&lt;/strong&gt;发送VRRP&lt;strong&gt;通告报文&lt;/strong&gt;，以公布其配置信息（优先级等）和工作状况&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;Master设备&lt;/strong&gt;出现&lt;strong&gt;故障&lt;/strong&gt;，VRRP备份组中的Backup设备将&lt;strong&gt;根据优先级重新选举新的Master&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;VRRP备份组状态&lt;strong&gt;切换时&lt;/strong&gt;，Master设备由一台设备切换为另外一台设备，&lt;strong&gt;新的Master设备&lt;/strong&gt;会立即发送携带虚拟路由器的&lt;strong&gt;虚拟MAC地址和虚拟IP&lt;/strong&gt;地址信息的&lt;strong&gt;免费ARP报文&lt;/strong&gt;，&lt;strong&gt;刷新&lt;/strong&gt;与它连接的主机或设备中的&lt;strong&gt;MAC表项&lt;/strong&gt;，从而把用户流量引到新的Master设备上来，&lt;strong&gt;整个过程对用户完全透明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;原Master设备故障&lt;strong&gt;恢复时&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;若&lt;strong&gt;该设备为IP地址拥有者（即优先级为255）&lt;/strong&gt;，将直接切换至&lt;strong&gt;Master状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若该设备优先级&lt;strong&gt;小于255&lt;/strong&gt;，将首先切换至&lt;strong&gt;Backup状态&lt;/strong&gt;，且其优先级恢复为故障前配置的优先级&lt;/li&gt;
&lt;li&gt;Backup设备的&lt;strong&gt;优先级高于Master设备时&lt;/strong&gt;，由Backup设备的工作方式（抢占方式和非抢占方式）决定是否重新选举Master
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;抢占模式(默认模式)&lt;/strong&gt;：Backup设备主动切换成Master&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非抢占模式&lt;/strong&gt;：Backup设备不做任何改变&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;重要功能1master设备的选举&#34;&gt;重要功能1：Master设备的选举&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优先级越高&lt;/strong&gt;，则越有&lt;strong&gt;可能&lt;/strong&gt;成为Master设备&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;刚创建的VRRP设备为Initialize状态，收到接口Up的消息后
&lt;ol&gt;
&lt;li&gt;如果&lt;strong&gt;优先级为255&lt;/strong&gt;，则直接成为Master设备&lt;/li&gt;
&lt;li&gt;如果设备的优先级&lt;strong&gt;小于255&lt;/strong&gt;，则会先切换至&lt;strong&gt;Backup状态&lt;/strong&gt;，待Master_Down_Interval定时器&lt;strong&gt;超时后再切换至Master状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;切换至Master状态的后&lt;strong&gt;通过VRRP通告报文&lt;/strong&gt;的获取其他设备的优先级，进行Master的选举：
&lt;ol&gt;
&lt;li&gt;其他设备的优先级&lt;strong&gt;高于或等于自己的优先级&lt;/strong&gt;，则&lt;strong&gt;切换回Backup状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其他设备的优先级&lt;strong&gt;低于自己的优先级&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;抢占方式&lt;/strong&gt;：&lt;strong&gt;保持Master状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非抢占方式&lt;/strong&gt;：&lt;strong&gt;切换回Backup状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;多个&lt;/strong&gt;VRRP设备&lt;strong&gt;同时切换到Master状态&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;优先级最高&lt;/strong&gt;的VRRP设备成为的&lt;strong&gt;Master设备&lt;/strong&gt;，其他的切换成Backup状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级相同&lt;/strong&gt;时，VRRP设备上&lt;strong&gt;VRRP备份组所在接口主IP地址较大的成为Master设备&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果创建的VRRP设备为IP地址拥有者&lt;code&gt;即虚拟IP和接口IP为同一个IP&lt;/code&gt;，收到接口Up的消息后，直接切换至&lt;strong&gt;Master状态&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;重要功能2master设备状态的通告&#34;&gt;重要功能2：Master设备状态的通告&lt;/h4&gt;
&lt;p&gt;Master设备周期性地发送VRRP通告报文公布其配置信息（优先级等）和工作状况，Backup设备通过接收到VRRP报文的情况来判断Master设备是否工作正常&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当&lt;strong&gt;Master设备主动放弃Master地位&lt;/strong&gt;（如Master设备退出备份组）时，会发送&lt;strong&gt;优先级为0的通告报文&lt;/strong&gt;，用来使Backup设备快速切换成Master设备，而不用等到Master_Down_Interval定时器超时&lt;/li&gt;
&lt;li&gt;当&lt;strong&gt;Master设备发生网络故障而不能发送通告报文&lt;/strong&gt;的时候，Backup设备并不能立即知道其工作状况，等到Master_Down_Interval定时器超时后，才会认为Master设备无法正常工作，从而将状态切换为Master&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多网关负载分担&#34;&gt;多网关负载分担&lt;/h2&gt;
&lt;p&gt;多个VRRP备份组同时承担业务，负载分担需要建立多个VRRP备份组，&lt;strong&gt;各备份组的Master设备不同&lt;/strong&gt;；同一台VRRP设备可以加入多个备份组，在不同的备份组中具有&lt;strong&gt;不同的优先级&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614613920675.png&#34; alt=&#34;多网关负载分担&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
VRRP备份组1：RouterA为Master设备，RouterB为Backup设备&lt;br&gt;
VRRP备份组2：RouterB为Master设备，RouterA为Backup设备&lt;br&gt;
一部分用户将VRRP备份组1作为网关，另一部分用户将VRRP备份组2作为网关，这样既可实现对业务流量的负载分担，同时，也起到了相互备份的作用&lt;/p&gt;
&lt;h2 id=&#34;监控上行链路的方法&#34;&gt;监控上行链路的方法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614614021072.png&#34; alt=&#34;监控上行链路的方法&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;【本质】：检测到故障后降低Master优先级，通知备份组重新选举Master；故障恢复后，回复原Master设备的优先级，如果支持抢占则重新选举Master&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-vrrp与接口状态联动实现vrrp主备切换&#34;&gt;1. VRRP与接口状态联动实现VRRP主备切换&lt;/h3&gt;
&lt;p&gt;直接&lt;strong&gt;用track命令&lt;/strong&gt;联动上行链路，上行链路出现问题时&lt;strong&gt;优先级降低&lt;/strong&gt;，恢复时优先级增高&lt;/p&gt;
&lt;h3 id=&#34;2-vrrp与路由联动监视上行链路快慢依赖于路由协议&#34;&gt;2. VRRP与路由联动监视上行链路（快慢依赖于路由协议）&lt;/h3&gt;
&lt;p&gt;使用VRRP&lt;strong&gt;监控设备上行转发路径路由条目&lt;/strong&gt;，当上行转发&lt;strong&gt;路由条目撤销或是变为非活跃状态&lt;/strong&gt;，通知VRRP备份组降低Master设备优先级，触发主备切换。&lt;br&gt;
上行链路故障恢复时，原Master设备在备份组中的优先级将恢复原来的值，重新抢占成为Master，继续承担流量转发的业务。&lt;br&gt;
联动路由时的链路&lt;strong&gt;切换时间依赖于VRRP所联动路由协议的收敛速度&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-vrrp与bfd联动监视上行链路最快&#34;&gt;3. VRRP与BFD联动监视上行链路（最快）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;首先在链路上创建一个BFD会话，然后用track与BFD会话绑定即可&lt;/code&gt;&lt;br&gt;
通过在Master设备上&lt;strong&gt;配置VRRP与BFD联动&lt;/strong&gt;，&lt;strong&gt;使用BFD会话检测Master设备上行链路状态&lt;/strong&gt;，当BFD检测到上行链路故障时，及时通知VRRP备份组降低Master设备优先级，触发主备切换。&lt;br&gt;
上行链路故障恢复时，原Master设备在备份组中的优先级将恢复原来的值，重新抢占成为Master，继续承担流量转发的业务。&lt;br&gt;
BFD可以&lt;strong&gt;实现毫秒级的故障检测&lt;/strong&gt;，联动BFD可以快速地检测故障，从而使主备切换速度更快。&lt;/p&gt;
&lt;h3 id=&#34;4-vrrp与nqa联动监视上行链路依赖与ping的速度&#34;&gt;4. VRRP与NQA联动监视上行链路（依赖与ping的速度）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;首先在链路上创建一个类型为ICMP的NQA，然后用track与该NQA绑定即可，其作用相当于去ping对端地址，ping不通时通知VRRP&lt;/code&gt;&lt;br&gt;
通过在Master设备上&lt;strong&gt;配置VRRP联动NQA&lt;/strong&gt;，使用NQA测试例检测设备上行链路状态，当NQA检测到上行链路故障时，通知VRRP备份组降低Master设备优先级，触发主备切换。&lt;br&gt;
上行链路故障恢复时，原Master设备在备份组中的优先级将恢复原来的值，重新抢占成为Master，继续承担流量转发的业务。&lt;/p&gt;
&lt;h2 id=&#34;心跳线&#34;&gt;心跳线&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614615285146.png&#34; alt=&#34;心跳线&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;当使用三层交换机做VRRP时，&lt;strong&gt;为防止链路VRRP协议报文所经过的链路不通或不稳定和来回路径不一致&lt;/strong&gt;，可以在SwitchA和SwitchB之间部署一条心跳线，该心跳线&lt;strong&gt;属于二层链路&lt;/strong&gt;，且允许相关VlanIF接口报文通过&lt;/li&gt;
&lt;li&gt;为&lt;strong&gt;防止环路&lt;/strong&gt;还需部署STP这样的&lt;strong&gt;二层破环协议&lt;/strong&gt;，且保证&lt;strong&gt;Master设备为STP协议中的根桥&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;vrrp和eth-trunk的区别&#34;&gt;VRRP和Eth-trunk的区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;vrrp主要是备份；eth-trunk主要是负载&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;vrrp利用率低。两条上联线路正常的话只用一条，而eth-trunk两条都跑流量&lt;/li&gt;
&lt;li&gt;vrrp需要配合STP，所以需要一定的收敛时间&lt;/li&gt;
&lt;li&gt;做eth-trunk一般核心交换机都采用集群方式，相当于一台设备，所以配置管理方便，并且两台核心交换机之间的互联带宽更高，主备交换机切换时间很短&lt;/li&gt;
&lt;li&gt;使用场景区分：有二台核心，要和接入做双机热备，但不支持堆叠或集群，这时候只能用VRRP+STP了，不是用Eth-Trunk。如果核心支持堆叠或集群的话，这时候核心和接入就做Eth-Trunk了，而不用VRRP了，因为核心堆叠后就成一台设备了，二台设备之间的双链路，肯定用Eth-Trunk更好。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bfd双向转发检测&#34;&gt;BFD(双向转发检测)&lt;/h1&gt;
&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;
&lt;p&gt;用于快速检测设备之间的通信故障，并在出现故障时通知上层应用&lt;br&gt;
&lt;strong&gt;现有检测机制&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过硬件检测信号，如SDH告警，检测链路硬件故障，优点是快速检测故障&lt;/li&gt;
&lt;li&gt;如果无法通过硬件信号检测故障，通常采用路由协议的Hello报文机制&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;以上检测机制存在的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;并不是所有的介质都能够提供硬件检测&lt;/li&gt;
&lt;li&gt;路由协议的Hello报文机制检测到故障所需时间比较长，超过1秒钟，当数据达到吉比特速率级时，会造成大量数据丢失&lt;/li&gt;
&lt;li&gt;在三层网络中，Hello报文检测机制无法针对所有路由协议来检测故障，如：静态路由&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BFD用于检测设备之间的通信故障，BFD&lt;strong&gt;对系统间的、同一路径上的一种数据协议的连通性进行检测&lt;/strong&gt;，这条路径可以是&lt;strong&gt;物理链路或逻辑链路，包括隧道&lt;/strong&gt;，可以把BFD看作是系统提供的一种服务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上层应用向BFD提供检测地址、检测时间等参数&lt;/li&gt;
&lt;li&gt;BFD根据这些信息创建、删除或修改BFD会话，并把会话状态通告给上层应用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;BFD提供如下功能&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对相邻设备之间的通道&lt;strong&gt;提供轻负荷、快速故障检测&lt;/strong&gt;，这些故障包括&lt;strong&gt;接口故障、数据链路故障、设备本身故障等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;提供一个单一的机制，能够用来&lt;strong&gt;对任何媒介、任何协议层进行实时地检测&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;BFD本身并&lt;strong&gt;没有邻居发现机制&lt;/strong&gt;，而是&lt;strong&gt;靠被服务的上层应用通知其邻居信息以建立会话&lt;/strong&gt;。会话建立后会周期性地快速发送BFD报文，如果在检测时间内没有收到BFD报文则认为该双向转发路径发生了故障，通知被服务的上层应用进行相应的处理&lt;/p&gt;
&lt;h2 id=&#34;检测机制&#34;&gt;检测机制&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;异步模式&lt;/strong&gt;：BFD的主要操作模式为异步模式，系统之间&lt;strong&gt;相互周期性地发送&lt;/strong&gt;BFD控制报文，如果某个系统连续几个报文都没有接收到，就认为此BFD会话的状态是Down&lt;/p&gt;
&lt;h2 id=&#34;检测的链路类型&#34;&gt;检测的链路类型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614690919412.png&#34; alt=&#34;检测的链路类型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;报文-3&#34;&gt;报文&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614691025147.png&#34; alt=&#34;报文&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;vers：版本，值为1&lt;/li&gt;
&lt;li&gt;Diag：诊断字，标明本地BFD系统最近一次会话状态发生变化的原因
&lt;ol&gt;
&lt;li&gt;0无诊断信息&lt;/li&gt;
&lt;li&gt;1检测时间超时&lt;/li&gt;
&lt;li&gt;2Echo功能失效&lt;/li&gt;
&lt;li&gt;4转发面复位&lt;/li&gt;
&lt;li&gt;3、5、6、7、8表示邻居会话、路径、级联路径、Admin、反向级联路径Down&lt;/li&gt;
&lt;li&gt;9-31预留&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Sta：本地状态
&lt;ol&gt;
&lt;li&gt;0管理状态Down&lt;/li&gt;
&lt;li&gt;1运行状态Down&lt;/li&gt;
&lt;li&gt;2初始状态&lt;/li&gt;
&lt;li&gt;3正常UP状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;P\F\C\A\D\M：参数改变后是否需要邻居确认/是否发送响应P标志置位的回应报文/转发和控制分离标志/认证标识/查询请求/为BFD将来支持点对多点扩展而设的预留位&lt;/li&gt;
&lt;li&gt;Detect Mult：检测超时倍数，用于检测方计算检测超时时间&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;会话建立方式&#34;&gt;会话建立方式&lt;/h2&gt;
&lt;p&gt;静态和动态创建BFD会话的主要区别在于&lt;strong&gt;本地标识符和远端标识符的配置方式不同&lt;/strong&gt;，静态的需要手动指定，而动态则自己产生&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态建立BFD会话&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;静态手工指定标识符&lt;/strong&gt;：通过命令行&lt;strong&gt;手工配置BFD会话参数&lt;/strong&gt;，&lt;strong&gt;包括配置本地标识符和远端标识符等&lt;/strong&gt;，然后手工下发BFD会话建立请求，配置步骤：
&lt;ol&gt;
&lt;li&gt;启用BFD&lt;/li&gt;
&lt;li&gt;建立BFD会话的名称及源目IP&lt;/li&gt;
&lt;li&gt;创建本地标识符和远端标识符&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;静态自协商标识符&lt;/strong&gt;：手工&lt;strong&gt;创建BFD会话&lt;/strong&gt;，但&lt;strong&gt;不需要配置本地标识符和远端标识符&lt;/strong&gt;，本地标识符和远端标识符通过会话协商获得&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态建立BFD会话&lt;/strong&gt;&lt;code&gt;动态BFD具有较高的灵活性，适用于全网都对可靠性要求较高的网络&lt;/code&gt;&lt;br&gt;
动态BFD会话是指由路由协议动态触发BFD会话建立。动态BFD中，本地标识符是动态分配的，远端标识符从对端的BFD报文中获取
&lt;ol&gt;
&lt;li&gt;动态分配本地标识符：当应用程序触发动态创建BFD会话时，系统分配属于动态会话标识符区域的值作为BFD会话的本地标识符&lt;/li&gt;
&lt;li&gt;自学习远端标识符：当BFD会话的一端收到远端标识符为0的BFD控制报文时，根据四元组（源地址、目的地址、出接口、VPN索引）判断该报文是否与本地BFD会话匹配，如果匹配，则学习接收到的BFD报文中本地标识符的值，即获取远端标识符，配置步骤：
&lt;ol&gt;
&lt;li&gt;启用BFD&lt;/li&gt;
&lt;li&gt;建立BFD会话的名称及源目IP即可，不用创建标识符&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;会话管理&#34;&gt;会话管理&lt;/h2&gt;
&lt;p&gt;BFD会话有&lt;strong&gt;四种状态&lt;/strong&gt;：&lt;code&gt;会话状态变化通过BFD报文的State字段传递&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AdminDown：会话处于管理性Down状态&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Down：会话处于Down状态或刚刚创建&lt;code&gt;1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Init：已经能够与对端系统通信，本端希望使会话进入Up状态&lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Up：会话已经建立成功&lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614693995968.png&#34; alt=&#34;会话管理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;BFD状态机的建立和拆除都采用三次握手机制，以确保两端系统都能知道状态的变化&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DeviceA和DeviceB各自启动BFD状态机，初始状态为Down，发送&lt;strong&gt;状态为Down的BFD报文&lt;/strong&gt;。对于静态配置BFD会话，报文中的远端标识符是用户指定的；对于动态创建BFD会话，远端标识符的值是0&lt;/li&gt;
&lt;li&gt;DeviceB收到状态为Down的BFD报文后，状态切换至Init，并发送状态为Init的BFD报文&lt;code&gt;DeviceB本地BFD状态为Init后，不再处理接收到的状态为Down的报文&lt;/code&gt;；DeviceA的BFD状态变化同DeviceB，并且向DeviceB发送状态为Init的报文&lt;/li&gt;
&lt;li&gt;DeviceB收到状态为Init的BFD报文后，本地状态切换至Up；DeviceA的BFD状态变化同DeviceB。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;联动功能&#34;&gt;联动功能&lt;/h2&gt;
&lt;p&gt;联动功能由&lt;strong&gt;检测模块、Track和应用模块&lt;/strong&gt;三部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监测模块：负责对链路状态、网络性能等进行监测，并将探测结果通知给Track模块&lt;/li&gt;
&lt;li&gt;Track模块：收到监测模块的探测结果后，及时改变Track项的状态，并通知应用模块&lt;/li&gt;
&lt;li&gt;应用模块：根据Track项的状态，进行相应的处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1-与静态路由的联动&#34;&gt;1. 与静态路由的联动&lt;/h3&gt;
&lt;p&gt;先创建BFD会话，然后在写静态路由时与创建的BFD会话名称绑定即可，如果会话出现问题，静态路由则不再加IP路由表&lt;br&gt;
在静态路由与BFD联动应用中，如果&lt;strong&gt;对端设备不支持静态BFD会话，而采用动态BFD会话&lt;/strong&gt;，此时本端设备既要与之互通，又要能够实现静态路由与BFD联动时，必须使用&lt;strong&gt;静态自协商标识符的BFD会话建立方式&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-与igpospf-isis-rip的联动&#34;&gt;2. 与IGP（ospf、isis、rip）的联动&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;使用动态建立BFD会话&lt;/code&gt;&lt;br&gt;
直接在IGP进程下启用BFD会话即可，邻居出现问题立马收敛&lt;/p&gt;
&lt;h3 id=&#34;3-与bgp的联动&#34;&gt;3. 与BGP的联动&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;使用动态建立BFD会话&lt;/code&gt;&lt;br&gt;
在BGP进程下指定peer时绑定BFD会话，邻居出现问题立马收敛&lt;/p&gt;
&lt;h3 id=&#34;4-与vrrp的联动&#34;&gt;4. 与VRRP的联动&lt;/h3&gt;
&lt;p&gt;先创建BFD会话，然后在创建VRRP时与创建的BFD会话名称绑定即可，如果会话出现问题，则会更改优先级&lt;/p&gt;
&lt;h3 id=&#34;5-bfd的单臂回声功能bfd-echo&#34;&gt;5. BFD的单臂回声功能（BFD Echo）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;一台设备支持BFD功能，另一台设备不支持BFD功能，只支持基本的网络层转发的情况下使用&lt;/code&gt;&lt;br&gt;
在支持BFD功能的设备上创建单臂回声功能的BFD会话，发送特殊报文，不支持BFD功能的设备接收到该报文后直接将其环回到支持BFD的设备上，从而实现转发链路的连通性检测功能&lt;code&gt;特殊报文：IP头中的源、目IP都是本端设备的IP地址，BFD协议报文中的本地和远端标识符相同&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;BFD Echo包括&lt;strong&gt;被动Echo和单臂Echo&lt;/strong&gt;，两种功能&lt;strong&gt;检测机制一样且只适用于单跳IP链路&lt;/strong&gt;，但是适用的场景不同&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;被动Echo功能&lt;/strong&gt;：两台设备&lt;strong&gt;直连&lt;/strong&gt;，且已经建立了&lt;strong&gt;异步模式&lt;/strong&gt;的BFD会话，其中&lt;strong&gt;一台&lt;/strong&gt;设备上使能&lt;strong&gt;主动Echo&lt;/strong&gt;功能，&lt;strong&gt;另一台&lt;/strong&gt;设备上使能&lt;strong&gt;被动Echo&lt;/strong&gt;功能后，两台设备会&lt;strong&gt;进入异步Echo&lt;/strong&gt;模式，&lt;strong&gt;分别向对端发送BFD报文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单臂Echo功能&lt;/strong&gt;：两台设备直连，其中&lt;strong&gt;一台&lt;/strong&gt;设备&lt;strong&gt;支持BFD&lt;/strong&gt;功能，&lt;strong&gt;另一台&lt;/strong&gt;设备&lt;strong&gt;不支持BFD&lt;/strong&gt;功能，在&lt;strong&gt;支持BFD功能的设备&lt;/strong&gt;上&lt;strong&gt;创建单臂Echo&lt;/strong&gt;功能的BFD会话，当不支持BFD功能的设备接收到该BFD报文后，直接将该报文环回，从而达到快速检测链路的目的&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614696609553.png&#34; alt=&#34;BFD Echo会话与静态单跳会话的比较&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nqa网络质量分析&#34;&gt;NQA（网络质量分析）&lt;/h1&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;通过发送测试报文，对网络性能、网络提供的服务及服务质量进行分析，并为用户提供网络性能和服务质量的&lt;br&gt;
参数，如时延抖动、TCP连接时延、FTP连接时延和文件传输速率等。利用NQA的测试结果，用户可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;及时了解网络的性能状况，针对不同的网络性能，进行相应处理&lt;/li&gt;
&lt;li&gt;对网络故障进行诊断和定位&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;获取丰富的网络质量或性能数据&lt;/strong&gt;&lt;br&gt;
可获取端到端连通性和路径信息、链路性能（包括时延、抖动、丢包率）和网络服务响应时间等&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持多种测试类型&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;Ping：检测网络的连通性，例如ICMP测试&lt;/li&gt;
&lt;li&gt;Tracert：获取网络的路径信息，例如Trace测试&lt;/li&gt;
&lt;li&gt;Jitter：测量网络的性能，例如ICMP Jitter测试、UDP Jitter测试&lt;/li&gt;
&lt;li&gt;网络服务性能：检测网络中各类服务的性能，例如TCP测试、DNS测试&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持灵活的调度机制&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;启动方式：立即启动、指定时间启动、延时启动、每日定时启动&lt;/li&gt;
&lt;li&gt;结束方式：指定结束时间、延时结束、指定运行时间&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;支持联动功能&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;联动功能是指通过建立联动项，对当前所在测试组中的探测进行监测，&lt;strong&gt;当连续探测失败次数达到一定数目时，就触发其他模块联动&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;由应用模块、Track模块和监测功能模块三部分组成，&lt;strong&gt;Track模块&lt;/strong&gt;位于应用模块和监测功能模块之间，主要功能是屏蔽不同监测功能模块的差异，&lt;strong&gt;为应用模块提供统一的接口&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当监测项的状态发生变化时，监测功能模块通知Track模块，再由Track模块通知应用模块进行相应的处理&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614698125873.png&#34; alt=&#34;联动功能&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;p&gt;NQA客户端是发起NQA测试的设备，NQA测试组在客户端创建。&lt;br&gt;
NQA的&lt;strong&gt;基本测试方式为客户端向对端发送不同类型的测试报文&lt;/strong&gt;，根据对端是否回应报文以及报文的往返时间等参数，来判断协议的可用性和网络的性能&lt;br&gt;
在大多数的测试中，只需要配置NQA客户端&lt;code&gt;对于TCP、UDP Jitter测试，还需要在对端设备上配置NQA服务器&lt;/code&gt;，启动NQA测试后，每隔一段时间启动一次测试，测试的时间间隔可以由用户来设定。一次NQA测试由一次或多次连续的探测组成，探测的次数可以由用户来设定&lt;/p&gt;
&lt;h2 id=&#34;测试原理&#34;&gt;测试原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614699175233.png&#34; alt=&#34;测试原理&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送请求报文时，将当前系统时间t1作为测试报文的发送时间，向请求报文中打入时间戳，然后再发送给服务器端&lt;/li&gt;
&lt;li&gt;服务器端接收请求报文后，向客户端发送对应地响应报文&lt;/li&gt;
&lt;li&gt;客户端在接收到响应报文后，会再次读取系统的时间t2，向响应报文中打入时间戳&lt;/li&gt;
&lt;li&gt;根据请求报文&lt;strong&gt;发送时间t1与响应报文接收时间t2的时间差&lt;/strong&gt;，就可以得出报文的往返时间，也即&lt;strong&gt;时延&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;对于Jitter类测试，不仅NQA客户端需要在发送和接收报文时打时间戳，NQA服务器端在接收和发送报文时，也要读取自己的本地系统时间，打上时间戳。通过每次往返时间的差别，就能够计算出抖动时间&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;测试操作&#34;&gt;测试操作&lt;/h2&gt;
&lt;p&gt;在NQA客户端上进行如下操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使能NQA客户端功能&lt;/li&gt;
&lt;li&gt;创建测试组，根据测试类型进行相应测试参数的配置&lt;/li&gt;
&lt;li&gt;通过启动测试命令执行NQA测试&lt;/li&gt;
&lt;li&gt;通过显示命令或调试命令查看测试结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;测试类型&#34;&gt;测试类型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614699598610.png&#34; alt=&#34;测试类型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;1-icmp测试&#34;&gt;1. ICMP测试&lt;/h3&gt;
&lt;p&gt;用于&lt;strong&gt;检测源端到目的端的路由是否可达&lt;/strong&gt;，与Ping操作类似，但输出信息更为丰富，&lt;strong&gt;默认情况下能够保存最近5次的测试结果&lt;/strong&gt;，结果能够显示IP网络的&lt;strong&gt;连通性、丢包率、平均时延、最后一个报文正确接收的时间&lt;/strong&gt;等&lt;br&gt;
ICMP测试的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源端向目的端发送构造的ICMP Echo Request报文&lt;/li&gt;
&lt;li&gt;目的端收到报文后，直接回应ICMP Echo Reply报文给源端&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-trace测试&#34;&gt;2. Trace测试&lt;/h3&gt;
&lt;p&gt;与Tracert操作类似，通过检测网络路径上的每一跳，&lt;strong&gt;检测网络的连通性和报文的转发路径&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-tcp测试&#34;&gt;3. TCP测试&lt;/h3&gt;
&lt;p&gt;通过模拟TCP请求与目的端建立TCP连接，&lt;strong&gt;检测源端与目的端建立TCP连接的速度&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-dns测试&#34;&gt;4. DNS测试&lt;/h3&gt;
&lt;p&gt;DNS测试以UDP报文为承载，通过模拟DNS Client向指定的DNS服务器发送域名解析请求，根据域名解析是否成功及域名解析需要的时间，来&lt;strong&gt;判断DNS服务器是否可用以及域名解析速度&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-icmpudp-jitter测试&#34;&gt;5. ICMP/UDP Jitter测试&lt;/h3&gt;
&lt;p&gt;通过发送一系列ICMP/UDP报文，&lt;strong&gt;统计端到端时延的差值，得出网络传输数据的稳定性&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;6-ftp测试&#34;&gt;6. FTP测试&lt;/h3&gt;
&lt;p&gt;FTP测试以TCP报文为承载，用于&lt;strong&gt;检测是否可以与指定的FTP服务器建立连接&lt;/strong&gt;，可以&lt;strong&gt;检测&lt;/strong&gt;FTP服务器下载指定文件或向FTP服务器上载指定&lt;strong&gt;文件的速度&lt;/strong&gt;，以及FTP控制链接和数据链接两个阶段的&lt;strong&gt;响应速度&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;7-http测试&#34;&gt;7. HTTP测试&lt;/h3&gt;
&lt;p&gt;HTTP测试主要是测试客户端是否可以&lt;strong&gt;与指定的HTTP服务器建立连接&lt;/strong&gt;，从而判断该设备&lt;strong&gt;是否提供了HTTP服务以及建立连接的时间&lt;/strong&gt;&lt;br&gt;
HTTP测试提供三个阶段的响应速度：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DNS解析时间：客户端发送DNS报文给DNS服务器，DNS服务器将HTTP服务器域名解析为IP地址，DNS 解析报文返回到客户端所花费的总时间&lt;/li&gt;
&lt;li&gt;TCP建立连接时间：客户端与HTTP服务器通过TCP三次握手建立连接所用的时间&lt;/li&gt;
&lt;li&gt;交易时间：客户端发送Get或Post报文给HTTP服务器，响应报文到达客户端的时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8-dhcp测试&#34;&gt;8. DHCP测试&lt;/h3&gt;
&lt;p&gt;DHCP测试用于检测DHCP客户端与DHCP服务器之间&lt;strong&gt;建立连接&lt;/strong&gt;的时间以及DHCP客户端&lt;strong&gt;获得地址&lt;/strong&gt;的时间&lt;/p&gt;
&lt;h3 id=&#34;9-snmp测试&#34;&gt;9. SNMP测试&lt;/h3&gt;
&lt;p&gt;SNMP测试用于&lt;strong&gt;检测主机与SNMP Agent之间通信的速度&lt;/strong&gt;，以UDP报文为承载。&lt;br&gt;
SNMP测试的过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;源端向SNMP Agent发送要求获取系统时间的请求报文&lt;/li&gt;
&lt;li&gt;SNMP Agent收到报文，查询系统时间并构造回应报文，然后再把这个数据包发回到源端&lt;/li&gt;
&lt;li&gt;源端收到数据包后通过计算源端接收报文的时间和源端发送报文的时间的差，计算出源端与SNMP Agent之间通信的时间，从而清晰的反映出网络SNMP协议的性能状况&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bfd与nqa的区别&#34;&gt;BFD与NQA的区别&lt;/h2&gt;
&lt;p&gt;BFD用于检查链路的故障，可与各协议进行联合使用，从而达到网络的快速收敛。&lt;br&gt;
NQA主要用于检查上层协议的服务是否可用，可与各种协议联动，当然它也可以通过与ICMP协议的联动，从而检测链路是否可用，这个方式比BFD慢&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;urpf单播逆向路径转发&#34;&gt;URPF（单播逆向路径转发）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;主要功能是防止基于源IP地址欺骗的网络攻击行为&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;原理-2&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;拒绝服务DoS攻击是一种阻止连接服务的网络攻击，就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。&lt;br&gt;
URPF在&lt;strong&gt;FIB表中查找数据包的IP源地址是否与数据包的源接口相匹配&lt;/strong&gt;，如果没有匹配表项将丢弃该数据包，从而预防IP欺骗，特别是针对伪造IP源地址的DoS攻击非常有效。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614819845614.png&#34; alt=&#34;原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在DeviceA上伪造源地址为2.1.1.1的报文向DeviceB发起请求，DeviceB响应请求时将向真正的2.1.1.1，即DeviceC发送报文。这种非法报文对DeviceB和DeviceC都造成了攻击，如果在DeviceB上启用URPF严格检查，则DeviceB在收到源地址为2.1.1.1的报文时，URPF检查到以此报文源地址对应的接口与收到该报文的接口不匹配，报文会被丢弃&lt;/p&gt;
&lt;h2 id=&#34;工作模式&#34;&gt;工作模式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;出现两种工作模式的原因：路由不对称的情况下，即对端设备记录的路由路径不一样，此时使能URPF的设备可能丢弃合法报文&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;严格模式&lt;br&gt;
设备不仅要求&lt;strong&gt;报文源地址在FIB表中&lt;/strong&gt;存在相应表项，还要求&lt;strong&gt;接口匹配&lt;/strong&gt;才能通过URPF检查，适合用在&lt;strong&gt;路由对称的环境下&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;松散模式&lt;br&gt;
设备&lt;strong&gt;不检查接口&lt;/strong&gt;是否匹配，&lt;strong&gt;只要FIB表中存在&lt;/strong&gt;该报文源地址的路由，报文就可以通过，适合用在&lt;strong&gt;不能保证路由对称的环境下&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;h3 id=&#34;1-严格模式下的urpf应用&#34;&gt;1. 严格模式下的URPF应用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614820398612.png&#34; alt=&#34;严格模式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;AS1、AS2与AS3之间为单连接。在RouterC的Interface1接口和Interface2接口上配置URPF，可以保护AS3免受来自AS1和AS2的源地址欺骗攻击。&lt;/li&gt;
&lt;li&gt;如果AS1中的主机PCA伪造了一个源地址为2.2.2.2的报文，向AS3中的Server发送请求。RouterC在接收到这个报文后，检查其入接口是否匹配，发现源地址为2.2.2.2的报文应该从Interface2进入，则RouterC认为该报文源地址是伪造的，直接丢弃该报文。&lt;/li&gt;
&lt;li&gt;从AS2发向Server的正常报文，检查通过后，被正常的转发&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-松散模式下的urpf应用&#34;&gt;2. 松散模式下的URPF应用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;单宿主单ISP客户&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614820830541.png&#34; alt=&#34;单宿主单ISP客户&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
为了保证可靠性，某公司网络和某个ISP之间有两条连接，这时就不能够保证公司和ISP之间路由的对称性，&lt;strong&gt;必须使用URPF松散模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;多宿主多ISP客户&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614820999854.png&#34; alt=&#34;多宿主多ISP客户&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
公司与多个ISP连接，很难保证公司和两个ISP之间路由的对称性，必须使用URPF松散模式&lt;br&gt;
客户与多个ISP连接下的URPF可以具有以下应用：
&lt;ol&gt;
&lt;li&gt;如果用户希望&lt;strong&gt;某些特殊报文&lt;/strong&gt;任何情况都可以&lt;strong&gt;通过URPF的检查&lt;/strong&gt;，可以在&lt;strong&gt;利用ACL&lt;/strong&gt;指定这些特殊的源地址允许通过&lt;/li&gt;
&lt;li&gt;许多用户连接的设备可能只有一条&lt;strong&gt;缺省路由指向ISP&lt;/strong&gt;，需要配置&lt;strong&gt;允许匹配缺省路由&lt;/strong&gt;选项&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;nat网络地址转换&#34;&gt;NAT（网络地址转换）&lt;/h1&gt;
&lt;p&gt;NAT是将IP数据报文头中的IP地址转换为另一个IP地址的过程，主要用于实现内部网络（私有IP地址）访问外部网络（公有IP地址）的功能。Basic NAT是实现一对一的IP地址转换，而NAPT可以实现多个私有IP地址映射到同一个公有IP地址上。&lt;br&gt;
NAT技术可以解决以下问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IP地址短缺&lt;code&gt;Basic NAT不能解决此问题，只有NAPT才能解决此问题，因此Basic NAT不常用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;避免来自外网的攻击&lt;/li&gt;
&lt;li&gt;控制内网主机访问外网，同时也可以控制外网主机访问内网，解决了内网和外网不能互通的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;h3 id=&#34;1-basic-nat不常用&#34;&gt;1. Basic NAT（不常用）&lt;/h3&gt;
&lt;p&gt;一对一的地址转换，只转换IP地址，而不处理TCP/UDP协议的端口号，一个公网IP地址不能同时被多个私网用户使用&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614822203249.png&#34; alt=&#34;Basic NAT&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Router收到Host发送的访问Server的报文，其源IP地址为10.1.1.100&lt;/li&gt;
&lt;li&gt;Router从地址池中选取一个空闲的公网IP地址，建立与内网侧报文源IP地址间的NAT转换表项（正反向），并依据查找正向NAT表项的结果将报文转换后向公网侧发送，其源IP地址是1.1.1.1，目的IP地址是2.2.2.2&lt;/li&gt;
&lt;li&gt;Router收到公网侧的回应报文后，根据其目的IP地址查找反向NAT表项，并依据查表结果将报文转换后向私网侧发送，其源IP地址是2.2.2.2，目的IP地址是10.1.1.100&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-napt&#34;&gt;2. NAPT&lt;/h3&gt;
&lt;p&gt;并发的地址转换，多个内部地址映射到同一个公有地址上，通过使用“IP地址＋端口号”的形式进行转换，使多个私网用户可共用一个公网IP地址访问外网&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614822371095.png&#34; alt=&#34;NAPT&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Router收到内网侧Host发送的访问公网侧Server的报文。比如收到HostA报文的源地址是10.1.1.100，端口号1025&lt;/li&gt;
&lt;li&gt;Router从地址池中选取一对空闲的“公网IP地址+端口号”，建立与内网侧报文“源IP地址＋源端口号”间的NAPT转换表项（正反向），并依据查找正向NAPT表项的结果将报文转换后向公网侧发送。比如HostA的报文经Router转换后的报文源地址为1.1.1.1，端口号16384&lt;/li&gt;
&lt;li&gt;Router收到公网侧的回应报文后，根据其“目的IP地址＋目的端口号”查找反向NAPT表项，并依据查表结果将报文转换后向私网侧发送。比如Server回应Host A的报文经Router转换后，目的地址为10.1.1.100，端口号1025&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-nat-pt&#34;&gt;3. NAT-PT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;静态映射的NAT-PT机制&lt;/li&gt;
&lt;li&gt;动态映射的NAT-PT机制：需要建立地址池&lt;/li&gt;
&lt;li&gt;NAT-PT机制：不同的IPv6地址转换时，可以对应同一个IPv4地址，通过端口号来区分不同的IPv6主机，从而使多个IPv6主机能够共享一个IPv4地址完成转换&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;
&lt;p&gt;NAT实现主要包括：Easy IP、地址池NAT&lt;sub&gt;和EasyIP类似，只介绍EasyIP&lt;/sub&gt;、NAT Server 和静态 NAT/NAPT&lt;/p&gt;
&lt;h3 id=&#34;1-easy-ip&#34;&gt;1. Easy IP&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;内网访问外网，原理跟NAPT相同&lt;/code&gt;&lt;br&gt;
Easy IP可以利用&lt;strong&gt;访问控制列表&lt;/strong&gt;来&lt;strong&gt;控制哪些内部地址可以进行地址转换&lt;/strong&gt;，&lt;strong&gt;适合小型局域网&lt;/strong&gt;访问Internet的情况，即内部主机较少、出接口通过拨号方式获得临时公网IP地址以供内部主机访问Internet&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614822818001.png&#34; alt=&#34;Easy IP&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-nat-server&#34;&gt;2. NAT Server&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;外网访问内网，提前配置地址和端口的映射&lt;/code&gt;&lt;br&gt;
NAT具有“屏蔽”内部主机的作用，但有时内网需要向外网提供服务，比如提供WWW服务或者FTP服务。这种情况下需要内网的服务器不被“屏蔽”，外网用户可以随时访问内网服务器。&lt;br&gt;
当外网用户访问内网服务器时，它通过事先配置好的“公网IP地址+端口号”与“私网IP地址+端口号”间的映射关系，将服务器的“公网IP地址+端口号”根据映射关系替换成对应的“私网IP地址+端口号”&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614823003208.png&#34; alt=&#34;NAT Server&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-静态natnapt&#34;&gt;3. 静态NAT/NAPT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;静态NAT是指在进行NAT转换时，&lt;strong&gt;私网IP同公网IP是一对一&lt;/strong&gt;静态绑定的，静态NAT中的公网IP只会给唯一且固定的内网主机转换使用&lt;/li&gt;
&lt;li&gt;静态NAPT是指“私网IP+协议号+端口号”同“公网IP+协议号+端口号”是一对一静态绑定的，静态NAPT中的&lt;strong&gt;公网IP可以为多个私网IP使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;静态NAT/NAPT还支持将&lt;strong&gt;指定私网范围内的主机IP转换为指定的公网范围内的主机IP&lt;/strong&gt;，实现私网和公网的双向访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;nat-alg&#34;&gt;NAT ALG&lt;/h2&gt;
&lt;p&gt;NAT和NAPT只能对IP报文的头部地址和TCP/UDP头部的端口信息进行转换&lt;br&gt;
对于一些特殊协议，例如FTP，&lt;strong&gt;报文的数据部分可能包含IP地址信息或者端口信息&lt;/strong&gt;，这些内容不能被NAT转换，解决这些特殊协议的NAT转换的方法就是在NAT实现中&lt;strong&gt;使用应用层网关ALG功能&lt;/strong&gt;&lt;br&gt;
ALG是对特定的应用层协议进行转换，在对这些特定的应用层协议&lt;strong&gt;进行NAT转换过程中&lt;/strong&gt;，通过NAT的状态信息来&lt;strong&gt;改变封装在IP报文数据部分中的特定数据&lt;/strong&gt;，最终&lt;strong&gt;使应用层协议可以跨越不同范围运行&lt;/strong&gt;&lt;br&gt;
目前支持ALG功能的协议包括：DNS、FTP、SIP、PPTP和RTSP&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614823750833.png&#34; alt=&#34;NAT ALG&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他内容&#34;&gt;其他内容&lt;/h2&gt;
&lt;h3 id=&#34;1-dns-mapping&#34;&gt;1. DNS Mapping&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;私网用户&lt;/strong&gt;希望&lt;strong&gt;通过域名访问位于同一私网的内部服务器&lt;/strong&gt;，而&lt;strong&gt;DNS服务器却位于公网&lt;/strong&gt;。由于通常DNS响应报文中携带的是内部服务器的公网IP地址，因此若NAT设备未将DNS Server解析的公网IP替换成内部服务器对应的私网IP，私网用户将无法通过域名访问到内部服务器。&lt;br&gt;
这个问题可以使用DNS Mapping方式来解决，通过配置&lt;code&gt;域名—公网IP地址—公网端口—协议类型&lt;/code&gt;映射表，建立内部服务器的域名与其公网信息间的对应关系。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614823889153.png&#34; alt=&#34;DNS Mapping&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-nat关联vpn&#34;&gt;2. NAT关联VPN&lt;/h3&gt;
&lt;p&gt;NAT允许内部网络中分属于不同VPN的用户通过同一个出口访问外部网络，解决内部网络中IP地址重叠的VPN同时访问外网主机的问题；NAT还支持VPN关联的NAT Server，允许外部网络中的主机访问内网中分属不同VPN的服务器，同时支持内网多个VPN地址重叠的场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VPN关联的源NAT&lt;code&gt;内网访问外网&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614827170019.png&#34; alt=&#34;VPN关联的源NAT&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;VPN关联的NAT Server&lt;code&gt;外网访问内网&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614827231225.png&#34; alt=&#34;VPN关联的NAT Server&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-两次nat&#34;&gt;3. 两次NAT&lt;/h3&gt;
&lt;p&gt;指源IP和目的IP同时转换，该技术应用于&lt;strong&gt;内部网络主机地址与外部网络上主机地址重叠的情况&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614827448961.png&#34; alt=&#34;两次NAT&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A要访问B，A向位于外部网络的DNS服务器发送访问B的DNS请求，DNS服务器应答B的IP地址为1.1.1.1，DNS应答报文在经过Router时，&lt;strong&gt;进行DNS ALG，Router将DNS应答报文中的重叠地址1.1.1.1转换为唯一的临时地址3.3.3.1&lt;/strong&gt;，然后再转发给A&lt;/li&gt;
&lt;li&gt;A访问B，目的IP为临时地址3.3.3.1，报文在经过Router时&lt;sub&gt;Router检查到源IP是重叠地址&lt;/sub&gt;，进行目的地址转换，将目的地址3.3.3.1转换成B的真实地址1.1.1.1，同时进行正常的NAT Outbound转换，将源地址1.1.1.1转换为源NAT地址池中地址3.3.3.2，然后Router将报文转发到B&lt;/li&gt;
&lt;li&gt;B回应A，目的IP为A的NAT Outbound地址池地址3.3.3.2，源IP为B的地址1.1.1.1，报文在经过Router时，Router检查到源IP是重叠地址，将报文的源地址1.1.1.1转换为对应的临时地址3.3.3.1，同时进行正常的目的地址转换，将报文的目的地址3.3.3.2转换为A的内网地址1.1.1.1，Router将报文转发到A&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ntp&#34;&gt;NTP&lt;/h1&gt;
&lt;p&gt;NTP的实现基于IP和UDP，NTP报文通过UDP传输，端口号是123。&lt;br&gt;
NTP主要应用于网络中所有设备时钟需要保持一致的场合，比如网络管理（日志采集等）、计费系统、多个系统协同处理同一个复杂事件、备份服务器和客户机之间进行增量备份、用户登录时间记录等&lt;/p&gt;
&lt;h2 id=&#34;演进&#34;&gt;演进&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;v1首次提出完整的NTP规则和算法，但不支持认证和控制消息&lt;/li&gt;
&lt;li&gt;v2加入认证和控制消息&lt;/li&gt;
&lt;li&gt;v3引入校正原则，改进了时钟选择和时钟过滤算法&lt;code&gt;目前使用最广泛的版本&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;v4同时支持IPv4和IPv6网络，提供了一套完整的加密认证体系&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614485953688.png&#34; alt=&#34;基本原理&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;RouterA发送一个NTP报文给RouterB，该报文中带有它离开RouterA时的时间戳10:00:00a.m.（T1）&lt;/li&gt;
&lt;li&gt;此NTP报文到达RouterB时，RouterB加上到达时间戳11:00:01a.m.（T2）&lt;/li&gt;
&lt;li&gt;此NTP报文离开RouterB时，RouterB再加上离开时间戳11:00:02a.m.（T3）&lt;/li&gt;
&lt;li&gt;RouterA接收到该响应报文时，加上新的时间戳10:00:03a.m.（T4）。至此，RouterA获得了足够信息来计算以下两个重要参数：
&lt;ol&gt;
&lt;li&gt;NTP报文&lt;strong&gt;来回一个周期的时延&lt;/strong&gt;：Delay=(T4-T1)-(T3–T2)=2秒&lt;/li&gt;
&lt;li&gt;RouterA相对RouterB的&lt;strong&gt;时间差&lt;/strong&gt;：Offset=((T2-T1)+(T3–T4))/2=1小时&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;RouterA根据计算得到Delay为2秒，Offset为1小时。RouterA根据这些信息来设定自己的时钟，实现与RouterB的时钟同步&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;网络架构&#34;&gt;网络架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614492385879.png&#34; alt=&#34;网络架构&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;同步子网：由主时间服务器、二级时间服务器、PC客户端和它们之间互连的传输路径组成同步子网&lt;/li&gt;
&lt;li&gt;主时间服务器：通过线缆或无线电&lt;strong&gt;直接同步到标准参考时钟&lt;/strong&gt;，&lt;strong&gt;标准参考时钟通常是Radio Clock或卫星定位系统等&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;二级时间服务器：通过网络中的&lt;strong&gt;主时间服务器或者其他二级服务器取得同步&lt;/strong&gt;。二级时间服务器通过NTP将时间信息传送到局域网内部的其它主机&lt;/li&gt;
&lt;li&gt;层数（stratum）：层数是对时钟同步情况的一个分级标准，代表了一个时钟的精确度，取值范围1～15，&lt;strong&gt;数值越小，精确度越高&lt;/strong&gt;。&lt;strong&gt;1表示时钟精确度最高，15表示未同步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;这样设计网络架构的目的&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当&lt;strong&gt;一台或多台主/二级时间服务器或它们之间的网络路径发生故障&lt;/strong&gt;时，同步子网的主从分层结构将自动发生重构以获得最精确和最可靠的时间&lt;/li&gt;
&lt;li&gt;当同步子网中正常使用的&lt;strong&gt;主时间服务器都失效&lt;/strong&gt;，备用的主时间服务器将继续运行&lt;/li&gt;
&lt;li&gt;当子网中&lt;strong&gt;所有的主时间服务器都失效时&lt;/strong&gt;，其它二级时间服务器将在它们内部达到同步。此时，这些二级时间服务器将脱离同步子网，自动运行在它们最后一次确定的时间和频率。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ntp的工作模式&#34;&gt;NTP的工作模式&lt;/h2&gt;
&lt;p&gt;工作模式选择：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在不能确定服务器或者对等体IP地址、网络中需要同步的设备数量很多的情况下，可以通过广播或组播的方式实现时钟同步&lt;/li&gt;
&lt;li&gt;单播和对等体模式中，设备从指定的服务器或者对等体获得时间同步，增加了时钟的可靠性&lt;/li&gt;
&lt;li&gt;多播模式和组播模式的区别：客户端发现服务端的方式不同，组播模式是NTP服务器通过组播默认组224.0.0.1发现客户端&lt;code&gt;即服务器发现客户端&lt;/code&gt;；多播模式是客户端通过组播默认组224.0.1.1发现NTP服务器&lt;code&gt;即客户端发现服务器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;广播和组播模式下，会通过一次单播模式来确定网络延时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;NTP报文中Mode字段&lt;/strong&gt;，即工作模式，不同值表示的含义如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0：保留&lt;/li&gt;
&lt;li&gt;1：主动对等体模式&lt;code&gt;仅在对等体模式中使用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;2：被动对等体模式&lt;code&gt;仅在对等体模式中使用&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;3：客户端模式&lt;/li&gt;
&lt;li&gt;4：服务器模式&lt;/li&gt;
&lt;li&gt;5：广播模式（或组播模式）&lt;/li&gt;
&lt;li&gt;6：NTP控制报文&lt;/li&gt;
&lt;li&gt;7：内部使用预留&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;1-单播服务器客户端模式&#34;&gt;1. 单播服务器/客户端模式&lt;/h3&gt;
&lt;p&gt;客户端同步服务器时钟&lt;br&gt;
运行在同步子网中&lt;strong&gt;层数较高层上&lt;/strong&gt;，需要预先知道服务器的IP地址&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614493901212.png&#34; alt=&#34;单播服务器/客户端模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端定期向服务器端发送Mode3报文&lt;code&gt;客户端不管服务器端是否可达及服务器端的层数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;服务器端接收并回应Mode4报文&lt;/li&gt;
&lt;li&gt;当客户端接收到应答报文时，客户端会&lt;strong&gt;进行时钟过滤和选择，并同步到时钟优选的服务器&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-对等体模式&#34;&gt;2. 对等体模式&lt;/h3&gt;
&lt;p&gt;主动对等体和被动对等体可以互相同步，等级低（层数大）的对等体向等级高（层数小）的对等体同步&lt;br&gt;
运行在同步子网中&lt;strong&gt;层数较低处&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614494271280.png&#34; alt=&#34;对等体模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主动对等体发起Mode3报文，由被动对等体响应Mode4报文&lt;code&gt;这一步的目的是选择主动和被动对等体&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主动对等体定期向被动对等体发送Mode=1报文&lt;code&gt;不考虑对端的对等体是否可达以及对等体的层数&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;被动对等体接收并回应Mode=2报文&lt;code&gt;被动对等体不需配置，只有当本机收到NTP报文时才建立连接及相关的状态变量&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对等体模式建立后，主动对等体和被动对等体可以互相同步，等级低（层数大）的对等体向等级高（层数小）的对等体同步&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-广播模式&#34;&gt;3. 广播模式&lt;/h3&gt;
&lt;p&gt;服务器周期性向广播地址发送时钟同步报文&lt;br&gt;
应用在有多台工作站、不需要很高准确度的高速网络，典型的情况是网络中的&lt;strong&gt;一台或多台时间服务器定期向工作站发送广播报文&lt;/strong&gt;，广播报文在毫秒级的延迟基础上确定时间&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614494684631.png&#34; alt=&#34;广播模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;广播服务器周期性&lt;strong&gt;向广播地址255.255.255.255发送Mode5的时钟同步报文&lt;/strong&gt;&lt;code&gt;不管客户端是否可达或层数为多少&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;客户端侦听来自服务器的广播消息包。当接收到第一个广播消息包后，&lt;strong&gt;为估计网络延迟&lt;/strong&gt;，客户端先启用一个&lt;strong&gt;短暂的服务器/客户端模式&lt;/strong&gt;与远程服务器交换消息（Mode3和Mode4消息）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端进入广播模式&lt;/strong&gt;，继续侦听广播消息包的到来，根据到来的广播消息包同步本地时钟&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-组播模式工作方式和广播模式相同&#34;&gt;4. 组播模式&lt;sub&gt;工作方式和广播模式相同&lt;/sub&gt;&lt;/h3&gt;
&lt;p&gt;服务器端周期性向组播地址发送时钟同步报文&lt;br&gt;
适用于有大量客户端分布在网络中的情况，通过在网络中使用NTP组播模式，&lt;strong&gt;NTP服务器发送的组播消息包可以到达网络中所有的客户端&lt;/strong&gt;，从而降低由于NTP报文过多而给网络造成的压力&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614495711497.png&#34; alt=&#34;组播模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组播服务器周期性向IPv4/IPv6组播地址发送Mode5时钟同步报文&lt;/li&gt;
&lt;li&gt;客户端侦听来自服务器的组播消息包。当接收到第一个组播消息包后，为估计网络延迟，客户端先启用一个短暂的服务器/客户端模式与远程服务器交换消息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;客户端进入组播模式&lt;/strong&gt;，继续侦听组播消息包的到来，根据到来的组播消息包同步本地时钟&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-多播模式&#34;&gt;5. 多播模式&lt;/h3&gt;
&lt;p&gt;多播服务器持续侦听报文，多播客户端周期性地向组播地址发送请求报文，寻找最小连接最小数的服务器&lt;br&gt;
适用于&lt;strong&gt;服务器分布分散的网络中&lt;/strong&gt;，客户端可以发现与之最近的多播服务器，并进行同步，多播模式&lt;strong&gt;适用于服务器不稳定的组网环境&lt;/strong&gt;中，少量服务器的失效不会导致整网中的客户端重新配置。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614495830063.png&#34; alt=&#34;多播模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多播客户端周期性向IPv4/IPv6组播地址发送Mode3请求报文，寻找TTL最小的多播服务器&lt;/li&gt;
&lt;li&gt;客户端发送报文的TTL初始值为1，每次发送时累加1，直到客户端收到应答报文或TTL达到上限
&lt;ol&gt;
&lt;li&gt;如果客户端收到应答报文，表明已找到距离最短的多播服务器，则每过一个超时周期，客户端都会发送一个报文给服务器以保持连接&lt;/li&gt;
&lt;li&gt;如果TTL达到上限时仍未收到应答报文，则客户端将停止一个超时周期的数据传输以清除所有连接，然后重复上述过程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;多播服务器持续侦听报文，如果某个服务器可以被同步，则服务器将使用客户端的单播地址返回Mode4报文&lt;/li&gt;
&lt;li&gt;当客户端接收到应答报文时，客户端会进行时钟过滤和选择，并同步到时钟优选的服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;netstream&#34;&gt;Netstream&lt;/h1&gt;
&lt;h2 id=&#34;系统组成&#34;&gt;系统组成&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614496633800.png&#34; alt=&#34;系统组成&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;网络流数据输出器NDE&lt;br&gt;
负责对网络流进行分析处理，提取符合条件的流进行统计，并将统计信息输出给NSC&lt;/li&gt;
&lt;li&gt;网络流数据收集器NSC&lt;br&gt;
运行于Unix或者Windows上的一个应用程序，负责解析来自NDE的报文，把统计数据收集到数据库中，可供NDA进行解析，NSC可以采集多个NDE设备输出的数据，对数据进行进一步的过滤和聚合&lt;/li&gt;
&lt;li&gt;网络流数据分析器NDA&lt;code&gt;在实际的应用中，NSC和NDA一般集成在一台NetStream服务器上&lt;/code&gt;&lt;br&gt;
一个网络流量分析工具，它从NSC中提取统计数据，进行进一步的加工处理后生成报表，为各种业务提供依据（比如流量计费、网络规划、攻击监测）。通常，NDA具有图形化用户界面，使用户可以方便地获取、显示和分析收集到的数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工作机制&#34;&gt;工作机制&lt;/h2&gt;
&lt;p&gt;NDE把采集到的关于流的详细信息定期发送给NSC，由NSC初步处理后发送给NDA，NDA对数据进行分析，以用于计费、网络规划等应用&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614496879159.png&#34; alt=&#34;工作机制&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
配置了NetStream功能的设备（即 NDE）业务流量正常转发，但是设备的NetStream模块按一定的采样方式进行&lt;strong&gt;NetStream采样&lt;/strong&gt;，接下来对采样数据&lt;strong&gt;建立NetStream流&lt;/strong&gt;，接着按一定的老化方式对流进行&lt;strong&gt;NetStream流老化处理&lt;/strong&gt;，最后按一定的输出方式以及相应的版本进行&lt;strong&gt;NetStream流输出&lt;/strong&gt;。至此，NDE设备把采集到的关于流的详细信息发送给NSC&lt;/p&gt;
&lt;h3 id=&#34;1-netstream采样&#34;&gt;1. NetStream采样&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;随机报文间隔采样&lt;code&gt;适用于有规律的流量&lt;/code&gt;：报文在&lt;strong&gt;配置数目间隔&lt;/strong&gt;内被&lt;strong&gt;随机&lt;/strong&gt;采样。例如配置间隔数为100，则每100个报文随机采样1个报文&lt;/li&gt;
&lt;li&gt;固定报文间隔采样&lt;code&gt;适用于网络流量统计计费&lt;/code&gt;：报文在&lt;strong&gt;配置数目间隔&lt;/strong&gt;内被&lt;strong&gt;周期&lt;/strong&gt;采样。例如配置间隔为100，第5个报文被采样，那么第一次采样是第5个报文，第二次采样是第105个报文&lt;/li&gt;
&lt;li&gt;随机时间间隔采样&lt;code&gt;适用于有规律的流量&lt;/code&gt;：报文在&lt;strong&gt;配置时间间隔&lt;/strong&gt;内被&lt;strong&gt;随机&lt;/strong&gt;采样。例如配置时间间隔为100，则每隔100毫秒采集1个报文&lt;/li&gt;
&lt;li&gt;固定时间间隔采样&lt;code&gt;适用于网络流量较大的情况&lt;/code&gt;：报文在&lt;strong&gt;配置时间间隔&lt;/strong&gt;内被&lt;strong&gt;周期&lt;/strong&gt;采样。例如配置时间间隔为100，第5毫秒进行采样，那么第一次采样是在5毫秒的时候，第二次采样是105毫秒的时候&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-netstream流&#34;&gt;2. NetStream流&lt;/h3&gt;
&lt;p&gt;NetStream流就是IP报文（UDP、TCP、ICMP报文）和MPLS报文的统计：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IPv4报文：根据IPv4报文的目的IP地址、源IP地址、目的端口号、源端口号、协议号、&lt;strong&gt;ToS&lt;/strong&gt;、输入接口或输出接口来定义流，&lt;strong&gt;相同的七元组标识为同一条流&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IPv6报文：根据IPv6报文的目的IP地址、源IP地址、目的端口号、源端口号、协议号、&lt;strong&gt;流量分类、流标签&lt;/strong&gt;、输入接口或输出接口来定义流，&lt;strong&gt;相同的八元组标识为同一条流&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MPLS报文：可以统计MPLS报文内的IPv4/IPv6信息，如果统计IP信息，此时会&lt;strong&gt;根据MPLS标签栈和IP信息共同确定一条流&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-netstream流老化&#34;&gt;3. NetStream流老化&lt;/h3&gt;
&lt;p&gt;流统计信息首先会被存储在设备的NetStream缓存区中，&lt;strong&gt;当存储在设备上的NetStream流信息老化后，设备会把缓存区中的流统计信息通过指定版本的NetStream输出报文发送给NSC&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按时老化
&lt;ol&gt;
&lt;li&gt;活跃流的老化：从第一个报文开始，一条流在指定的时间内一直能被采集到。该种老化方式主要用于持续时间较长的流量，定期输出统计信息。&lt;/li&gt;
&lt;li&gt;非活跃流的老化：从最后一个报文开始，一条流在指定的时间内没有被采集到。该种老化方式主用于短时流量，流量停止则立即输出统计信息，节省内存空间。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;由TCP连接的FIN和RST报文触发老化：当一条已经存在的TCP协议NetStream流中流过一条标志为FIN或RST&lt;sub&gt;表示一次会话结束&lt;/sub&gt;的报文时，立即把相应的NetStream流老化掉&lt;/li&gt;
&lt;li&gt;统计字节超过限制时老化：NetStream缓存区中的流需要记录流过的报文字节数，当字节数量超过定义的变量上限时，该流就会溢出&lt;/li&gt;
&lt;li&gt;强制老化：用户可以通过执行命令强制将NetStream缓存区中所有流老化，该功能主要用于老化条件尚未满足，但又需要最新的统计信息，或者NetStream业务发生异常，导致流缓存区中某些流始终不老化&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-netstream流输出&#34;&gt;4. NetStream流输出&lt;/h3&gt;
&lt;p&gt;NetStream流输出是指储存缓存区里面的流老化后把流统计信息输出到指定的NSC，NetStream流输出具有原始流、聚合流和灵活流的三种流输出方式，以及三种输出报文的版本格式，分别是V5、V8、V9、V10，所有版本的报文都是&lt;strong&gt;通过UDP协议传递统计信息的&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;流输出方式&#34;&gt;流输出方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;原始流输出方式：所有流的统计信息都要被统计，在流老化后，&lt;strong&gt;每条流的统计信息&lt;/strong&gt;都要输出到NetStream服务器&lt;/li&gt;
&lt;li&gt;聚合流输出方式：设备对与聚合关键项完全相同的流统计信息进行汇总，得到对应的聚合流统计信息，将该&lt;strong&gt;聚合统计信息&lt;/strong&gt;发送到NetStream服务器&lt;/li&gt;
&lt;li&gt;灵活流输出方式：流的建立条件是按照自定义的条件设置，可以对报文按照协议类型、源IP地址、目的IP地址、源端口号、目的端口号、流标签等进行分类统计，将&lt;strong&gt;分类统计信息&lt;/strong&gt;发送给NetStream服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;输出报文的版本格式&#34;&gt;输出报文的版本格式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;v5：根据&lt;strong&gt;七元组&lt;/strong&gt;产生原始的数据流，但报文格式固定，不易扩展&lt;/li&gt;
&lt;li&gt;v8：&lt;strong&gt;支持聚合输出&lt;/strong&gt;格式，但报文格式固定，不易扩展&lt;/li&gt;
&lt;li&gt;v9：&lt;strong&gt;基于模板方式&lt;/strong&gt;，使统计信息的输出更为灵活，可以灵活输出各种组合格式的数据。版本9&lt;strong&gt;支持对BGP下一跳、MPLS等统计输出&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;v10：&lt;strong&gt;基于模板方式&lt;/strong&gt;，&lt;strong&gt;根据数据流特征输出统计信息&lt;/strong&gt;。具有很强的可扩展性，对于不同的需求输出不同格式的数据。&lt;/li&gt;
&lt;/ol&gt;
">特性：DHCP+FTP+SNMP+NTP+Netstream+VRRP+BFD+NQA+URPF+NAT</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/zu-bo/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84&#34;&gt;组播地址结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADip%E5%9C%B0%E5%9D%80&#34;&gt;组播IP地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADip%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB&#34;&gt;组播IP模型分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB&#34;&gt;组播IP地址分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADmac%E5%9C%B0%E5%9D%80&#34;&gt;组播MAC地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ip%E5%9C%B0%E5%9D%80%E5%88%B0mac%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84&#34;&gt;IP地址到MAC地址的映射&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%98%A0%E5%B0%84%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;映射导致的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%88%86%E5%8F%91%E6%A0%91&#34;&gt;组播分发树&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%BA%90%E8%B7%AF%E5%BE%84%E6%A0%91spt&#34;&gt;1. 源路径树SPT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%85%B1%E4%BA%AB%E6%A0%91rpt&#34;&gt;2. 共享树RPT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;组播数据转发&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rpf%E6%A3%80%E6%9F%A5%E5%8F%8D%E5%90%91%E8%B7%AF%E5%BE%84%E8%BD%AC%E5%8F%91%E6%A3%80%E6%9F%A5&#34;&gt;RPF检查（反向路径转发检查）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%8E%E4%B8%BArpf%E6%A3%80%E6%9F%A5%E8%BF%87%E7%A8%8B&#34;&gt;华为RPF检查过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rpf%E6%A3%80%E6%9F%A5%E5%9C%A8%E7%BB%84%E6%92%AD%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8&#34;&gt;RPF检查在组播数据转发中的应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE&#34;&gt;组播相关协议&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#igmp%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE&#34;&gt;IGMP互联网组管理协议&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#v1&#34;&gt;v1&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5&#34;&gt;组成员加入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E7%A6%BB%E5%BC%80&#34;&gt;组成员离开&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%93%8D%E5%BA%94&#34;&gt;组播路由器的查询与响应&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%93%8D%E5%BA%94%E6%8A%91%E5%88%B6%E6%9C%BA%E5%88%B6&#34;&gt;响应抑制机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BE%E4%BE%8B&#34;&gt;举例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v2&#34;&gt;v2&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-2&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5-2&#34;&gt;组成员加入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%93%8D%E5%BA%94&#34;&gt;查询与响应&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E8%AF%A2%E5%99%A8%E9%80%89%E4%B8%BE&#34;&gt;查询器选举&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E7%A6%BB%E5%BC%80-2&#34;&gt;组成员离开&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v1%E5%92%8Cv2%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7&#34;&gt;v1和v2的互操作性&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#v2%E4%B8%BB%E6%9C%BA%E4%B8%8Ev1%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;v2主机与v1路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v1%E4%B8%BB%E6%9C%BA%E4%B8%8Ev2%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;v1主机与v2路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B7%B7%E5%90%88%E7%89%88%E6%9C%AC&#34;&gt;混合版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v3&#34;&gt;v3&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-3&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6&#34;&gt;工作机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84&#34;&gt;改进之处&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#igmp%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%AF%94%E8%BE%83&#34;&gt;IGMP三个版本的比较&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%89%88%E6%9C%AC%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%BB%84%E6%92%AD%E6%A8%A1%E5%9E%8B&#34;&gt;1. 版本服务的组播模型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B&#34;&gt;2. 报文类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84&#34;&gt;3. 报文结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E7%89%88%E6%9C%AC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&#34;&gt;4. 版本工作流程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#igmp-snooping&#34;&gt;IGMP Snooping&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%83%8C%E6%99%AF&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8&#34;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&#34;&gt;基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-2&#34;&gt;工作机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#igmp-snooping-proxy%E4%BA%8C%E5%B1%82%E5%92%8Cigmp-proxy%E4%B8%89%E5%B1%82&#34;&gt;IGMP Snooping Proxy（二层）和IGMP Proxy（三层）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#igmp-snooping-proxy&#34;&gt;IGMP Snooping Proxy&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-3&#34;&gt;工作机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#igmp-proxy&#34;&gt;IGMP Proxy&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#igmp-ssm-mapping&#34;&gt;IGMP SSM Mapping&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B&#34;&gt;工作过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim&#34;&gt;PIM&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D&#34;&gt;概念介绍&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%88%86%E5%8F%91%E6%A0%91mdt&#34;&gt;组播分发树MDT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;PIM路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim%E8%B7%AF%E7%94%B1%E8%A1%A8%E9%A1%B9&#34;&gt;PIM路由表项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pimv2%E6%8A%A5%E6%96%87%E5%A4%B4%E6%A0%BC%E5%BC%8F&#34;&gt;PIMv2报文头格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87&#34;&gt;报文&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hello%E6%8A%A5%E6%96%87&#34;&gt;Hello报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#join%E6%8A%A5%E6%96%87&#34;&gt;Join报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#state-refresh%E7%8A%B6%E6%80%81%E5%88%B7%E6%96%B0%E6%8A%A5%E6%96%87&#34;&gt;State Refresh状态刷新报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim-dmdense_mode%E5%AF%86%E9%9B%86%E6%A8%A1%E5%BC%8F&#34;&gt;PIM-DM（Dense_mode，密集模式）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-4&#34;&gt;工作机制&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%92%8Cdr%E7%AB%9E%E9%80%89neighbor-discovery&#34;&gt;1. 邻居发现和DR竞选Neighbor Discovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%89%A9%E6%95%A3flooding&#34;&gt;2. 扩散Flooding&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%89%AA%E6%9E%9Dprune&#34;&gt;3. 剪枝Prune&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%AB%81%E6%8E%A5graft&#34;&gt;4. 嫁接Graft&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%96%AD%E8%A8%80assert&#34;&gt;5. 断言Assert&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E7%8A%B6%E6%80%81%E5%88%B7%E6%96%B0state-refresh&#34;&gt;6. 状态刷新State Refresh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AF%84%E4%BB%B7&#34;&gt;总结与评价&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim-smasm%E6%A8%A1%E5%9E%8B&#34;&gt;PIM-SM（ASM模型）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&#34;&gt;基本原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-5&#34;&gt;工作机制&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%92%8Cdr%E7%AB%9E%E9%80%89&#34;&gt;1. 邻居发现和DR竞选&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-rp%E5%8F%91%E7%8E%B0&#34;&gt;2. RP发现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-rpt%E6%9E%84%E5%BB%BA&#34;&gt;3. RPT构建&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E7%BB%84%E6%92%AD%E6%BA%90%E6%B3%A8%E5%86%8C&#34;&gt;4. 组播源注册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-spt%E5%88%87%E6%8D%A2&#34;&gt;5. SPT切换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E6%96%AD%E8%A8%80assert&#34;&gt;6. 断言Assert&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E6%AE%8A%E5%9C%BA%E6%99%AF&#34;&gt;特殊场景&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim-smssm%E6%A8%A1%E5%9E%8B&#34;&gt;PIM-SM（SSM模型）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-2&#34;&gt;基本原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-6&#34;&gt;工作机制&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%92%8Cdr%E7%AB%9E%E9%80%89-2&#34;&gt;1. 邻居发现和DR竞选&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-spt%E6%9E%84%E5%BB%BA&#34;&gt;2. SPT构建&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ssm%E4%B8%8Easm%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83&#34;&gt;SSM与ASM模型比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#g%E4%B8%8Esg%E6%9D%A1%E7%9B%AE%E5%85%B3%E7%B3%BB&#34;&gt;（*，G）与（S，G）条目关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#msdp&#34;&gt;MSDP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%BB%E6%84%8F%E6%92%ADanycast&#34;&gt;任意播Anycast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#msdp%E5%AF%B9%E7%AD%89%E4%BD%93%E5%BB%BA%E7%AB%8B&#34;&gt;MSDP对等体建立&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E6%BA%90%E4%BF%A1%E6%81%AF%E5%9C%A8%E5%9F%9F%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92&#34;&gt;组播源信息在域间的传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&#34;&gt;应用场景&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#msdp%E5%AE%9E%E7%8E%B0as%E5%86%85pim-sm%E5%9F%9F%E9%97%B4%E7%BB%84%E6%92%AD&#34;&gt;MSDP实现AS内PIM-SM域间组播&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mbgp&#34;&gt;MBGP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%8F%8C%E6%A0%88%E6%8A%80%E6%9C%AF&#34;&gt;组播双栈技术&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mld&#34;&gt;MLD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv4-ipv6-%E7%BB%84%E6%92%AD%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%BA%94%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%AF%94%E8%BE%83&#34;&gt;IPv4、IPv6 组播网络中应用的协议比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%85%A5%E5%BC%8Frp%E5%8A%9F%E8%83%BD&#34;&gt;什么是嵌入式RP功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipv6%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80%E4%B8%8Emac%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84&#34;&gt;IPv6组播地址与MAC地址映射&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85&#34;&gt;补充&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E7%89%B9%E7%82%B9&#34;&gt;组播特点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%8A%BF&#34;&gt;优势&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A3%E5%8A%BF&#34;&gt;劣势&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8-2&#34;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%BB%84%E6%92%AD&#34;&gt;为什么需要组播&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;组播地址结构&#34;&gt;组播地址结构&lt;/h1&gt;
&lt;h2 id=&#34;组播ip地址&#34;&gt;组播IP地址&lt;/h2&gt;
&lt;p&gt;一个组播组就是一个IP地址，不表示具体的主机，而是表示一系列系统的集合，主机加入某个组播组&lt;br&gt;
即声明自己接收目的为某个IP地址的报文&lt;br&gt;
IP组播组地址&lt;strong&gt;224.0.0.0–239.255.255.255&lt;/strong&gt;，D类地址空间，&lt;strong&gt;第一个字节的高四位&lt;/strong&gt;为“&lt;strong&gt;1110&lt;/strong&gt;”&lt;/p&gt;
&lt;h2 id=&#34;组播ip模型分类&#34;&gt;组播IP模型分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;ASM：任意源组播&lt;br&gt;
&lt;strong&gt;任意发送者都可以成为组播源&lt;/strong&gt;，向某组播组地址发送信息。接收者无法预知组播源的地址，接收者可以在任意时间加入或者离开该主机组。&lt;/li&gt;
&lt;li&gt;SFM：过滤源组播&lt;br&gt;
从发送者角度来看，组播组成员关系完全相同。SFM在功能上对ASM进行了扩展，&lt;strong&gt;接收者只能接收来自部分组播源的数据&lt;/strong&gt;。从接收者角度来看，只有部分组播源是有效的，组播源经过了筛选。&lt;/li&gt;
&lt;li&gt;SSM：指定源组播&lt;br&gt;
针对特定源和组的绑定数据流提供服务，接收者主机在加入组播组时，可以指定只接收哪些源的数据，加入组播组以后，&lt;strong&gt;主机只会收到指定源发送到该组的数据&lt;/strong&gt;。对组地址不再要求全网唯一，只需要每个组播源保持唯一。这里的“唯一”指的是同一个源上不同的组播应用必须使用不同的SSM地址来区分，但不同的源之间可以使用相同的组地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;组播ip地址分类&#34;&gt;组播IP地址分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;永久组地址
&lt;ol&gt;
&lt;li&gt;所有开启组播的设备（224.0.0.1）&lt;/li&gt;
&lt;li&gt;所有开启组播的路由器（224.0.0.2）&lt;/li&gt;
&lt;li&gt;OSPF（224.0.0.5）&lt;/li&gt;
&lt;li&gt;OSPF的DR（224.0.0.6）&lt;/li&gt;
&lt;li&gt;RIPv2（224.0.0.9）&lt;/li&gt;
&lt;li&gt;EIGRP（224.0.0.10）&lt;/li&gt;
&lt;li&gt;dhcp（224.0.0.12）&lt;/li&gt;
&lt;li&gt;PIM（224.0.0.13）&lt;/li&gt;
&lt;li&gt;VRRP（224.0.0.18）&lt;/li&gt;
&lt;li&gt;IGMPv3（224.0.0.22）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;临时组地址&lt;br&gt;
为用户组播组临时分配的IP地址，组成员的数量一旦为零，即取消。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597066331855.png&#34; alt=&#34;常见的永久组地址列表&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596607503545.png&#34; alt=&#34;组播IP地址分类&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
专用地址（224.0.0.0-224.0.0.255）用于网络协议组的广播&lt;br&gt;
公用地址（224.0.1.0-238.255.255.255）用于全球网络组播&lt;br&gt;
私用地址（239.0.0.0-239.255.255.255）用于本地测试、局域网使用&lt;br&gt;
ASM地址（224.0.1.0-231.255.255.255、233.0.0.0.0-238.255.255.255.255）&lt;br&gt;
SSM地址（232.0.0.0.0-232.255.255.255.255)&lt;br&gt;
全网用在IPv6协议中，第一个字节必须是0xFF。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;组播mac地址&#34;&gt;组播MAC地址&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596607753123.png&#34; alt=&#34;组播MAC地址&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;组播MAC地址的高24bit为0x01005e，第25bit固定为0&lt;/strong&gt;，低23bit为组播IP地址的低23bit，就以太网而言，IP组播帧为以01-00-5E-xx-xx-xx&lt;/p&gt;
&lt;h2 id=&#34;ip地址到mac地址的映射&#34;&gt;IP地址到MAC地址的映射&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;为什么需要组播IP到组播MAC的映射？单播可以通过ARP获得MAC，但是组播无法根据组播IP得到组播MAC，只能通过人为的方式规定一个地址&lt;/code&gt;&lt;br&gt;
MAC地址的低23bit为组播IP地址的低23b，&lt;code&gt;丢失组播ip地址的前9bit，因为所有的组播IP均为D类，即前4bit为1110，实际丢失的是5bit信息&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596608065677.png&#34; alt=&#34;IP地址到MAC地址的映射&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;映射导致的问题&#34;&gt;映射导致的问题&lt;/h3&gt;
&lt;p&gt;存在当第3层IP地址映射成第2层MAC地址时导致32:1的地址不明确问题&lt;sub&gt;（原因：第25bit固定为0，IP地址32bit，只映射后23bit）&lt;/sub&gt;，如下图：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596608304089.png&#34; alt=&#34;映射导致的问题&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;因此在规划组播网络的时候，为防止出现相同的组播MAC，需要组播IP的后23bit不相同&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;组播分发树&#34;&gt;组播分发树&lt;/h1&gt;
&lt;p&gt;用来描述IP组播报文在网络中经过的路径。&lt;/p&gt;
&lt;h2 id=&#34;1-源路径树spt&#34;&gt;1. 源路径树SPT&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;PIM-DM和PIM-SM中都用&lt;/code&gt;&lt;br&gt;
以&lt;strong&gt;组播源作为树根&lt;/strong&gt;，将组播源到每一个接收者的最短路径结合起来构成的转发树。&lt;br&gt;
每一个组播源与接收者之间建立一棵独立的SPT&lt;br&gt;
&lt;code&gt;这个机制的作用是实现组播流量的最优转发路径&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596610760187.png&#34; alt=&#34;源路径树&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;特点&lt;/strong&gt;：路径最优，延迟最小，占用内存较多&lt;/p&gt;
&lt;h2 id=&#34;2-共享树rpt&#34;&gt;2. 共享树RPT&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;仅在PIM-SM中才会使用，即适合规模较大、组成员相对比较分散的网络&lt;/code&gt;&lt;br&gt;
在网络的某些节点的&lt;strong&gt;单独的公用根（RP）&lt;/strong&gt;，共享树即RPT&lt;br&gt;
对应某个组，网络中只有一棵树&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596611226847.png&#34; alt=&#34;共享树&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;特点&lt;/strong&gt;：路径不是最优的，引入额外的延迟，&lt;strong&gt;占用内存较少&lt;/strong&gt;（单个表项）&lt;/p&gt;
&lt;h1 id=&#34;组播数据转发&#34;&gt;组播数据转发&lt;/h1&gt;
&lt;p&gt;组播路由和单播路由是相反的，单播路由关心数据报文要到哪里去，组播路由关心数据报文从哪里来（防环）。组播路由使用 “反向路径转发”机制(RPF, Reverse Path Forwarding)&lt;/p&gt;
&lt;h2 id=&#34;rpf检查反向路径转发检查&#34;&gt;RPF检查（反向路径转发检查）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;避免重复收到组播流和组播流量的环路，同时也能解决次优路径和确定建立共享树的出接口&lt;/code&gt;&lt;br&gt;
路由器收到组播数据报文后，只有确认这个数据报文是&lt;strong&gt;从自身连接到组播源的接口上收到的，才进行转发&lt;/strong&gt;，否则丢弃。&lt;br&gt;
&lt;code&gt;这个机制的作用是防止组播流量转发环路&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;RPF检查&lt;/strong&gt;：在&lt;strong&gt;单播路由表中&lt;/strong&gt;查找到&lt;strong&gt;组播报文源地址的路由&lt;/strong&gt;，如果&lt;strong&gt;该路由的出接口&lt;/strong&gt;就是&lt;strong&gt;组播报文的入接口&lt;/strong&gt;【即&lt;code&gt;确保组播流的入接口是单播路由的出接口&lt;/code&gt;】，RPF检查成功；否则RPF检查失败，报文丢弃&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RPF举例&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596613155173.png&#34; alt=&#34;RPF举例&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;组播转发RPF举例&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596613223608.png&#34; alt=&#34;组播转发RPF举例1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596613270842.png&#34; alt=&#34;组播转发RPF举例2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;华为rpf检查过程&#34;&gt;华为RPF检查过程&lt;/h3&gt;
&lt;p&gt;除单播路由外，MBGP路由、组播静态路由也是RPF检查的依据。当路由器收到一份组播报文之后，如果这三种路由表都存在，具体检查过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，通过报文源地址，分别从&lt;strong&gt;单播路由表、MBGP路由表和组播静态路由表&lt;/strong&gt;中各选出一条最优路由。单播路由、MBGP路由的出借口为RPF接口，下一跳为RPF邻居&lt;code&gt;组播静态路由实际上属于手工配置的组播路由，已经明确指定了RPF接口与RPF邻居&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后，根据以下原则从这三条最优路由中选择一条作为RPF路由
&lt;ol&gt;
&lt;li&gt;如果配置了按照&lt;strong&gt;最长匹配&lt;/strong&gt;选择路由
&lt;ol&gt;
&lt;li&gt;从这三条路由中&lt;strong&gt;选出最长匹配&lt;/strong&gt;的那条路由&lt;/li&gt;
&lt;li&gt;如果这三条路由的掩码一样，则选择&lt;strong&gt;优先级最高&lt;/strong&gt;的那条路由&lt;/li&gt;
&lt;li&gt;如果优先级也相同（即手工修改了协议优先级），则按照&lt;strong&gt;组播静态路由&amp;gt;MBGP路由&amp;gt;单播路由&lt;/strong&gt;的顺序进行选择&lt;/li&gt;
&lt;li&gt;如果都是单播路由，则比较&lt;strong&gt;下一跳IP地址，越大越优&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;没有配置最长匹配&lt;/strong&gt;选择路由&lt;code&gt;默认&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;从者三条路由中选出&lt;strong&gt;优先级最高&lt;/strong&gt;的那条路由（默认参考原则）&lt;/li&gt;
&lt;li&gt;如果优先级相同，则按照&lt;strong&gt;组播静态路由&amp;gt;MBGP路由&amp;gt;单播路由&lt;/strong&gt;的顺序进行选择&lt;/li&gt;
&lt;li&gt;如果都是单播路由，则比较掩码长度，&lt;strong&gt;即最长匹配&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果单播路由的掩码长度一样，则比较&lt;strong&gt;下一跳IP地址，越大越优&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后，路由器会将报文的入接口与RPF路由的RPF接口进行比较。如果一样则RPF检查通过，表明报文来源路径正确，会将其向下游转发；如果不一致即RPF检查失败，表明该报文来源路径错误，就将其丢弃。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组播静态路由的优先级为1，MBGP默认为255&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpf检查在组播数据转发中的应用&#34;&gt;RPF检查在组播数据转发中的应用&lt;/h3&gt;
&lt;p&gt;在实际组播数据转发过程中，&lt;strong&gt;如果对每一份接收到的组播数据报文都通过单播路由表进行RPF检查，会给路由器带来很大负担&lt;/strong&gt;。因此，路由器在收到一份来自源S发往组G的组播数据报文之后，首先会在组播转发表中查找有无相应的（S，G）组播转发表项：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果&lt;code&gt;不存在（S，G）&lt;/code&gt;转发表项，则对该报文执行RPF检查，&lt;strong&gt;将检查到的RPF接口作为入接口，创建组播路由表项&lt;/strong&gt;，下发到组播转发表中。其中，对RPF检查结果的处理方式为：
&lt;ol&gt;
&lt;li&gt;如果检查通过，&lt;strong&gt;表明接收接口为RPF接口&lt;/strong&gt;，向转发表项的所有出接口转发&lt;/li&gt;
&lt;li&gt;如果检查失败，表明报文来源路径错误，&lt;strong&gt;丢弃该报文&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;存在（S，G）&lt;/code&gt;转发表项
&lt;ol&gt;
&lt;li&gt;接收该&lt;strong&gt;报文的接口与转发表项的入接口一致&lt;/strong&gt;，则向所有的出接口转发该报文&lt;/li&gt;
&lt;li&gt;接收该&lt;strong&gt;报文的接口与转发表项的入接口不一致&lt;/strong&gt;，则对此报文进行RPF检查。对RPF检查结果的处理方式为：
&lt;ol&gt;
&lt;li&gt;若RPF检查选取出的&lt;strong&gt;RPF接口与转发表项的入接口一致&lt;/strong&gt;，则说明（S，G）表项正确，报文来源路径错误，&lt;strong&gt;将其丢弃&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若RPF检查选取出的&lt;strong&gt;RPF接口与转发表项的入接口不符，则说明（S，G）表项已过时&lt;/strong&gt;，于是把表项中的入接口更新为RPF接口。然后再根据RPF检查规则进行判断：如果接收该&lt;strong&gt;报文的接口正是其RPF接口，则向转发表项的所有出接口转发该报文&lt;/strong&gt;，否则将其丢弃。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;组播相关协议&#34;&gt;组播相关协议&lt;/h1&gt;
&lt;p&gt;组播协议包括用于主机注册的组播组管理协议，和用于组播选路转发的组播路由协议。组播相关协议有IGMP、PIM、MSDP、MBGP&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596609093773.png&#34; alt=&#34;组播相关协议&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;igmp互联网组管理协议&#34;&gt;IGMP互联网组管理协议&lt;/h2&gt;
&lt;p&gt;运行在&lt;strong&gt;接收者与叶路由器&lt;/strong&gt;之间，用于维护组播网络中叶路由器是否需要向特定接口转发组播流。3个版本 ,v2比较常用，v1、v2、v3 均支持ASM，v3主要是针对SSM模型做有力支撑。&lt;/p&gt;
&lt;h3 id=&#34;v1&#34;&gt;v1&lt;/h3&gt;
&lt;h4 id=&#34;报文格式&#34;&gt;报文格式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596636710868.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Version：表示版本标识，版本1为1，版本2没有这个字段&lt;/li&gt;
&lt;li&gt;Type：版本1只有
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;成员关系查询&lt;/strong&gt;（membership query，&lt;strong&gt;0x11&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成员关系报告&lt;/strong&gt;（membership report，&lt;strong&gt;0x12&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;没有特定的组关系查询，也没有主机发送的离开报告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;组地址：当一个成员关系&lt;strong&gt;报告&lt;/strong&gt;正被发送时，组地址字段包含&lt;strong&gt;组播地址&lt;/strong&gt;；当用于成员关系&lt;strong&gt;查询&lt;/strong&gt;时，&lt;strong&gt;本字段为0&lt;/strong&gt;，并被主机忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;版本1不能设定响应时间，&lt;strong&gt;所有的响应时间都是默认的10秒&lt;/strong&gt;，这容易引起&lt;strong&gt;响应突发&lt;/strong&gt;。&lt;br&gt;
版本1成员离开的时候是默默离开的，不发送离开报告，这样离开延迟比较大，也不会引起特定的组查询，因此v1版本的路由器会周期性(&lt;strong&gt;60秒&lt;/strong&gt;)的查询(&lt;strong&gt;源地址是路由器地址，目标地址是224.0.0.1，组地址为0.0.0.0&lt;/strong&gt;)是否还有接收者。&lt;br&gt;
&lt;strong&gt;组播表的老化时间为130秒（=60x2+10）&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;组成员加入&#34;&gt;组成员加入&lt;/h4&gt;
&lt;p&gt;当一个主机希望接收一个组播组的数据，则&lt;strong&gt;发送成员加入报告给组播组&lt;/strong&gt;，该报文中组地址为主机想加入的组播组的地址&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596638205183.png&#34; alt=&#34;组成员加入过程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;组成员离开&#34;&gt;组成员离开&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;华为周期为130秒&lt;/code&gt;，成员悄悄离开组播组，不发送任何报文。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596639902390.png&#34; alt=&#34;组成员离开&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;组播路由器的查询与响应&#34;&gt;组播路由器的查询与响应&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;IGMP查询器周期性的向共享网段内所有主机以组播方式（目的地址为224.0.0.1）发送成员关系查询消息（组地址为0）&lt;/li&gt;
&lt;li&gt;网络内所有主机都接收到该查询消息，如果某主机对某一组播组（比如，组播组G）感兴趣，则以组播方式发送“成员关系报告”报文（其中携带组播组G的地址）来宣告自己将加入该组播组，假设PC2首先发送此报告&lt;/li&gt;
&lt;li&gt;经过查询/响应过程后，IGMP路由器了解到本网络内存在组播组G对应的接收者，生成（*，G）【*表示任意组播源，G表示某个组播组】组播项并依据此作为组播信息的转发依据&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596639701738.png&#34; alt=&#34;组播路由器的查询&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IGMPv1规定，当共享网络中有多台路由器时，由组播路由协议选举查询器。不同的组播路由协议有不同的选举机制。&lt;strong&gt;IGMP查询器选举，由组播协议决定，如果是PIM协议，PIM的DR将做为查询器&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;224.0.0.1-代表所有的组播节点；224.0.0.2-代表所有的组播路由器&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;响应抑制机制&#34;&gt;响应抑制机制&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;原因：组播路由器只关心某个组播组中是否还有接收者，只要有一个接收者就仍然需要转发组播流量，即只需要有一个人回复组播路由器即可&lt;/code&gt;&lt;br&gt;
IGMP成员关系查询报文的目的地址为224.0.0.1，就是说网段内所有的设备都会收到该查询报文。但并不是所有收到该报文的主机都会响应查询请求的。下图中只有一个主机会以成员关系报告报文响应，而其它主机则抑制成员关系报告的发送。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596639715421.png&#34; alt=&#34;响应&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实际上主机收到IGMP成员关系查询时，会对它已经加入的每个组播组启动一个倒计数报告计时器。&lt;strong&gt;IGMPv1中计时器固定使用10s&lt;/strong&gt;。计时器到时的主机则主动发送成员关系报告，组地址为该组播组地址，目的地址为224.0.0.1。于是网段内其他主机都会收到该成员关系报告报文，接收到成员关系报告报文的主机抑制成员关系报告的发送，并删除计时器。当路由器周期性的发送成员关系查询报文时，每个主机都会再次启动计时器进行查询\响应\抑制。&lt;/p&gt;
&lt;h4 id=&#34;举例&#34;&gt;举例&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596699712692.png&#34; alt=&#34;举例&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;多台IGMP路由器的情况下会选举IGMP查询者，v1没有选举机制，使用PIM的DR充当查询者，DR选举：1.优先级越大越优，2.IP地址越大越优。即v1中IP地址大的充当查询者，而查询者的老化时间为125秒（=60x2+0.5x10，小于130秒，即这个值必须小于组播表的老化时间，不然会出现查询者的翻动）&lt;/code&gt;&lt;br&gt;
主机加入组播组的基本过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IGMP 查询器（RouterB）周期性地向共享网段内所有主机以组播方式（目的地址为组播地址）发送普遍组查询消息。该报文的目的地址为224.0.0.1，表示该网段上的所有主机和路由器。&lt;/li&gt;
&lt;li&gt;网段内所有主机都接收到该普遍组查询消息。如果主机（如HostB 和HostC）希望加入某组播组G1，则以组播方式发送Report报告。该报文的目的地址为224.0.0.1，报文中携带组播组G1的地址信息。&lt;/li&gt;
&lt;li&gt;网段中所有主机和路由器都接收到该Report报告，并获知组播组G1地址信息，此时网段中其它也希望加入该组播组G1的主机将不再发送针对相同组播组的Report报告。同时，网段中预备加入另一组播组G2的主机发送针对组播组G2的Report报告以响应普遍组查询消息。&lt;/li&gt;
&lt;li&gt;经过查询和响应过程后，IGMP路由器了解到本网段内存在组播组G1对应的组播组成员，则由组播路由协议生成（*，G1）组播转发项并以此作为组播数据的转发依据。之后，组播路由协议将发起上游路由更新以维护组播转发树。&lt;/li&gt;
&lt;li&gt;组播源发出的组播数据经过组播路由到达IGMP路由器，如果IGMP路由器上存在（*，G1）组播转发项，则转发该组播数据到此共享网段，G1组播组成员主机接收该数据。&lt;/li&gt;
&lt;li&gt;IGMPv1中没有专门定义离开组播组的消息。当主机离开某组播组后，将不再发送以此组播组地址为目的地址的Report报告。当网段中不再存在该组播组成员后，IGMP路由器将不能收到任何针对此组播组的Report报告，则IGMP路由器删除该组播组对应的转发项。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;v2&#34;&gt;v2&lt;/h3&gt;
&lt;h4 id=&#34;报文格式-2&#34;&gt;报文格式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596697000398.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IGMPv2报文相比IGMPv1报文，取消了版本字段而相应增加了最大响应时间的字段&lt;br&gt;
IGMPv2支持特定组查询、增加了离组消息（增加了触发查询机制）、报告抑制机制优化了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大响应时间：仅用于组成员关系查询时主机可以响应查询，返回报告的时间范围，可以适当调高，给主机足够的响应时间。以0.1秒为单位，&lt;code&gt;默认值是100，即10秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;组地址：
&lt;ul&gt;
&lt;li&gt;在成员查询消息中，发送一个常规查询报文时组地址为0，当发送一个特定组的查询报文时，则设置为该组的地址。&lt;/li&gt;
&lt;li&gt;在成员报告或离开组的消息中，目的地址是224.0.0.2则为所有的组播路由器，&lt;strong&gt;但华为设备上实现为特定组&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类型：IGMPv2报文中有三种报文类型：
&lt;ul&gt;
&lt;li&gt;Type=0x11：成员关系查询报文，分为两种子类型：
&lt;ul&gt;
&lt;li&gt;常规查询：用于确定哪些组播组是有效的，即该组是否还有成员在使用，&lt;strong&gt;常规查询组地址全零&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;特定查询：用于查询特定的组播组是否还有组成员，&lt;strong&gt;组地址为特定的组播地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Type=0x16：IGMPv2组成员关系报告
&lt;ul&gt;
&lt;li&gt;为了和IGMPv1兼容，还有另外的一个附加消息类别：0x12为IGMPv1成员报告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Type=0x17：离开组消息，主机发送的离开报告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;组成员加入-2&#34;&gt;组成员加入&lt;/h4&gt;
&lt;p&gt;当一个主机加入一个组播组，则应该立即发送一个或多个成员关系报告给组播组&lt;code&gt;和v1相同&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596699055945.png&#34; alt=&#34;组成员加入&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;查询与响应&#34;&gt;查询与响应&lt;/h4&gt;
&lt;p&gt;与IGMPv1相同，都存在抑制机制。&lt;br&gt;
&lt;strong&gt;增加了最大响应时间&lt;/strong&gt;来指定延时值来规定所有主机的查询响应延时的上限，此外最大响应时间在&lt;strong&gt;IGMP查询器&lt;/strong&gt;上配置，只应用在成员关系查询信息。&lt;br&gt;
在常规查询之外增加了特定组查询，这种查询报文的目的IP地址为某个组播组的IP地址，报文中的组地址字段也为该组播组的IP地址，网络中属于该组播组成员的主机才会进行响应，这样就避免了属于其他组播组成员的主机发送响应报文&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596699127088.png&#34; alt=&#34;查询与响应&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PC2发送响应报文：&lt;br&gt;
其他接收者收到之后会抑制发送响应报文，刷新定时器&lt;br&gt;
查询者收到之后会刷新该组的老化时间为130秒，同时记录&lt;code&gt;last reporter（每一轮查询中倒计时第一个到时的设备，所以last reporter不是固定不变的）&lt;/code&gt;为PC2的IP地址&lt;br&gt;
&lt;code&gt;为什么要有last reporter？减少离组报文、特定组查询报文以及报告报文的泛洪&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;查询器选举&#34;&gt;查询器选举&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;选举原则：IP地址最小的设备&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596700187559.png&#34; alt=&#34;查询器选举&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查询器也会有失效的时间，当查询器失效时，另一个路由器成为查询器，所以非查询路由器会启动一个查询计时器，周期检查IGMP查询路由器的状态，&lt;strong&gt;缺省情况下为120秒，但是查询路由器的死亡时间为125秒&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;组成员离开-2&#34;&gt;组成员离开&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;只有last reporter离组才会发送离组报文，其他接收者离组并不会发送离组报文，因为其他接收者离组时知道自己不是这个组的唯一接收者，而last reporter离组时不知道组内还有其他成员，因为他没有收到其他成员的响应报文&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596700612639.png&#34; alt=&#34;组成员离开&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当一个主机决定离开一个组播组时，他会向所有组播路由器以组播的形式（224.0.0.2）发送离开组消息，为了明确该组播组中是否还包含其他成员主机，该组播路由器会向网络中发送&lt;strong&gt;特定组查询消息&lt;/strong&gt;。&lt;br&gt;
在查询的最大响应时间内（&lt;strong&gt;默认为1s&lt;/strong&gt;）没有收到该组的报告，则再次发特定组查询。2次特定组查询之后仍然没有收到成员报告，则认为该组播成员全部离开。&lt;/p&gt;
&lt;h3 id=&#34;v1和v2的互操作性&#34;&gt;v1和v2的互操作性&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;以查询者的版本优先，如果查询者之间版本不同，则以低版本的优先&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;v2主机与v1路由器&#34;&gt;v2主机与v1路由器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;协商使用v1&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596710458120.png&#34; alt=&#34; v2主机与v1路由器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
v1路由器把v2报告看作无效的IGMP信息类型并且&lt;strong&gt;忽略它&lt;/strong&gt;&lt;br&gt;
当v1路由器作为有效的IGMP查询器时，v2的主机必须发送v1报告。&lt;br&gt;
当v2的的主机检测出IGMP查询器时v1的路由器时，他必须始终用v1报告作出响应。在这种情况下，v2的主机也可以抑制发送离开组消息。&lt;br&gt;
为了维护接口的状态，无论何时v1查询在接口处被收到，&lt;strong&gt;v2主机会启动一个400秒的倒数计时器&lt;/strong&gt;（&lt;strong&gt;向下兼容v1&lt;/strong&gt;），当另一个v1查询被收到时，计时器被复位。如果计时器到时，此接口恢复成为v2接口并且v2信息被再次发送。&lt;/p&gt;
&lt;h4 id=&#34;v1主机与v2路由器&#34;&gt;v1主机与v2路由器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;只会运行v2版本，v1主机后续无法收到组播流量&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596710463619.png&#34; alt=&#34;v1主机与v2路由器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
局域网中v1的主机也是同一组成员，那么该组的v1报告总是被收到，因为v2报告在v1的主机中不会被抑制，v1的主机不兼容v2的报告，因此&lt;strong&gt;忽略它们&lt;/strong&gt;。无论何时，只要v1的主机成为组成员，v2离开过程都将被搁置&lt;/p&gt;
&lt;h4 id=&#34;混合版本&#34;&gt;混合版本&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;只要有1的查询者存在，只会运行v1&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596710522472.png&#34; alt=&#34;混合版本&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果一些&lt;strong&gt;运行v1的路由器&lt;/strong&gt;存在于子网中，那么必须强制性地为子网中的&lt;strong&gt;所有路由器配置v1以便正常使用&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;v3&#34;&gt;v3&lt;/h3&gt;
&lt;p&gt;服务于SSM模型；允许主机指定接收某些网络发送的某些组播组；增加了主机的控制能力，&lt;strong&gt;不仅可以指定组播组，还能指定组播的源&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;报文格式-3&#34;&gt;报文格式&lt;/h4&gt;
&lt;p&gt;IGMPv3报文包含两大类：查询报文和成员报告报文。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查询报文（0x11）
&lt;ol&gt;
&lt;li&gt;普遍组查询报文&lt;/li&gt;
&lt;li&gt;特定组查询报文&lt;/li&gt;
&lt;li&gt;特定源组查询报文（离组通过该报文实现，离组之后，查询器发送该报文进行查询）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613224109571.png&#34; alt=&#34;IGMPv3查询报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Type&lt;br&gt;
等于0x11&lt;/li&gt;
&lt;li&gt;Max Response Code（最大响应时间）&lt;br&gt;
成员主机在收到IGMP查询器发送的普遍组查询报文后，需要在最大响应时间内做出回应&lt;/li&gt;
&lt;li&gt;Group Address（组播组地址）&lt;br&gt;
在普遍组查询报文中，该字段设为0；在特定组查询报文和特定源组查询报文中，该字段为要查询的组播组地址&lt;/li&gt;
&lt;li&gt;S&lt;br&gt;
为1时，所有收到此查询报文的其他路由器&lt;strong&gt;不启动定时器刷新过程&lt;/strong&gt;，但是此查询报文并不抑制查询器选举过程和路由器的主机侧处理过程&lt;/li&gt;
&lt;li&gt;QRV&lt;br&gt;
&lt;code&gt;即在v2中计算查询者老化时间中的那个2，在v3中默认为2&lt;/code&gt;&lt;br&gt;
非0，则表示查询器的健壮系数，将自己的健壮系数调整为该字段的值；为0，则表示查询器的健壮系数大于7，则不做处理&lt;/li&gt;
&lt;li&gt;QQIC（IGMP查询器的查询间隔）&lt;br&gt;
单位为秒，非查询器收到查询报文时，如果发现该字段非0，则将自己的查询间隔参数调整为该字段的值；如果发现该字段为0，则不做处理&lt;/li&gt;
&lt;li&gt;Number of Sources（报文中包含的组播源的数量）&lt;br&gt;
对于普遍组查询报文和特定组查询报文，该字段为0；对于特定源组查询报文，该字段非0，此参数的大小受到所在网络MTU大小的限制&lt;/li&gt;
&lt;li&gt;Source Address（组播源地址）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成员报告报文（0x22）&lt;code&gt;目的地址为224.0.0.22（代表所有运行v3的路由器，即主机不监听，因此v3也就没有响应抑制机制）&lt;/code&gt;&lt;br&gt;
不仅包含主机想要加入的组播组，而且包含主机想要接收来自哪些组播源的数据&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613224330953.png&#34; alt=&#34;IGMPv3成员报告报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Type&lt;br&gt;
等于0x22&lt;/li&gt;
&lt;li&gt;Number of Group Records（报文中包含的组记录的数量）&lt;/li&gt;
&lt;li&gt;Group Record（组记录）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613224926638.png&#34; alt=&#34;Group Record&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;Record Type（组记录的类型），共分为3类
&lt;ol&gt;
&lt;li&gt;当前状态报告：用于对查询报文进行响应，通告自己目前的状态，共两种：
&lt;ol&gt;
&lt;li&gt;MODE_IS_INCLUDE，表示接收源地址列表包含的源发往该组的组播数据&lt;/li&gt;
&lt;li&gt;MODE_IS_EXCLUDE，表示不接收源地址列表包含的源发往该组的组播数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;过滤模式改变报告：当组和源的关系在INCLUDE和EXCLUDE之间切换时，会通告过滤模式发生变化，共两种：
&lt;ol&gt;
&lt;li&gt;CHANGE_TO_INCLUDE_MODE，表示过滤模式由EXCLUDE转换到INCLUDE，接收源地址列表包含的新组播源发往该组播组的数据&lt;/li&gt;
&lt;li&gt;CHANGE_TO_EXCLUDE_MODE，表示过滤模式由INCLUDE转换到EXCLUDE，拒绝源地址列表包含的新组播源发往该组的组播数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;源列表改变报告：当指定源发生改变时，会通告源列表发生变化，共两种：
&lt;ol&gt;
&lt;li&gt;ALLOW_NEW_SOURCES，表示在现有的基础上，需要接收源地址列表包含的组播源发往该组播组的组播数据&lt;/li&gt;
&lt;li&gt;BLOCK_OLD_SOURCES，表示在现有的基础上，不再接收源地址列表包含的组播源发往该组播组的组播数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工作机制&#34;&gt;工作机制&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613227026206.png&#34; alt=&#34;工作机制&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;v3响应消息的目的地址为224.0.0.22&lt;/strong&gt;（代表所有运行v3的路由器），其中可以携带至少一个组记录，在每个组记录中，包含组播组地址、数目不等的源地址信息。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;特定源组加入&lt;br&gt;
网络中存在S1和S2两个组播源，均向组播组G发送组播数据，Host仅希望接收从组播源S1发往组播组G的信息&lt;br&gt;
如果Host和组播路由器之间运行的是IGMPv1或IGMPv2，Host加入组播组G时无法对组播源进行选择，无论其是否需要，都会同时接收到来自组播源S1和S2的数据。如果采用IGMPv3，成员主机可以选择仅接收S1组播数据。
&lt;ol&gt;
&lt;li&gt;Host发送IGMPv3报告（G，INCLUDE，(S1)），仅接收源S1向组播组G发送的数据&lt;/li&gt;
&lt;li&gt;Host发送IGMPv3报告（G，EXCLUDE，(S2)），不接收指定源S2向组播组G发送的数据，从而仅有来自S1的组播数据才能传递到Host&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特定源组查询&lt;br&gt;
当接收到组成员发送的&lt;strong&gt;改变组播组与源列表的对应关系&lt;/strong&gt;的报告时（&lt;code&gt;CHANGE_TO_INCLUDE_MODE、CHANGE_TO_EXCLUDE_MODE、ALLOW_NEW_SOURCES、BLOCK_OLD_SOURCES&lt;/code&gt;），IGMP查询器会发送&lt;strong&gt;特定源组查询&lt;/strong&gt;报文。如果组成员希望接收其中任意一个源的组播数据，将反馈报告报文。IGMP查询器根据反馈的组成员报告更新该组对应的源列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;改进之处&#34;&gt;改进之处&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596780155795.png&#34; alt=&#34;改进之处&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
v3不仅支持v1的普遍组查询、v2的特定组查询，还支持v3的指定源/组查询。在IGMP消息中携带组播源地址和多种控制字段（如查询器强壮性系数、查询间隔等）。&lt;br&gt;
对于普遍组查询，既不携带组地址(0.0.0.0)，也不携带源地址；对于特定组查询，携带组地址，但是不携带源地址；对于指定源/组查询，既携带组地址，而且还携带至少一个源地址&lt;/p&gt;
&lt;h3 id=&#34;igmp三个版本的比较&#34;&gt;IGMP三个版本的比较&lt;/h3&gt;
&lt;h4 id=&#34;1-版本服务的组播模型&#34;&gt;1. 版本服务的组播模型&lt;/h4&gt;
&lt;p&gt;IGMPV1和V2服务于ASM模型，只能指定组播组，不能指定组播源，可以使用的组播地址范围：224.0.1.0到238.255.255.255，除去232.0.0.0/8（用于SSM）&lt;br&gt;
IGMPV3可以同于服务于ASM和SSM，可以同时指定需要加入的组播组和组播源，并且在报文中可以同时通告多个组。&lt;/p&gt;
&lt;h4 id=&#34;2-报文类型&#34;&gt;2. 报文类型&lt;/h4&gt;
&lt;p&gt;IGMPV1:  成员关系查询0x11、成员关系报告0x12&lt;br&gt;
IGMPV2:  成员关系查询0x11&lt;code&gt;普遍组查询、特定组查询&lt;/code&gt; 、成员关系报告0x16、离组报文0x17&lt;br&gt;
IGMPV3:  成员关系查询0x11&lt;code&gt;普遍组查询、特定组查询、特定源组查询&lt;/code&gt;、成员关系报告0x22&lt;code&gt;当前状态报告：MODE_IS_INCLUDE、MODE_IS_EXCLUDE；过滤模式改变报告：CHANGE_TO_INCLUDE_MODE、CHANGE_TO_EXCLUDE_MODE；源列表改变报告：ALLOW_NEW_SOURCE、BLOCK_OLD_SOURCE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;v1和v2所有组播路由其监听224.0.0.2；v3成员报告报文目的地址为224.0.0.22，即所有运行v3的路由器监听地址，但是主机不监听，因此v3也就没有响应抑制机制&lt;/p&gt;
&lt;h4 id=&#34;3-报文结构&#34;&gt;3. 报文结构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;V1：版本、类型、组播组&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596636710868.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;V2：类型、最大响应时间、组播组&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596697000398.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;V3：分为查询报文和成员报告报文&lt;br&gt;
查询报文：继承v2的前8B，即类型、Max Response Code(最大响应时间)和组播组地址，之后又添加4B，主要针对的是查询者，主要包含S(抑制查询者定时器)、QRV(查询器的健壮系数)、QQIC(查询间隔)，除此之外还有组播源地址个数和地址&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613224109571.png&#34; alt=&#34;IGMPv3查询报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
成员报告报文：类型、组记录的数量和类型&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613224330953.png&#34; alt=&#34;IGMPv3成员报告报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;4-版本工作流程&#34;&gt;4. 版本工作流程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;组成员加组&lt;br&gt;
v1和v2只能加入指定的组播组，无法指定组播源；&lt;br&gt;
v3不仅能够指定组播组，还能够选择组播源&lt;/li&gt;
&lt;li&gt;组成员离组&lt;br&gt;
v1离组没有离组报文，需要等待130秒之后，组播表才会删除；&lt;br&gt;
v2离组时会发送离组报文，但只有last reporter才会发送离组报文，其他接收者不会发送离组报文，查询者收到离组报文之后，会发送特定组查询报文，1秒/次，连续发2次；&lt;br&gt;
v3离组时因为没有离组报文，通过发送成员关系报告报文触发查询者的特定源组查询，这个成员关系报告报文中的组记录里面组播源数目设置为0，代表不接受任何组播源的组播流，从而实现离组&lt;/li&gt;
&lt;li&gt;组成员报告抑制&lt;br&gt;
v1和v2都有组成员报告抑制；&lt;br&gt;
v3路由器监听地址为224.0.0.22，但主机不监听此地址，因此v3没有响应抑制机制&lt;/li&gt;
&lt;li&gt;查询者的选举&lt;br&gt;
v1没有选举查询者机制，使用PIM的DR充当查询者，优先级相同时选择IP地址较大的；&lt;br&gt;
v2和v3均选举IP地址最小的为查询者，选举时间125秒；&lt;/li&gt;
&lt;li&gt;查询者的维护&lt;br&gt;
3个版本默认值均为125秒，&lt;br&gt;
v1无法改变也无法协商参数；&lt;br&gt;
v2可以修改参数，但是无法协商参数；&lt;br&gt;
v3可以修改参数，也可以协商，包括S、QRV和QQIC&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;igmp-snooping&#34;&gt;IGMP Snooping&lt;/h3&gt;
&lt;h4 id=&#34;背景&#34;&gt;背景&lt;/h4&gt;
&lt;p&gt;在很多情况下，组播报文要不可避免地经过一些二层交换设备，&lt;strong&gt;由于组播报文的目的地址为组播组地址，在二层设备上是学习不到这一类MAC表项的&lt;/strong&gt;，&lt;strong&gt;因此组播报文就会在所有接口进行广播&lt;/strong&gt;，和它在同一广播域内的组播成员和非组播成员都能收到组播报文，这样不但浪费了网络带宽，而且影响了网络信息安全。&lt;/p&gt;
&lt;h4 id=&#34;应用&#34;&gt;应用&lt;/h4&gt;
&lt;p&gt;配置IGMP Snooping后，二层组播设备可以&lt;strong&gt;侦听和分析组播用户和上游路由器之间的IGMP报文&lt;/strong&gt;，根据这些信息&lt;strong&gt;建立二层组播转发表项&lt;/strong&gt;&lt;code&gt;组播转发表项包含组播mac+组播地址+成员端口+路由器端口&lt;/code&gt;，控制组播数据报文转发，防止了组播数据在二层网络中的广播。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613278597795.png&#34; alt=&#34;应用&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本概念&#34;&gt;基本概念&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613278662661.png&#34; alt=&#34;基本概念&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;路由器端口：二层组播设备上&lt;strong&gt;朝向三层组播设备&lt;/strong&gt;（DR或IGMP查询器）一侧的接口，二层组播设备从此接口接收组播数据报文
&lt;ul&gt;
&lt;li&gt;动态路由器端口：收到源地址不为0.0.0.0的IGMP普遍组查询报文（老化定时器为180秒）或PIM Hello报文（老化定时器为105秒）&lt;/li&gt;
&lt;li&gt;静态路由器端口：手动配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;成员端口：二层组播设备上&lt;strong&gt;朝向组播组成员&lt;/strong&gt;一侧的端口，二层组播设备往此接口发送组播数据报文
&lt;ul&gt;
&lt;li&gt;动态成员端口：收到IGMP Report报文&lt;/li&gt;
&lt;li&gt;静态成员端口：手动配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工作机制-2&#34;&gt;工作机制&lt;/h4&gt;
&lt;p&gt;针对不同的报文进行不同的处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;普遍组查询：&lt;br&gt;
（目的地址为224.0.0.1）向VLAN内&lt;strong&gt;除接收接口外的其他所有接口转发&lt;/strong&gt;，并对接收接口做如下处理：
&lt;ol&gt;
&lt;li&gt;如果路由器端口列表中尚未包含该接口，则将其添加进去，并启动老化定时器&lt;code&gt;默认为180秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果路由器端口列表中已包含该动态路由器端口，则重置老化定时器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;成员报告：&lt;br&gt;
一是成员回复查询者的普遍组查询报文，二是成员加入组播组的报文。&lt;strong&gt;向VLAN内所有路由器端口转发&lt;/strong&gt;，从报文中解析出&lt;strong&gt;主机要加入的组播组地址&lt;/strong&gt;，并对接收接口做如下处理：
&lt;ol&gt;
&lt;li&gt;如果&lt;strong&gt;不存在&lt;/strong&gt;该组对应的&lt;strong&gt;转发表项&lt;/strong&gt;，则&lt;strong&gt;创建转发表项&lt;/strong&gt;，将该接口作为动态成员端口添&lt;strong&gt;加到出接口列表&lt;/strong&gt;中，并启动老化定时器&lt;code&gt;动态成员端口的老化定时器=健壮系数x普遍组查询间隔+最大响应时间，默认130秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;已存在&lt;/strong&gt;该组对应的&lt;strong&gt;转发表项&lt;/strong&gt;，但出接口列表中&lt;strong&gt;未包含该接口&lt;/strong&gt;，则将该接口作为动态成员端口&lt;strong&gt;添加到出接口列表&lt;/strong&gt;，并启动老化定时器&lt;/li&gt;
&lt;li&gt;如果已存在该组所对应的转发表项，且出接口列表中已包含该动态成员端口，则重置其老化定时器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;成员离开组播组&lt;br&gt;
（针对v2和v3）成员发送离组报文，查询器收到之后发送特定组查询或者特定源组查询报文
&lt;ol&gt;
&lt;li&gt;针对离组报文
&lt;ol&gt;
&lt;li&gt;判断离开的组是否存在&lt;strong&gt;对应的转发表项&lt;/strong&gt;，以及转发表项&lt;strong&gt;出接口列表是否包含&lt;/strong&gt;报文的&lt;strong&gt;接收接口&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;如果不存在该组对应的转发表项，或者该组对应转发表项的出接口列表中不包含接收接口，二层组播设备不转发该报文，将其直接丢弃&lt;/li&gt;
&lt;li&gt;如果存在该组对应的转发表项，且转发表项的出接口列表中包含该接口，二层组播设备会将报文向VLAN内所有路由器端口转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对于IGMP离开报文的接收接口，二层组播设备在其老化时间内：
&lt;ol&gt;
&lt;li&gt;如果从该接口收到了主机响应IGMP特定组/源组查询的报告报文，表示接口下还有该组的成员，于是重置其老化定时器&lt;/li&gt;
&lt;li&gt;如果没有从该接口收到主机响应IGMP特定组/源组查询的报告报文，则表示接口下已没有该组成员，则在&lt;strong&gt;老化时间超时后&lt;/strong&gt;，将接口从该组的转发表项出接口列表中删除&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;针对特定组（源组）查询报文：向有特定组成员的接口转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;【总结】:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成员端口（即接收者一侧）的维护时间默认为130秒，路由器端口的维护时间默认是180秒&lt;/li&gt;
&lt;li&gt;v1没有离组报文，需要等待130秒之后才能删除表项中离组的端口&lt;/li&gt;
&lt;li&gt;开启IGMP Snooping之后就&lt;strong&gt;没有成员响应抑制功能&lt;/strong&gt;了，交换机收到主机成员关系报告，只将该报文转发到路由器端口，不再向成员端口转发【因为交换机通过定时器维护端口，同时建立组播表需要知道哪些端口是成员端口，所有需要所有的成员端口都能够发送成员关系报告，因此每台接收者都是last reporter】&lt;/li&gt;
&lt;li&gt;IGMP Snooping维护端口依赖定时器，所以&lt;strong&gt;成员离组报文实际上已经没有任何意义&lt;/strong&gt;，交换机将特定源组查询报文转发到成员单口之后，没有接收者响应并不会立即删除该端口，需要等到&lt;strong&gt;130秒计时器超时之后才会删除该端口&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;igmp-snooping-proxy二层和igmp-proxy三层&#34;&gt;IGMP Snooping Proxy（二层）和IGMP Proxy（三层）&lt;/h3&gt;
&lt;h4 id=&#34;igmp-snooping-proxy&#34;&gt;IGMP Snooping Proxy&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;IGMP Snooping Proxy配置在交换机上，主要是为了代理路由器处理IGMP报文，减轻查询者路由器的压力。从查询者路由器角度看，这个交换机相当于接收者；从接收者主机角度看，这个交换机相当于发送者&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613288948022.png&#34; alt=&#34;IGMP Snooping Proxy&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IGMP Snooping Proxy功能在IGMP Snooping的基础上添加两项功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代替查询者向接收者发送IGMP查询报文&lt;/li&gt;
&lt;li&gt;代替接收者向查询者发送IGMP成员关系报告和离组报文&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;工作机制-3&#34;&gt;工作机制&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;普遍组查询报文&lt;br&gt;
向本VLAN内除接收接口以外的所有接口发送IGMP普遍组查询报文；同时根据本地维护的组成员关系生成报告报文，向所有路由器端口发送&lt;code&gt;为什么还会转发普遍组查询报文？为了复位成员端口定时器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;成员关系报告报文
&lt;ol&gt;
&lt;li&gt;若&lt;strong&gt;不存在该组对应的转发表项&lt;/strong&gt;，则创建转发表项，将接收接口作为动态成员端口添加到出接口列表中，并启动其老化定时器，然后向&lt;strong&gt;所有路由器端口发送该组的报告报文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;若已&lt;strong&gt;存在该组对应的转发表项&lt;/strong&gt;，且其出接口列表中已包含该动态成员端口，则重置其老化定时器&lt;/li&gt;
&lt;li&gt;若已存在该组对应的转发表项，但其出接口列表中&lt;strong&gt;不包含该接收接口&lt;/strong&gt;，则将该接口作为动态成员端口添加到出接口列表中，并启动其老化定时器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;离开报文
&lt;ol&gt;
&lt;li&gt;向接收接口发送针对该组的特定组查询报文。&lt;strong&gt;只有当删除某组播组对应转发表项中的最后一个成员端口时，才会向所有路由器端口发送该组的离开报文&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IGMP特定源组查询报文&lt;br&gt;
如果该组播组还有成员，则回复成员关系报文，否则&lt;strong&gt;直接丢弃&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;收到成员关系报告后，只有交换机上没有该组播mac地址表时才会向路由器发送成员关系报告；已经存在组播mac地址表项，则不需要再向路由器发送成员关系报告，只需要将成员端口加入组播mac地址表即可&lt;/li&gt;
&lt;li&gt;收到成员离组报文，会代替路由器发送特定组查询。只有一个组播组中没有成员之后，交换机才会向路由器发送离组报文&lt;/li&gt;
&lt;li&gt;交换机收到通用组查询报文之后，会向所有成员端口转发，并根据组播mac地址表项生成响应报文，回复查询者&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;igmp-proxy&#34;&gt;IGMP Proxy&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;IGMP Proxy配置在最后一跳路由器上（接入设备和成员主机之间的三层设备），工作原理和IGMP Snooping Proxy相同&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613287096583.png&#34; alt=&#34;IGMP Proxy&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在接入设备RouterA看来，RouterB就是一台主机；在下游成员主机看来，RouterB就是IGMP查询器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IGMP Proxy设备可以收集下游成员主机的IGMP报告/离开报文，将报告/离开报文汇聚后代理下游成员主机统一上送给接入设备&lt;/li&gt;
&lt;li&gt;IGMP Proxy设备也可以代理IGMP查询器向下游成员主机发送查询报文，维护组成员关系，基于组成员关系进行组播转发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;两种类型的接口：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上游接口（主机接口）：配置IGMP Proxy功能的接口，执行主机行为&lt;/li&gt;
&lt;li&gt;下游接口（路由器接口）：配置IGMP功能的接口，执行路由器行为&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;igmp-ssm-mapping&#34;&gt;IGMP SSM Mapping&lt;/h3&gt;
&lt;p&gt;作用：让只能运行IGMPv1或IGMPv2的接收者也能指定组播源，即能够使用SSM服务&lt;br&gt;
实现原理：启动了mapping后，要手动绑定一个源信息，让路由器知道源的信息，从而建成SPT树&lt;/p&gt;
&lt;h4 id=&#34;工作过程&#34;&gt;工作过程&lt;/h4&gt;
&lt;p&gt;配置了SSM Mapping规则后，当IGMP查询器收到来自成员主机的IGMPv1或IGMPv2报告报文时，检查该报文中所携带的组播组地址G：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果G在ASM地址范围内，则只提供ASM服务&lt;/li&gt;
&lt;li&gt;如果G在SSM组地址范围内：
&lt;ol&gt;
&lt;li&gt;如果路由器上没有G对应的SSM Mapping规则，则无法提供SSM服务，丢弃该报文&lt;/li&gt;
&lt;li&gt;如果路由器上有G对应的SSM Mapping规则，则依据规则将报告报文中所包含的(*, G)信息映射为(G, INCLUDE, (S1, S2...))信息，提供SSM服务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;IGMP SSM Mapping不处理IGMPv3的报告报文，但为了保证同一网段运行任意版本IGMP的主机都能得到SSM服务，需要在与成员主机所在网段相连的组播路由器接口上运行IGMPv3&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613401694204.png&#34; alt=&#34;工作过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
SSM网络中HostA运行IGMPv3、HostB运行IGMPv2、HostC运行IGMPv1。HostB和HostC无法升级到IGMPv3，如果要为该网段中的所有主机提供SSM服务，需要在IGMP查询器（Router）上使能IGMP SSM Mapping并配置相应的映射规则&lt;code&gt;在图中，查询器与主机相连的接口上需要运行IGMPv3&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;pim&#34;&gt;PIM&lt;/h2&gt;
&lt;p&gt;PIM称为协议无关组播，表示组播依靠的单播路由可以由静态路由、RIP、OSPF、ISIS、BGP等提供，&lt;strong&gt;组播路由和单播路由协议无关&lt;/strong&gt;，只要单播路由协议产生所需路由表项能够完成RPF检查即可。&lt;br&gt;
&lt;strong&gt;协议号为103&lt;/strong&gt;（0x67），目前使用的是v2版本，PIM路由器目的组播地址为&lt;strong&gt;224.0.0.13&lt;/strong&gt;。&lt;br&gt;
在组播路由器之间建立PIM的邻居关系，能够根据规则产生组播路由表。用于&lt;strong&gt;组播路由器之间&lt;/strong&gt;。PIM协议包括&lt;strong&gt;PIM-SM（稀疏模式）和PIM-DM（密集模式）&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PIM-DM适合规模较小、组播组成员相对比较集中的网络。不需要区分ASM模型和SSM模型&lt;/li&gt;
&lt;li&gt;PIM-SM适合规模较大、组成员相对比较分散的网络。根据组播地址区分ASM模型和SSM模型，如果在SSM组播地址范围内，则按照PIM-SM在SSM中的实现流程进行处理，&lt;strong&gt;PIM-SSM&lt;/strong&gt;不但效率高，而且简化了组播地址分配流程，特别适用于对于特定组&lt;strong&gt;只有一个特定源&lt;/strong&gt;的情况。如果在ASM组播地址范围内，则按照PIM-SM在ASM中的实现流程进行处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;概念介绍&#34;&gt;概念介绍&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613305769773.png&#34; alt=&#34;概念介绍&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;组播分发树mdt&#34;&gt;组播分发树MDT&lt;/h4&gt;
&lt;p&gt;PIM网络&lt;strong&gt;以组播组为单位&lt;/strong&gt;在路由器上建立一点到多点的组播转发路径&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SPT：以组播源为根，组播组成员为叶子，适用于PIM-DM或PIM-SM&lt;br&gt;
如图：RouterE→RouterD→RouterA（RouterB），就是一棵以Source为根，以HostA、HostB为叶子的SPT&lt;/li&gt;
&lt;li&gt;RPT：以RP为根，组播组成员为叶子，RPT适用于PIM-SM网络&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pim路由器&#34;&gt;PIM路由器&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;叶子路由器：&lt;strong&gt;与用户主机相连的PIM路由器&lt;/strong&gt;，但连接的用户主机不一定为组成员，如图：RouterA、RouterB、RouterC&lt;/li&gt;
&lt;li&gt;第一跳路由器：组播转发路径上，&lt;strong&gt;与组播源相连且负责转发该组播源发出的组播数据&lt;/strong&gt;的PIM路由器，如图：RouterE&lt;/li&gt;
&lt;li&gt;最后一跳路由器：组播转发路径上，&lt;strong&gt;与组播组成员相连且负责向该组成员转发组播数据&lt;/strong&gt;的PIM路由器，如图：RouterA、RouterB&lt;/li&gt;
&lt;li&gt;中间路由器：组播转发路径上，&lt;strong&gt;第一跳路由器与最后一跳路由器之间&lt;/strong&gt;的PIM路由器，如图：RouterD&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;pim路由表项&#34;&gt;PIM路由表项&lt;/h4&gt;
&lt;p&gt;PIM网络中存在两种路由表项：&lt;code&gt;S表示组播源，G表示组播组，*表示任意&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;（S，G）路由表项：用于在建立SPT，适用于PIM-DM或PIM-SM&lt;/li&gt;
&lt;li&gt;（*，G）路由表项：用于建立RPT，适用于PIM-SM&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PIM路由器上&lt;strong&gt;可能同时存在两种路由表项&lt;/strong&gt;，当收到源地址为S，组地址为G的组播报文，且RPF检查通过的情况下，按照如下的规则转发：&lt;code&gt;（S，G）优先级高于（*，G）&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果存在（S，G）路由表项，则由（S，G）路由表项指导报文转发&lt;/li&gt;
&lt;li&gt;如果不存在（S，G）路由表项，只存在（*，G）路由表项，则先依照（*，G）路由表项创建（S，G）路由表项，再由（S，G）路由表项指导报文转发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PIM路由表项中主要用于指导转发的信息如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组播源地址。&lt;/li&gt;
&lt;li&gt;组播组地址。&lt;/li&gt;
&lt;li&gt;上游接口：本地路由器上接收到组播数据的接口，如图：Int3&lt;/li&gt;
&lt;li&gt;下游接口：将组播数据转发出去的接口，如图：Int1、Int2&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pimv2报文头格式&#34;&gt;PIMv2报文头格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596788566300.png&#34; alt=&#34;报文头格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;版本：版本字段标识版本信息，目前为2&lt;/li&gt;
&lt;li&gt;报文类型：
&lt;ul&gt;
&lt;li&gt;0：Hello（周期30秒，死亡时间105秒&lt;code&gt;3.5倍hello时间&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;1：Register（注册，SM，单播）&lt;/li&gt;
&lt;li&gt;2：Register Stop（停止注册，SM，单播）&lt;/li&gt;
&lt;li&gt;3：Join/Prune（加入/剪枝）&lt;/li&gt;
&lt;li&gt;4：Bootstrap（SM，选取BSR）&lt;/li&gt;
&lt;li&gt;5：Assert（断言）&lt;/li&gt;
&lt;li&gt;6：Graft（嫁接，DM，单播）&lt;/li&gt;
&lt;li&gt;7：Graft Ack（嫁接确认，DM，单播）&lt;/li&gt;
&lt;li&gt;8：Candidate RP Advertisement（候选RP公告，SM，单播）&lt;/li&gt;
&lt;li&gt;9：State Refresh（状态刷新，DM）&lt;br&gt;
&lt;code&gt;SM独有的报文：Register、Register Stop、Bootstrap、Candidate RP Advertisement；DM独有的报文：Graft、Graft Ack、State Refresh&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ping一个组播组，有时第一个包通，但是后面的包不通，这是因为第一个包是用来注册的。如果后面的也不通，则说明组播网络有问题&lt;/code&gt;&lt;br&gt;
优先级值大的选举为DR，具备抢占性，组播地址为224.0.0.13，使用hello报文进行选举。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;报文&#34;&gt;报文&lt;/h3&gt;
&lt;h4 id=&#34;hello报文&#34;&gt;Hello报文&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596875197726.png&#34; alt=&#34;Hello报文&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
组播路由器需要使用Hello消息来发现邻居，并维护邻居关系。&lt;br&gt;
&lt;code&gt;除了头部，剩下的均为TLV格式&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type1：hello hold time，默认105秒，时间用2B表示，全1代表永远不过期，全0代表立即断开邻居关系&lt;/li&gt;
&lt;li&gt;type19：priority，只有SM中才有，通过比较Hello消息上携带的优先级（越高越优）和IP地址（越大越优），各路由器为各网段选举指定路由器DR&lt;/li&gt;
&lt;li&gt;type21：状态刷新功能&lt;/li&gt;
&lt;li&gt;type22：双向PIM&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;join报文&#34;&gt;Join报文&lt;/h4&gt;
&lt;p&gt;3个重要比特位：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;S：PIM-SM则置位&lt;/li&gt;
&lt;li&gt;W：标识该报文来自共享树&lt;/li&gt;
&lt;li&gt;R：表明该报文发送给RP&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;state-refresh状态刷新报文&#34;&gt;State Refresh状态刷新报文&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613316519968.png&#34; alt=&#34;状态刷新报文&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;R：表示是RP，PIM-DM中设置为0&lt;/li&gt;
&lt;li&gt;TTL：和IP中的TTL不同，这个TTL表示组播报文能够传输多远，默认为255&lt;/li&gt;
&lt;li&gt;P：如果状态刷新报文是从处于Prune状态的端口发送除去的，此位置1&lt;/li&gt;
&lt;li&gt;N：Prune Now flag，每发送3个状态刷新报文会置位1次，用于刷新端口的Prune状态&lt;code&gt;虽然剪枝定时器为210秒，但是每隔120秒就会被刷新一次&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;O：Assert Override flag，置位之后则刷新Assert的端口状态，即维护winner的地位，winner会转发状态刷新报文，而loser不会转发&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pim-dmdense_mode密集模式&#34;&gt;PIM-DM（Dense_mode，密集模式）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;链路一端配置DM，一端配置SM，虽然可以建立邻居，但是无法正常工作，主要是组播分发树不一样&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;工作机制-4&#34;&gt;工作机制&lt;/h4&gt;
&lt;p&gt;采用“&lt;strong&gt;推（Push）模式&lt;/strong&gt;”转发组播报文，因此此模式只关心两件事：哪些接口开启了PIM-DM模式；RPF检查。&lt;code&gt;采用推的机制的目的是在DM中产生组播路由表，先有组播路由表再去推组播流&lt;/code&gt;&lt;br&gt;
PIM-DM的&lt;strong&gt;关键任务&lt;/strong&gt;：建立SPT（最短路径树）&lt;/p&gt;
&lt;h5 id=&#34;1-邻居发现和dr竞选neighbor-discovery&#34;&gt;1. 邻居发现和DR竞选Neighbor Discovery&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596868793202.png&#34; alt=&#34;邻居发现&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PIM路由器上每个使能了PIM协议的接口都会对外发送Hello报文&lt;br&gt;
封装Hello报文的组播报文的目的地址是224.0.0.13（表示同一网段中所有PIM路由器）、源地址为接口的IP地址、&lt;strong&gt;TTL数值为1&lt;/strong&gt;、DR优先级等&lt;br&gt;
&lt;strong&gt;Hello报文的作用&lt;/strong&gt;：发现PIM邻居、协调各项PIM协议报文参数、维持邻居关系&lt;br&gt;
&lt;code&gt;选取DR（在DM模式下仅充当IGMPv1的查询者，无其他作用）&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;DR选举规则&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DR优先级越大越优&lt;/li&gt;
&lt;li&gt;DR优先级相同时，IP地址越大越优&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DR出现故障，将导致PIM邻居关系超时，其他PIM邻居之间会触发新一轮的DR竞选&lt;code&gt;同时也支持抢占&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;2-扩散flooding&#34;&gt;2. 扩散Flooding&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;扩散需要两次，第2此为了后来可能出现的需要流量的枝杈，即重新泛洪（180s倒计时）&lt;/code&gt;&lt;br&gt;
当PIM-DM网络中出现活跃的组播源之后，组播源发送的组播报文将在全网内扩散，下游PIM路由器接收到组播报文，根据单播路由表进行RPF检查通过后，然后在该路由器上创建（S，G）表项，组播报文继续向下游组播，直至到达叶子路由器，然后会出现以下两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;叶子路由器上&lt;strong&gt;存在组成员&lt;/strong&gt;，则将相应接口加入（S，G）表项，后续的组播报文会向组成员转发&lt;/li&gt;
&lt;li&gt;若&lt;strong&gt;不存在组成员&lt;/strong&gt;，且不需要向其下游PIM邻居转发组播报文，则进行&lt;strong&gt;剪枝&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613310319137.png&#34; alt=&#34;扩散&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;组播源S向组播组G发送组播报文&lt;/li&gt;
&lt;li&gt;RouterC接收到组播报文后，根据单播路由表进行RPF检查。RPF检查通过，创建（S，G）表项，继续向下游接口转发该组播报文&lt;/li&gt;
&lt;li&gt;RouterA接收到来自RouterC的组播报文，RPF检查成功，在本地创建对应（S，G）表项，存在组成员HostA，将与HostA相连的接口加入表项中&lt;/li&gt;
&lt;li&gt;RouterB接收到来自RouterC的组播报文，由于不存在组成员和PIM邻居，执行&lt;strong&gt;剪枝&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;3-剪枝prune&#34;&gt;3. 剪枝Prune&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;只有下游设备没有接收者之后才会向上游设备发送Prune报文&lt;/code&gt;&lt;br&gt;
剪枝是为了优化成SPT，剪枝行为是由下游PIM路由器设备发起，删除不需要转发组播流量的端口。&lt;strong&gt;剪枝延迟&lt;/strong&gt;，上游设备收到剪枝消息，&lt;strong&gt;默认延迟3秒&lt;/strong&gt;再剪枝。剪枝后形成SPT树&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613311931612.png&#34; alt=&#34;剪枝&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RouterB向上游RouterC发送Prune报文，通知RouterC不用再转发数据到该下游网段&lt;/li&gt;
&lt;li&gt;RouterC收到Prune报文后，停止该下游接口转发，将该下游接口从（S，G）表项中删除&lt;code&gt;只删除接口，不删除（S，G）表，因为后面可能有新的接收者加入，下游接口的状态由Forwarding变为Prune，计时器为210秒&lt;/code&gt;。&lt;strong&gt;由于RouterC上还存在其他处于转发状态的下游接口，剪枝过程停止&lt;/strong&gt;，后续到达的报文只向RouterA转发&lt;/li&gt;
&lt;li&gt;RouterA也会收到剪枝报文，因为它有接收者，所以回复一个剪枝否定报文，即Join报文&lt;/li&gt;
&lt;li&gt;RouterC会收到该Join报文，继续向RouterA相连的接口转发；RouterB收到之后知道了还有其他接收者，然后抑制Prune报文的发送（抑制之后再也不会发送Prune报文）&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;4-嫁接graft&#34;&gt;4. 嫁接Graft&lt;/h5&gt;
&lt;p&gt;针对在剪枝之后出现的接收者向上请求组播流，下游设备向上发嫁接（Graft）消息，上游设备向下发嫁接确认。嫁接之后形成新的SPT树&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613312395861.png&#34; alt=&#34;嫁接&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RouterB希望在下一次“扩散-剪枝”&lt;sub&gt;扩散--剪枝周期性进行，每3分钟重复一次&lt;/sub&gt;来临前恢复对HostB组播报文的转发，向上游路由器RouterC发送Graft报文，请求恢复相应出接口转发组播报文&lt;/li&gt;
&lt;li&gt;RouterC收到Graft报文后，回复Graft Ack报文，将该接口添加到（S，G）表项中的下游接口列表中。&lt;strong&gt;由于RouterC上有组播报文到达，嫁接过程停止&lt;/strong&gt;，后续到达的报文向RouterB转发&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5-断言assert&#34;&gt;5. 断言Assert&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;避免流量重复拷贝&lt;/code&gt;&lt;br&gt;
&lt;code&gt;触发发送Assert报文的条件：路由器从下游接口收到了自己转发的组播流量&lt;/code&gt;&lt;br&gt;
有多个相连的PIM路由器RPF检查通过向该网段转发组播报文时，则需要通过断言机制来保证只有一个PIM路由器向该网段转发组播报文。&lt;br&gt;
PIM路由器在接收到邻居路由器发送的相同组播报文后，会以组播的方式向本网段的所有PIM路由器发送Assert报文，其它PIM路由器在接收到Assert报文后，将自身参数与对方报文中携带的参数做比较，进行Assert竞选。&lt;br&gt;
&lt;strong&gt;竞选规则：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单播路由协议优先级较高者获胜&lt;/li&gt;
&lt;li&gt;如果优先级相同，则到组播源的开销较小者获胜&lt;/li&gt;
&lt;li&gt;如果以上都相同，则下游接口IP地址最大者获胜&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据Assert竞选结果，&lt;strong&gt;路由器将执行不同的操作&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获胜一方的下游接口称为&lt;strong&gt;Assert Winner&lt;/strong&gt;，将&lt;strong&gt;负责&lt;/strong&gt;后续对该网段&lt;strong&gt;组播报文的转发&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;落败一方的下游接口称为&lt;strong&gt;Assert Loser&lt;/strong&gt;，后续&lt;strong&gt;不会对该网段转发组播报文&lt;/strong&gt;，PIM路由器也会将其从（S，G）表项&lt;strong&gt;下游接口列表中删除&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613312914276.png&#34; alt=&#34;断言&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;RouterB和RouterC从各自下游接口接收到对方发来的组播报文，RPF检查都失败，报文被丢弃。同时，RouterB和RouterC分别向该网段发送Assert报文&lt;/li&gt;
&lt;li&gt;RouterB将自身的路由信息与RouterC发来的Assert报文中携带的路由信息进行比较，由于自身到组播源的开销较小而获胜，于是后续组播报文仍然向该网段转发&lt;/li&gt;
&lt;li&gt;RouterC在接收到组播报文后仍然由于RPF检查失败而丢弃，RouterC将自身的路由信息与RouterB发来的Assert报文中携带的路由信息进行比较，由于自身到组播源的开销较大而落败。于是禁止相应下游接口向该网段转发组播报文，将其从（S，G）表项的下游接口列表中删除&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么有RPF检查了，还需要断言？&lt;br&gt;
RPF检查是为了防止组播流量转发环路或者收到重复的组播流，而断言机制是收到了重复的组播流之后为了避免流量的重复拷贝而进行的&lt;br&gt;
如上图，RouterD执行RPF检查，与RouterB和RouterC相连的接口都能通过RPF检查，如果没有断言机制，RouterD就会收到重复的组播流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;6-状态刷新state-refresh&#34;&gt;6. 状态刷新State Refresh&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;发送状态刷新报文的条件：第一跳路由器收到组播源的组播流&lt;/code&gt;&lt;br&gt;
&lt;code&gt;状态刷新报文的作用：1. 维护Prune状态；2. 维护Assert状态&lt;/code&gt;&lt;br&gt;
为了避免被裁剪的接口因为“剪枝定时器&lt;code&gt;默认210秒&lt;/code&gt;”超时而恢复转发，&lt;strong&gt;第一跳路由器会周期性（60秒）地触发State Refresh报文在全网内扩散&lt;/strong&gt;，收到State Refresh报文的&lt;strong&gt;PIM路由器会刷新剪枝定时器的状态&lt;/strong&gt;。被裁剪接口的下游叶子路由器&lt;strong&gt;如果一直没有组成员加入，该接口将一直处于抑制转发状态&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613312561028.png&#34; alt=&#34;状态刷新&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RouterC触发状态刷新，将State Refresh报文向RouterA和RouterB扩散&lt;/li&gt;
&lt;li&gt;RouterC上存在被裁剪接口，刷新该接口的“剪枝定时器”的状态。下一次“扩散-剪枝”来临时，由于RouterB上仍然没有组成员加入，RouterC上被裁剪的接口将被抑制转发组播报文&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;总结与评价&#34;&gt;总结与评价&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;协议假设：网络中的每个子网都存在至少一个对组播源感兴趣的接受站点，因此组播数据包被扩散到网络中的所有网段，因此对于小型网络来说非常有效&lt;/li&gt;
&lt;li&gt;PIM-DM对没有组播数据转发的分支进行Prune剪枝操作，只保留包含接收者的分支&lt;/li&gt;
&lt;li&gt;为了使剪掉的有组播数据转发需求的分支能够重新接收组播流数据，剪掉的分支周期性的恢复成转发状态&lt;/li&gt;
&lt;li&gt;为了减少等待被剪掉的分支恢复成转发状态的延时时间，PIM-DM使用Graft机制主动恢复组播报文的转发&lt;/li&gt;
&lt;li&gt;PIM-DM域中数据包的转发路径是有源树
&lt;ul&gt;
&lt;li&gt;以组播源为根，组播组成员为枝叶的一棵树&lt;/li&gt;
&lt;li&gt;由于有源树使用的是从组播源到接收者的最短路径，因此也称为最短路径树SPT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PIM-DM不依赖于特定的单播路由协议，而是使用现存的单播路由表进行RPF检查&lt;/li&gt;
&lt;li&gt;优势：
&lt;ul&gt;
&lt;li&gt;易于配置，且实现机制简单：邻居发现--扩散--剪枝--嫁接--断言--状态刷新&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;潜在问题：
&lt;ul&gt;
&lt;li&gt;扩散剪枝过程不够高效，复杂的Assert机制&lt;/li&gt;
&lt;li&gt;不支持共享树【共享树不用于转发数据，其入接口为NULL，仅用于产生（S,G），这是和SM模式的重要区别】&lt;/li&gt;
&lt;li&gt;控制和数据平面混合导致网络内部的所有路由器上都由（S，G）表项存在【一旦有任意组播源出现，所有设备会自动生成表项，占用内存】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;pim-smasm模型&#34;&gt;PIM-SM（ASM模型）&lt;/h3&gt;
&lt;h4 id=&#34;基本原理&#34;&gt;基本原理&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在ASM模型中，PIM-SM使用“&lt;strong&gt;拉（Pull）模式&lt;/strong&gt;”转发组播报文，&lt;strong&gt;从接收者开始向RP方向尝试拉取组播流&lt;/strong&gt;，&lt;code&gt;先有组播路由表，后有组播流&lt;/code&gt;一般应用于组播组成员规模相对较大、相对稀疏的网络。基于这一种稀疏的网络模型，它的实现方法是：
&lt;ol&gt;
&lt;li&gt;在网络中维护一台重要的PIM路由器：汇聚点RP，可以为随时出现的组成员或组播源服务，&lt;strong&gt;网络中所有PIM路由器都知道RP的位置&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当网络中&lt;strong&gt;出现组成员&lt;/strong&gt;时，&lt;strong&gt;最后一跳路由器向RP发送Join报文&lt;/strong&gt;，逐跳创建（*，G）表项，&lt;strong&gt;生成一棵以RP为根的RPT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当网络中&lt;strong&gt;出现&lt;/strong&gt;活跃的&lt;strong&gt;组播源&lt;/strong&gt;时，&lt;strong&gt;第一跳路由器将组播数据封装在Register报文中单播发往RP&lt;/strong&gt;，在RP上创建（S，G）表项，注册源信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;术语
&lt;ol&gt;
&lt;li&gt;源：发送组播数据的终端主机或PC&lt;/li&gt;
&lt;li&gt;接收者：接收组播数据的终端主机或PC&lt;/li&gt;
&lt;li&gt;汇聚点RP：接收者从这里获取源信息，并且是共享树的根&lt;code&gt;一个RP可以同时为多个组播组服务，但一个组播组只能对应一个RP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;指定路由器DR（需要向向RP注册）：在共享网段上选举&lt;strong&gt;优先级最高（数值最大）或者IP地址最大&lt;/strong&gt;的路由器为DR；
&lt;ol&gt;
&lt;li&gt;源端DR：负责向RP发送单播的Register消息，将数据从源转发至RP&lt;/li&gt;
&lt;li&gt;接收者（组成员端）DR：负责向RP发送（*，G）的Join加入消息，将数据从RP转发到接收者或称最后一跳DR&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;RPT：从&lt;strong&gt;接收者DR到RP&lt;/strong&gt;逐跳建立起来的，&lt;strong&gt;以RP为根的共享树&lt;/strong&gt;。RPT实现了组播数据按需转发的目的，减少了数据泛洪对网络带宽的占用&lt;/li&gt;
&lt;li&gt;SPT：从&lt;strong&gt;接收者DR到源DR&lt;/strong&gt;建立起来的，&lt;strong&gt;以源DR为根的最短路径树&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BSR：自举路由器，负责在PIM-SM网络启动后，收集网络内的RP信息，为每个组选举出RP，然后将RP集（即组-RP映射数据库）发布到整个PIM-SM网络。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;PIM-SM的&lt;strong&gt;关键任务&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;建立RPT：
&lt;ol&gt;
&lt;li&gt;接收者通过IGMP向叶路由器报告组播流需求，叶路由器产生（*，G）&lt;/li&gt;
&lt;li&gt;SM要求整个组播网络的所有参与路由器都需要知道RP的位置&lt;/li&gt;
&lt;li&gt;叶路由器向RP方向做RPF检查，从RPF邻居接口向上游发送PIM的join消息&lt;/li&gt;
&lt;li&gt;上游路由器产生（*，G） ，同时向上传递join消息，直至RP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;建立SPT:
&lt;ol&gt;
&lt;li&gt;第一跳路由器最先感知到组播流和组播源，执行注册，将组播流封装在单播报文中，单播转发至RP，向RP注册组播源地址&lt;/li&gt;
&lt;li&gt;RP主动向着组播源方向发起PIM join（S,G），这个过程会形成SPT&lt;/li&gt;
&lt;li&gt;注册停止，当SPT建立完毕，第一跳路由器将能够沿着SPT向下转发组播流，当RP收到来自SPT的组播流，将单播向第一跳路由器发送注册停止消息&lt;/li&gt;
&lt;li&gt;第一跳路由器收到注册停止消息，停止发送注册报文&lt;br&gt;
&lt;code&gt;此时，SM中RPT也负责转发组播流，但是，目前为止，组播的转发路径依然不是最优的&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;SPT切换：
&lt;ol&gt;
&lt;li&gt;当叶路由器接收到组播流，将感知到组播源地址，默认的情况下，叶路由器会立刻触发一个叫做SPT切换的过程&lt;/li&gt;
&lt;li&gt;叶路由器将根据感知到的组播源地址，针对组播源做RPF检查。向着源方向做(S,G) join，完成后组播流将沿着SPT转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;工作机制-5&#34;&gt;工作机制&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613380751089.png&#34; alt=&#34;工作机制&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;1-邻居发现和dr竞选&#34;&gt;1. 邻居发现和DR竞选&lt;/h5&gt;
&lt;p&gt;与PIM-DM发现和选举过程基本相同，但是DR的作用不同。在PIM-DM中的DR只能充当IGMPv1的查询者，但在PIM-SM中，&lt;strong&gt;DR来负责源端（源DR）或组成员端（接收者DR）组播报文的收发&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613368585670.png&#34; alt=&#34;邻居发现和DR竞选&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;2-rp发现&#34;&gt;2. RP发现&lt;/h5&gt;
&lt;p&gt;汇聚点RP用于&lt;strong&gt;处理源端DR注册信息及组成员加入请求&lt;/strong&gt;，网络中的所有PIM路由器都&lt;strong&gt;必须知道RP的地址&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;配置RP方式：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态RP：在所有PIM路由器上静态指定RP的地址&lt;/li&gt;
&lt;li&gt;动态RP：在PIM域内选择几台PIM路由器，配置C-RP（候选RP）来动态竞选出RP。同时，还需要通过配置C-BSR（候选BSR）选举出BSR，来收集C-RP的通告信息，向PIM-SM域内的所有PIM路由器发布。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;BSR竞选：&lt;/strong&gt;&lt;br&gt;
每个C-BSR都认为自己是BSR，泛洪Bootstrap报文，携带自己的地址和优先级，其他PIM路由器都收到所有C-BSR发出的Bootstrap报文，通过比较这些C-BSR信息，竞选产生BSR，规则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优先级越大越优&lt;/li&gt;
&lt;li&gt;如果优先级相同，IP越大越优&lt;br&gt;
&lt;code&gt;一个网络内部只有一个BSR，但可以配置多个C-BSR。BSR周期性（60秒，老化时间时130秒）地向组播发送BSR消息（即TTL=1，消息内容包含BSR地址和RP集，其中RP集中主要是C-RP发送给BSR的信息的汇总，包含C-RP的地址、服务范围、优先级等），所有的路由器使用收到的RP集来确定RP，所有路由器都使用相同的RP选择算法，选择的RP也是一致的&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613369054372.png&#34; alt=&#34;RP竞选&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;RP竞选：&lt;/strong&gt;&lt;br&gt;
C-RP向BSR发送Advertisement报文&lt;code&gt;通过单播方式发送（目标地址为BSR地址，源地址为C-RP地址）&lt;/code&gt;，报文中携带C-RP地址、服务的组范围和C-RP优先级，BSR将这些信息汇总为RP集，然后在整个网络中泛洪，各PIM路由器根据RP集竞选出该组RP，竞选规则如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;与用户加入的组地址匹配的C-RP服务的组范围掩码最长者获胜&lt;/li&gt;
&lt;li&gt;C-RP&lt;strong&gt;优先级越小越优，默认优先级为0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;执行Hash值越大越优&lt;code&gt;hash值由3部分组成：组地址、RP地址、hash掩码长度（默认为30，除了用作hash，还可以用来做RP的负载）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;C-RP的IP越大越优&lt;br&gt;
&lt;code&gt;总结：C-RP周期（60秒）性单播发送候选信息，超时时间为150秒，选举规则：服务范围小的、优先级值小的优先级高、hash结果大的、IP地址大的&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;因此，RP并不是BSR选出来的，是由其他PIM路由器自己选出来的，其他PIM路由器依据BSR发送的RP集进行选举的&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;3-rpt构建&#34;&gt;3. RPT构建&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613369891769.png&#34; alt=&#34;RPT构建&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
出现接收者时，从接收者DR开始，逐跳发送Join报文，中间的PIM路由器会进行RPF检查&lt;sub&gt;查找到达RP的单播路由，单播路由的出接口为上游接口，下一跳为RPF邻居&lt;/sub&gt;，直至到RP，在通向RP的路径上逐跳创建（*，G）表项，生成一棵以RP为根的RPT。&lt;/p&gt;
&lt;h5 id=&#34;4-组播源注册&#34;&gt;4. 组播源注册&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613370276319.png&#34; alt=&#34;组播源注册&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新出现的组播源都必须首先在RP处注册，注册过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组播源将组播报文发给源端DR&lt;/li&gt;
&lt;li&gt;源端DR（第一跳路由器）接收到组播报文后，将其封装在Register报文中（源地址为源DR连接组播源接口的地址，目的地址为RP地址），&lt;strong&gt;单播&lt;/strong&gt;发送给RP&lt;code&gt;此时在源DR和RP之间的路由器上并不会产生（S，G）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RP接收到Register报文，将其解封装，进行RPF检查，建立（S，G）表项&lt;sub&gt;老化时间为210秒&lt;/sub&gt;。
&lt;ol&gt;
&lt;li&gt;如果RP上已经有需要该组播源的组播组，那么RP会将组播数据沿RPT发送到达组成员，并向源DR发送（S，G）的Join报文&lt;sub&gt;之后会以60秒为周期发送，主要是维护（S，G）表项&lt;/sub&gt;，&lt;strong&gt;在源DR与RP之间的路由器收到Join报文之后会建立（S，G）表项&lt;/strong&gt;，同时源DR也会停止注册过程&lt;/li&gt;
&lt;li&gt;如果没有需要该组播源的组播组，则将该组播数据丢弃，向源DR单播发送停止注册消息，停止注册过程&lt;code&gt;注册停止报文计时器60秒，即停止注册报文只有在组播源注册之后，且没有接受者的情况下才会发送&lt;/code&gt;&lt;br&gt;
&lt;code&gt;PIM-SM中，偶尔会出现的组播初始流量通，后续流量不通的情况：最开始是单播注册转发&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;5-spt切换&#34;&gt;5. SPT切换&lt;/h5&gt;
&lt;p&gt;为了解决所有组播报文都封装在注册报文中经过RP解封之后再按照RPT转发，导致RP压力过大的问题，PIM-SM允许&lt;strong&gt;RP或组成员端DR&lt;/strong&gt;通过触发SPT切换来减轻RP的负担：&lt;br&gt;
&lt;code&gt;RP或者组成员端DR在接收到第一份组播报文时都会触发各自的SPT切换。如果SPT和RPT是一棵树则没必要进行切换&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RP触发SPT切换
&lt;ol&gt;
&lt;li&gt;RP收到源端DR的注册报文后，将封装在注册报文中的组播报文沿RPT转发给组成员，同时RP会向源端DR逐跳发送Join报文。发送过程中在PIM路由器创建（S，G）表项，从而建立了&lt;strong&gt;RP到源的SPT&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SPT树建立成功后，&lt;strong&gt;源端DR直接将组播报文转发到RP&lt;/strong&gt;，不需要再封装在注册报文中，使源端DR和RP免除了频繁的封装与解封装&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;组成员端DR触发SPT切换&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613370992390.png&#34; alt=&#34;SPT切换&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;组成员端DR逐跳向源端DR逐跳发送Join报文&lt;/strong&gt;并创建（S，G）表项，建立源端DR到接收者DR的SPT&lt;/li&gt;
&lt;li&gt;SPT建立后，&lt;strong&gt;组成员端DR会沿着RPT逐跳向RP发送剪枝报文&lt;/strong&gt;，删除（S，G）表项中相应的下游接口。剪枝结束后，RP不再沿RPT转发组播报文到组成员端。&lt;code&gt;此处的剪枝和PIM-DM中略有不同，DM中剪枝之后端口还保留在组播表中，只是状态由转发变为剪枝，但是SM中是直接从组播表中删除的&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;SPT不经过RP，RP会继续向源端DR逐跳发送剪枝报文&lt;/strong&gt;，删除（S，G）表项中相应的下游接口。剪枝结束后，源端DR不再沿“源端DR-RP”的SPT转发组播报文到RP。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;6-断言assert&#34;&gt;6. 断言Assert&lt;/h5&gt;
&lt;p&gt;断言机制与PIM-DM中的相同&lt;/p&gt;
&lt;h4 id=&#34;特殊场景&#34;&gt;特殊场景&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613389903520.png&#34; alt=&#34;特殊场景&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这个场景下PC可以接收到组播流量，原因是SPT切换。但是华为在这种情况下不是依赖SPT切换实现，是通过第一跳路由器不断的发送Assert报文实现的。&lt;/p&gt;
&lt;h3 id=&#34;pim-smssm模型&#34;&gt;PIM-SM（SSM模型）&lt;/h3&gt;
&lt;h4 id=&#34;基本原理-2&#34;&gt;基本原理&lt;/h4&gt;
&lt;p&gt;SSM模型是借助&lt;strong&gt;PIM-SM的部分技术和IGMPv3/MLDv2&lt;/strong&gt;来实现的，&lt;strong&gt;无需维护RP、构建RPT、注册组播源&lt;/strong&gt;，可以&lt;strong&gt;直接在源与组成员之间建立SPT&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;SSM特点&lt;/strong&gt;：网络用户能&lt;strong&gt;够预先知道组播源的具体位置&lt;/strong&gt;。&lt;br&gt;
在SSM模型中，PIM-SM的关键机制包括邻居发现、DR竞选、构建SPT。&lt;/p&gt;
&lt;h4 id=&#34;工作机制-6&#34;&gt;工作机制&lt;/h4&gt;
&lt;h5 id=&#34;1-邻居发现和dr竞选-2&#34;&gt;1. 邻居发现和DR竞选&lt;/h5&gt;
&lt;p&gt;此过程和PIM-SM（ASM模型）中的相同&lt;/p&gt;
&lt;h5 id=&#34;2-spt构建&#34;&gt;2. SPT构建&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613373441266.png&#34; alt=&#34;SPT构建&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;RouterD、RouterE借助IGMPv3/MLDv2协议了解到&lt;strong&gt;用户主机有到相同组播组，但是不同组播源的组播需要&lt;/strong&gt;，逐跳向源方向发送Join报文&lt;/li&gt;
&lt;li&gt;PIM路由器通过Join报文分别创建（S1，G）、（S2，G）表项，从而分别建立了源S1到组成员HostA、源S2到组成员HostB的SPT&lt;/li&gt;
&lt;li&gt;SPT建立后，源端就会将组播报文沿着SPT分发给组成员&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;ssm与asm模型比较&#34;&gt;SSM与ASM模型比较&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SSM模型与ASM模型之间的最大差异就是是否指定了组播源&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613374814256.png&#34; alt=&#34;SSM与ASM模型比较&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;g与sg条目关系&#34;&gt;（*，G）与（S，G）条目关系&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596965258370.png&#34; alt=&#34;条目关系&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;msdp&#34;&gt;MSDP&lt;/h2&gt;
&lt;p&gt;组播源发现协议，解决多个PIM-SM域之间的互连的一种域间组播协议，用来发现其他PIM-SM域内的组播源信息，实现组播报文的跨域转发。&lt;strong&gt;只有IPv4网络中PIM-SM使用ASM模型时，才需要使用MSDP&lt;/strong&gt;。&lt;br&gt;
SDP通过在不同PIM-SM域的路由器（通常在RP上）之间建立MSDP对等体，MSDP对等体之间交互SA（Source-Active）消息，共享组播源信息，最终可以使一个域内的组播用户接收到其他域的组播源发送的组播数据&lt;/p&gt;
&lt;h3 id=&#34;任意播anycast&#34;&gt;任意播Anycast&lt;/h3&gt;
&lt;p&gt;任意播地址是从单播地址空间中划分出来的。当&lt;strong&gt;一个单播地址分配给多个接口&lt;/strong&gt;，就变成了任意播地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意播地址是一个标识符对应多个接口的情况。如果一个数据报文要求被传送到一个任意点地址，则将被传送到最近一个接口（路由器决定）&lt;/li&gt;
&lt;li&gt;单播就是一对一；任意波就是&lt;strong&gt;一对最近&lt;/strong&gt;；组播就是一对多&lt;/li&gt;
&lt;li&gt;任意播是指某组中任意发送方对应拓朴结构中几个&lt;strong&gt;最接近的接收方&lt;/strong&gt;之间的通信&lt;/li&gt;
&lt;li&gt;任意播是&lt;strong&gt;IPv6 中更新路由表时所采用的一种方法&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Anycast RP&lt;/strong&gt;(任播RP)是指在&lt;strong&gt;同一PIM-SM域内通过设置两个或多个具有相同地址的RP&lt;/strong&gt;，并在这些RP之间建立MSDP对等体关系，&lt;code&gt;以实现域内各RP之间的负载分担和冗余备份&lt;/code&gt;，同时也能&lt;strong&gt;避免次优路径&lt;/strong&gt;的问题（因为任意播是找最近的）&lt;code&gt;【静态RP备份的原理】&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;msdp对等体建立&#34;&gt;MSDP对等体建立&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用MSDP实现跨域组播的首要任务是：&lt;strong&gt;建立MSDP对等体，MSDP对等体通常建立在RP上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MSDP对等体&lt;strong&gt;通过TCP连接建立，使用端口639&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;两台设备使能MSDP并互相指定对方为MSDP对等体后，两端&lt;strong&gt;先比较IP地址，IP地址较小的一端会启动连接重试定时器，并主动发起TCP连接，通过keepalive维持&lt;/strong&gt;，&lt;strong&gt;IP地址较大的一端负责确认&lt;/strong&gt;是否有TCP连接在端口639建立&lt;/li&gt;
&lt;li&gt;通常在各个PIM-SM域的&lt;strong&gt;RP之间配置MSDP对等体关系&lt;/strong&gt;，MSDP对等体之间交互SA消息，&lt;strong&gt;SA消息中携带组播源DR在RP上注册时的（S，G）信息&lt;/strong&gt;。通过这些MSDP对等体之间的信息传递，任意一个RP发出的SA消息能够被其他所有的RP收到&lt;code&gt;哪些RP必须配置对等体？源RP和接收者RP必须配置msdp，因为这两个RP知道组播源和组播接收者的信息。其他的msdp对等体不一定配置在RP上&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;状态机：down、listen、connect、up&lt;/li&gt;
&lt;li&gt;MSDP报文：IP头+TCP头+TLV格式内容&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613393808332.png&#34; alt=&#34;MSDP对等体建立&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;起始状态下，两台路由器的MSDP会话状态都是Down&lt;/li&gt;
&lt;li&gt;在两端使能MSDP并互相指定对方为MSDP对等体后，两端比较建立连接使用的地址：
&lt;ol&gt;
&lt;li&gt;RouterA的地址较小，进入Connect状态，向RouterB发起连接，并启动ConnectRetry定时器，该定时器用于定义连接重试的周期&lt;/li&gt;
&lt;li&gt;RouterB的地址较大，进入Listen状态，等待对端进行连接&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;TCP连接建立成功后，两端的MSDP会话进入Up状态&lt;/li&gt;
&lt;li&gt;MSDP对等体两端发送KeepAlive消息，通知对方保持MSDP连接状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;组播源信息在域间的传递&#34;&gt;组播源信息在域间的传递&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613393926457.png&#34; alt=&#34;组播源信息在域间的传递&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;当PIM-SM1域内的组播源Source向组播组G发送第一个组播数据包时，DR1将该组播数据封装在注册报文中，并发给RP1&lt;/li&gt;
&lt;li&gt;RP1作为源端RP，创建SA消息，并周期性地向它的对等体RP2发送，SA消息中包含组播源的地址、组播组的地址以及创建该SA消息的源端RP（即RP1）的地址&lt;/li&gt;
&lt;li&gt;RP2接收到该SA消息后，向RP3转发，同时检查本域内是否存在组G成员。由于PIM-SM2域内没有组G的接收者，故RP2不做其他动作&lt;/li&gt;
&lt;li&gt;RP3接收到该SA消息后，域内存在组G成员，则通过IGMP协议在RP3上生成（*，G）表项，然后创建（S，G）表项，向组播源Source逐跳发送（S，G）加入报文，创建一条从Source到RP3的组播路径SPT&lt;/li&gt;
&lt;li&gt;组播数据沿SPT到达RP3后，再沿RPT向接收者转发，当接收者侧DR3收到Source发出的组播数据后，可以自行决定是否发起SPT切换&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;
&lt;h4 id=&#34;msdp实现as内pim-sm域间组播&#34;&gt;MSDP实现AS内PIM-SM域间组播&lt;/h4&gt;
&lt;p&gt;组播源和组成员处于同一AS内不同PIM-SM域间，可以在RP上配置MSDP对等体，实现域间组播&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613398349937.png&#34; alt=&#34;MSDP实现AS内PIM-SM域间组播&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在两个PIM-SM域的RP之间配置MSDP对等体，可以共享对方域内的组播源信息。&lt;br&gt;
&lt;strong&gt;【注意】&lt;/strong&gt;：多个RP配置相同地址的情况下（即Anycast RP，避免次优的问题），建立msdp对等体的时候，需要修改msdp报文中RP的内容&lt;code&gt;在msdp进程下：originating-rp g0/0/0&lt;/code&gt;，主要是修改SA报文中RP的地址，使用物理接口的地址充当RP的地址，从而避免RPF检查不通过的问题。当然也可以在pim进程下直接配置anycast-rp地址，然后配置邻居地址和本地地址（发报地址）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;组播中静态RP的备份方式及原理：&lt;strong&gt;使用Anycast技术，并配置MSDP&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;mbgp&#34;&gt;MBGP&lt;/h2&gt;
&lt;p&gt;跨AS域的组播转发，适用于组播源与组播接收者在不同AS域的场景&lt;/p&gt;
&lt;h1 id=&#34;组播双栈技术&#34;&gt;组播双栈技术&lt;/h1&gt;
&lt;h2 id=&#34;mld&#34;&gt;MLD&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;组播侦听者发现协议，负责IPv6组播成员管理的协议，用在IPv6成员主机和与其直接相邻的组播路由器之间&lt;/li&gt;
&lt;li&gt;MLD通过在成员主机和组播路由器之间交互MLD报文实现组成员管理功能，MLD报文封装在IPv6报文中&lt;/li&gt;
&lt;li&gt;MLD可以理解为IGMP的IPv6版本，两者的协议行为完全相同，区别仅仅在于报文格式&lt;/li&gt;
&lt;li&gt;MLDv1对应IGMPv2，基于查询和响应机制完成对IPv6组播组成员的管理；MLDv2对应IGMPv3。MLDv2在MLDv1的基础上，增加的主要功能是成员主机可以指定接收或不接收某些组播源的报文。MLD向前兼容，即运行MLDv2的组播路由器可以识别MLDv1的协议报文&lt;/li&gt;
&lt;li&gt;所有MLD版本都支持ASM，MLDv2可以直接应用于SSM模型，而MLDv1则需要MLD SSM Mapping技术的支持才可以应用于SSM模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ipv4-ipv6-组播网络中应用的协议比较&#34;&gt;IPv4、IPv6 组播网络中应用的协议比较&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613402586756.png&#34; alt=&#34;应用的协议比较&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;什么是嵌入式rp功能&#34;&gt;什么是嵌入式RP功能&lt;/h2&gt;
&lt;p&gt;使能了PIM-SM（IPv6）的设备都会默认使能嵌入式RP功能，当设备收到组播报文后，直接从IPv6组播地址中解析出RP地址，而&lt;strong&gt;无需再预先知道RP的信息&lt;/strong&gt;，从而&lt;strong&gt;取代静态配置RP或由BSR动态计算的RP&lt;/strong&gt;，&lt;strong&gt;使用嵌入式RP的组播组地址范围是FF7x::/16和FFFx::/16&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;ipv6组播地址与mac地址映射&#34;&gt;IPv6组播地址与MAC地址映射&lt;/h2&gt;
&lt;p&gt;组播IPv6报文的目的IP地址是组播IPv6地址，而目的MAC地址则必须是组播MAC地址，并且该地址必须与组播IPv6地址对应。&lt;strong&gt;33-33是专门为IPv6组播预留的MAC地址前缀&lt;/strong&gt;，&lt;strong&gt;MAC地址的后32bit从对应的组播IPv6地址的后32bit拷贝而来&lt;/strong&gt;，IPv6地址映射会丢失更多的信息，所以IPv6中会有更多的组地址用同一个MAC地址&lt;code&gt;FF00::/8是IPV6组播地址前缀&lt;/code&gt;&lt;br&gt;
如图，IPv6组播地址FF01::1111:1的MAC地址映射&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613403041176.png&#34; alt=&#34;IPv6组播地址与MAC地址映射&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;组播特点&#34;&gt;组播特点&lt;/h2&gt;
&lt;h3 id=&#34;优势&#34;&gt;优势&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提高效率：降低网络流量、减轻硬件负荷&lt;/li&gt;
&lt;li&gt;优化性能：减少冗余流量、节约网络带宽、降低网络负载&lt;/li&gt;
&lt;li&gt;分布式应用：使多点应用成为可能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;劣势&#34;&gt;劣势&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;组播是&lt;strong&gt;基于UDP的&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;尽力而为&lt;/li&gt;
&lt;li&gt;没有拥塞避免机制&lt;/li&gt;
&lt;li&gt;报文重复&lt;/li&gt;
&lt;li&gt;报文失序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用-2&#34;&gt;应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多媒体&lt;/li&gt;
&lt;li&gt;培训、联合作业场合的通信&lt;/li&gt;
&lt;li&gt;数据仓库、金融应用（股票）&lt;/li&gt;
&lt;li&gt;任何的“单到多”数据发布应用&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;为什么需要组播&#34;&gt;为什么需要组播&lt;/h2&gt;
&lt;p&gt;可以降低网络流量，减轻服务器负担，减少冗余流量，节约带宽，可以点对多点&lt;/p&gt;
">组播</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/bgp-xie-yi/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E6%8A%A5%E6%96%87&#34;&gt;BGP报文&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#open&#34;&gt;Open&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4%E5%AD%97%E8%8A%82as%E5%8F%B7&#34;&gt;4字节AS号&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#update&#34;&gt;Update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notification&#34;&gt;Notification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#keepalive&#34;&gt;KeepAlive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#route-refresh&#34;&gt;Route-refresh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8A%B6%E6%80%81%E6%9C%BA&#34;&gt;状态机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93&#34;&gt;BGP的数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E9%BB%91%E6%B4%9E&#34;&gt;路由黑洞&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E5%86%B3%E8%B7%AF%E7%94%B1%E9%BB%91%E6%B4%9E%E6%96%B9%E6%B3%95&#34;&gt;解决路由黑洞方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E8%B7%AF%E7%94%B1%E9%80%9A%E5%91%8A%E5%8E%9F%E5%88%99&#34;&gt;BGP路由通告原则&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%90%86%E8%A7%A3&#34;&gt;理解&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E8%B7%AF%E7%94%B1%E7%9A%84%E6%9D%A5%E6%BA%90&#34;&gt;BGP路由的来源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7&#34;&gt;BGP路径属性&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AC%E8%AE%A4%E5%BF%85%E9%81%B5well-known-mondatory%E5%91%A8%E7%9F%A5%E5%BC%BA%E5%88%B6&#34;&gt;公认必遵Well-known mondatory（周知强制）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-origin%E8%B5%B7%E6%BA%90&#34;&gt;1. Origin：起源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-as_pathas%E8%B7%AF%E5%BE%84&#34;&gt;2. AS_Path：AS路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-next_hop%E4%B8%8B%E4%B8%80%E8%B7%B3&#34;&gt;3. Next_Hop：下一跳&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AC%E8%AE%A4%E4%BB%BB%E6%84%8Fwell-known-discretionary%E5%91%A8%E7%9F%A5%E5%8F%AF%E9%80%89&#34;&gt;公认任意Well-known discretionary（周知可选）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-local_pref%E6%9C%AC%E5%9C%B0%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;1. Local_Pref：本地优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-atomic_aggregate%E5%8E%9F%E5%AD%90%E8%81%9A%E5%90%88&#34;&gt;2. Atomic_Aggregate：原子聚合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E9%80%89%E5%8F%AF%E4%BC%A0%E9%80%92optional-transitive%E8%BF%87%E6%B8%A1&#34;&gt;可选可传递Optional transitive（过渡）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-aggregator%E8%81%9A%E5%90%88%E8%80%85&#34;&gt;1. Aggregator：聚合者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-community%E5%9B%A2%E4%BD%93&#34;&gt;2. Community：团体&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E9%80%89%E9%9D%9E%E5%8F%AF%E4%BC%A0%E9%80%92optional-non-transitive%E9%9D%9E%E8%BF%87%E6%B8%A1&#34;&gt;可选非可传递Optional non-transitive（非过渡）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-multi_exit_discmed%E5%A4%9A%E5%87%BA%E5%8F%A3%E5%88%86%E7%A6%BB%E5%99%A8&#34;&gt;1. Multi_Exit_Disc(MED)：多出口分离器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-originator_id%E8%B5%B7%E6%BA%90id&#34;&gt;2. Originator_ID：起源ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-cluster_list&#34;&gt;3. Cluster_List&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99&#34;&gt;BGP选路原则&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-preferred-value%E9%A6%96%E9%80%89%E9%A1%B9&#34;&gt;1. Preferred-Value（首选项）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-local-preference%E6%9C%AC%E5%9C%B0%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;2. Local-Preference（本地优先级）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E6%9C%AC%E5%9C%B0%E8%B5%B7%E6%BA%90%E8%AF%84%E4%BC%B0&#34;&gt;3. 本地起源评估&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-as-path&#34;&gt;4. as-path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E8%B7%AF%E7%94%B1%E8%B5%B7%E6%BA%90%E4%BB%A3%E7%A0%81&#34;&gt;5. 路由起源代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-med%E5%80%BC%E5%8D%B3cost%E5%80%BC&#34;&gt;6. MED值（即cost值）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-ebgpibgp&#34;&gt;7. EBGP&amp;gt;IBGP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-bgp%E4%B8%8B%E4%B8%80%E8%B7%B3%E7%9A%84igp%E5%BA%A6%E9%87%8F&#34;&gt;8. BGP下一跳的IGP度量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#9-cluster-list&#34;&gt;9. Cluster-List&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#10-routerid%E9%9D%9Err%E5%8F%8D%E5%B0%84%E7%9A%84%E8%B7%AF%E7%94%B1originator_id%E7%BB%8F%E8%BF%87rr%E5%8F%8D%E5%B0%84%E7%9A%84%E8%B7%AF%E7%94%B1&#34;&gt;10.  RouterID（非RR反射的路由）/Originator_ID（经过RR反射的路由）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E5%AF%B9%E7%AD%89%E4%BD%93%E7%9A%84ip%E5%9C%B0%E5%9D%80&#34;&gt;11. 对等体的IP地址&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%9A%84%E9%98%B2%E7%8E%AF&#34;&gt;BGP的防环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E5%86%B3ibgp%E7%9A%84%E6%B0%B4%E5%B9%B3%E5%88%86%E9%9A%94%E9%98%B2%E7%8E%AF%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;解决IBGP的水平分隔防环导致的问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8&#34;&gt;路由反射器&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%92%E8%89%B2&#34;&gt;角色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%AE%A3%E5%91%8A%E5%8E%9F%E5%88%99&#34;&gt;路由反射宣告原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E7%B0%87%E5%8D%B3%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E9%9B%86%E7%BE%A4cluster&#34;&gt;路由反射簇（即路由反射集群，Cluster）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8D%E5%B0%84%E5%99%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F&#34;&gt;反射器部署方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%A4%87%E4%BB%BD%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8&#34;&gt;1. 备份路由反射器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%A4%9A%E9%9B%86%E7%BE%A4%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8&#34;&gt;2. 多集群路由反射器&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%88%86%E7%BA%A7%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8&#34;&gt;1. 分级路由反射器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%90%8C%E7%BA%A7%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8&#34;&gt;2. 同级路由反射器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%81%94%E7%9B%9F&#34;&gt;联盟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8%E5%92%8C%E8%81%94%E7%9B%9F%E7%9A%84%E6%AF%94%E8%BE%83&#34;&gt;路由反射器和联盟的比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%A0%E6%95%88%E8%B7%AF%E7%94%B1%E5%9C%BA%E6%99%AFbgp%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E5%9C%A8%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%B8%8D%E5%8A%A0%E8%A1%A8&#34;&gt;无效路由场景（BGP路由条目在什么情况下不加表）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-bgp%E8%B7%AF%E7%94%B1%E4%B8%8B%E4%B8%80%E8%B7%B3%E4%B8%8D%E5%8F%AF%E8%BE%BE&#34;&gt;1. BGP路由下一跳不可达&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E9%80%9A%E8%BF%87%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E5%BB%BA%E7%AB%8Bbgp%E9%82%BB%E5%B1%85%E5%85%B3%E7%B3%BB&#34;&gt;2. 通过默认路由建立BGP邻居关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-bgp%E8%B7%AF%E7%94%B1%E5%90%8C%E6%AD%A5%E8%B7%AF%E7%94%B1%E4%B8%BA%E6%9C%89%E6%95%88%E4%BD%86%E6%98%AF%E4%B8%8D%E4%BC%9A%E4%BC%98%E9%80%89&#34;&gt;3. BGP路由同步（路由为有效，但是不会优选）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%B0%86%E5%BB%BA%E7%AB%8B%E9%82%BB%E5%B1%85%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%9A%E5%91%8A%E8%BF%9Bbgp&#34;&gt;4. 将建立邻居的路由通告进BGP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-ebgp%E8%B7%AF%E7%94%B1%E6%83%A9%E7%BD%9Adampening&#34;&gt;5. EBGP路由惩罚(dampening)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-mpls-vpn-%E5%9C%BA%E6%99%AFlsp%E4%B8%8D%E5%AE%8C%E6%95%B4%E9%80%A0%E6%88%90%E7%9A%84%E6%97%A0%E6%95%88%E8%B7%AF%E7%94%B1&#34;&gt;6. MPLS VPN 场景（LSP不完整造成的无效路由）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%E5%85%B6%E4%BB%96%E5%9C%BA%E6%99%AF&#34;&gt;7. 其他场景&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85&#34;&gt;补充&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#igp%E5%92%8Cbgp%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;IGP和BGP的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%89%B9%E7%82%B9&#34;&gt;BGP特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93&#34;&gt;属性总结&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3%E4%B8%AA%E9%80%89%E8%B7%AFweight-local-med&#34;&gt;3个选路（weight、local、med）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E4%B8%AA%E9%98%B2%E7%8E%AForigin-as_path-next_hop&#34;&gt;3个防环（origin、as_path、next_hop）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E4%B8%AA%E5%8F%8D%E5%B0%84%E9%98%B2%E7%8E%AForiginator-id-cluster-list&#34;&gt;2个反射防环（originator-id、cluster-list）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E4%B8%AA%E6%B1%87%E6%80%BBatomic-aggregate-aggregator&#34;&gt;2个汇总（Atomic-aggregate、aggregator）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1%E4%B8%AA%E5%9B%A2%E4%BD%93community&#34;&gt;1个团体（community）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BD%B1%E5%93%8Dbgp%E9%82%BB%E5%B1%85%E5%BB%BA%E7%AB%8B%E7%9A%84%E5%9B%A0%E7%B4%A0&#34;&gt;影响BGP邻居建立的因素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E5%9C%A8%E4%BC%A0%E9%80%92ipv4-ipv6-vpnv4%E8%B7%AF%E7%94%B1%E6%97%B6%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9B%B4%E5%8A%A0%E7%AE%80%E5%8D%95&#34;&gt;BGP在传递IPV4、IPV6、VPNv4路由时为什么更加简单&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ibgp%E4%B8%8Eebgp%E4%BC%A0%E9%80%92%E8%B7%AF%E7%94%B1%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB&#34;&gt;IBGP与EBGP传递路由有什么区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;bgp报文&#34;&gt;BGP报文&lt;/h1&gt;
&lt;p&gt;运行BGP的路由器称之为BGP Speaker，它们之间将会交换五种类型的报文，其中&lt;strong&gt;Open、Keeplive以及Notification报文用于邻居关系的建立和维护&lt;/strong&gt;。 &lt;code&gt;前4种消息是在RFC4271中定义的，而Refresh的消息则是在RFC2918中定义的&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594954867397.png&#34; alt=&#34;BGP报文头&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Marker（标记）：16字节，固定为1&lt;/li&gt;
&lt;li&gt;Length（长度）：两字节无符号整数。指定了消息的全长，包括头部&lt;/li&gt;
&lt;li&gt;Type（类型）：1 字节，指示报文类型，如OPEN、UPDATE报文等
&lt;ul&gt;
&lt;li&gt;1 – OPEN&lt;/li&gt;
&lt;li&gt;2 – UPDATE&lt;/li&gt;
&lt;li&gt;3 – NOTIFICATION&lt;/li&gt;
&lt;li&gt;4 – KEEPALIVE&lt;/li&gt;
&lt;li&gt;5 – REFRESH&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;open&#34;&gt;Open&lt;/h2&gt;
&lt;p&gt;负责和对等体建立邻居关系。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594954990823.png&#34; alt=&#34;Open&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version：BGP的版本号，对于BGPv4来说，其值为4&lt;/li&gt;
&lt;li&gt;My Autonomous System：本地AS编号，通过比较两端的AS编号可以&lt;strong&gt;确定是EBGP连接还是IBGP连接&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Hold Time：在建立对等体关系时协商Hold time，如果两端配置不同，则&lt;strong&gt;选择较小的值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BGP Identifier：BGP路由器的RouterID，以IP地址的形式表示，用来识别BGP路由器&lt;code&gt;RouterID没有配置情况下的选举原则：Loopback接口地址中最大的地址--物理接口中最大IP地址&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Opt Parm Len（Optional Parameters Length）：可选参数的长度。如果为0则没有可选参数&lt;/li&gt;
&lt;li&gt;Optional Parameters：是一个可选参数用于BGP验证、多协议扩展或者4字节的AS号等功能，每个参数都是TLV格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589899259545.png&#34; alt=&#34;AFI及SAFI编码说明&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4字节as号&#34;&gt;4字节AS号&lt;/h3&gt;
&lt;p&gt;将AS号的编码范围从2字节扩展到4字节&lt;br&gt;
协议扩展：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定义了一种新的Open能力码用于进行BGP连接的能力协商&lt;/li&gt;
&lt;li&gt;2中新的可选过渡属性，AS4_Path和AS4_Aggregator属性&lt;/li&gt;
&lt;li&gt;定义AS_TRANS(保留值为23456)，用于衔接2字节和4字节的AS&lt;br&gt;
&lt;code&gt;open报文里AS号等于23456代表什么？用于衔接2字节AS号和4字节的AS号&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;update&#34;&gt;Update&lt;/h2&gt;
&lt;p&gt;用来在BGP对等体之间传递路由信息（更新、撤销）。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594955311891.png&#34; alt=&#34;Update&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;撤销路由部分：
&lt;ul&gt;
&lt;li&gt;Withdrawn Routes Length ：（2字节无符号整数） &lt;strong&gt;不可达路由长度&lt;/strong&gt;，表示Withdrawn Routes字段的数据长度。如果Withdrawn Routes Length字段数值为0，则表示Withdrawn Routes字段没有任何数据，在UPDATE消息中不会被显示&lt;/li&gt;
&lt;li&gt;Withdrawn Routes ：（变长） 撤销路由。该字段包括一系列的IP地址前缀信息，以&lt;code&gt;&amp;lt;length, prefix&amp;gt;&lt;/code&gt;的格式来表示，比如&lt;code&gt;&amp;lt;19,198.18.160.0&amp;gt;&lt;/code&gt;表示一个&lt;code&gt;198.18.160.0 255.255.224.0&lt;/code&gt;的网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新路由部分：
&lt;ul&gt;
&lt;li&gt;Path Attribute Length ：（2字节无符号整数）&lt;strong&gt;路由属性长度&lt;/strong&gt;，表示Path Attribute字段的数据长度。如果Path Attribute Length数值为0，则表示Path Attribute字段没有任何数据，在UPDATE消息中不会被显示&lt;/li&gt;
&lt;li&gt;Path Attributes ：（变长） 路径属性。每个路径属性都是由TLV三元组所组成：&lt;code&gt;&amp;lt;attribute type, attribute length, attribute value&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Network Layer Reachability Information ：（变长） 网络可达信息。包括一系列的IP地址前缀。格式与撤消路由字段一样&lt;code&gt;&amp;lt;length, prefix&amp;gt;&lt;/code&gt;。	&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613052529036.png&#34; alt=&#34;1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613052533251.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;最小UPDATE消息&lt;/strong&gt;的长度为23个字节(19字节的报文头+2字节的撤消路由长度+2字节的路径属性长度)。这样的UPDATE消息被称之为&lt;strong&gt;End-of-RIB，用于BGP GR&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一条UPDATE消息可以&lt;strong&gt;发布多条具有相同路由属性的可达路由&lt;/strong&gt;，这些路由可共享一组路由属性。所有包含在一个给定的Update消息里的路由属性适用于该Update消息中的NLRI(网络层可达性信息)字段里的所有目的地（用IP前缀表示）。&lt;/li&gt;
&lt;li&gt;一条UPDATE消息可以&lt;strong&gt;撤销多条不可达路由&lt;/strong&gt;。每一个路由通过目的地（用IP前缀表示），清楚的定义了BGP Speaker之间先前通告过的路由。&lt;/li&gt;
&lt;li&gt;一条UPDATE消息可以&lt;strong&gt;只用于撤销路由&lt;/strong&gt;，这样就不需要包括路径属性或者网络可达信息。相反，也可以&lt;strong&gt;只用于通告可达路由&lt;/strong&gt;，就不需要携带Withdrawn Routes了。&lt;strong&gt;不可即更新又撤销路由&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;notification&#34;&gt;Notification&lt;/h2&gt;
&lt;p&gt;当BGP Speaker检测到错误的时候，就发送该消息给对等体（报错，用于拆除连接，释放资源）。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594962555808.png&#34; alt=&#34;Notification&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Errorcode：错误码&lt;/li&gt;
&lt;li&gt;Errsubcode：错误子码&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594964879096.png&#34; alt=&#34;错误码和错误子码&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;keepalive&#34;&gt;KeepAlive&lt;/h2&gt;
&lt;p&gt;在对等体之间周期性（60s）地发送，检测TCP的连通性，用以维护连接。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594955204497.png&#34; alt=&#34;KeepAlive&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
KeepAlive报文&lt;strong&gt;只包括一个BGP数据报头&lt;/strong&gt;，KeepAlive 消息在对等体之间的&lt;strong&gt;交换频率以保证对方保持定时器不超时为限&lt;/strong&gt;。&lt;br&gt;
缺省情况下，发送&lt;strong&gt;KeepAlive的时间间隔为60秒&lt;/strong&gt;，&lt;strong&gt;Hold Time是180秒&lt;/strong&gt;。每次从邻居处接收到KeepAlive 报文将重置Hold Time定时器，如果Hold Time定时器超时，就认为对等体Down掉。&lt;/p&gt;
&lt;h2 id=&#34;route-refresh&#34;&gt;Route-refresh&lt;/h2&gt;
&lt;p&gt;用来通知对等体自己支持路由刷新能力&lt;code&gt;对等体一端不支持路由刷新的能力，如果强制刷新，则会重新建立邻居&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594962609077.png&#34; alt=&#34;Route-refresh&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AFI（Address Family Identifier）：地址族标识符&lt;/li&gt;
&lt;li&gt;Res.（Reserved field）：保留区域，发送方应将其设置为0，接收方应当忽略该区域的信息&lt;/li&gt;
&lt;li&gt;SAFI（Subsequent Address Family Identifier）：子地址族标识符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在所有BGP路由器&lt;strong&gt;使能Route-refresh能力&lt;/strong&gt;的情况下，如果BGP的&lt;strong&gt;入口路由策略发生了变化&lt;/strong&gt;，本地BGP路由器会向对等体发布Route-refresh消息，&lt;strong&gt;收到此消息的对等体会将其路由信息重新发给本地BGP路由器&lt;/strong&gt;&lt;code&gt;即由路由的接收方发送RouteRefresh报文，用来重新请求相应协议簇的报文，路由的发送方发送对应路由的Update报文，路由的接收方收到Update报文之后应用修改之后的入口路由策略&lt;/code&gt;。这样，可以在不中断BGP连接的情况下，对BGP路由表进行动态刷新，并应用新的路由策略。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么时候产生Route-refresh报文？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求：refresh bgp all import，自身产生refresh报文，邻居收到之后回复update报文【如果执行refresh bgp all export，则是主动发送update报文】&lt;/li&gt;
&lt;li&gt;ORF（出方向的路由过滤），只允许通过需要的路由&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;状态机&#34;&gt;状态机&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1594965930073.png&#34; alt=&#34;BGP状态机&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Idle：
&lt;ul&gt;
&lt;li&gt;不发起TCP连接，需要转换成Connect状态，然后才发起一条TCP连接，复位&lt;strong&gt;连接重试计时器（32秒）&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;如果EBGP邻居使用环回口建立，但是没有设置EBGP多跳或者开启了直连检查，会停留在此状态，因为EBGP规定是直连，即eBGP报文的TTL默认是1、iBGP报文的TTL默认是255&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Connect：&lt;br&gt;
在此状态，BGP&lt;strong&gt;发起第一个TCP连接&lt;/strong&gt;，&lt;code&gt;在重试计时器时间内只发送这一个TCP连接&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;如果连接重试计时器&lt;strong&gt;超时&lt;/strong&gt;，就重新发起TCP连接，并继续&lt;strong&gt;保持在Connect&lt;/strong&gt;状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接&lt;strong&gt;成功&lt;/strong&gt;，就转入&lt;strong&gt;OpenSent&lt;/strong&gt;状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接&lt;strong&gt;失败&lt;/strong&gt;，就转入&lt;strong&gt;Active&lt;/strong&gt;状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Active：&lt;br&gt;
在此状态，BGP总是在&lt;strong&gt;试图建立TCP连接&lt;/strong&gt;，
&lt;ul&gt;
&lt;li&gt;如果连接重试计时器&lt;strong&gt;超时&lt;/strong&gt;，就&lt;strong&gt;退回到Connect&lt;/strong&gt;状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接&lt;strong&gt;成功&lt;/strong&gt;，就转入&lt;strong&gt;OpenSent&lt;/strong&gt;状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接&lt;strong&gt;失败&lt;/strong&gt;，就继续&lt;strong&gt;保持在Active&lt;/strong&gt;状态，并继续发起TCP连接&lt;br&gt;
&lt;code&gt;Active和Connect状态的区别：Connect状态只发送一次TCP连接，而Active状态下会多次发送TCP连接；Connect是主动建立TCP连接，Active是被动等待TCP连接&lt;/code&gt;&lt;br&gt;
&lt;code&gt;如果一直处在Connect或者Active状态，说明TCP连接未建立起来，有以下情况：更新源地址错误（源IP地址检查）、认证（通过TCP的option字段实现的）、ACL过滤&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSent：&lt;br&gt;
在此状态，&lt;strong&gt;TCP连接已经建立&lt;/strong&gt;，BGP也&lt;strong&gt;已经发送了第一个Open报文&lt;/strong&gt;，剩下的工作，BGP就在&lt;strong&gt;等待其对等体发送Open报文&lt;/strong&gt;。并对收到的Open报文进行正确性检查，
&lt;ul&gt;
&lt;li&gt;如果&lt;strong&gt;有错误&lt;/strong&gt;，系统就会发送一条&lt;strong&gt;出错通知消息并退回到Idle状态&lt;/strong&gt;，&lt;/li&gt;
&lt;li&gt;如果&lt;strong&gt;没有错误&lt;/strong&gt;，BGP就开始发送Keepalive报文，并&lt;strong&gt;复位Keepalive&lt;/strong&gt;计时器，开始计时。&lt;strong&gt;同时转入OpenConfirm状态。&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;发送KeepAlive报文的时机：收到Open报文并检测通过&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenConfirm：&lt;br&gt;
在OpenConfirm状态，BGP&lt;strong&gt;等待一个Keepalive报文，同时复位保持计时器&lt;/strong&gt;，
&lt;ul&gt;
&lt;li&gt;如果收到了一个Keepalive报文，就转入Established阶段，BGP邻居关系就建立起来了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Established：&lt;br&gt;
在Established状态，BGP邻居关系&lt;strong&gt;已经建立&lt;/strong&gt;，这时，BGP将和它的邻居们交换Update报文，同时复位保持计时器。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;除Idle状态以外的其它五个状态&lt;strong&gt;出现任何Error的时候，BGP状态机就会退回到Idle状态&lt;/strong&gt;。&lt;br&gt;
在BGP对等体建立的过程中，&lt;strong&gt;通常可见的三个状态是：Idle、Active、Established&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Idle状态下，BGP拒绝任何进入的连接请求，是BGP初始状态。&lt;/li&gt;
&lt;li&gt;Active状态下，BGP将尝试进行TCP连接的建立，是BGP的中间状态。&lt;/li&gt;
&lt;li&gt;Established状态下，BGP对等体间可以交换Update报文、Route-refresh报文、Keepalive报文和Notification报文。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;BGP对等体双方的状态必须都为Established，BGP邻居关系才能成立，双方通过Update报文交换路由信息&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;bgp的数据库&#34;&gt;BGP的数据库&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;IP路由表 (IP-RIB)：全局路由信息库，包括所有IP路由信息&lt;/li&gt;
&lt;li&gt;BGP路由表 (Loc-RIB)：BGP路由信息库，包括本地BGP Speaker选择的路由信息&lt;/li&gt;
&lt;li&gt;邻居表：对等体邻居清单列表&lt;/li&gt;
&lt;li&gt;Adj-RIB-In：对等体宣告给本地Speaker的未处理的路由信息库&lt;/li&gt;
&lt;li&gt;Adj-RIB-Out：本地Speaker宣告给指定对等体的路由信息库&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594967902505.png&#34; alt=&#34;BGP路由信息处理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;本地被优选的路由，才允许更新给对等体&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;路由黑洞&#34;&gt;路由黑洞&lt;/h1&gt;
&lt;p&gt;简单的说，它会默默的将数据包丢弃，使所有数据包有去无回，主要原因是&lt;strong&gt;没有相应的路由&lt;/strong&gt;，本质是&lt;strong&gt;IP逐跳转发导致数据包丢失&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589986054853.png&#34; alt=&#34;BGP的路由黑洞&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;举例&lt;/strong&gt;：AR6无法ping通AR1的11.11.11.11，主要是AR5的路由表中11.11.11.11的下一跳是2.2.2.2（AR5和AR2没有直连），在其转发表中2.2.2.2的下一跳是35.1.1.3（或者45.1.1.4），但是AR3（或者AR4）中没有关于11.11.11.11的路由，导致所有涉及11.11.11.11的数据包被丢弃。&lt;/p&gt;
&lt;h2 id=&#34;解决路由黑洞方法&#34;&gt;解决路由黑洞方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;物理线路直连（&lt;strong&gt;不可取&lt;/strong&gt;），但是可以使用&lt;strong&gt;GRE隧道&lt;/strong&gt;。【即在AR2和AR5之间建立GRE通道】&lt;/li&gt;
&lt;li&gt;全互联可以解决 ，管理成本增加（&lt;strong&gt;不可取&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;将EBGP路由引入IGP可以解决路由黑洞 （&lt;strong&gt;不可取&lt;/strong&gt;），会造成IGP负担过重&lt;/li&gt;
&lt;li&gt;可以在黑洞设备上配置静态也可以解决（&lt;strong&gt;不可取&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;开启同步，即从IBGP收到的路由，如果IGP中不存在，就不会通告EBGP邻居【即AR5中不存在11.11.11.11/32，所以AR5不会将此路由通告给AR6】&lt;/li&gt;
&lt;li&gt;配置路由反射器，路由反射器不是解决路由黑洞的，是解决水平分割的问题。【在R3上配置RR，R2和R5不再需要配置BGP邻居】&lt;code&gt;iBGP的水平分割规则：来自iBGP对等体的路由，不能传递给iBGP对等体 。路由反射器是专门破坏这个规则的&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;联邦是用来解决水平分割的问题，但也可以解决路由黑洞&lt;/li&gt;
&lt;li&gt;MPLS网络&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp路由通告原则&#34;&gt;BGP路由通告原则&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;只把本身的&lt;strong&gt;最优路由&lt;/strong&gt;通告给对等体，多条路径时，只选择&lt;strong&gt;最优路由&lt;/strong&gt;放入路由表&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;eBGP&lt;/strong&gt;获得的路由会向它&lt;strong&gt;所有的BGP对等体&lt;/strong&gt;（包括eBGP和iBGP）通告&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;iBGP&lt;/strong&gt;获得的路由&lt;strong&gt;不会通告给它的iBGP&lt;/strong&gt;邻居&lt;code&gt;水平分隔&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从&lt;strong&gt;iBGP&lt;/strong&gt;获得的路由是否通告给它的&lt;strong&gt;eBGP对等体要依IGP和BGP同步的情况&lt;/strong&gt;来决定。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;BGP同步的概念：&lt;br&gt;
BGP Speaker不将从IBGP对等体获得的路由信息通告给它的EBGP对等体，除非该路由信息也能通过IGP获得&lt;code&gt;即从IBGP对等体获得的路由只有在IGP中也存在的情况下才会优选&lt;/code&gt;&lt;br&gt;
目的是防止AS内部出现路由黑洞，向外部通告了一个本AS不可达的虚假的路由&lt;br&gt;
只影响IBGP邻居之间的路由传递，不影响EBGP邻居之间的路由传递&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;理解&#34;&gt;理解&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体&lt;sub&gt;默认修改下一跳&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;从EBGP对等体获得的BGP路由，BGP设备发布给它所有EBGP&lt;sub&gt;不在同一广播网，默认修改下一跳；在同一广播网则不修改下一跳&lt;/sub&gt;和IBGP&lt;sub&gt;默认不修改下一跳&lt;/sub&gt;对等体&lt;sub&gt;为了避免次优路径，例子参考同一交换机下的三个路由器&lt;/sub&gt;&lt;code&gt;即接收者为EBGP时才会修改下一跳&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当存在多条到达同一目的地址的有效路由时，BGP设备只将最优路由发布给对等体，同时只把最优的放进路由表&lt;/li&gt;
&lt;li&gt;路由更新时，BGP设备只发送更新的BGP路由&lt;/li&gt;
&lt;li&gt;所有对等体发送的路由，BGP设备都会接收&lt;br&gt;
&lt;code&gt;EBGP多跳和指定更新源：EBGP可以采用直连建立，也可以采用环回口作为更新源建立EBGP邻居用以备份，但需要修改TTL值&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp路由的来源&#34;&gt;BGP路由的来源&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;network（宣告）&lt;br&gt;
精确的将一条IGP路由放入BGP路由表，需要本地存在并且可达，network宣告的路由的&lt;strong&gt;起源属性为i&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;import-route命令（引入）&lt;br&gt;
通过import-route命令把IGP路由或静态路由注入到BGP路由表中，import-route引入的路由的&lt;strong&gt;起源属性为？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;aggregate命令（聚合）&lt;br&gt;
聚合路由，本地该路由的下一跳是127.0.0.1&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp路径属性&#34;&gt;BGP路径属性&lt;/h1&gt;
&lt;h2 id=&#34;公认必遵well-known-mondatory周知强制&#34;&gt;公认必遵Well-known mondatory（周知强制）&lt;/h2&gt;
&lt;p&gt;所有BGP路由器&lt;strong&gt;都可以识别&lt;/strong&gt;，且&lt;strong&gt;必须&lt;/strong&gt;存在于Update消息中。如果缺少这种属性，路由信息就会出错。&lt;/p&gt;
&lt;h3 id=&#34;1-origin起源&#34;&gt;1. Origin：起源&lt;/h3&gt;
&lt;p&gt;一般的，具体的实现按如下方式决定一条路由的Origin属性&lt;code&gt;默认情况下不被任何路由器修改，i&amp;gt;e&amp;gt;?&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;某条路由是&lt;strong&gt;直接而具体&lt;/strong&gt;的注入到BGP路由表中的，&lt;strong&gt;则origin属性为IGP(i)&lt;/strong&gt;，例如：通过network命令注入BGP的路由&lt;/li&gt;
&lt;li&gt;通过EGP学到的路由，&lt;strong&gt;则origin属性为EGP(e)，目前已经不用了&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其他情形下，&lt;strong&gt;Origin属性都为Incomplete(?)&lt;/strong&gt;，例如通过import命令注入BGP的路由&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-as_pathas路径&#34;&gt;2. AS_Path：AS路径&lt;/h3&gt;
&lt;p&gt;描述到达目标网络所要经过的AS号序列。&lt;strong&gt;最重要的作用是EBGP防环&lt;/strong&gt;，如果要修改AS_PATH属性，则必须在ABR上执行策略。&lt;br&gt;
&lt;strong&gt;有四种类型的AS_PATH&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AS_SET：as-number无序的，表示方法为｛100 200 300｝，并且大括号内不管有多少个as-number，在选路时其长度为1【拓展：小括号表示联盟的子as，中括号表示联盟内对路由汇总】&lt;/li&gt;
&lt;li&gt;AS_SEQUENCE：as-number有序的，&lt;code&gt;追加as-number时是在as-path头部插入，例如起源于as100的路由，由as200传递给as300时，其as-path为&amp;quot;200 100&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;AS_CONFED_SEQUENCE：联盟内使用，as-number有序的&lt;/li&gt;
&lt;li&gt;AS_CONFED_SET：联盟内使用，as-number无序的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;eBGP防环规则的修改以及应用场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hub-spoke架构网络
&lt;ol&gt;
&lt;li&gt;使用DM VPN模块&lt;/li&gt;
&lt;li&gt;使用相同的AS，中间点配置成路由反射器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;客户路由通过SP（运营商）更新
&lt;ol&gt;
&lt;li&gt;overraid，覆写，即左边AS300的路由传到AS200时，其属性as-path修改为200，然后在传递给右边的AS300（应用于MPLS VPN）&lt;/li&gt;
&lt;li&gt;允许接收相同AS的路由，可以设置次数，即右边的AS300可以接收左边AS300的路由&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595860627469.png&#34; alt=&#34;eBGP防环规则的修改&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;仅通过as-path选路可能会出现次优路径&lt;/strong&gt;，但可以通过加长as_path的列表长度，从而影响路径选择。例如：从RTA向RTB更新时增加as-path长度，则使得路由选择2M链路，而不是64K的&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595861450538.png&#34; alt=&#34;加长as_path的列表长度&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-next_hop下一跳&#34;&gt;3. Next_Hop：下一跳&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;从IBGP对等体获得的BGP路由，BGP设备&lt;strong&gt;只发布&lt;/strong&gt;给它的EBGP对等体，&lt;strong&gt;默认修改下一跳&lt;/strong&gt;&lt;code&gt;只有这条路由能够从IGP获得时才会通告给EBGP邻居，主要是为了防止路由黑洞&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从EBGP对等体获得的BGP路由
&lt;ol&gt;
&lt;li&gt;BGP设备发布给它所有&lt;strong&gt;EBGP邻居&lt;/strong&gt;，&lt;strong&gt;不在同一广播网，默认修改下一跳&lt;/strong&gt;，在同一广播网则不修改下一跳&lt;/li&gt;
&lt;li&gt;BGP设备发布给它所有&lt;strong&gt;IBGP邻居&lt;/strong&gt;，&lt;strong&gt;默认不修改下一跳&lt;/strong&gt;，对等体为了避免次优路径&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;即只有2种情况下修改下一跳：1. iBGP到EBGP；2. EBGP到不同网络的EBGP&lt;/code&gt;&lt;br&gt;
&lt;code&gt;【总结】：一般会在ASBR对内部对等体设置下一跳自我，即修改下一跳；eBGP对等体之间的下一条不改变一般用于域间MPLS VPN，一般用在RR之间&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;公认任意well-known-discretionary周知可选&#34;&gt;公认任意Well-known discretionary（周知可选）&lt;/h2&gt;
&lt;p&gt;所有BGP路由器&lt;strong&gt;都可以识别&lt;/strong&gt;，但&lt;strong&gt;不要求必须&lt;/strong&gt;存在于Update消息中，可以根据具体情况来决定是否添加到Update消息中&lt;/p&gt;
&lt;h3 id=&#34;1-local_pref本地优先级&#34;&gt;1. Local_Pref：本地优先级&lt;/h3&gt;
&lt;p&gt;告诉AS中的路由器，哪条路径是离开AS的首选路径。优先级属性用来影响iBGP邻居，告诉自己的&lt;strong&gt;iBGP邻居如何离开本AS&lt;/strong&gt;，&lt;strong&gt;只能在本AS内传递（iBGP对等体或者联邦内部），不能传给EBGP邻居&lt;/strong&gt;。默认值为100，越大越好。&lt;br&gt;
&lt;code&gt;MED控制流量怎样进入AS，而本地优先级则控制流量怎样流出AS；路由器优选Local-preference值大的路由控制出流量，优选MED值小的路由控制入流量。&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-atomic_aggregate原子聚合&#34;&gt;2. Atomic_Aggregate：原子聚合&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;与团体属性互斥&lt;/strong&gt;，只有在聚合路由时追加&lt;code&gt;detail-suppressed&lt;/code&gt;时才会携带该属性，命令如下：&lt;code&gt;aggregate 1.1.1.0 255.255.255.0 detail-suppressed&lt;/code&gt;。&lt;strong&gt;一旦设置该属性，则不会再继承明细路由的团体属性，即默认情况下通告聚合路由的同时也通告明细路由，追加此参数之后就不再通告明细路由&lt;/strong&gt;&lt;br&gt;
有时BGP发布者会收到两条重叠的路由，其中&lt;strong&gt;一条路由包含的地址是另一条路由的子集&lt;/strong&gt;。一般情况下BGP发布者会优选更精细的路由（前者），但是在对外发布时，如果它选择发布&lt;strong&gt;更粗略&lt;/strong&gt;的那条路由（后者），这时&lt;strong&gt;需要附加上ATOMIC-AGGREGATE属性&lt;/strong&gt;，以知会对等体。它实际上是&lt;strong&gt;一种警告&lt;/strong&gt;，因为发布更粗略的路由意味着更精细的路由信息在发布过程中丢失了。在进行&lt;strong&gt;路由聚合&lt;/strong&gt;时，&lt;strong&gt;对于聚合的路由信息会添加ATOMIC-AGGREGATE属性&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;可选可传递optional-transitive过渡&#34;&gt;可选可传递Optional transitive（过渡）&lt;/h2&gt;
&lt;p&gt;BGP路由器可以&lt;strong&gt;选择是否在Update消息中携带这种属性&lt;/strong&gt;。&lt;strong&gt;接收的路由器如果不识别这种属性，可以转发给邻居路由器&lt;/strong&gt;，邻居路由器可能会识别并使用到这种属性。&lt;/p&gt;
&lt;h3 id=&#34;1-aggregator聚合者&#34;&gt;1. Aggregator：聚合者&lt;/h3&gt;
&lt;p&gt;聚合时也会自动出现该属性。它包括&lt;strong&gt;发动聚合路由器的AS号码还有它的RouterID&lt;/strong&gt;，从而提供了执行聚合的地点信息。Atomic-aggregate属性指示出现了路径信息的丢失而aggregator属性指示聚合路由出现在哪里。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;路由聚合后会继承哪些属性？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Origin：如果一条路由有多个起源，则&lt;strong&gt;继承优先级最低&lt;/strong&gt;的那个起源属性&lt;/li&gt;
&lt;li&gt;AS_Path：只有配置了as-set才会继承，继承此属性是为了防环，在detail-suppressed后追加参数as-set才会继承&lt;/li&gt;
&lt;li&gt;Community：在没有配置Atomic_Aggregate时才会继承&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-community团体&#34;&gt;2. Community：团体&lt;/h3&gt;
&lt;p&gt;团体是一组有&lt;strong&gt;相同性质的目的地址路由&lt;/strong&gt;。&lt;strong&gt;目的&lt;/strong&gt;就是将路由信息编组，通过组的标识决定路由传递的策略。它被一组共享相同特性的前缀所定义，多个社团可以应用到一条前缀上。&lt;br&gt;
团体属性是&lt;strong&gt;BGP的私有属性&lt;/strong&gt;，&lt;strong&gt;在BGP对等体之间传播，且不受AS限制&lt;/strong&gt;。利用团体属性可以使AS中的一组BGP设备共享相同的策略，从而简化路由策略的应用和降低维护管理难度。&lt;br&gt;
BGP设备可以在&lt;strong&gt;发布路由&lt;/strong&gt;时（或者针对邻居更新以及收取时、或者引入路由时），新增或者改变路由的团体属性。&lt;br&gt;
团体属性是在BGP中一种&lt;strong&gt;给路由条目打上标记&lt;/strong&gt;，用于确保路由过滤和选择的连续性，BGP路由器可以过滤进出路由更新或者优选某些路由。&lt;br&gt;
&lt;code&gt;默认不传递给对等体，要针对邻居做传递，即传递团体属性需要配置命令peer 22.1.1.1 advertise-community&lt;/code&gt;&lt;br&gt;
Community属性有&lt;strong&gt;4个字节(0x00000000—0xFFFFFFFF)&lt;/strong&gt;，&lt;strong&gt;前两个字节代表AS号码&lt;/strong&gt;，&lt;strong&gt;后两个字节是管理上定义的标识符&lt;/strong&gt;。格式为AA:NN。&lt;br&gt;
团体属性有以下&lt;strong&gt;3种类型&lt;/strong&gt;：保留的团体属性、公认的团体属性、私有团体属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;保留团体属性&lt;/strong&gt;：0x00000000—0x0000FFFF、0xFFFF0000—0xFFFFFFFF&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公认团体属性&lt;/strong&gt;：当收到这些带有团体属性的前缀时，对等体会自动根据预定义（操作已经定义好了）的社团属性意义来采取操作，不需要额外的配置。公共团体属性的保留范围是（0xFFFF0000-0xFFFFFFFF）。下面是4种公共社团属性：
&lt;ol&gt;
&lt;li&gt;Internet：所有属于这个团体属性的路由都有一个缺省值，可以自由地公布属于这个团体的路由。换句话说&lt;strong&gt;这个团体的前缀通告没有任何限制&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;No-export：有这个属性的前缀&lt;strong&gt;不会被通告给eBGP对等体&lt;/strong&gt;，但是&lt;strong&gt;可以发送给联邦的eBGP对等体&lt;/strong&gt;，也就是&lt;strong&gt;不能在联邦范围以外公布&lt;/strong&gt;。这个团体的值为0xFFFFFF01&lt;/li&gt;
&lt;li&gt;No-advertise：接收到带有此值的路由&lt;strong&gt;不能公布给任何对等体&lt;/strong&gt;，包括iBGP对等体和eBGP对等体。它的值为0xFFFFFF02&lt;/li&gt;
&lt;li&gt;No-export-subconfed：有这个属性的路由条目&lt;strong&gt;不会被通告到本地AS之外&lt;/strong&gt;。在&lt;strong&gt;联邦&lt;/strong&gt;情况下，&lt;strong&gt;只有在同一个子AS中的对等体才会允许接受这些前缀&lt;/strong&gt;。它的值为0xFFFFFF03在RFC1997中这个团体也叫做&lt;code&gt;no-export-subconfed&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私有社团属性&lt;/strong&gt;（自定义团体属性）：AS(2B):Number(2B)，有网络管理员自己定义的社团属性，它的主要目的是为前缀附加管理标记，以便制定合适的策略。通过干预携带的团体属性的路由，影响数据报文的转发，也用于路由清洗。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;可选非可传递optional-non-transitive非过渡&#34;&gt;可选非可传递Optional non-transitive（非过渡）&lt;/h2&gt;
&lt;p&gt;BGP路由器可以选择是否在Update消息中携带这种属性。在整个路由发布的路径上，如果部分路由器不能识别这种属性，可能会导致该属性无法发挥效用。因此&lt;strong&gt;接收的路由器如果不识别这种属性，将丢弃这种属性&lt;/strong&gt;，不必再转发给邻居路由器&lt;/p&gt;
&lt;h3 id=&#34;1-multi_exit_discmed多出口分离器&#34;&gt;1. Multi_Exit_Disc(MED)：多出口分离器&lt;/h3&gt;
&lt;p&gt;区别到达同一邻居AS的多条入口链路(MED的默认值为0，越小越优先)，&lt;strong&gt;通过eBGP发送MED值给对等体&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;通告规则&lt;/strong&gt;：&lt;code&gt;起源于自身的传递给任何邻居时都携带，从邻居学到的只能在本AS内传递&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MED属性起源于iBGP对等体，在传递给eBGP对等体时会清除MED属性&lt;/li&gt;
&lt;li&gt;MED起源于eBGP对等体，在传递给iBGP对等体时携带&lt;/li&gt;
&lt;li&gt;MED起源于本地，可以通告给所有对等体&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如：起源于RT1，RT1传递给RT2时携带MED值；起源于RT1，RT2在向RT3传递时不携带；起源于RT2，RT2在向RT3传递时携带。&lt;code&gt;只在2个设备之间传递，不会传递给第3个设备&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595864546574.png&#34; alt=&#34;通告规则&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;对比规则&lt;/strong&gt;：缺省情况下，不允许比较来自不同AS邻居的路由信息的MED值。但是，可以调整这个规则。&lt;/p&gt;
&lt;h3 id=&#34;2-originator_id起源id&#34;&gt;2. Originator_ID：起源ID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;用于RR，防止客户端之间环路&lt;/code&gt;&lt;br&gt;
是本地AS中&lt;strong&gt;路由发起者的RouterID&lt;/strong&gt;。如果路由发起者在接收到路由的originator-id中发现了自己的RouterID，就知道产生了环路，于是忽略该路由条目，它提供在&lt;strong&gt;AS内的防环作用&lt;/strong&gt;，它&lt;strong&gt;由第一个RR创建，并且不被后续的RR修改&lt;/strong&gt;。&lt;br&gt;
它&lt;strong&gt;只应在iBGP对等体那里接收到&lt;/strong&gt;，在RR上originator-id用来替代路由选择过程中的RouterID。它应该是这些路由器的RouterID：在本地AS始发路由的BGP宣告者的router-id；如果是从eBGP学到的就是最初学到那个条目的路由器(本AS内边界路由器)的router-id（它一定是本AS内路由器的router-id）&lt;/p&gt;
&lt;h3 id=&#34;3-cluster_list&#34;&gt;3. Cluster_List&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;用于RR，防止RR之间的环路&lt;/code&gt;&lt;br&gt;
是&lt;strong&gt;路由经过的路由反射器的簇ID&lt;/strong&gt;（默认RR的router-ID）的一个列表，如果路由反射器接收到的路由的cluster-List中发现了自己的本地簇ID，就知道产生了环路，于是忽略该路由条目，RR从而能够分别出路由选择信息是否又环回到同一个簇。可以配置bgp cluster-id。cluter-id默认为RR自己的router-id所以默认情况下所有的RR都不在同一个簇。&lt;/p&gt;
&lt;h1 id=&#34;bgp选路原则&#34;&gt;BGP选路原则&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;前提&lt;/strong&gt;：&lt;code&gt;如果此路由的下一跳不可达，忽略此路由&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-preferred-value首选项&#34;&gt;1. Preferred-Value（首选项）&lt;/h2&gt;
&lt;p&gt;越大越优&lt;code&gt;默认0，只具有本地意义，不传递给对等体&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613136468957.png&#34; alt=&#34;Preferred-Value&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-local-preference本地优先级&#34;&gt;2. Local-Preference（本地优先级）&lt;/h2&gt;
&lt;p&gt;越大越优&lt;code&gt;默认100，属于公认非强制属性，只在AS内部传递&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613136498327.png&#34; alt=&#34;Local-Preference&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-本地起源评估&#34;&gt;3. 本地起源评估&lt;/h2&gt;
&lt;p&gt;本地生成路由优先，手动聚合&amp;gt;自动聚合&amp;gt;network&amp;gt;import-route&lt;code&gt;起源于0.0.0.0或者127.0.0.1的，例如network、aggregate、import-route&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613136544811.png&#34; alt=&#34;本地起源评估&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
例如：R1、R2都将10.1.12.0/24宣告进BGP，R2收到R1发过来的10.1.12.0 的路由，prefer-value、local-preference都一样，但是本地发起的优先，所以bgp表中自己宣告的路由为最优路径&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;手动聚合和自动聚合的区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动聚合可以聚合network和import-route的路由条目&lt;/li&gt;
&lt;li&gt;自动聚合只能聚合import-route的路由条目，并且只能汇总为主类路由&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-as-path&#34;&gt;4. as-path&lt;/h2&gt;
&lt;p&gt;长度越短越优&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以使用命令&lt;code&gt;bestroute as-path-ignore&lt;/code&gt;跳过本条&lt;/li&gt;
&lt;li&gt;AS_CONFED_SEQUENCE 和 AS_CONFED_SET（联盟内部AS号）不计入as-path长度&lt;/li&gt;
&lt;li&gt;AS_SET长度计为1&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613136808415.png&#34; alt=&#34;as-path&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
例如：左侧路径路由传递过来as-path为&lt;code&gt;200 100&lt;/code&gt;，长度为 2；右侧传递过来as-path为&lt;code&gt;400&lt;/code&gt;, 长度为1，优选右侧传递过来的路由为最优路径&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-路由起源代码&#34;&gt;5. 路由起源代码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;i&amp;gt;e&amp;gt;?&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;6-med值即cost值&#34;&gt;6. MED值（即cost值）&lt;/h2&gt;
&lt;p&gt;越小越优&lt;code&gt;默认为0&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认只比较as-path中最近一个相同as中的路由，否则忽略此条&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;compare-different-as-med&lt;/code&gt;，允许比较来自不同自治系统中的邻居的路由的MED值&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;bestroute med-confederation&lt;/code&gt;，仅在联盟内比较MED值&lt;code&gt;即超出子AS的界限，边界是联盟&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置&lt;code&gt;deterministic-med&lt;/code&gt;，对从多个不同AS收到的相同前缀的路由进行选路时，首先会按路由的AS_Path最左边的AS号进行分组。在组内进行比较后，再用组中的优选路由和其他组中的优选路由进行比较，消除了选路的结果和路由接收顺序的相关性&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613137319981.png&#34; alt=&#34;MED值&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;7-ebgpibgp&#34;&gt;7. EBGP&amp;gt;IBGP&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613137692207.png&#34; alt=&#34;EBGP&amp;gt;IBGP&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;8-bgp下一跳的igp度量&#34;&gt;8. BGP下一跳的IGP度量&lt;/h2&gt;
&lt;p&gt;越小越优&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613137783314.png&#34; alt=&#34;BGP下一跳的IGP度量&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;p&gt;当以上全部相同&lt;strong&gt;且as-path完全相同&lt;/strong&gt;，则为等价路由，可以负载分担。但是&lt;strong&gt;默认情况下max-paths为1&lt;/strong&gt;，即最多只能有一个下一跳，因此通告给邻居的路由条目只有一条最优路由。如果要进行负载分担，需要修改max-paths值。&lt;strong&gt;当负载分担时，以下原则无效&lt;/strong&gt;：&lt;/p&gt;
&lt;h2 id=&#34;9-cluster-list&#34;&gt;9. Cluster-List&lt;/h2&gt;
&lt;p&gt;长度越短越优&lt;code&gt;由RR添加该属性，Cluster-List中包含RR的ClusterID，默认情况下为RR的RouterID，用于RR的防环&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613137980850.png&#34; alt=&#34;Cluster-List&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;10-routerid非rr反射的路由originator_id经过rr反射的路由&#34;&gt;10.  RouterID（非RR反射的路由）/Originator_ID（经过RR反射的路由）&lt;/h2&gt;
&lt;p&gt;越小越优&lt;code&gt;如果两条路由一条只有Originator_ID、一条只有RouterID，那么选择只有RouterID那条。因为携带Originator_ID那条路由是经过反射的，经过反射的路由必然会携带Clust-list，而不经过反射的不携带，即长度为0，所以会选择只有RouterID的那条路由&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613138092003.png&#34; alt=&#34;Originator_ID&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
as外部路由，originator-id就是边界路由器5和6，这里虽然邻居R3路由器ID小，但是由于 originator-id是4那边小，所以选择右侧过来的路由为最优&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613138187638.png&#34; alt=&#34;RouterID&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;11-对等体的ip地址&#34;&gt;11. 对等体的IP地址&lt;/h2&gt;
&lt;p&gt;越小越优&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613138239921.png&#34; alt=&#34;对等体的IP地址&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
下方路由器与上面路由器的2个地址10.1.12.2和10.1.22.2分别建立2个邻居，2个链路igp开销也相同，这2个邻居其实是同一个路由器，所以路由器id一样，至此前面所有的法则都无法打破僵局，最终只能根据建邻居地址越低越优先，选择了10.1.12.2的邻居关系来发送BGP路由&lt;/p&gt;
&lt;h1 id=&#34;bgp的防环&#34;&gt;BGP的防环&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;EBGP&lt;/strong&gt;&lt;br&gt;
通过as-path防环。丢弃从EBGP对等体接收到的在as-path属性里包含自身as号的任何更新信息。可以配置&lt;code&gt;peer allow-as loop 重复出现的次数&lt;/code&gt;，来配置一个AS号在as-path中出现的次数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IBGP&lt;/strong&gt;&lt;br&gt;
通过水平分隔防环。BGP路由器不会将任何从IBGP对等体接收到的更新信息传给其他IBGP对等体。这个带来路由黑洞等问题，可以通过全互联、RR、联盟等手段解决&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由反射器&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;通过Cluster-list防止RR间环路。RR收到的路由的Cluster-list中包含自己的cluste-id则丢弃&lt;/li&gt;
&lt;li&gt;通过Originator_ID防止客户端之间环路。客户端收到的路由的Originator_ID为自己的RouterID则丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由聚合时，聚合路由器会自动产生指向null0的路由&lt;code&gt;自动和手动聚合都会产生&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IBGP默认不能重发布给IGP，即把BGP的路由引入到IGP中只会引入EBGP的路由，不会引入IBGP的路由。如果想要引入IBGP的路由需要在&lt;code&gt;import bgp&lt;/code&gt;后面再加上IBGP。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;解决ibgp的水平分隔防环导致的问题&#34;&gt;解决IBGP的水平分隔防环导致的问题&lt;/h1&gt;
&lt;h2 id=&#34;路由反射器&#34;&gt;路由反射器&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;成为RR的两种方式：1.配置ClusterID；2.配置至少一个客户端&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;角色&#34;&gt;角色&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590220985716.png&#34; alt=&#34;BGP路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;路由反射器RR：允许把从IBGP对等体学到的路由&lt;strong&gt;反射到其他IBGP对等体的BGP设备&lt;/strong&gt;，类似OSPF网络中的DR。&lt;/li&gt;
&lt;li&gt;客户机Client：与RR形成反射邻居关系的IBGP设备。&lt;strong&gt;在AS内部客户机只需要与RR直连&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;非客户机Non-Client：既不是RR也不是客户机的IBGP设备。在AS&lt;strong&gt;内部非客户机与RR&lt;/strong&gt;之间，以及&lt;strong&gt;所有的非客户机之间&lt;/strong&gt;仍然必须建立&lt;strong&gt;全连接关系&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;客户端和非客户端只具有本地意义，并且只有RR才知道。客户端和非客户端都只和RR建立邻居关系，RR收到后负责转发，因此只需要在RR上定义客户端和非客户端&lt;/code&gt;&lt;br&gt;
&lt;code&gt;RR反射的路由条目不修改任何属性，同时会追加属性Cluster-list和Originator_ID，用于防止集群之间和集群内部的环路&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;始发者Originator：在AS内部始发路由的设备。Originator_ID属性用于&lt;strong&gt;防止集群内产生路由环路&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;集群Cluster：路由反射器及其客户机的集合。Cluster_List属性用于防止集群间产生路由环路。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;路由反射宣告原则&#34;&gt;路由反射宣告原则&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;RR突破了&amp;quot;从IBGP对等体获得的BGP路由 只发布给它的EBGP对等体&amp;quot;的限制&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从非客户机&lt;sub&gt;IBGP&lt;/sub&gt;学到的路由，发布给此RR的所有客户机&lt;sub&gt;和EBGP对等体&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;从客户机学到的路由，发布给此RR所有非客户机和客户机&lt;sub&gt;（发起此路由的客户机除外）&lt;/sub&gt;&lt;/li&gt;
&lt;li&gt;从EBGP对等体学到的路由，发布给所有的非客户机和客户机&lt;br&gt;
&lt;code&gt;从非客户端学到的只发布给客户端，否则发布给所有的客户端和非客户端&lt;/code&gt;&lt;br&gt;
&lt;code&gt;【总结】：eBGP--&amp;gt;所有客户机和非客户机（因为这些设备与RR之间都是IBGP关系），非客户机路由--&amp;gt;所有客户机和eBGP，客户机--&amp;gt;所有客户机、非客户机和eBGP&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由反射簇即路由反射集群cluster&#34;&gt;路由反射簇（即路由反射集群，Cluster）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过4字节的Cluster_ID来标识Cluster，通常会使用LoopBack地址作为Cluster_ID&lt;/li&gt;
&lt;li&gt;一个Cluster里可以包括一个或者多个RR；一个Client可以同时属于多个Cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反射器部署方式&#34;&gt;反射器部署方式&lt;/h3&gt;
&lt;h4 id=&#34;1-备份路由反射器&#34;&gt;1. 备份路由反射器&lt;/h4&gt;
&lt;p&gt;为增加网络的&lt;strong&gt;可靠性&lt;/strong&gt;，防止单点故障对网络造成影响，需要在一个集群中配置一个以上的RR，但&lt;strong&gt;集群中的所有RR必须使用相同的ClusterID&lt;/strong&gt;，以避免RR之间的路由环路。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590225110630.png&#34; alt=&#34;备份路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;路由反射器RR1和RR2在同一个集群内，配置了相同的Cluster ID&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当客户机Client1从EBGP对等体接收到一条更新路由，它将通过IBGP向RR1和RR2通告这条路由。&lt;/li&gt;
&lt;li&gt;RR1和RR2在接收到该更新路由后，将本地Cluster ID添加到Cluster List前面，然后向其他的客户机（Client2、Client3）反射，同时相互反射。&lt;/li&gt;
&lt;li&gt;RR1和RR2在接收到该反射路由后，检查Cluster List，发现自己的Cluster ID已经包含在Cluster List中。于是RR1和RR2丢弃该更新路由，从而避免了路由环路。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-多集群路由反射器&#34;&gt;2. 多集群路由反射器&lt;/h4&gt;
&lt;p&gt;一个AS中可以存在多个集群，各个集群的RR之间建立IBGP对等体。当RR所处的网络层不同时，可以将较低网络层次的RR配成客户机，形成分级RR。当RR所处的网络层相同时，可以将不同集群的RR全连接，形成同级RR。&lt;/p&gt;
&lt;h5 id=&#34;1-分级路由反射器&#34;&gt;1. 分级路由反射器&lt;/h5&gt;
&lt;p&gt;在实际的RR部署中，常用的是分级RR的场景。ISP为AS100提供Internet路由。AS100内部分为两个集群，其中Cluster1内的四台设备是核心路由器，采用备份RR的形式保证可靠性。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590225258979.png&#34; alt=&#34;分级路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;2-同级路由反射器&#34;&gt;2. 同级路由反射器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590225345221.png&#34; alt=&#34;同级路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
一个骨干网被分成多个集群。各集群的RR互为非客户机关系，并建立全连接。此时虽然每个客户机只与所在集群的RR建立IBGP连接，但所有RR和客户机都能收到全部路由信息。&lt;/p&gt;
&lt;h2 id=&#34;联盟&#34;&gt;联盟&lt;/h2&gt;
&lt;p&gt;解决AS内部的IBGP网络连接激增问题，除了使用路由反射器之外，还可以使用联盟（Confederation）。联盟&lt;strong&gt;将一个AS划分为若干个子AS&lt;/strong&gt;。&lt;strong&gt;每个子AS内部建立IBGP全连接关系，子AS之间建立联盟EBGP连接关系（&lt;code&gt;子AS之间通告路由不修改下一跳&lt;/code&gt;），但联盟外部AS仍认为联盟是一个AS&lt;/strong&gt;。配置联盟后，原AS号将作为每个路由器的联盟ID。这样有两个&lt;strong&gt;好处&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以保留原有的IBGP属性，包括Local Preference属性、MED属性和NEXT_HOP属性等；&lt;/li&gt;
&lt;li&gt;联盟相关的属性在传出联盟时会自动被删除，即管理员无需在联盟的出口处配置过滤子AS号等信息的操作。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590226126773.png&#34; alt=&#34;BGP联盟&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AS100使用联盟后被划分为3个子AS：AS65001、AS65002和AS65003，使用AS100作为联盟ID。此时IBGP的连接数量从10条减少到4条，不仅简化了设备的配置，也减轻了网络和CPU的负担。而AS100外的BGP设备因为仅知道AS100的存在，并不知道AS100内部的联盟关系，所以不会增加CPU的负担。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;路由反射器和联盟的比较&#34;&gt;路由反射器和联盟的比较&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;在联盟中可以使用RR，但是在RR中无法使用联盟&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;路由反射器&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;联盟&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要更改现有的网络拓扑，兼容性好&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要改变逻辑拓扑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;配置方便，只需要对作为反射器的设备进行配置，客户机并不需要知道自己是客户机&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;所有设备需要重新进行配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;集群与集群之间仍然需要全连接&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;联盟的子AS之间是特殊的EBGP连接，不需要全连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;适用于中、大规模网络（对现有网络进行改造）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;适用于大规模网络（新建大型网络）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;无效路由场景bgp路由条目在什么情况下不加表&#34;&gt;无效路由场景（BGP路由条目在什么情况下不加表）&lt;/h1&gt;
&lt;p&gt;BGP无效路由是指可以收到路由，但是路由条目前面没有&lt;code&gt;*&lt;/code&gt;号标记，表示是一条无效路由【即BGP表中有路由，但是此路由是不可用路由，不装进 IP 路由表】&lt;/p&gt;
&lt;h2 id=&#34;1-bgp路由下一跳不可达&#34;&gt;1. BGP路由下一跳不可达&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613112963841.png&#34; alt=&#34;BGP路由下一跳不可达&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R1上将1.1.1.1/32 路由通告进BGP，在R3上查看BGP路由表，可以收到 1.1.1.1/32 路由，但不是一条有效路由，因为其下一跳为12.1.1.1不可达。&lt;br&gt;
解决方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R2上设置下一跳自我&lt;/li&gt;
&lt;li&gt;R2上将12.1.1.1引入到IGP或者在R3上创建一条静态路由&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-通过默认路由建立bgp邻居关系&#34;&gt;2. 通过默认路由建立BGP邻居关系&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613113449411.png&#34; alt=&#34;通过默认路由建立BGP邻居关系&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
分别在R1和R2上配置到对方的默认路由，并通过lo0口建立IBGP邻居关系。在R1上将lo1的11.1.1.1/32路由宣告进BGP。在R2上可以收到11.1.1.1/32路由，但不是一条有效路由，因为&lt;strong&gt;BGP邻居是通过默认路由建立，为了防止环路问题从邻居收到的路由条目全部设置为无效&lt;/strong&gt;&lt;br&gt;
解决方案：&lt;br&gt;
通过静态路由或者IGP路由建立BGP邻居关系&lt;/p&gt;
&lt;h2 id=&#34;3-bgp路由同步路由为有效但是不会优选&#34;&gt;3. BGP路由同步（路由为有效，但是不会优选）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613114719074.png&#34; alt=&#34;BGP路由同步&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R1上将1.1.1.1/32宣告进 BGP，在AS200中的所有设备上开启BGP同步，R2可以收到1.1.1.1/32的EBGP路由并且优选，R2将路由通告给R3并且修改下一跳自我，在R3上查看BGP路由表，可以收到1.1.1.1/32的路由，但是为非优路由，R3不优选同时不会通告给其它的客户端。&lt;br&gt;
BGP开启同步后，会检查从IBGP邻居（如果路由来自EBGP邻居，忽略同步检查）接收的BGP路由是否同时存在于IGP路由表中，如果IGP路由表中有同样的路由条目，优选该路由，如果没有则不优选，目的是避免因为通告而造成的路由黑洞问题&lt;br&gt;
解决方案：&lt;br&gt;
将BGP路由引入到IGP（不可行）&lt;/p&gt;
&lt;h2 id=&#34;4-将建立邻居的路由通告进bgp&#34;&gt;4. 将建立邻居的路由通告进BGP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613114801412.png&#34; alt=&#34;将建立邻居的路由通告进BGP&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R1和R2通过OSPF互通，并通过lo0口建立IBGP邻居关系。IBGP邻居关系建立后，分别在R1和R2上将lo0口路由在宣告进BGP。R1和R2上都可以看到对方通告的BGP路由，但是为无效路由。&lt;br&gt;
由于IGP和BGP通告了同样的路由条目，并且BGP是通过此路由建立的邻居关系。如果现在将BGP路由设置为有效并且优选&lt;code&gt;需要将BGP路由的优先级设置为9（小于ospf的优先级10就行）&lt;/code&gt;会带来IBGP邻居震荡的问题。&lt;br&gt;
原因是用于建立IBGP邻居的路由优选了BGP，出现了自环&lt;code&gt;即用于建立BGP邻居的路由来自BGP内部&lt;/code&gt;，导致路由不可达。造成180秒后IBGP邻居down，IBGP邻居down后在次优选IGP路由，路由可达。重新建立IBGP邻居并重复之前的流程，IBGP邻居会一直震荡下去。&lt;br&gt;
华为针对这种场景做了优化，如果&lt;strong&gt;收到的BGP路由等于建立BGP邻居的路由，设置该路由为无效路由&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;5-ebgp路由惩罚dampening&#34;&gt;5. EBGP路由惩罚(dampening)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613115126892.png&#34; alt=&#34;EBGP路由惩罚&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
R1和R2建立EBGP邻居，R1将 1.1.1.1/32路由通告进BGP，在R2上配置BGP路由惩罚，配置完成后在R1上连续执行针对1.1.1.1/32路由的取消通告和通告操作，那么在R2上1.1.1.1/32路由被标记为D，设置为无效路由&lt;/p&gt;
&lt;h2 id=&#34;6-mpls-vpn-场景lsp不完整造成的无效路由&#34;&gt;6. MPLS VPN 场景（LSP不完整造成的无效路由）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613115246569.png&#34; alt=&#34;MPLS VPN 场景&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AS100内通过OSPF路由协议互联，PE1和PE2建立MP-IBGP邻居关系，并在PE1上将CE1路由引入到 MP-BGP，AS100内只开启MPLS，但是不配置LDP。&lt;br&gt;
PE2上可以收到PE1通告的MP-IBGP路由，但是路由不是有效路由，因为到达私网路由的下一跳没有一条完整的LSP，从而造成VPNv4路由不是一条有效路由。&lt;br&gt;
解决方案：&lt;br&gt;
在AS100内的所有设备上开启LDP，通过LDP分配公网标签，建立一条到达下一跳的LSP&lt;/p&gt;
&lt;h2 id=&#34;7-其他场景&#34;&gt;7. 其他场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果是VPNv4的路由，无法迭代到下一跳对应的隧道，或者隧道不是/32 位掩码，则此路由不进客户的实例路由或者不传给EBGP邻居&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bgp-rib-only&lt;/code&gt;命令用来禁止BGP路由下发到IP路由表&lt;code&gt;只在BGP路由表中有，不进自身路由表&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;active-route-advertise&lt;/code&gt;命令用来配置BGP仅发布在IP路由表中被优选的路由，那些在BGP中是最优但是在IP路由表中不是最优的路由则不通告给邻居&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;igp和bgp的区别&#34;&gt;IGP和BGP的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;IGP主要解决数据的转发，BGP主要解决路由的传递和控制&lt;/li&gt;
&lt;li&gt;IGP，运行于AS内部的路由协议，主要有RIP、OSPF、ISIS，着重于发现和计算路由；EGP，运行于AS之间的路由协议，现通常都是指BGP，着重于控制路由的传播和选择最优的路由。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bgp特点&#34;&gt;BGP特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BGP是外部路由协议，用来在AS之间传递路由信息&lt;/li&gt;
&lt;li&gt;是一种增强的距离矢量路由协议
&lt;ul&gt;
&lt;li&gt;可靠的路由更新机制
&lt;ul&gt;
&lt;li&gt;使用TCP承载，端口号为179&lt;/li&gt;
&lt;li&gt;无需周期性更新，路由更新时只发送增量路由&lt;code&gt;触发更新和增量更新&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;周期性发送KeepAlive报文检测TCP的连通性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;丰富的Metric度量方法&lt;/li&gt;
&lt;li&gt;从设计上避免了环路的发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为路由附带属性信息&lt;/li&gt;
&lt;li&gt;支持CIDR（无类别域间选路）&lt;/li&gt;
&lt;li&gt;丰富的路由过滤和路由策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;属性总结&#34;&gt;属性总结&lt;/h2&gt;
&lt;p&gt;根据属性主要作用，将其可大致分为5个方向：&lt;strong&gt;3个选路、3个防环、2个反射、2个汇总、1个团体&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613136203738.png&#34; alt=&#34;属性总结&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3个选路weight-local-med&#34;&gt;3个选路（weight、local、med）&lt;/h3&gt;
&lt;p&gt;首先为什么要有三个选路属性？因为三个属性各司其职，&lt;strong&gt;作用均不相同&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;preferred-value：只作用于自己，不可传递给其他人；适用于一个路由器在多条路径下的选路，无视邻居属性，默认情况下preferred-value=0&lt;/li&gt;
&lt;li&gt;local-pref：与preferred-value相比，最大的优点为公有且可作用于AS内其他路由器，用于本AS选择离开AS的出口路由器&lt;/li&gt;
&lt;li&gt;med：与前两者相比，最大的区别在于，可以作用于出口、影响其他AS，如果在本AS使用，和local差别不大；值得注意的是，med属性只能在两个as之间传递，不能传递给第三个as。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3个防环origin-as_path-next_hop&#34;&gt;3个防环（origin、as_path、next_hop）&lt;/h3&gt;
&lt;p&gt;BGP协议利用3个公认必遵属性进行防环&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;origin：起源属性，标识该路由的来源方式，i表示自己产生的、e表示EGP学到的、？表示其他手段得到的（重发布），优先顺序为i&amp;gt;e&amp;gt;?。这一属性，实为路由协议之间的较量，在自己内部传递是不会改变属性的；通过这一属性，来保证从自己发出的路由，经过其他协议处理之后，不会再流传给自己，从而防环。&lt;/li&gt;
&lt;li&gt;as_path：将经过的AS统统记下来，最近经过的的排前面，路由器拒绝接受携带自己AS号的路由，当然该属性也可以用来选路，as_path短的优先。&lt;/li&gt;
&lt;li&gt;next_hop：IBGP之间传递路由不会更新next_hop（只有next_hop为0.0.0.0的情况才会更新，&lt;code&gt;自己为0，保证从自己发出去的不再回来&lt;/code&gt;）；eBGP之间传递路由会更新next_hop为自己的更新源地址。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2个反射防环originator-id-cluster-list&#34;&gt;2个反射防环（originator-id、cluster-list）&lt;/h3&gt;
&lt;p&gt;非客户端之间不能相互反射，但在反射之后，就违背了BGP设计之初防环的作用，所以又诞生了两个反射防环属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;originator-id：反射路由器收到路由后，用起源者的rid标记，后面的路由器看到自己的rid，不收，从而起到防环的作用。originator-id只能标记一个路由器，若途经多个反射器，则无能为力，可能导致反射器之间出环，所以出现了cluster-list。&lt;/li&gt;
&lt;li&gt;cluster-list：反射路由器反射出去的路由，会生成列表，加入自己的rid，沿途反射的均加入自己的rid，等收到后，若列表中有自己的rid，则忽略，达到防环的目的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2个汇总atomic-aggregate-aggregator&#34;&gt;2个汇总（Atomic-aggregate、aggregator）&lt;/h3&gt;
&lt;p&gt;由于路由协议庞大且复杂，那么避免不了需要对一些路由进行汇总，汇总本身就是消灭一些路由、产生一些路由，而在这个过程中必然会丢失很多属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Atomic-aggregate：通过添加某些选项，来达到弥补丢失一些属性的作用。&lt;br&gt;
追加&lt;code&gt;as-set&lt;/code&gt;，继承明细as-path属性，防环；加&lt;code&gt;summary only&lt;/code&gt; 只显示汇总；加&lt;code&gt;advertise-map&lt;/code&gt; 显示某些属性；加&lt;code&gt;attribute-map&lt;/code&gt; 为聚合后的添加某些属性。&lt;br&gt;
而在其他路由器得到汇总路由之后，有可能需要知道是谁产生的汇总，那么就产生了aggregator属性。&lt;/li&gt;
&lt;li&gt;aggregator：通告汇总路由的汇总路由器BGP-ID ，寻找汇总者方便&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;1个团体community&#34;&gt;1个团体（community）&lt;/h3&gt;
&lt;p&gt;团体属性主要有两大作用：1. 为了可读性好； 2. 规定和谁玩&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可读性好：&lt;br&gt;
利用正则表达式&lt;code&gt;X：Y&lt;/code&gt; 形式来标识，使得可读性大大提高。&lt;/li&gt;
&lt;li&gt;规定和谁玩：&lt;br&gt;
利用四条子属性来规定和谁玩的问题。
&lt;ol&gt;
&lt;li&gt;Internet：默认属性，可以给任何bgp发送，不对携带团体值的路由做任何限制&lt;/li&gt;
&lt;li&gt;no-advertise：不在ibgp，ebgp邻居间传递，禁止传递给其他邻居&lt;/li&gt;
&lt;li&gt;no-export：只能在一个as之内传递，可以在联盟内传递，该属性就是限制携带团体值的路由传递给ebgp邻居，联盟ebgp除外&lt;/li&gt;
&lt;li&gt;no-export-subconfed：不向任何ebgp邻居发送，包括联盟的ebgp邻居&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;影响bgp邻居建立的因素&#34;&gt;影响BGP邻居建立的因素&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;版本号：默认我4&lt;/li&gt;
&lt;li&gt;AS号：IBGP要求必须一致，EBGP邻居必须不一致&lt;/li&gt;
&lt;li&gt;RouterID：不能冲突
&lt;ol&gt;
&lt;li&gt;直连冲突：地址大的一方开启TCP连接，TCP连接建立成功后互发open消息并将状态转为opensent，但是由于open消息中的BGP ID（BGP标识符一样）导致建立不起来邻居，于是互相发送notification消息，type=2 （open消息） 3错误的BGP ID。互相收到后进入Idle状态，进入TCP重置。&lt;/li&gt;
&lt;li&gt;非直连冲突：同上&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;179 端口被禁止：如果被禁止，则无法建立 TCP 连接，也就无法建立邻居&lt;/li&gt;
&lt;li&gt;peer可达性：peer地址必须可达&lt;/li&gt;
&lt;li&gt;认证不通过&lt;/li&gt;
&lt;li&gt;收到报文的源地址必须和peer的地址相同&lt;/li&gt;
&lt;li&gt;EBGP用环回口建邻居需要指多跳&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bgp在传递ipv4-ipv6-vpnv4路由时为什么更加简单&#34;&gt;BGP在传递IPV4、IPV6、VPNv4路由时为什么更加简单&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;BGP是外部路由协议，用来在AS之间传递路由信息，是一种增强的距离矢量路由协议，具有丰富的Metric计算方法，并且支持CIDR&lt;/li&gt;
&lt;li&gt;Open报文中的Optional Parameters字段可协商传递何种路由，可通过AFI和SAFI协商具体携带何种路由信息&lt;/li&gt;
&lt;li&gt;Update报文是邻居之间用于交换路由信息的报文，由5个部分组成，其中包括撤销路由信息和可达路由信息及其各种路由属性，是一种TLV的报文结构，携带多种路由信息比较简单&lt;/li&gt;
&lt;li&gt;拥有丰富的扩展属性传递路由&lt;br&gt;
MP_BGP是一种多协议的BGP，为了提供对多种网络层协议的支持，MP-BGP使用扩展属性和地址族来实现对IPv6、组播和VPN相关内容的支持，包含传递IPv4的BGPv4版本、传递IPv6的BGPv4+版本和传递组播的MBGP版本，所以可以传递多种路由条目，为支持VPNv4，增加了属性值为14（传递可达路由）和15（撤销不可达路由）的两种属性，但是BGP协议原有的报文机制和路由机制并没有改变。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ibgp与ebgp传递路由有什么区别&#34;&gt;IBGP与EBGP传递路由有什么区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;next-hop：从IBGP邻居学到的路由向EBGP传递路由的时候，下一跳改为自己；从EBGP邻居学到的路由向IBGP传递路由的时候，下一跳不改变&lt;/li&gt;
&lt;li&gt;as-path：传递给EBGP邻居的时候会添加自己的AS号；传递给IBGP邻居的时候不加自己的AS号&lt;/li&gt;
&lt;li&gt;local-preference：EBGP传递路由的时候剥离LP属性；IBGP传递路由时携带LP属性&lt;/li&gt;
&lt;li&gt;med：从IBGP邻居收到的路由传递给EBGP路由时候MED默认剥离；从EBGP邻居收到路由传递给IBGP邻居的时候MED不变&lt;/li&gt;
&lt;li&gt;cluster-list和起源ID：向IBGP反射路由时候保留cluster-list和起源ID，向EBGP传递路由时剥离这两个属性&lt;/li&gt;
&lt;/ol&gt;
">BGP协议</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/igp-xie-yi-isis/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E7%9A%84%E5%BB%BA%E7%AB%8B&#34;&gt;ISIS邻接关系的建立&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B9%BF%E6%92%AD%E7%BD%91&#34;&gt;广播网&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E7%BB%86%E8%8A%82&#34;&gt;报文细节&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#p2p&#34;&gt;P2P&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3-way%E6%8A%A5%E6%96%87&#34;&gt;3-way报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E7%9A%84lsp%E4%BA%A4%E4%BA%92%E8%BF%87%E7%A8%8B&#34;&gt;ISIS的LSP交互过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B9%BF%E6%92%AD%E7%BD%91%E7%BB%9C&#34;&gt;广播网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#p2p%E7%BD%91%E7%BB%9C&#34;&gt;P2P网络&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E7%9A%84ssn%E5%92%8Csrm%E6%A0%87%E5%BF%97&#34;&gt;ISIS的SSN和SRM标志&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#p2p-2&#34;&gt;P2P&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B9%BF%E6%92%AD&#34;&gt;广播&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E6%B8%97%E9%80%8F%E8%B7%AF%E7%94%B1%E6%B3%84%E6%BC%8F&#34;&gt;路由渗透（路由泄漏）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A7%E7%94%9Fatt%E7%BD%AE%E4%BD%8D%E7%9A%84lsplevel-1%E7%9A%84%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E7%9A%84%E6%9D%A1%E4%BB%B6&#34;&gt;产生ATT置位的LSP（Level-1的默认路由）的条件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E6%B3%84%E6%BC%8F%E4%B9%8B%E5%90%8E%E9%98%B2%E7%8E%AF&#34;&gt;路由泄漏之后防环&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%A9%E7%94%A8ol%E8%BF%87%E8%BD%BD%E4%BD%8D%E7%9A%84%E5%9C%BA%E6%99%AF&#34;&gt;利用OL过载位的场景&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99&#34;&gt;ISIS选路原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E6%94%B6%E6%95%9B%E7%89%B9%E6%80%A7&#34;&gt;ISIS收敛特性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%A6%E9%87%8F%E5%80%BC&#34;&gt;度量值&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-narrow%E6%A8%A1%E5%BC%8F&#34;&gt;1. Narrow模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#4%E7%A7%8D%E5%BA%A6%E9%87%8F%E5%80%BC&#34;&gt;4种度量值&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-wide%E6%A8%A1%E5%BC%8F&#34;&gt;2. Wide模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E8%AE%A4%E8%AF%81&#34;&gt;ISIS认证&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB&#34;&gt;分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F&#34;&gt;报文认证方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%E7%9A%84%E6%90%BA%E5%B8%A6%E5%BD%A2%E5%BC%8F&#34;&gt;认证信息的携带形式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lsp&#34;&gt;LSP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E7%9A%84lsdb%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B&#34;&gt;ISIS的LSDB更新过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lsp%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0&#34;&gt;LSP产生的原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%94%B6%E5%88%B0%E9%82%BB%E5%B1%85%E6%96%B0%E7%9A%84lsp%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B&#34;&gt;收到邻居新的LSP的处理过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lsp-id&#34;&gt;LSP ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lsp%E5%88%86%E7%89%87&#34;&gt;LSP分片&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F&#34;&gt;工作模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95&#34;&gt;路由算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#spf%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B&#34;&gt;SPF计算过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E7%9A%84%E8%AE%A1%E7%AE%97%E7%89%B9%E7%82%B9&#34;&gt;ISIS的计算特点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88&#34;&gt;路由聚合&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85&#34;&gt;补充&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84&#34;&gt;ISIS地址结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#nsap&#34;&gt;NSAP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#net&#34;&gt;NET&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B3%E4%BA%8Esystemid&#34;&gt;关于SystemID&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E6%95%B4%E4%BD%93%E6%8B%93%E6%89%91&#34;&gt;ISIS整体拓扑&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%B1%BB&#34;&gt;ISIS路由器分类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#level-1%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;Level-1路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#level-2%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;Level-2路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#level-1-2%E8%B7%AF%E7%94%B1%E5%99%A8%E9%BB%98%E8%AE%A4&#34;&gt;Level-1-2路由器（默认）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E6%9C%AF%E8%AF%AD&#34;&gt;ISIS术语&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B&#34;&gt;ISIS报文类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-hello-pduiihhello%E6%8A%A5%E6%96%87&#34;&gt;1. Hello PDU（IIH）（hello报文）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#level-1-lan-iih&#34;&gt;Level-1 LAN IIH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#level-2-lan-iih&#34;&gt;Level-2 LAN IIH&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#p2p-iih&#34;&gt;P2P IIH&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-lsp-pdu%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%8A%A5%E6%96%87&#34;&gt;2. LSP PDU（链路状态报文）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-snp-pdu%E5%BA%8F%E5%88%97%E5%8F%B7%E6%8A%A5%E6%96%87&#34;&gt;3. SNP PDU（序列号报文）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#csnp%E5%85%A8%E5%BA%8F%E5%88%97%E5%8F%B7%E6%8A%A5%E6%96%87&#34;&gt;CSNP（全序列号报文）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#psnp%E9%83%A8%E5%88%86%E5%BA%8F%E5%88%97%E5%8F%B7%E6%8A%A5%E6%96%87&#34;&gt;PSNP（部分序列号报文）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B&#34;&gt;ISIS网络类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E6%94%AF%E6%8C%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B&#34;&gt;ISIS支持的网络类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dis&#34;&gt;DIS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dis%E7%9A%84%E9%80%89%E4%B8%BE&#34;&gt;DIS的选举&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BD%B1%E5%93%8Disis%E9%82%BB%E5%B1%85%E5%BB%BA%E7%AB%8B%E7%9A%84%E6%9D%A1%E4%BB%B6&#34;&gt;影响ISIS邻居建立的条件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E8%BF%90%E8%A1%8C%E7%BA%A7%E5%88%AB%E5%92%8C%E5%8C%BA%E5%9F%9Fid&#34;&gt;1. 运行级别和区域ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-system-id&#34;&gt;2. System-ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E8%AE%A4%E8%AF%81&#34;&gt;3. 认证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-mtu&#34;&gt;4. MTU&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B&#34;&gt;5. 接口的网络类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-ip%E5%9C%B0%E5%9D%80%E4%B8%8D%E5%9C%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%BD%91%E6%AE%B5&#34;&gt;6. IP地址不在同一个网段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-cost-style&#34;&gt;7. cost-style&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-%E5%85%B6%E4%BB%96&#34;&gt;8. 其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dr%E5%92%8Cdis%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;DR和DIS的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E5%92%8Cospf%E7%9A%84%E5%8C%BA%E5%9F%9F%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;ISIS和OSPF的区域的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E5%92%8Cisis%E7%9A%84%E5%BC%82%E5%90%8C&#34;&gt;OSPF和ISIS的异同&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B8%E5%90%8C%E7%82%B9&#34;&gt;相同点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E5%90%8C%E7%82%B9&#34;&gt;不同点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%9F%BA%E6%9C%AC%E7%82%B9%E6%AF%94%E8%BE%83&#34;&gt;1. 基本点比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E6%AF%94%E8%BE%83&#34;&gt;2. 邻接关系比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%93%BE%E8%B7%AF%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5%E8%BF%87%E7%A8%8B%E6%AF%94%E8%BE%83&#34;&gt;3. 链路状态数据库同步过程比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E6%AF%94%E8%BE%83&#34;&gt;4. 路由计算过程比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%80%A7%E8%83%BD%E5%8F%8A%E6%89%A9%E5%B1%95%E8%83%BD%E5%8A%9B%E6%AF%94%E8%BE%83&#34;&gt;5. 性能及扩展能力比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis-ipv6&#34;&gt;ISIS IPv6&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ipv6%E5%A2%9E%E5%8A%A0%E4%BA%86%E5%93%AA%E4%B8%A4%E4%B8%AAtlv&#34;&gt;1. IPv6增加了哪两个TLV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-isis%E5%A4%9A%E6%8B%93%E6%89%91%E6%8C%87%E6%98%AF%E4%BB%80%E4%B9%88&#34;&gt;2. isis多拓扑指是什么&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#isis%E5%9C%A8%E5%B8%A7%E4%B8%AD%E7%BB%A7%E7%8E%AF%E5%A2%83%E4%B8%8B%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B&#34;&gt;ISIS在帧中继环境下使用什么网络类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;isis邻接关系的建立&#34;&gt;ISIS邻接关系的建立&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;ISIS的邻居状态机：只有down、init、up三种状态&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;广播网&#34;&gt;广播网&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在广播网络上，使用LAN IIH报文来建立邻接关系。有两种类型的LAN IIH：L1 LAN IIH（组播MAC:01-80-C2-00-00-14）和L2 LAN IIH （组播MAC:01-80-C2-00-00-15） 。&lt;/li&gt;
&lt;li&gt;Level-1路由器通过交互L1 LAN IIH报文来建立邻接关系；Level-2路由器通过交互L2 LAN IIH报文来建立邻接关系；Level-1-2路由器会同时交互L1 LAN IIH报文和L2 LAN IIH报文来建立邻接关系。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588860400476.png&#34; alt=&#34;广播邻接关系建立&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以两台L2路由器在广播链路上建立邻居关系为例：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;R1组播发送Level-2 LAN IIH（组播MAC:01-80-C2-00-00-15），此报文中无邻居标识。&lt;/li&gt;
&lt;li&gt;R2收到此报文后，将自己和R1的邻居状态标识为Initial。然后，R2再组播向R1回复Level-2 LAN IIH，此报文中标识R1为R2的邻居（&lt;strong&gt;6号TLV，通过R1的接口MAC地址进行标识&lt;/strong&gt;）。&lt;/li&gt;
&lt;li&gt;R1收到此报文后，将自己与R2的邻居状态标识为Up。然后R1再组播向R2发送一个标识R2为R1邻居的Level-2 LAN IIH。&lt;/li&gt;
&lt;li&gt;R2收到此报文后，将自己与R1的邻居状态标识为Up。这样，两个路由器成功建立了邻居关系。&lt;br&gt;
&lt;code&gt;因为是广播网络，需要选举DIS，所以在邻居关系建立后，路由器会等待两个Hello报文间隔再进行DIS的选举。Hello报文中包含Priority字段，Priority值最大的将被选举为该广播网的DIS，若优先级相同，接口MAC地址较大的被选举为DIS&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;报文细节&#34;&gt;报文细节&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612704235180.png&#34; alt=&#34;报文细节&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;p2p&#34;&gt;P2P&lt;/h2&gt;
&lt;p&gt;在P2P连路上，邻接关系建立不同于广播链路，分为两次握手机制和&lt;strong&gt;三次握手机制（默认）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588860853052.png&#34; alt=&#34;P2P邻接关系建立&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两次握手2-way（容易存在单通的风险，即链路两端分别为Up和Down）&lt;br&gt;
只要路由器收到对端发来的Hello报文，就单方面宣布邻居为Up状态，建立邻居关系&lt;/li&gt;
&lt;li&gt;三次握手3-way（默认方式）&lt;br&gt;
通过三次发送P2P的Hello PDU最终建立邻居关系，类似广播邻居关系建立&lt;br&gt;
&lt;code&gt;240号TLV包含：邻居状态、接口ID、system-id和自己的接口ID&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-way报文&#34;&gt;3-way报文&lt;/h3&gt;
&lt;p&gt;增加P2P邻接TLV，类型为240，长度为15B，其中&lt;code&gt;电路ID用于标识接口（广播网络使用MAC地址来标识接口），而system-id用于标识节点&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612707484067.png&#34; alt=&#34;3-way报文&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;isis的lsp交互过程&#34;&gt;ISIS的LSP交互过程&lt;/h1&gt;
&lt;h2 id=&#34;广播网络&#34;&gt;广播网络&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LSP交互不需要确认，CSNP和PSNP中是LSP的摘要信息&lt;/code&gt;&lt;br&gt;
CSNP报文在广播网络中的作用：确认机制，相当于ACK&lt;br&gt;
PSNP报文在广播网络中的作用：请求（LSR）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588862762123.png&#34; alt=&#34;广播网络LSP交互过程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新加入的路由器R3已经与R2（&lt;strong&gt;DIS&lt;/strong&gt;）、R1建立邻居关系&lt;/li&gt;
&lt;li&gt;R3使用组播地址发送自己的LSP&lt;/li&gt;
&lt;li&gt;R2收到R3的LSP之后，会将R3的LSP内容加入LSDB中，并等待CSNP报文定时器超时（10s）并发送CSNP报文，进行该网络的LSDB同步&lt;/li&gt;
&lt;li&gt;R3收到DIS发来的CSNP后，对比自己的LSDB，然后向R2发送PSNP用来请求自己没有的LSP&lt;code&gt;如果R3发现CSNP中缺少自己的LSP的内容，即DIS没有收到自己的LSP，R3会再次组播发送自己的LSP（通过该机制保证广播网中LSP的可靠性）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;R2收到R3发来的PSNP之后，将R3请求的LSP用组播方式发送给R3&lt;code&gt;R3发送PSNP之后如果没有收到LSP，R3会在5秒后重新发送该PSNP&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;p2p网络&#34;&gt;P2P网络&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LSP交互需要确认&lt;/code&gt;&lt;br&gt;
PSNP报文在P2P网络中的作用：作为ACK应答以确认收到的LSP，用来请求所需的LSP&lt;br&gt;
在P2P链路上，&lt;strong&gt;CSNP只会发送一次&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588863344689.png&#34; alt=&#34;P2P网络LSP交互过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
理论步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建立邻接关系之后首先都发送一个CSNP，通告本地的LSDP摘要信息&lt;/li&gt;
&lt;li&gt;两端设备接收到CSNP之后和本地LSDB做比较，发送PSNP请求自己缺少的LSP&lt;/li&gt;
&lt;li&gt;收到对方的PSNP之后回复具体的LSP&lt;/li&gt;
&lt;li&gt;收到对方发来的LSP之后，需要再回复一个PSNP进行确认&lt;br&gt;
&lt;code&gt;实际抓包过程：第一阶段R1和R2各发一个LSP；第二阶段R1和R2各发送一个PSNP；第三阶段R1发送LSP，R2发送CSNP进行确认&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;isis的ssn和srm标志&#34;&gt;ISIS的SSN和SRM标志&lt;/h1&gt;
&lt;p&gt;SSN/SRM标志在发送、接收LSP的接口下配置，只具有本地意义，用于LSP完整性、可靠性保证，虽然两种网络中都存在，但是&lt;code&gt;只有在P2P网络中才有意义&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;p2p-2&#34;&gt;P2P&lt;/h2&gt;
&lt;p&gt;SSN标志：用于P2P链路&lt;strong&gt;接收方&lt;/strong&gt;，在收到一个LSP时设置，在完成PSNP确认时清除（&lt;code&gt;即发送了用于确认该LSP的PSNP后删除&lt;/code&gt;）&lt;br&gt;
SRM标志：用于P2P链路&lt;strong&gt;发送方&lt;/strong&gt;，在发送一个LSP时设置，在收到其PSNP确认时清除&lt;/p&gt;
&lt;h2 id=&#34;广播&#34;&gt;广播&lt;/h2&gt;
&lt;p&gt;SSN标志：用于broadcast链路数据库同步过程中，请求完整的LSP。&lt;br&gt;
SRM标志：用于broadcast链路&lt;strong&gt;发送方&lt;/strong&gt;，在发送一个LSP时设置，但在LSP传送出去后被立即清除，因为broadcast链路不需要PSNP确认。&lt;/p&gt;
&lt;h1 id=&#34;路由渗透路由泄漏&#34;&gt;路由渗透（路由泄漏）&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;简而言之，路由渗透解决非骨干区域访问骨干区域时，因为不知道明细路由而导致的次优路径问题&lt;/code&gt;&lt;br&gt;
Level-1的路由通过Level-1-2传递进Level-2，但是Level-2的路由并不会传递进Level-1。因此，Level-1-2和Level-2路由器知道整个IS-IS路由域的路由信息。但是，&lt;strong&gt;为了有效减小路由表的规模，在缺省情况下，Level-1-2路由器并不将自己知道的其他Level-1区域以及骨干区域的路由信息通报给它所在的Level-1区域&lt;/strong&gt;。这样，&lt;strong&gt;Level-1路由器将不了解本区域以外的路由信息&lt;/strong&gt;，可能导致与本区域之外的目的地址通信时无法选择最佳的路由。&lt;br&gt;
&lt;code&gt;关联ISIS选路原则&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612783046989.png&#34; alt=&#34;路由渗透&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;未配置ISIS的路由渗透之前&lt;/strong&gt;：&lt;br&gt;
R1不知道本区域外部的任何路由，那么发往区域外的报文会选择最近的Level-1-2路由器（即R3）产生的默认路由发送出去，所以R1会选择次优路径（R1--R3--R5--R6），但是流量返回的路径是R6--R5--R4--R2--R1，同时还造成往返路径不一致，如果存在防火墙，会导致流量不通的问题&lt;/p&gt;
&lt;h2 id=&#34;产生att置位的lsplevel-1的默认路由的条件&#34;&gt;产生ATT置位的LSP（Level-1的默认路由）的条件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ISIS中的ABR（Level-1-2）生成默认路由（ATT=1）的条件：一边为Level-1，另外一边为Level-2&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设备运行级别为Level-1-2&lt;/li&gt;
&lt;li&gt;在Level-2的区域中有一个活动的邻接关系&lt;/li&gt;
&lt;li&gt;Level-2的区域ID&lt;strong&gt;不能&lt;/strong&gt;和Level-1的区域ID&lt;strong&gt;相同&lt;/strong&gt;&lt;code&gt;即Level-1-2设备的区域ID和Level-1相同，和Level-2不同&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;关于第3点的理解：&lt;br&gt;
区域的“不同”的准确含义是“包含”，即level-1-2设备的area如果包含了level-2邻居的area那么不置位，不包含则置位（默认可以配置3个NET地址，即3个area）&lt;br&gt;
通俗的理解：level-1-2设备认为level-1可以通过level-2到达更多区域才会将ATT置位，其中area信息通过报文中tlv0交互&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;路由泄漏之后防环&#34;&gt;路由泄漏之后防环&lt;/h2&gt;
&lt;p&gt;level-1-2的路由器在向level-1泄露路由时，这些level-2的LSP会将UP/DOWN置位，当这些泄露的路由再次想传入level-2时，level-1-2的路由器不会再向level-2的路由器传这些泄露的LSP。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;三个重要比特位&lt;/strong&gt;：&lt;br&gt;
P（PRTtition）：分区位。仅与Level-2的LSP有关（即只在Level-2区域才会被置位），表示路由器是否支持自动修复区域分割。（用于虚链路，但是目前并没有用过）&lt;br&gt;
ATT（Attach）：连接位。由Level-1-2路由器产生，但仅与Level-1的LSP有关（即只在Level-1区域才会被置位，使Level-1路由器产生指向Level-1-2路由器的默认路由），表示产生此LSP的路由器（Level-1-2路由器）&lt;strong&gt;与多个区域相连接&lt;/strong&gt;。&lt;br&gt;
OL（Overload）：过载标志位。表示本路由器因内存不足而导致LSDB不完整。其它路由器在得知这一信息后，就&lt;strong&gt;不会再利用这台路由器转发需要经过它传送的数据流&lt;/strong&gt;，但到此路由器直连地址的报文仍然可以被转发（一般用于承载BGP的核心ISIS，即isis over bgp）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;利用ol过载位的场景&#34;&gt;利用OL过载位的场景&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612784779309.png&#34; alt=&#34;利用OL过载位的场景&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;R5、R6之间建立EBGP邻居关系，R6与R3、R2、R4之间通过lo0分别建立IBGP邻居关系，lo0互通是通过isis协议。R2的lo0访问R5的lo0，下一跳选择R3，因为R3的cost更小。&lt;/li&gt;
&lt;li&gt;假设R3和R6之间的链路断开，则R3不再通告R6的路由条目，R2会将下一跳切换到R4。&lt;/li&gt;
&lt;li&gt;如果此时R3与R6之间的链路恢复，isis邻居已经建立，但是IBGP邻居还未建立（IBGP邻居建立依赖于IGP），此时R3会向R2通告R6的路由。如果R2此时切换到R3，R3与R6之间的IBGP邻居还未建立，可能造成丢包。为了避免这种场景，需要用到isis over bgp，即R3再通告LSP时，首先会查看BGP邻居状态，如果BGP邻居未建立，则将该LSP的OL位置位，那么R2收到此OL位置位的LSP，则进行SPF计算时不考虑此条LSP。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;isis选路原则&#34;&gt;ISIS选路原则&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Level-1＞Level-2＞leaked（注意内部优先级）&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Level-1：先查看是否和目标在同一区域，若在通过Level -1路由访问，若不在则使用缺省默认路由通过最近的Level-1-2路由器访问&lt;/li&gt;
&lt;li&gt;Level-2路由器访问某个目标时，直接通过Level-2数据库访问&lt;/li&gt;
&lt;li&gt;Level-1-2路由器访问目标时，先查看是否和目标在同一区域，若在同一区域通过Level-1路由访问，若不在同一区域通过Level-2数据库访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;isis收敛特性&#34;&gt;ISIS收敛特性&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;和OSPF收敛特性基本相同，但是RPC对ISIS的支持优于对OSPF的支持，因为ISIS的路由均是通过TLV进行传递的，但是OSPF传递路由的有1、3、5、7类LSA，RPC不支持1类LSA&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;快速收敛
&lt;ol&gt;
&lt;li&gt;增量最短路径优先算法ISPF：只对受影响的节点进行路由计算，仅第一次计算全部节点&lt;/li&gt;
&lt;li&gt;部分路由计算PRC：PRC的原理和ISPF相同，都是只对发生变化的路由进行重新计算。&lt;/li&gt;
&lt;li&gt;智能定时器&lt;/li&gt;
&lt;li&gt;LSP快速扩散：接口上发送LSP报文的最小间隔为50毫秒，每次发送LSP报文的最大数目是10&lt;br&gt;
&lt;code&gt;LSP默认发送间隔为900秒，老化时间(剩余老化时间)为1200秒，如果LSP剩余时间变为0，还需要在等待60S（零老化时间）才会从LSDB中删除。ospf和isis均不能删除不是自身产生的路由，即不能删除不是自己产生的LSA或者LSP。但是isis如果收到的lsp是有问题的，是可以删除的，删除时间为1260秒，这点和ospf不同&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;按优先级收敛&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;度量值&#34;&gt;度量值&lt;/h1&gt;
&lt;h2 id=&#34;1-narrow模式&#34;&gt;1. Narrow模式&lt;/h2&gt;
&lt;p&gt;设备默认模式开销都是10，手工配置接口开销取值范围为1-63&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2号TLV(IS Neighbors TLV)，IS可达性TLV，用来携带邻居信息，通告节点&lt;/li&gt;
&lt;li&gt;128号TLV（IP Internal Reachability TLV），IP内部可达性TLV，用来携带路由域内的IS-IS路由信息，通告内部路由&lt;/li&gt;
&lt;li&gt;130号TLV（IP External Reachability TLV），IP外部可达性TLV，用来携带路由域外的IS-IS路由信息，通告外部路由&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4种度量值&#34;&gt;4种度量值&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;每个度量1个字节，经常用的是默认度量，而延迟度量、开销度量、差错度量主要用在QOS路由选择中&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;默认度量：跟接口带宽成反比，参考带宽/带宽=cost （默认情况下，所有路由器都必须支持这个默认度量）
&lt;ol&gt;
&lt;li&gt;7bit：up/down&lt;sub&gt;up为1&lt;/sub&gt;，用于防环&lt;code&gt;Level-1-2的路由器不会将来自Level-2的路由发布进Level-1。如果将Level-2的路由泄漏进Level-1，那么up/down会置1，up/down置位的Level-1的LSP不会再被通告进Level-2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;6bit：内部度量/外部度量&lt;sub&gt;外部度量为1&lt;/sub&gt; （默认是内部度量）&lt;/li&gt;
&lt;li&gt;5bit~0bit(6bit) ：用于表示度量值， 即最大为为63。接口下配置的最大度量值为63，转发路径上累加度量值不能超过1024，否则不参与计算&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;延迟度量：用来表示链路传输的延迟&lt;/li&gt;
&lt;li&gt;开销度量：用来表示链路传输的开销&lt;/li&gt;
&lt;li&gt;差错度量：用来表示链路传输的错误&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612788412581.png&#34; alt=&#34;4种度量值&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-wide模式&#34;&gt;2. Wide模式&lt;/h2&gt;
&lt;p&gt;设备默认开销模式都是10，手工配置接口开销取值范围为1-16777215&lt;br&gt;
OSPF与ISIS协议都被扩展以便携带MPLS TE接口参数，对于ISIS协议来说，使用以下两种新的TLV：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;22号TLV（IS Extended Neighbors TLV），扩展IS可达性TLV，用来携带邻居信息&lt;/li&gt;
&lt;li&gt;135号TLV(Extended IP Reachability TLV)，扩展IP可达性TLV，用来替换原有的IP reachability TLV，携带ISIS路由信息，它扩展了路由开销值的范围，并可以携带sub TLV&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589100789194.png&#34; alt=&#34;接收和发送的类型详细列表&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用宽度量的场景：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;最大63的度量值已经不能满足要求&lt;/li&gt;
&lt;li&gt;配置需要支持IPv6&lt;/li&gt;
&lt;li&gt;外部路由需要携带tag（管理标记），tag也是包含在度量值中的&lt;br&gt;
&lt;strong&gt;管理标记&lt;/strong&gt;：管理标记特性允许在IS-IS域中通过管理标记对IP地址前缀进行控制，可以简化管理。其用途包括&lt;strong&gt;控制不同级别和不同区域间的路由引入&lt;/strong&gt;，以及在&lt;strong&gt;同一路由器上运行的IS-IS多实例&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;auto-cost&lt;/strong&gt;&lt;br&gt;
华为独有的计算cost值的方式，根据带宽自动计算接口开销，参数compatible表示使能根据带宽自动计算接口开销的兼容模式&lt;br&gt;
如果在接口和isis进行下都没有配置开销值，则此接口的开销由系统自动计算&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;当开销类型为wide或wide-compatible时&lt;/strong&gt;：&lt;code&gt;接口的开销值= (参考带宽/接口带宽值)×10&lt;/code&gt;&lt;br&gt;
配置&lt;code&gt;auto-cost enable compatible&lt;/code&gt;命令后：&lt;code&gt;接口的开销值= 参考带宽/接口带宽值&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当开销类型为narrow、narrow-compatible或compatible时&lt;/strong&gt;，不同带宽开销值如下：10M以内60，100M以内50，155M以内40，622M以内30，2.5G以内20，大于2.5Ｇ为10&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;isis认证&#34;&gt;ISIS认证&lt;/h1&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;接口认证&lt;/strong&gt;&lt;br&gt;
对Level-1和Level-2的Hello报文进行认证&lt;br&gt;
&lt;code&gt;针对Hello报文做的认证，会影响ISIS邻居，也会影响路由&lt;/code&gt;&lt;br&gt;
有以下两种设置
&lt;ol&gt;
&lt;li&gt;发送带认证TLV的认证报文，本地对收到的报文也进行认证检查&lt;/li&gt;
&lt;li&gt;发送带认证TLV的认证报文，但是本地对收到的报文不进行认证检查&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区域认证&lt;/strong&gt;&lt;br&gt;
对Level-1的SNP和LSP报文进行认证&lt;br&gt;
&lt;code&gt;针对Level-1的SNP和LSP做的认证，不会影响ISIS邻居，但是会影响Level-1的LSDB的同步，仅影响Level-1的路由，不会影响Level-2的路由&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由域认证&lt;/strong&gt;&lt;br&gt;
对Level-2的SNP和LSP报文进行认证&lt;br&gt;
&lt;code&gt;针对Level-2的LSP和SNP的认证，不会影响ISIS邻居，但是会影响Level-2的LSDB的同步，仅影响Level-2的路由，不影响Level-1的路由&lt;/code&gt;&lt;br&gt;
可以设置为SNP和LSP分开认证：
&lt;ol&gt;
&lt;li&gt;本地发送的LSP报文和SNP报文都携带认证TLV，对收到的LSP报文和SNP报文都进行认证检查&lt;/li&gt;
&lt;li&gt;本地发送的LSP报文携带认证TLV，对收到的LSP报文进行认证检查；发送的SNP报文携带认证TLV，但不对收到的SNP报文进行检查&lt;/li&gt;
&lt;li&gt;本地发送的LSP报文携带认证TLV，对收到的LSP报文进行认证检查；发送的SNP报文不携带认证TLV，也不对收到的SNP报文进行认证检查&lt;/li&gt;
&lt;li&gt;本地发送的LSP报文和SNP报文都携带认证TLV，对收到的LSP报文和SNP报文都不进行认证检查&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;报文认证方式&#34;&gt;报文认证方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;明文认证&lt;/li&gt;
&lt;li&gt;MD5认证&lt;/li&gt;
&lt;li&gt;Keychian认证：通过配置随时间变化的密码链表来进一步提升网络的安全性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;认证信息的携带形式&#34;&gt;认证信息的携带形式&lt;/h2&gt;
&lt;p&gt;ISIS通过TLV的形式携带认证信息，&lt;strong&gt;认证TLV的类型为10&lt;/strong&gt;，具体格式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type：ISO定义认证报文的类型值为10，长度为1字节&lt;/li&gt;
&lt;li&gt;Length：指定认证TLV值的长度，长度1字节&lt;/li&gt;
&lt;li&gt;Value：指定认证的具体内容，其中包括了认证的类型和认证的密码，长度为1～254字节，其中认证的类型为1字节，具体定义如下：
&lt;ul&gt;
&lt;li&gt;0：保留的类型&lt;/li&gt;
&lt;li&gt;1：明文认证&lt;/li&gt;
&lt;li&gt;54：MD5认证&lt;/li&gt;
&lt;li&gt;255：路由域私有认证方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;lsp&#34;&gt;LSP&lt;/h1&gt;
&lt;h2 id=&#34;isis的lsdb更新过程&#34;&gt;ISIS的LSDB更新过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;DIS接收到LSP，在数据库中搜索对应的记录，若没有该LSP，则将其加入数据库，并广播新数据库内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列号越大越优&lt;/strong&gt;：若收到的LSP序列号大于本地LSP的序列号，就替换为新报文，并广播新数据库内容；若收到的LSP序列号小本地LSP的序列号，就向入接口发送本地LSP报文&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RemainingLifetime剩余生存时间越小越优&lt;/strong&gt;：若两个序列号相等，则比较RemainingLifetime。若收到的LSP的RemainingLifetime小于本地LSP的Remaining Lifetime，就替换为新报文，并广播新数据库内容；若收到的LSP的Remaining Lifetime大于本地LSP的Remaining Lifetime，就向入端接口发送本地LSP报文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Checksum越大越优&lt;/strong&gt;：若两个序列号和RemainingLifetime都相等，则比较Checksum。若收到的LSP的Checksum大于本地LSP的Checksum，就替换为新报文，并广播新数据库内容；若收到的LSP的Checksum小于本地LSP的Checksum，就向入端接口发送本地LSP报文。&lt;/li&gt;
&lt;li&gt;若两个序列号、Remaining Lifetime和Checksum都相等，则不转发该报文&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;lsp产生的原因&#34;&gt;LSP产生的原因&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;邻居Up或Down&lt;/li&gt;
&lt;li&gt;ISIS相关接口Up或Down&lt;/li&gt;
&lt;li&gt;引入的IP路由发生变化&lt;/li&gt;
&lt;li&gt;区域间的IP路由发生变化&lt;/li&gt;
&lt;li&gt;接口被赋了新的metric值&lt;/li&gt;
&lt;li&gt;周期性更新&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;收到邻居新的lsp的处理过程&#34;&gt;收到邻居新的LSP的处理过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将接收的新的LSP合入到自己的LSDB数据库中，并标记为flooding&lt;/li&gt;
&lt;li&gt;发送新的LSP到除了收到该LSP的接口之外的接口&lt;/li&gt;
&lt;li&gt;邻居再扩散到其他邻居&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;lsp-id&#34;&gt;LSP ID&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612865056558.png&#34; alt=&#34;LSP ID&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;lsp分片&#34;&gt;LSP分片&lt;/h2&gt;
&lt;p&gt;当ISIS要发布的链路状态协议数据报文PDU中的信息量太大时，IS-S路由器将会生成多个LSP分片，用来携带更多的ISIS信息&lt;br&gt;
ISIS LSP分片由LSP ID中的LSP Number字段进行标识，这个字段的长度是&lt;strong&gt;1字节&lt;/strong&gt;。因此，一个IS-IS进程&lt;strong&gt;最多可产生256个LSP分片&lt;/strong&gt;（最多携带路由3万左右），携带的信息量有限。IS-IS可以配置虚拟的SystemID （最多可配置50个，即isis进程最多可生成51*256个LSP分片），并生成虚拟IS-IS的LSP报文来携带路由等信息。&lt;br&gt;
&lt;code&gt;为什么需要分片？因为isis不是通过IP承载的，是通过链路层承载的，链路层本身不具备分片的能力，只能依靠isis自身实现&lt;/code&gt;&lt;br&gt;
&lt;code&gt;如果LSP分片之后，没有收到分片序列号为0的LSP，那么后续的LSP将全部丢弃，因为00分片中包含该LSP的头部信息&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;工作模式&#34;&gt;工作模式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589101539252.png&#34; alt=&#34;LSP分片工作模式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;Mode-1&lt;br&gt;
用于网络中的部分路由器不支持LSP分片扩展特性的情况&lt;br&gt;
RouterB是不支持分片扩展的路由器，RouterA1和RouterA2是RouterA的虚拟系统，RouterB&lt;strong&gt;认为对端有三台独立的路由器&lt;/strong&gt;，并进行正常的路由计算。同时&lt;strong&gt;RouterA到RouterA1和RouterA2的开销都是0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Mode-2&lt;br&gt;
用于网络中所有路由器都支持LSP分片扩展特性的情况&lt;br&gt;
RouterB通过IS Alias ID TLV&lt;sub&gt;24号TLV，用来表示初始系统与虚拟系统的关系&lt;/sub&gt;知道他们的初始系统是RouterA，则把RouterA1，RouterA2所发布的信息都视为RouterA的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;路由算法&#34;&gt;路由算法&lt;/h2&gt;
&lt;p&gt;设备默认接口开销值都是10&lt;/p&gt;
&lt;h2 id=&#34;spf计算过程&#34;&gt;SPF计算过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;单区域LSDB同步完成&lt;/li&gt;
&lt;li&gt;生成全网拓扑结构图&lt;/li&gt;
&lt;li&gt;以本节点为根生成最短路径树&lt;/li&gt;
&lt;li&gt;默认跨越每个节点的开销一样&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;isis的计算特点&#34;&gt;ISIS的计算特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在本区域收到的LSP更新，如果是部分拓扑的变化执行的SSPF内路由器第一次启动的时候执行的是Full-SPF算法&lt;/li&gt;
&lt;li&gt;如果只是路由信息的变法，执行的是PRC算法&lt;/li&gt;
&lt;li&gt;由于采用拓扑与网络分离的算法，路由收敛速度得到了加强&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;路由聚合&#34;&gt;路由聚合&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;summary ip-address mask [ avoid-feedback | generate_null0_route | tag tag-value | [ level-1 | level-2 | level-1-2 ] ]&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;avoid-feedback&lt;br&gt;
避免从另外一个level学到自己发布的聚合路由。&lt;br&gt;
如果另外一个level中有与summary地址相同的学习路由，则认为该路由是其他路由器学到了本地路由器发布的summary路由后，渗透到另外一个level并发布的。此时avoid-feedback产生作用，该路由变为inactive，从RM路由表中删除。&lt;/li&gt;
&lt;li&gt;generate_null0_route&lt;br&gt;
指定生成Null 0路由，以防止路由循环。&lt;/li&gt;
&lt;li&gt;tag&lt;br&gt;
指定发布路由的管理标签号&lt;/li&gt;
&lt;li&gt;level-1、level-2、level-1-2&lt;br&gt;
对指定区域的路由进行聚合。如果配置时没有指定Level，缺省为Level-2&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;isis地址结构&#34;&gt;ISIS地址结构&lt;/h2&gt;
&lt;h3 id=&#34;nsap&#34;&gt;NSAP&lt;/h3&gt;
&lt;p&gt;NSAP是OSI协议中用于定位资源的地址，相当于OSI的网络层协议CLNP的地址（&lt;strong&gt;类似IP地址的概念&lt;/strong&gt;）&lt;br&gt;
由&lt;strong&gt;IDP和DSP&lt;/strong&gt;组成，IDP和DSP的长度都是可变的，NSAP总长度&lt;strong&gt;最多是20字节，最少是8字节&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IDP相当于IP地址中的主网络号，是由ISO规定的，由AFI的IDI两部分组成
&lt;ul&gt;
&lt;li&gt;AFI表示地址分配机构和地址格式(长度固定为1B)&lt;/li&gt;
&lt;li&gt;IDI用来标识域&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DSP相当于IP地址中的子网号和主机地址，由HighOrderDSP、SystemID、SEL三部分
&lt;ul&gt;
&lt;li&gt;HighOrderDSP用来分割区域&lt;/li&gt;
&lt;li&gt;SystemID用来区分区域&lt;/li&gt;
&lt;li&gt;SEL用来指示服务类型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AreaAddress(AreaID)由&lt;strong&gt;IDP和DSP中的HighOrderDSP组成&lt;/strong&gt;，既能够标识路由域，也能够标识路由域中的区域，它们一起被称为&lt;strong&gt;区域地址&lt;/strong&gt;，&lt;strong&gt;类似OSPF中的区域编号AreaID&lt;/strong&gt;，&lt;strong&gt;同一Level1区域内的所有路由器必须具有相同的区域地址，Level2区域内的路由器可以具有不同的区域地址&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SystemID&lt;/strong&gt;用来在区域内唯一标识主机或路由器，在设备的实现中，它的&lt;strong&gt;长度固定为48bit(6字节)&lt;/strong&gt;，一般情况先，使用设备的RouterID转换为SystemID&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEL&lt;/strong&gt;的作用类似于IP中的“协议标识符”，不同的传输协议对应不同的SEL，&lt;strong&gt;在IP上SEL均为00，长度固定为1B(8bit)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;net&#34;&gt;NET&lt;/h3&gt;
&lt;p&gt;NET是&lt;code&gt;一类特殊的NSAP（SEL=00）&lt;/code&gt;，在路由器上配置ISIS时，只需要考虑NET即可&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络实体名称NET指的是设备本身的网络层的意思，可以看做是一类特殊的NSAP（SEL=00）,NET的长度与NSAP相同，最多为20字节，最少为8字节，&lt;strong&gt;在路由器上配置ISIS时，只需要考虑NET即可，NSAP不必去关注&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在配置ISIS过程中，NET最多只能配置3个，在配置多个NET时，必须保证他们的SystemID都相同&lt;br&gt;
&lt;code&gt;没有NET地址ISIS无法运行，该地址包含了区域ID和系统ID，而他本质上是一个ISO地址，最后的SEL等同于TCP的端口号，永远等于00&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;TCP/IP协议栈&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;IP协议&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;IP地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;OSPF&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;AreaID+RouterID&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OSI系统&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CLNP协议&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSAP地址&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ISIS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NET标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588665973437.png&#34; alt=&#34;ISIS地址结构&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;最短长度8B：1B的AFI + 6B的SystemID + 1B的SEL&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588667599284.png&#34; alt=&#34;ISIS地址例子&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;用ISIS做网络设计需要注意：保证L2路由器连续&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;关于systemid&#34;&gt;关于SystemID&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;一个中间系统（路由器）至少有一个NET，&lt;strong&gt;华为设备最多支持3个&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;同一个Area的中间系统必须有相同的AreaID（Level1必须一样，Level2可以不一样）&lt;/li&gt;
&lt;li&gt;每个中间系统在&lt;strong&gt;一个Area中必须有一个唯一的SystemID&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个domain中的两个Level2中间系统不能有相同的SystemID&lt;/li&gt;
&lt;li&gt;NSAP至少为8字节，最多为20个字节&lt;/li&gt;
&lt;li&gt;对于传统IP应用程序而言，1字节定义AFI（标识二进制DSP语法的地址域），最少2字节定义实际区域信息（IDI+HighOrder+DSP），6字节定义系统ID和1字节的NSEL，故NSAP地址最少为10字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isis整体拓扑&#34;&gt;ISIS整体拓扑&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588690827975.png&#34; alt=&#34;ISIS整体拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将&lt;strong&gt;Level-1路由器部署在非骨干区域&lt;/strong&gt;，&lt;strong&gt;Level-2路由器和Level-1-2（类似ABR，ISIS默认设置）路由器部署在骨干区域&lt;/strong&gt;。&lt;strong&gt;每一个非骨干区域都通过Level-1-2路由器与骨干区域相连&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在OSPF中，每个链路只属于一个区域；而在IS-IS中，每个链路可以属于不同的区域&lt;code&gt;OSPF基于接口，即一个设备上的多个接口可以属于不同的Area；ISIS基于设备，即一个设备只能属于一个Level&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在IS-IS中，单个区域没有物理的骨干与非骨干区域的概念；而在OSPF中，Area0被定义为骨干区域&lt;/li&gt;
&lt;li&gt;在IS-IS中，&lt;strong&gt;Level-1和Level-2级别的路由器分别采用SPF算法，分别生成最短路径树SPT&lt;/strong&gt;；在OSPF中，只有在同一个区域内才使用SPF算法，区域之间的路由需要通过骨干区域来转发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isis路由器分类&#34;&gt;ISIS路由器分类&lt;/h2&gt;
&lt;h3 id=&#34;level-1路由器&#34;&gt;Level-1路由器&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Level-1路由器负责区域内的路由，它只与属于&lt;strong&gt;同一区域&lt;/strong&gt;的Level-1和Level-1-2路由器形成邻居关系，属于不同区域的Level-1路由器不能形成邻居关系&lt;/li&gt;
&lt;li&gt;Level-1路由器只负责维护Level-1的LSDB，该LSDB包含本区域的路由信息&lt;/li&gt;
&lt;li&gt;到本区域外的报文转发给最近的Level-1-2路由器&lt;/li&gt;
&lt;li&gt;Level-1路由器必须通过Level-1-2路由器才能连接至其他区域&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Level-1区域&lt;strong&gt;建立的条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要求Area号必须一致&lt;/li&gt;
&lt;li&gt;Level-1路由器可以和Level-1、Level-1-2路由器建立Level-1的邻居&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;level-2路由器&#34;&gt;Level-2路由器&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Level-2路由器负责区域间的路由，可以和&lt;strong&gt;同一或者不同区域&lt;/strong&gt;的Level-2或Level-1-2路由器形成邻居关系&lt;/li&gt;
&lt;li&gt;Level-2路由器维护一个Level-2的LSDB，该LSDB包含ISIS区域内的所有路由信息&lt;/li&gt;
&lt;li&gt;所有Level-2级别（即形成Level-2邻居关系）的路由器组成路由域的骨干网，负责在不同区域间通信，&lt;strong&gt;路由域中Level-2级别的路由器必须是物理连续的，以保证骨干网的连续性&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Level-2区域&lt;strong&gt;建立的条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Area号可以不一致&lt;/li&gt;
&lt;li&gt;Level-2路由器可以和Level-2、Level-1-2路由器建立Level-2的邻居&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;level-1-2路由器默认&#34;&gt;Level-1-2路由器（默认）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;同时属于Level-1和Level-2的路由器&lt;/li&gt;
&lt;li&gt;可以与同一区域的Level-1和Level-1-2路由器形成Level-1邻居关系，也可以和其他区域的Level-2和Level-1-2路由器形成Level-2邻居关系&lt;/li&gt;
&lt;li&gt;Level-1路由器必须通过Level-1-2路由器才能连接至其他区域&lt;/li&gt;
&lt;li&gt;Level-1-2路由器维护两个LSDB，Level-1的LSDB用于区域内路由，Level-2的LSDB用于区域间路由&lt;br&gt;
&lt;code&gt;既有Level-1又有Level-2的情况下，Level-1-2必须和Level-1的AreaID保持一致，否则无法建立邻居，导致无法进行通信&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Level-1-2路由器之间建立什么样的邻居？&lt;br&gt;
&lt;strong&gt;区域号不同&lt;/strong&gt;：一个，Level-2区域&lt;br&gt;
&lt;strong&gt;区域号相同&lt;/strong&gt;：两个，Level-1区域和Level-2区域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;isis术语&#34;&gt;ISIS术语&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588776831130.png&#34; alt=&#34;术语对照表&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;IIH，hello时间10秒，hold时间30秒&lt;/li&gt;
&lt;li&gt;LSP相当于LSU，那么TLV相当于LSA&lt;/li&gt;
&lt;li&gt;ISIS只支持P2P和广播网络，PSNP分为两种报文，一种是请求LSP（类似LSR，可用于p2p和广播），一种是确认LSP（类似LSAck，&lt;strong&gt;只用于p2p&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isis报文类型&#34;&gt;ISIS报文类型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;ISIS的9种报文&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612824742640.png&#34; alt=&#34;ISIS的9种报文&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;其他常见TLV&lt;/strong&gt;：&lt;a href=&#34;https://www.cnblogs.com/cyrusxx/p/12615744.html&#34;&gt;https://www.cnblogs.com/cyrusxx/p/12615744.html&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612824994199.png&#34; alt=&#34;ISIS报文类型-2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-hello-pduiihhello报文&#34;&gt;1. Hello PDU（IIH）（hello报文）&lt;/h3&gt;
&lt;p&gt;用于邻居发现，协商参数并建立邻居关系，后期充当保活报文。ISIS目前只支持&lt;strong&gt;点到点和广播&lt;/strong&gt;两种网络类型。&lt;br&gt;
在广播网络中，ISIS通过MAC地址来标识邻居（OSPF是通过RID来标识的）；在P2P中，是通过系统ID来标识邻居的，通过电路ID来标识自己的哪个接口与对端相连。&lt;br&gt;
广播网中的Level-1 IS-IS使用Level-1 LAN IIH，Level-2 IS-IS使用Level-2 LAN IIH；非广播网络中则使用P2P IIH。&lt;br&gt;
它们的报文格式有所不同。P2P IIH中相对于LAN IIH来说，多了一个表示本地链路ID的&lt;code&gt;Local Circuit ID&lt;/code&gt;字段，缺少了表示广播网中DIS的优先级的&lt;code&gt;Priority&lt;/code&gt;字段以及表示DIS和伪节点System ID的&lt;code&gt;LAN ID&lt;/code&gt;字段。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588779975219.png&#34; alt=&#34;LSDB-DIS&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;level-1-lan-iih&#34;&gt;Level-1 LAN IIH&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;组播MAC&lt;/strong&gt;：&lt;code&gt;01-80-c2-00-00-14&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588780182952.png&#34; alt=&#34;L1和L2的帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;level-2-lan-iih&#34;&gt;Level-2 LAN IIH&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;组播MAC&lt;/strong&gt;：&lt;code&gt;01-80-c2-00-00-15&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;p2p-iih&#34;&gt;P2P IIH&lt;/h4&gt;
&lt;p&gt;简而言之：&lt;code&gt;将多字节的Priority和LAN ID替换成1字节的Local Circuit ID&lt;/code&gt;&lt;br&gt;
非广播网络中则使用P2P IIH，但是其没有表示DIS（虚节点）的相关字段&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588780285711.png&#34; alt=&#34;P2P的帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-lsp-pdu链路状态报文&#34;&gt;2. LSP PDU（链路状态报文）&lt;/h3&gt;
&lt;p&gt;用于交换链路状态信息，相当于OSPF的LSU&lt;br&gt;
Level–1 LSP由Level-1路由器传送，Level–2 LSP由Level-2路由器传送，Level-1-2路由器则可传送以上两种LSP&lt;br&gt;
Level-1 LSP和Level-2 LSP具有相同的报文结构&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612599734899.png&#34; alt=&#34;LSP PDU&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ATT：区域关联位&lt;br&gt;
当L1区域中的路由设备收到Level-1-2路由设备发送的ATT位被置位的L1 LSP后，它将创建一条指向Level-1-2路由设备的缺省路由。&lt;br&gt;
虽然ATT位同时在L1 LSP和L2 LSP中进行了定义，但是它只会在L1 LSP中被置位，并且只有L1/2路由设备会设置这个字段。&lt;/li&gt;
&lt;li&gt;OL：过载标志位&lt;br&gt;
设置了过载标志位的LSP虽然还会在网络中扩散，但是在计算通过过载设备的路由时不会被采用，即对设备设置过载位后，&lt;strong&gt;其它设备在进行SPF计算时不会使用这台设备做转发&lt;/strong&gt;，&lt;strong&gt;只计算该节点上的直连路由&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;IS Type：生成LSP的IS-IS类型&lt;br&gt;
用来指明是Level-1还是Level-2 IS-IS（01表示Level-1，11表示Level-2）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-snp-pdu序列号报文&#34;&gt;3. SNP PDU（序列号报文）&lt;/h3&gt;
&lt;p&gt;用于维护LSDB的完整与同步，且为摘要信息&lt;/p&gt;
&lt;h4 id=&#34;csnp全序列号报文&#34;&gt;CSNP（全序列号报文）&lt;/h4&gt;
&lt;p&gt;类似于OSPF的DBD信息，用来同步LSDB，DIS定期泛洪CSNP(10秒)&lt;br&gt;
分为Level-1 CSNP和Level-2 CSNP&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612599938690.png&#34; alt=&#34;CSNP&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Source ID：发出CSNP报文的设备的System ID&lt;/li&gt;
&lt;li&gt;Start LSP ID：CSNP报文中第一个LSP的ID值&lt;/li&gt;
&lt;li&gt;End LSP ID：CSNP报文中最后一个LSP的ID值&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;psnp部分序列号报文&#34;&gt;PSNP（部分序列号报文）&lt;/h4&gt;
&lt;p&gt;在广播网络中，类似于OSPF的LSR；在P2P网络中，类似于OSPF的LSR和LSAck。非DIS设备向DIS发送PSNP，用于请求非DIS设备上缺少的LSDB中的详细路由信息&lt;br&gt;
分为Level-1 PSNP和Level-2 PSNP&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612600150201.png&#34; alt=&#34;PSNP&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;isis网络类型&#34;&gt;ISIS网络类型&lt;/h2&gt;
&lt;h3 id=&#34;isis支持的网络类型&#34;&gt;ISIS支持的网络类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;P2P，例如PPP和HDLC&lt;code&gt;不选举DIS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;广播
&lt;ul&gt;
&lt;li&gt;DIS：&lt;strong&gt;指定中间系统&lt;/strong&gt;，为了在广播网络中实现&lt;strong&gt;更高效的数据库同步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;伪节点：用来模拟广播网络的一个虚拟节点，并非真实的路由设备，用DIS的System ID和一个字节的Circuit ID（非0值）标识。使用伪节点可以简化网络拓扑，使路由设备产生的LSP长度较小。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612651281734.png&#34; alt=&#34;伪节点&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dis&#34;&gt;DIS&lt;/h4&gt;
&lt;p&gt;在广播网络中，IS-IS需要在所有的路由器中选举一个路由器作为DIS，&lt;strong&gt;Level-1和Level-2的DIS是分别选举的&lt;/strong&gt;&lt;br&gt;
可以为不同级别的DIS选举设置不同的优先级，&lt;strong&gt;优先级为0的路由器也参与DIS的选举，只是具有最小可能成为DIS&lt;/strong&gt;，且DIS选举&lt;strong&gt;支持抢占&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;同一网段上的同一级别的路由器之间都会形成邻接关系&lt;/strong&gt;，包括所有的非DIS路由器之间也会形成邻接关系，&lt;strong&gt;但LSDB的同步仍然依靠DIS来保证&lt;/strong&gt;&lt;br&gt;
DIS用来创建和更新伪节点，并负责生成伪节点的链路状态协议数据单元LSP，用来描述这个网络上有哪些网络设备&lt;br&gt;
IS-IS中DIS发送Hello时间间隔为10/3秒，而其他非DIS路由器发送Hello间隔为10秒，ISIS的LSP的更新时间为900秒，Hold time时间为1200秒，是从大往小减的&lt;br&gt;
&lt;strong&gt;ISIS系统中没有DIS也能完成数据库同步&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么DIS不需要备份的DIS？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;DIS支持抢占&lt;/li&gt;
&lt;li&gt;DIS发送Hello消息的时间为10/3秒，可以让ISIS快速发现DIS失效，重新选举DIS&lt;/li&gt;
&lt;li&gt;ISIS主要用在运营商网络中，而运营商网络一般很少会更换设备，所以影响不大&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么在ISIS中DIS可以被抢占？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在ISIS中所有的设备都可以建立邻接关系&lt;/li&gt;
&lt;li&gt;ISIS主要用在运营商网络中，而运营商网络一般很少会更换设备，所以影响不大&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;dis的选举&#34;&gt;DIS的选举&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;优先级越大越优，默认优先级为64，取值范围（0-127）&lt;/li&gt;
&lt;li&gt;MAC地址越大越优&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;影响isis邻居建立的条件&#34;&gt;影响ISIS邻居建立的条件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;建立邻居关系原则：同一层次(级别)、同一区域（只有L1会做严格检查）、同一网段、同一网络类型&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-运行级别和区域id&#34;&gt;1. 运行级别和区域ID&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;区域ID只影响Level-1邻居的建立，Level-1只能和同一区域的Level-1或Level-1-2建立Level-1级别的邻居&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;level1-level2：无法建立&lt;/li&gt;
&lt;li&gt;level1-level1：level1&lt;/li&gt;
&lt;li&gt;level1-level1/2：level1&lt;/li&gt;
&lt;li&gt;level2-level1/2：level2&lt;/li&gt;
&lt;li&gt;levle2-level/2：level2&lt;/li&gt;
&lt;li&gt;level1/2- level1/2：
&lt;ol&gt;
&lt;li&gt;区域号相同level1和level2&lt;/li&gt;
&lt;li&gt;区域号不同则只有Level2关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-system-id&#34;&gt;2. System-ID&lt;/h3&gt;
&lt;p&gt;system-id标识一台路由器，具有唯一性，默认是6个字节，如果system-id长度不一致或者直连设备的system-id冲突则无法建立邻居&lt;/p&gt;
&lt;h3 id=&#34;3-认证&#34;&gt;3. 认证&lt;/h3&gt;
&lt;p&gt;接口认证是对Level-1和Level-2的Hello报文的认证，区域认证是对Level-1的SNP和LSP的认证，路由域认证是对Level-2的SNP和LSP的认证，对于区域和路由域的认证可以设置为SNP和LSP分别认证。认证方式分为明文认证、MD5认证和keychian认证。&lt;br&gt;
接口认证不一致影响邻居的建立，区域认证和路由域认证不一致可以正常建立邻居，但是无法正常同步LSDB&lt;/p&gt;
&lt;h3 id=&#34;4-mtu&#34;&gt;4. MTU&lt;/h3&gt;
&lt;p&gt;ISIS中存在隐式的MTU检测机制，通过IIH报文，P2P为1500，广播网为1497，少的那3字节的原因如下：&lt;br&gt;
ISIS通过802.3承载，3字节用于802.2头部（即LLC，包含DSAP、SSAP和Control三部分），标识上层协议。&lt;br&gt;
广播网络中所有的Hello报文都会使用Padding填充，但是P2P只有在建立邻居时的Hello报文才会被填充，其他的Hello报文不会被填充。&lt;/p&gt;
&lt;h3 id=&#34;5-接口的网络类型&#34;&gt;5. 接口的网络类型&lt;/h3&gt;
&lt;p&gt;P2P和广播网络无法建立邻居，因为这两种网络类型建立邻居所需的TLV不同，P2P的3次握手模式使用240号TLV，而广播网络使用6号TLV。但是可以通过将以太网接口模拟成P2P接口，建立P2P链路邻居关系。&lt;/p&gt;
&lt;h3 id=&#34;6-ip地址不在同一个网段&#34;&gt;6. IP地址不在同一个网段&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;默认开启源检查，只影响广播网&lt;/code&gt;&lt;br&gt;
ISIS邻居关系的形成与IP地址无关，但在IP网络上运行ISIS协议，要检查设备两端的IP地址。如果设备接口配置了辅用IP地址，那么只要双方有某个IP地址（主用IP地址或者辅用IP地址）在同一网段，就能建立邻居，不要求设备两端的主用IP地址相同。&lt;br&gt;
Hello报文不携带掩码，只携带IP，路由器用收到的IP与本地接口的掩码进行与运算，必须处于同一个网段，如192.168.1.1/24和192.168.1.200/25之间建立邻居，结果.1侧显示对端为init状态，.200侧显示无邻居。&lt;br&gt;
当链路两端ISIS接口的地址不在同一网段时，如果配置接口对接收的Hello报文不作IP地址检查，也可以建立邻居关系。对于P2P接口，可以配置接口忽略IP地址检查；对于以太网接口，需要将以太网接口模拟成P2P接口，才可以配置接口忽略IP地址检查。&lt;/p&gt;
&lt;h3 id=&#34;7-cost-style&#34;&gt;7. cost-style&lt;/h3&gt;
&lt;p&gt;度量值类型不同不影响邻居的建立，但是影响路由的计算。&lt;br&gt;
窄度量和宽度量主要有以下3点区别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;窄度量值最大为63，宽度量值最大为2的24次方&lt;/li&gt;
&lt;li&gt;窄度量不支持TLV的分片，但是宽度量支持&lt;/li&gt;
&lt;li&gt;用来通告路由信息的TLV类型不同，窄度量的TLV为2号、128号和130号，而宽度量为22号和135号&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8-其他&#34;&gt;8. 其他&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;max area数量不一致 （默认是3个）&lt;/li&gt;
&lt;li&gt;多拓扑，即一边只有IPv4，另外一边有IPv4和IPv6&lt;/li&gt;
&lt;li&gt;p2p中3次握手和2次握手无法建立邻居，因为所使用的TLV不同，2次握手使用17号TLV，3次握手使用240号TLV&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dr和dis的区别&#34;&gt;DR和DIS的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;选举时机的比较。DR是在建立邻居关系之后选举，而DIS是在邻接关系建立后，需要再等待两个Hello报文间隔&lt;/li&gt;
&lt;li&gt;选举时优选级的比较。DIS的优先级为0也可以参与选举，但DR优先级为0不参与选举；DR先比优先级再比RouteID，而DIS先比优先级再比MAC地址&lt;/li&gt;
&lt;li&gt;选举的过程需要一定的时间。OSPF选举DR/BDR需要waiting time达40秒，过程也较为复杂，而ISIS选举DIS等待两个Hello报文间隔就可以，简单快捷&lt;/li&gt;
&lt;li&gt;选举结果。ISIS只有一个DIS，但是OSPF除了有DR，还有一个BDR用做备份&lt;/li&gt;
&lt;li&gt;选举结束后。后期有新的Router加入到链路进来，如果优先级比DIS高是可抢占的，但是DR是不可抢占的&lt;/li&gt;
&lt;li&gt;选举完成后。DIS的发送Hello报文时间是3秒，DR是10秒或者30秒。ISIS网络链路内所有的路由器之间都建立的是邻接关系。OSPF中DRothers只与DR/BDR形成邻接关系， DRothers之间只有2-way的关系&lt;/li&gt;
&lt;li&gt;作用不同。DIS周期性发送CSNP，保证网络中的LSDB同步，而DR的存在主要是为了减少泛洪&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612652351825.png&#34; alt=&#34;ISIS的DIS与OSPF的DR区别&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;isis和ospf的区域的区别&#34;&gt;ISIS和OSPF的区域的区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ISIS中Level-2可以学习到Level-1中的路由，但是Level-1无法学习到Level-2的路由。Level-1类似ospf的nssa区域，而Level-2类似ospf的骨干区域，即isis的骨干区域是由连续的level-2的路由器组成的&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ospf区域类型一致才能建立邻居，isis只有在level-1时才要求一致&lt;/li&gt;
&lt;li&gt;ospf区域类型更加丰富，isis只有2种&lt;/li&gt;
&lt;li&gt;表示形式不一样，ospf使用点分十进制，isis表示方法比较复杂&lt;/li&gt;
&lt;li&gt;在ospf中，一条链路只能属于一个区域，而在isis中，一条链路可以属于不同的区域&lt;code&gt;ospf是基于接口的，isis是基于设备的&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf和isis的异同&#34;&gt;OSPF和ISIS的异同&lt;/h2&gt;
&lt;h3 id=&#34;相同点&#34;&gt;相同点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;维护一个链路状态数据库&lt;/li&gt;
&lt;li&gt;都利用Hello包形成和维护邻居&lt;/li&gt;
&lt;li&gt;使用区域概念来构成层次化的拓扑接口&lt;/li&gt;
&lt;li&gt;都提供在区域之间进行地址汇总的能力&lt;/li&gt;
&lt;li&gt;无类路由协议&lt;/li&gt;
&lt;li&gt;都选举一个指定路由器来描述广播性网络&lt;/li&gt;
&lt;li&gt;认证能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;不同点&#34;&gt;不同点&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;差异性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;ISIS&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;OSPF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络方式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;少，2种&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多，5种&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开销方式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;复杂&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;简便，参考带宽100M&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;少，2种&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由报文类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;简单&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多样&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由收敛速度&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;很快&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;扩展性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由负载能力&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;超强&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;1-基本点比较&#34;&gt;1. 基本点比较&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;ospf只支持IP，而isis支持IP和CLNP环境&lt;/li&gt;
&lt;li&gt;ospf通过IP承载，协议号89；isis通过链路层承载，安全性相对高些&lt;/li&gt;
&lt;li&gt;ospf基于接口划分区域，区域类型多，区域0为骨干区域；而isis基于设备划分区域&lt;/li&gt;
&lt;li&gt;ospf支持的网络类型有P2P、P2MP、NBMA、广播、虚链路，而isis仅支持广播和P2P&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-邻接关系比较&#34;&gt;2. 邻接关系比较&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ospf邻接关系只有一种，但是isis邻接关系分level-1和level-2邻接关系&lt;/li&gt;
&lt;li&gt;ospf的DR优先级为0则不参与选举、不支持抢占、有BDR，而isis的DIS优先级为0参与选举DIS、支持抢占、没有备份DIS&lt;/li&gt;
&lt;li&gt;ospf中只有DR other之间是邻居关系，其余均是邻接关系，但是isis网络中所有设备均是邻接关系&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-链路状态数据库同步过程比较&#34;&gt;3. 链路状态数据库同步过程比较&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ospf的LSA种类多，数据库结构复杂，因此定位故障困难；而isis的LSP只有路由器LSP和伪节点LSP，数据库结构简单，定位故障容易&lt;/li&gt;
&lt;li&gt;ospf的LSA的生存周期从0递增（maxage=3600，refresh周期为1800，不可调），而isis是从最大值递减（maxage=1200，refreshment 周期为900，可调）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-路由计算过程比较&#34;&gt;4. 路由计算过程比较&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ospf将前缀作为SPF的节点，而isis将前缀作为叶子，叶子发生变化时可以用PRC来更新叶子而不需要进行SPF计算&lt;/li&gt;
&lt;li&gt;ospf的接口开销根据接口带宽变化，而isis的接口开销值在缺省时相同，所有接口默认为10&lt;/li&gt;
&lt;li&gt;ospf在区域内任何路由变化（LSA1/2中路由条目）均会触发iSPF计算，仅3类、5类、7类LSA的变化才使用PRC，而isis任何路由变化都是PRC&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-性能及扩展能力比较&#34;&gt;5. 性能及扩展能力比较&lt;/h3&gt;
&lt;p&gt;ospf支持按需链路而isis不支持，但是isis采用TLV结构，扩展性更好&lt;/p&gt;
&lt;h2 id=&#34;isis-ipv6&#34;&gt;ISIS IPv6&lt;/h2&gt;
&lt;h3 id=&#34;1-ipv6增加了哪两个tlv&#34;&gt;1. IPv6增加了哪两个TLV&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;232号TLV（IPv6 Interface Address）：它相当于IPv4中的132号TLV（IP Interface Address），只不过把原来的32比特的IPv4地址改为128比特的IPv6地址&lt;/li&gt;
&lt;li&gt;236号TLV（IPv6 Reachability）：通过定义路由信息前缀、度量值等信息来说明网络的可达性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;NLPID是标识网络层协议报文的一个1字节字段，IPv6的NLPID值为0x8E（ipv4是0xCC）。如果isis支持IPv6，那么向外发布IPv6路由时必须携带NLPID值&lt;/p&gt;
&lt;h3 id=&#34;2-isis多拓扑指是什么&#34;&gt;2. isis多拓扑指是什么&lt;/h3&gt;
&lt;p&gt;isis多拓扑是指在一个isis自治域内运行多个独立的IP拓扑。例如IPv4拓扑和IPv6拓扑，而不是将它们视为一个集成的单一拓扑。这有利于isis在路由计算中根据实际组网情况来单独考虑IPv4和IPv6网络。根据链路所支持的IP协议类型，不同拓扑运行各自的SPF计算，实现网络的相互屏蔽。&lt;/p&gt;
&lt;h2 id=&#34;isis在帧中继环境下使用什么网络类型&#34;&gt;ISIS在帧中继环境下使用什么网络类型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612867070344.png&#34; alt=&#34;帧中继环境&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
网络类型为P2P，且只能采用2次握手的方式建立邻居，接收LSP，但是并不计算路由（即没有路由条目），可以在HUB上采用子接口的方式解决。&lt;br&gt;
如果采用3次握手，假设R1和R2先建立邻居（有路由条目），那么R3无法与R1建立邻居，因为R1给R3发送的IIH中的SystemID和电路ID并不是R3的，而是R2的。&lt;/p&gt;
">IGP协议-ISIS</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/igp-xie-yi-ospf/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B&#34;&gt;OSPF邻接关系建立&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8A%B6%E6%80%81%E6%9C%BA&#34;&gt;状态机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%82%BB%E6%8E%A5%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B&#34;&gt;邻接建立过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E6%8A%A5%E6%96%87&#34;&gt;OSPF报文&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E8%AE%A4%E8%AF%81&#34;&gt;OSPF认证&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F&#34;&gt;认证配置方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB&#34;&gt;分类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B&#34;&gt;报文类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-hello&#34;&gt;1. Hello&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-dbd&#34;&gt;2. DBD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-lsr&#34;&gt;3. LSR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-lsu&#34;&gt;4. LSU&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lsa%E6%8A%A5%E6%96%87&#34;&gt;LSA报文&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lsa%E5%A4%B4%E9%83%A820%E5%AD%97%E8%8A%82&#34;&gt;LSA头部（20字节）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#router-lsatype1&#34;&gt;Router-LSA（Type1）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-lsatype2&#34;&gt;Network-LSA（Type2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#network-summary-lsatype3&#34;&gt;Network-summary-LSA（Type3）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#asbr-summary-lsatype4&#34;&gt;ASBR-summary-LSA（Type4）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#as-external-lsatype5&#34;&gt;AS-External-LSA（Type5）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B3%E4%BA%8Efa%E5%9C%B0%E5%9D%80%E7%9A%844%E9%97%AE&#34;&gt;关于FA地址的4问：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nssatype7&#34;&gt;NSSA（Type7）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-lsack&#34;&gt;5. LSAck&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E6%94%AF%E6%8C%81%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B&#34;&gt;OSPF支持的网络类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%BB%BA%E7%AB%8B%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E6%98%AF%E5%90%A6%E6%9C%89%E8%B7%AF%E7%94%B1&#34;&gt;不同的网络类型之间是否可以建立邻接关系？是否有路由？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3%E6%89%80%E5%B1%9E%E7%9A%84%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B&#34;&gt;判断一个接口所属的网络类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84%E5%8C%BA%E5%9F%9F%E7%B1%BB%E5%9E%8B&#34;&gt;OSPF的区域类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#option%E9%80%89%E9%A1%B9%E4%B8%8E%E5%8C%BA%E5%9F%9F%E7%B1%BB%E5%9E%8B&#34;&gt;Option选项与区域类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BD%B1%E5%93%8Dospf%E9%82%BB%E6%8E%A5%E5%85%B3%E7%B3%BB%E5%BB%BA%E7%AB%8B%E7%9A%84%E5%9B%A0%E7%B4%A0&#34;&gt;影响OSPF邻接关系建立的因素&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-route-id&#34;&gt;1. Route ID&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%90%8C%E4%B8%80%E5%8C%BA%E5%9F%9F%E5%86%85&#34;&gt;1. 同一区域内&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%9B%B4%E8%BF%9E%E8%AE%BE%E5%A4%87routerid%E5%86%B2%E7%AA%81&#34;&gt;1. 直连设备RouterID冲突&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E9%9D%9E%E7%9B%B4%E8%BF%9E%E8%AE%BE%E5%A4%87routerid%E5%86%B2%E7%AA%81&#34;&gt;2. 非直连设备RouterID冲突&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E9%9D%9E%E7%9B%B4%E8%BF%9E%E8%AE%BE%E5%A4%87%E5%92%8Cabr%E7%9A%84routerid%E5%86%B2%E7%AA%81&#34;&gt;3. 非直连设备和ABR的RouterID冲突&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%B8%8D%E5%90%8C%E5%8C%BA%E5%9F%9F%E5%86%85&#34;&gt;2. 不同区域内&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E9%9D%9E%E7%9B%B4%E8%BF%9E%E8%AE%BE%E5%A4%87routerid%E5%86%B2%E7%AA%81&#34;&gt;1. 非直连设备RouterID冲突&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E9%9D%9E%E7%9B%B4%E8%BF%9E%E8%AE%BE%E5%A4%87%E5%92%8Casbr%E7%9A%84routerid%E5%86%B2%E7%AA%81&#34;&gt;2. 非直连设备和ASBR的RouterID冲突&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%8C%BA%E5%9F%9Fid&#34;&gt;2. 区域ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-flag%E4%BD%8D%E5%8C%BA%E5%9F%9F%E7%B1%BB%E5%9E%8B&#34;&gt;3. flag位（区域类型）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-hello%E5%92%8Cdead%E6%97%B6%E9%97%B4&#34;&gt;4. hello和dead时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E8%AE%A4%E8%AF%81&#34;&gt;5. 认证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#6-%E6%8E%A9%E7%A0%81%E9%95%BF%E5%BA%A6&#34;&gt;6. 掩码长度&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#7-%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B&#34;&gt;7. 网络类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8-%E5%85%B6%E4%BB%96&#34;&gt;8. 其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84%E7%8E%AF%E8%B7%AF%E5%9C%BA%E6%99%AF&#34;&gt;OSPF的环路场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84%E9%98%B2%E7%8E%AF%E6%9C%BA%E5%88%B6&#34;&gt;OSPF的防环机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dn%E6%AF%94%E7%89%B9%E4%BD%8D%E9%98%B2%E7%8E%AF%E9%97%AE%E9%A2%98&#34;&gt;DN比特位防环问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E6%97%A0%E6%95%88%E8%B7%AF%E7%94%B1%E5%9C%BA%E6%99%AF&#34;&gt;OSPF无效路由场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E5%BF%AB%E9%80%9F%E6%94%B6%E6%95%9B%E6%9C%BA%E5%88%B6&#34;&gt;OSPF快速收敛机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85&#34;&gt;补充&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dr%E5%92%8Cbdr%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;DR和BDR的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dr%E5%92%8Cbdr%E7%9A%84%E9%80%89%E4%B8%BE&#34;&gt;DR和BDR的选举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%89%B9%E7%82%B9&#34;&gt;OSPF特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B&#34;&gt;路由计算过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E8%AE%BE%E5%A4%87%E8%A7%92%E8%89%B2%E5%92%8C%E5%AE%A3%E5%91%8A&#34;&gt;OSPF设备角色和宣告&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%99%A8%E5%88%86%E7%B1%BB&#34;&gt;路由器分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%8F%A3%E5%AE%A3%E5%91%8A%E6%96%B9%E5%BC%8F&#34;&gt;接口宣告方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#router-id%E5%A6%82%E4%BD%95%E4%BA%A7%E7%94%9F&#34;&gt;Router ID如何产生？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%8F%A3%E7%8A%B6%E6%80%81%E6%9C%BA&#34;&gt;接口状态机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%99%9A%E8%BF%9E%E6%8E%A5%E8%99%9A%E9%93%BE%E8%B7%AF&#34;&gt;虚连接（虚链路）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E7%82%B9&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A5%BD%E5%A4%84&#34;&gt;好处&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%BA%E7%82%B9&#34;&gt;缺点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%99%9A%E8%BF%9E%E6%8E%A5%E9%98%B2%E7%8E%AF&#34;&gt;虚连接防环&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF&#34;&gt;应用场景&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#spf%E8%AE%A1%E7%AE%97%E8%BF%87%E7%A8%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5&#34;&gt;SPF计算过程的两个阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E6%AE%8A%E5%8C%BA%E5%9F%9F&#34;&gt;特殊区域&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-stub&#34;&gt;1. Stub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-totally-stub&#34;&gt;2. Totally Stub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-nssa&#34;&gt;3. NSSA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-totally-nssa&#34;&gt;4. Totally NSSA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lsa%E5%9C%A8%E5%90%84%E5%8C%BA%E5%9F%9F%E4%B8%AD%E4%BC%A0%E6%92%AD%E7%9A%84%E6%94%AF%E6%8C%81%E6%83%85%E5%86%B5&#34;&gt;LSA在各区域中传播的支持情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E9%80%9A%E5%91%8A%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E5%BC%8F&#34;&gt;OSPF通告默认路由的方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84%E8%81%9A%E5%90%88%E6%B1%87%E6%80%BB%E5%92%8C%E8%BF%87%E6%BB%A4&#34;&gt;OSPF的聚合(汇总)和过滤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84%E6%97%B6%E9%97%B4&#34;&gt;OSPF的时间&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-lsrefreshtimelsa%E5%AE%9A%E6%97%B6%E5%88%B7%E6%96%B0%E6%97%B6%E9%97%B4&#34;&gt;1. LSRefreshTime（LSA定时刷新时间）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-maxagelsa%E8%80%81%E5%8C%96%E6%97%B6%E9%97%B4&#34;&gt;2. MaxAge（LSA老化时间）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-rxmtinterval%E9%82%BB%E6%8E%A5%E9%87%8D%E4%BC%A0lsa%E7%9A%84%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4&#34;&gt;3. RxmtInterval（邻接重传LSA的间隔时间）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-hello%E7%9B%B8%E5%85%B3%E7%9A%84%E6%97%B6%E9%97%B4&#34;&gt;4. Hello相关的时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-waittimerdr%E7%9A%84%E9%80%89%E4%B8%BE%E7%AD%89%E5%BE%85%E6%97%B6%E9%97%B4&#34;&gt;5. WaitTimer（DR的选举等待时间）：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#one-way-%E6%98%AF%E4%BB%80%E4%B9%88%E7%8A%B6%E6%80%81%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5-two-way&#34;&gt;one-way 是什么状态，如何进入 two-way&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dr%E7%9A%84%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B%E5%8F%8A%E6%97%B6%E9%97%B4&#34;&gt;DR的选举过程及时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#first-dbd%E4%B8%8Edbd%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;first DBD与DBD的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E9%80%89%E4%B8%BE%E4%B8%BB%E4%BB%8E%E9%80%89%E4%B8%BE%E4%B8%BB%E4%BB%8E%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;如何选举主从，选举主从的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81&#34;&gt;OSPF协议的可靠性如何保证？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%99%A4%E4%BA%86lsa%E7%9A%84%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6%E5%A4%96%E9%92%88%E5%AF%B9%E5%8F%91%E9%80%81%E7%9A%84lsu%E8%BF%98%E6%9C%89%E6%B2%A1%E6%9C%89%E5%85%B6%E5%AE%83%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6&#34;&gt;除了LSA的确认机制外，针对发送的LSU还有没有其它确认机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E5%8D%8F%E8%AE%AE%E4%B8%BA%E4%BB%80%E4%B9%88%E5%85%88%E8%BF%9B%E8%A1%8Cbdr%E9%80%89%E4%B8%BE%E7%84%B6%E5%90%8E%E6%89%8D%E6%98%AFdr&#34;&gt;ospf协议为什么先进行BDR选举，然后才是DR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#hello%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84dr%E5%92%8Cbdr%E5%AD%97%E6%AE%B5%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80%E8%80%8C%E4%B8%8D%E6%98%AFrouterid&#34;&gt;Hello报文中的DR和BDR字段为什么是接口地址而不是RouterID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%94%B6%E5%88%B0lsa%E4%B9%8B%E5%90%8E%E7%9A%84%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B&#34;&gt;收到LSA之后的处理流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;OSPF路由的优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5%E7%B1%BBlsa%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81fa%E5%9C%B0%E5%9D%80&#34;&gt;5类LSA为什么需要FA地址？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%AC%A1%E4%BC%98%E8%B7%AF%E5%BE%84&#34;&gt;1. 次优路径&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%8E%AF%E8%B7%AF&#34;&gt;2. 环路&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E9%80%89%E8%B7%AF%E9%97%AE%E9%A2%98&#34;&gt;外部路由选路问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%95%E5%85%A51211024%E5%92%8C1211030%E4%B8%A4%E6%9D%A1%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E4%BC%9A%E9%80%9A%E5%91%8A%E5%87%A0%E6%9D%A15%E7%B1%BBlsa&#34;&gt;引入12.1.1.0/24和12.1.1.0/30两条外部路由，会通告几条5类LSA?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E4%B8%8B%E5%AD%A6%E5%88%B0%E5%90%8C%E4%B8%80%E6%9D%A1%E8%B7%AF%E7%94%B1%E7%B1%BB%E5%88%AB%E5%92%8C%E5%BC%80%E9%94%80%E9%83%BD%E7%9B%B8%E5%90%8C&#34;&gt;不同进程下学到同一条路由(类别和开销都相同)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%8Fospf%E7%9A%84lsdb%E7%9A%84%E5%A4%A7%E5%B0%8F&#34;&gt;如何减小ospf的lsdb的大小&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%E4%BB%A5%E5%8F%8A%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%9C%BA%E6%99%AF&#34;&gt;OSPF的路由选路原则以及负载的场景&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99%E8%AF%A6%E8%A7%A3&#34;&gt;外部路由选路原则详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%AD%A3%E5%B8%B8%E5%9C%BA%E6%99%AF%E9%BB%98%E8%AE%A4oe2&#34;&gt;正常场景（默认OE2）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%9E%E6%AD%A3%E5%B8%B8%E5%9C%BA%E6%99%AF%E9%9C%80%E8%A6%81%E9%AA%8C%E8%AF%81%E9%BB%98%E8%AE%A4oe2&#34;&gt;非正常场景，需要验证（默认OE2）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospfv2%E5%92%8Cv3%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9&#34;&gt;OSPFv2和v3的异同点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B8%E5%90%8C%E7%82%B9&#34;&gt;相同点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E5%90%8C%E7%82%B9&#34;&gt;不同点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;ospf邻接关系建立&#34;&gt;OSPF邻接关系建立&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt;：每两台设备之间都会建立邻居关系，DR others会和DR与BDR之间、以及DR和BDR之间建立邻接关系&lt;code&gt;即只有DR Others之间才会建立邻居关系，其他的都是邻接关系&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;状态机&#34;&gt;状态机&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587217625536.png&#34; alt=&#34;ospf-邻居状态机&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
OSPF 共有 8 种状态机：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Down：邻居的初始状态，表示&lt;strong&gt;没有从邻居收到任何信息(包括hello报文检测不通过)或者邻居失效后&lt;/strong&gt;变为该状态。在NBMA网络上，此状态下仍然可以向静态配置的邻居发送Hello报文，发送间隔为PollInterval，通常和RouterDeadInterval间隔相同。&lt;/li&gt;
&lt;li&gt;Attempt：此状态&lt;strong&gt;只在NBMA&lt;/strong&gt;网络上存在【&lt;strong&gt;配置完peer就从Down变为Attempt&lt;/strong&gt;】，表示没有收到邻居的任何信息，但是已经周期性的向邻居发送报文，发送间隔为Hello时间(30秒)。如果Dead时间(120秒)内间隔内未收到邻居的Hello报文，则转为Down状态，然后启动定时器Poll Interval（默认等于Dead时间，120秒），定时器到期前不再发送hello报文，定时器到期后重新发送hello报文&lt;/li&gt;
&lt;li&gt;Init：从邻居&lt;strong&gt;收到了Hello报文并且检测通过&lt;/strong&gt;变为此状态，但是自己不在所收到的Hello报文的邻居列表中，表示尚未与邻居建立双向通信关系。在此状态下的邻居要被包含在自己所发送的Hello报文的邻居列表中。
&lt;ul&gt;
&lt;li&gt;1-Way：表示路由器发现自己没有在邻居发送Hello报文的邻居列表中，通常是由于对端邻居重启造成的&lt;/li&gt;
&lt;li&gt;2-Way：表示路由器发现与邻居的双向通信已经开始（&lt;strong&gt;发现自己RID在邻居发送的Hello报文的邻居列表&lt;/strong&gt;中）。Init状态下产生此事件之后，如果需要和邻居建立邻接关系则&lt;strong&gt;进入ExStart状态&lt;/strong&gt;，开始&lt;strong&gt;数据库同步&lt;/strong&gt;过程；如果不能与邻居建立邻接关系则进入&lt;strong&gt;2-Way&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;成为邻居的7个条件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;RouterID不冲突&lt;/li&gt;
&lt;li&gt;区域ID相同&lt;/li&gt;
&lt;li&gt;特殊区域的flag字段相同，flag位主要体现的是区域类型，即区域类型相同&lt;/li&gt;
&lt;li&gt;hello/dead相同&lt;/li&gt;
&lt;li&gt;认证相同&lt;/li&gt;
&lt;li&gt;子网掩码相同，即在同一网段，只影响广播和NBMA网络&lt;/li&gt;
&lt;li&gt;网络类型&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;2-way：在此状态下，双向通信已经建立，但是没有与邻居建立邻接关系。&lt;strong&gt;这是建立邻接关系以前的最高级状态。DR和BDR是从达到2-way或者更高状态的邻居中选举出来的，即此状态是选举DR和BDR的开始（选举周期为40秒，选举期之后没有抢占性）&lt;/strong&gt;【40秒为WaitingTimer，不可修改，详情参考接口状态机】&lt;code&gt;如果此阶段发现接收到的hello报文的邻居列表里没有自己的RouterID，则变回Init状态&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;两端同时进入2-way标志着邻居关系的建立，进入2-way后，要建立邻接关系（Full）的情况如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;接口类型为p2p（点到点），p2MP（点到多）&lt;/li&gt;
&lt;li&gt;自己为DR，或者为BDR&lt;/li&gt;
&lt;li&gt;邻居为DR，或BDR&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Exstart：交换信息的初始化状态。发送DBD（包含本地的LSA的摘要信息）报文，选举主从路由器，并确定初始的DBD序号，达到此状态或者更高状态的邻居才能称为邻接&lt;code&gt;发送第一个DBD报文，由2-way转成Exstart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Exchange：交换信息的状态。该状态下，相互间发送DBD，告知对端本地所有的LSA的目录；同时，可以发送LSR、LSU、LSACK来学习对端的LSA&lt;code&gt;主从选举完毕之后，由Exstart转换成Exchange&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Loading：加载状态（没有学习完的状态）。发送LSR、LSU、LSACK，专门学习对端的LSA的详细信息&lt;code&gt;当DBD报文中的M=0时，由Exchange转成Loading&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Full：邻接状态（学习完的状态）。彼此的LSDB同步，即所有的LSA相同&lt;code&gt;重传列表为空，由Loading转成Full&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;停留在2-way状态：广播网或者NBMA网络中，DR优先级为0（无法选举DR）&lt;/li&gt;
&lt;li&gt;停留在ExStart状态：MTU不一致时，主&amp;gt;从时双方都是；从&amp;gt;主时的主，从进入ExChange（开启MTU检查时）&lt;/li&gt;
&lt;li&gt;停留在Loading状态：如果忽略MTU检测且MTU不一致，路由条目多的情况下，报文长度超过MTU，有可能会卡在Loading状态；如果路由条目比较少，报文长度没有超过MTU，则可以达到full状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;ospf的MTU在哪里比较，如果不通过时什么状态？&lt;br&gt;
MTU在ExStart状态的时候进行比较，MTU在DBD报文里面，华为默认忽略MTU检查，即DBD报文中MTU字段为0。开启MTU检查情况下，在收到报文的MTU大于本端MTU时会丢弃，否则接收。&lt;br&gt;
情况1：2端都忽略MTU检查。路由条目多的情况下，LSU报文长度超过MTU，需要同步数据库的一端停留在在Loading状态，因为收不到LSU；如果路由条目比较少，报文长度没有超过MTU，则可以达到full状态&lt;br&gt;
情况2：2端同时开启MTU检查。MTU不一致时，主&amp;gt;从时，因为双方都认为自己是主，所以双方都是ExStart；从&amp;gt;主时的主，从知道主的存在，所以从进入ExChange，但是主不知道从，所以停留在ExStart&lt;br&gt;
情况3：1端开启1端忽略。不开启的一端发送的MTU值为0，开启的一端收到之后直接检查通过，不开启的一端发送的MTU值不为0，但是对方忽略检查。所以和两端都忽略检查的本质相同，即如果LSU过大，会卡在loading状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;邻接建立过程&#34;&gt;邻接建立过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611546198144.jpg&#34; alt=&#34;邻接建立过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
邻接关系建立分3步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邻居关系的建立：&lt;code&gt;R1和R2的Router ID分别为1.1.1.1和2.2.2.2&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;【R1-&amp;gt;R2】：R1发送第一个Hello报文（以组播的方式发送，目的地址为224.0.0.5），此时状态为Down，R2收到R1的Hello报文后，状态置为init&lt;code&gt;需要注意的是，首次发送hello报文的时候不包含邻居字段，报文长度为44&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;【R2-&amp;gt;R1】：R2向R1组播发送&lt;strong&gt;邻居列表为1.1.1.1&lt;/strong&gt;的hello报文，发送3个周期（也有超过3个周期），R1在收到R2发来的报文邻居列表中发现自己的Router ID，而且满足ospf邻居的7个条件，状态变为2-way&lt;/li&gt;
&lt;li&gt;【R1-&amp;gt;R2】：R1向R2组播发送&lt;strong&gt;邻居列表为2.2.2.2&lt;/strong&gt;的hello报文，发送3个周期，R2在收到hello报文邻居列表中发现自己的Router ID，而且满足ospf邻居的7个条件，状态变为2-way，至此R1和R2之间建立了邻居关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;DR和BDR的选举：&lt;code&gt;DR无法选举则停留在2-way&lt;/code&gt;&lt;br&gt;
&lt;code&gt;广播40秒，NBMA120秒&lt;/code&gt;&lt;br&gt;
&lt;code&gt;为什么要选举DR？ 一个既不是DR也不是BDR的路由器只与DR和BDR形成邻接关系并交换链路状态信息以及路由信息，大大减少了邻接关系数量，减少链路状态信息以及路由信息的交换次数，这样可以节省带宽，减少路由器硬件的负担&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;R1和R2都会成为DR others，发现Hello报文中没有DR和BDR&lt;/li&gt;
&lt;li&gt;先选举BDR，先比较优先级，再比较Router ID，&lt;code&gt;假设优先级相等，R2的Router ID大&lt;/code&gt;，R2成为BDR，R2发现没有DR，自动成为DR&lt;/li&gt;
&lt;li&gt;DR others发现又没有了BDR，再选举出来一个BDR，R1成为BDR&lt;br&gt;
&lt;code&gt;DR的选举时间等于Dead time(40秒)，只有在广播网络中才会选举DR&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ospf协议为什么先进行BDR选举？因为DR和BDR的切换状态机是：当DR失效时，BDR成为DR。如果先选举DR，再选举BDR，那么当选举BDR的过程中DR失效，那么此时网络中既没有DR也没有BDR，切换将无法进行，状态机也就没办法做了。所以，先有BDR，后有DR是为了保证状态机能工作。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;邻接关系的建立
&lt;ol&gt;
&lt;li&gt;主从选举&lt;code&gt;检查MTU，分情况讨论MTU不一致的情况&lt;/code&gt;&lt;br&gt;
&lt;code&gt;为什么进行主从选举？刚才已经选举出DR和BDR，为了保证其他设备与DR同步数据的时候不出现问题，需要统一1个序列号，同时进行MTU的协商&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;【R1-&amp;gt;R2】：状态变为ExStart，R1向R2发送第一个DD报文，在这个报文中，seq(DD序列号)被设置为x，I(Initial)=1表示这是第一个DD报文，M(More)=1表示后续还有DD报文要发送，Ms(Master)=1表示R1宣告自己为主路由器&lt;code&gt;seq=x,I=1,M=1,Ms=1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;【R2-&amp;gt;R1】：R2向R1发送第一个DD报文，状态变为ExStart，&lt;code&gt;seq=y,I=1,M=1,Ms=1&lt;/code&gt;&lt;br&gt;
由于R2的Router ID比R1的大，所以R2应当为主路由器，Router ID的比较结束后，R1会产生一个NegotiationDone的事件，R1从ExStart改变为Exchange&lt;code&gt;主从选举出来：R1进入ExChange状态，但是R2需要收到R1的隐式确认才能进入ExChange&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;同步LSDB
&lt;ol&gt;
&lt;li&gt;【R1-&amp;gt;R2】：R1发送一个新的DD报文，在这个新的报文中包含LSDB的摘要信息，&lt;strong&gt;seq=y&lt;/strong&gt;、I=0、M=1、MS=0&lt;code&gt;主从选举完毕：R1使用R2的序列号，隐式确认R2为主，R2收到后变为ExChange状态。以后R2是主，其主动权通过修改seq来体现&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;【R2-&amp;gt;R1】：R2发送一个新的DD报文，seq=y+1、I=0、M=1、MS=1，R1和R2通过DBD交互了解到对方的OSPF数据库中的摘要信息。这个过程可能交互很多个DBD报文，但这些报文有一个共同点I=0、M=1、R1发的MS=0、R2发的MS=1&lt;/li&gt;
&lt;li&gt;【R1-&amp;gt;R2】：seq=y+1，I=0，M=0，MS=0。R2收到一个M=0的DBD包的时候表明是R1发来的最后一个DBD包了，如果R2搜集完R1发来的DBD并且发现这些DBD里有它感兴趣的LSA，R2期望更详细的LSA信息时，R2将自己的状态变为&lt;strong&gt;Loading&lt;/strong&gt;，并且开始发送LSR报文去请求特定LSA的详细信息。&lt;/li&gt;
&lt;li&gt;【R2-&amp;gt;R1】：seq=y+2，I=0，M=0，MS=1。R1收到一个M=0的DBD包的时候表明是R2发来的最后一个DBD包了，如果R1搜集完R2发来的DBD，假如没有发现自己感兴趣的LSA&lt;code&gt;假设R1是LSDB是最新最全的，不需要向R2请求&lt;/code&gt;，将自己的状态变为Full。&lt;code&gt;此时R2直接进入Full状态而不是Loading状态，R1进入Loading状态&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;【R1-&amp;gt;R2】：&lt;code&gt;Loading到Full状态的转换&lt;/code&gt;R1将自己感兴趣的LSA通过请求报文LSR发送给R2&lt;/li&gt;
&lt;li&gt;【R2-&amp;gt;R1】：R2收到这个LSR后，会以LSU进行回应，其中就包含了对方请求的LSA详细信息，因此，只有在LSU报文中，才能看到LSA的完整信息&lt;/li&gt;
&lt;li&gt;【R1-&amp;gt;R2】：R1收到R2发来的LSU之后，将LSA详细信息放进自己的LSDB，并且给R2发送一个LSAck进行确认，状态转换为Full状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ospf报文&#34;&gt;OSPF报文&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;OSPF报文头部&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587202960222.png&#34; alt=&#34;OSPF报文头部&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ospf认证&#34;&gt;OSPF认证&lt;/h2&gt;
&lt;h3 id=&#34;认证配置方式&#34;&gt;认证配置方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;区域认证&lt;/li&gt;
&lt;li&gt;接口认证，&lt;strong&gt;接口认证优先于区域认证&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;明文认证&lt;/strong&gt;：传递明文密码，不安全，报文被劫获后密码泄露，无抗重放攻击特性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;MD5认证&lt;/strong&gt;：不传输密码只传输HASH值，就算报文被劫获也无法看到密码，同时认证序列号(4B)可以实现抗重发攻击和报文有效性检查。【注意：摘要信息虽然在ospf头部中，但是并不计算到ospf头部长度内；认证序列号是基于计数的方式，每隔1秒加1(可以用136年)，如果收到的报文系列号比之前发送的小则丢弃，不需要顺序匹配，只要保证比之前的大即可】&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;报文类型&#34;&gt;报文类型&lt;/h2&gt;
&lt;h3 id=&#34;1-hello&#34;&gt;1. Hello&lt;/h3&gt;
&lt;p&gt;用来发现、建立和维护OSPF的邻居关系，可以组播也可以单播发送，在不同的网络类型中发送方式和发送间隔不同&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587204145080.png&#34; alt=&#34;OSPF-hello&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network Mask：只有在广播网络或者NBMA网络才有意义（在P2P和P2MP链路上是不检测的）&lt;/li&gt;
&lt;li&gt;HelloInterval：在广播网络和P2P中是10秒一次，在P2MP和NBMA中是30秒一次&lt;/li&gt;
&lt;li&gt;Options：标识发送此报文的OSPF路由器所支持的可选功能&lt;br&gt;
&lt;code&gt;Hello报文中Option字段位置 和 DBD、LSA报文中中位置相同【即只要hello、DBD和LSA存在Option字段，其他报文不存在此字段】&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;DN位&lt;/strong&gt;：Down比特位，是用来防止MPLS VPN环境下的3类环路问题&lt;code&gt;如果一台PE设备收到DN位置位的3类或者5类LSA，直接丢弃&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;O位：用来支持9、10、11类LSA的能力&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DC位&lt;/strong&gt;：当始发链路支持按需链路(意思是需要建立时才建立)时该比特位会置位，例如虚链路、sham-link&lt;code&gt;华为设备此比特位不会置1，华为的虚链路是使用P2P来维护，如果思科与华为对接，思科按照华为的方式(P2P)维护电路，每隔1800秒(30分钟)通告一次LSA，来维护LSA的有效性&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;N位&lt;/strong&gt;：N位表明是否支持7类LSA，N=0表明不接收和发送7类LSA&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;P位&lt;/strong&gt;：用在NSSA LSA（7类LSA），是否做7类转成5类&lt;br&gt;
&lt;code&gt;NP位在不同的报文中意义不一样，如果在hello或者DBD报文中，说明此报文来自NSSA区域；如果在LSA报文中，说明这个LSA需要进行7转5的&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;E位&lt;/strong&gt;：能否接收外部路由（5类LSA），默认E位是1，是可以接收外部路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rtr Pri：用来选举DR和BDR的&lt;/li&gt;
&lt;li&gt;RouterDeadInterval：通常为4倍HelloInterval，&lt;code&gt;hello影响dead，但是dead不影响hello&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Designated Router：如果设置为0.0.0.0，表示未选举DR路由器。&lt;/li&gt;
&lt;li&gt;Backup Designated Router：如果设置为0.0.0.0，表示未选举BDR路由器。&lt;/li&gt;
&lt;li&gt;Neighbor：邻居路由器的Router ID列表，表示本路由器已经从该邻居收到合法的Hello报文&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;验证一个接收到的Hello报文是否合法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果接收端口的网络类型是&lt;strong&gt;广播型、NBMA&lt;/strong&gt;，Network Mask字段必须和接收端口的网络掩码一致，如果接收端口的网络类型为&lt;strong&gt;P2P、P2MP、虚连接&lt;/strong&gt;，则不检查Network Mask字段；&lt;/li&gt;
&lt;li&gt;所接收的Hello报文中的HelloInterval字段必须和接收端口的配置保持一致；&lt;/li&gt;
&lt;li&gt;所接收的Hello报文中的RouterDeadInterval字段必须和接收端口的配置保持一致；&lt;/li&gt;
&lt;li&gt;所接收的Hello报文中的Options字段中的E位（表示是否接收外部路由信息）必须和相关区域的配置保持一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;2-dbd&#34;&gt;2. DBD&lt;/h3&gt;
&lt;p&gt;数据库描述报文，选择主从关系，通告LSA摘要信息&lt;code&gt;完整的LSA头部信息&lt;/code&gt;，确保DBD报文交互的可靠性&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587286604710.png&#34; alt=&#34;OSPF-DBD&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;firstDBD：不携带LSA头部信息。通过firstDBD确认主从关系。作用只是为了控制序列号的同步。Router-ID高的将成为主。&lt;/li&gt;
&lt;li&gt;DBD只携带LSA的头部信息，没有携带LSA的具体信息&lt;br&gt;
&lt;code&gt;只有主才会生成DD序列号&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-lsr&#34;&gt;3. LSR&lt;/h3&gt;
&lt;p&gt;接收到DBD报文后，将DBD报文中的LSA摘要信息和本地LSDB做对比，如果有本地不存在的LSA，需要发送LSR请求具体的LSA内容，LSA值包含3部分内容：LSA类型（LSA TYPE）、链路状态ID(Link state ID)、通告路由器(Advertising Router)&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311400960.png&#34; alt=&#34;OSPF-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;LSR报文中不会包含option选项&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-lsu&#34;&gt;4. LSU&lt;/h3&gt;
&lt;p&gt;用于向对方回复具体的LSR，含有真正LSA完整信息的&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311547987.png&#34; alt=&#34;OSPF-LSU&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;lsa报文&#34;&gt;LSA报文&lt;/h4&gt;
&lt;h5 id=&#34;lsa头部20字节&#34;&gt;LSA头部（20字节）&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;除Hello报文外，其它的OSPF报文都携带LSA信息&lt;/li&gt;
&lt;li&gt;常用的LSA：Router LSA、Network LSA、Network-summary LSA、ASBR-Summary LSA、AS External LSA、NSSA LSA，即1、2、3、4、5、7&lt;/li&gt;
&lt;li&gt;还有哪些LSA：Opaque LSA(9-仅在接口所在网段范围内传播、10-在区域内传播、11-在AS内传播，主要用于MPLS多协议标签交换，即MPLS TE，不透明LSA) 、Mutilcast LSA(6，组播LSA)、External attributes LSAfor BGP（8，BGP的外部属性LSA）&lt;br&gt;
&lt;code&gt;OSPF协议规定LSA的更新时间间隔5秒，是为了防止网络连接或者路由频繁动荡引起的过多占用网络带宽和设备资源，所以看到每隔5秒，LSA重新泛洪一次&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311683821.png&#34; alt=&#34;OSPF-LSAHead&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;LSA age：默认最大值为3600。&lt;code&gt;通过将LSA Age设置为3600来删除该条LSA，但1类LSA不适应此条规则&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LAS的序列号：可用的最小数值为0x80000001(初始序号，-2^31+1 )，每次更新该LSA，序列号+1，序列号越大则该LSA越新，最大为0x7FFFFFFF，达到最大值之后，重新从0x80000001开始&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;收到重复的LSA如何判断新旧&lt;/strong&gt;？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较LSA的序列号，越大越新&lt;/li&gt;
&lt;li&gt;比较校验值（Checksum）,越大越新&lt;/li&gt;
&lt;li&gt;比较LSA的Age是否等于Max Age时间3600，相等则最新&lt;/li&gt;
&lt;li&gt;LSA的Age不等于3600，会比较age与3600之间的差值，如果差值大于900（即15分钟），越小越新&lt;/li&gt;
&lt;li&gt;LSA的Age不等于3600，且age与3600之间的差值小于900，则会认为是同一条LSA，忽略其中一条&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;如何保证让邻居收到一个最新的LSA&lt;/strong&gt;？&lt;br&gt;
&lt;strong&gt;A.&lt;/strong&gt; 假设AB两台直连设备建立OSPF邻接关系，并且由A通告给B一条&lt;strong&gt;序列号为10&lt;/strong&gt;的Router-LSA，这条LSA会存在于B的LSDB中。现在，我们将A设备的直连接口shutdown，会造成A和B的OSPF的邻居关系断开，那现在&lt;strong&gt;B设备的LSDB中&lt;/strong&gt;是否还会&lt;strong&gt;有A发送的Router-LSA&lt;/strong&gt;呢？&lt;br&gt;
&lt;strong&gt;B.&lt;/strong&gt; 答案是肯定有的，原因是&lt;strong&gt;OSPF 为了保证LSDB 的一致性，是没有能力删除邻居发送的LSA 的，只能删除由自己通告的LSA&lt;/strong&gt;。了解这个机制后，我们再考虑一下，如果现在将A的直连接口恢复，并重新和B 建立邻居关系，那么A会再次通告自己的Router-LSA，那么现在通告的序列号会是多少呢？&lt;br&gt;
&lt;strong&gt;C.&lt;/strong&gt; 会是通告序列号为1 的Router-LSA吗？答案是否定的，&lt;strong&gt;A会通告一条序列号为11的Router-LSA&lt;/strong&gt;。这是为什么呢？我们可以想一下，如果A重新通告一条序列号为1 的Router-LSA 给B，B会接收吗？&lt;br&gt;
&lt;strong&gt;D.&lt;/strong&gt; 答案是不会，原因就是我们之前谈到的LSA 新旧比较问题，由于B的LSDB中存在A 之前通告的一条序列号为10 的Router-LSA，现在又收到同样的的一条LSA，需要比较两条LSA 的新旧，由于收到的LSA 的序列号比LSDB中保存的LSA 的序列号还要小，那么这条LSA 会被忽略掉。&lt;br&gt;
&lt;strong&gt;E.&lt;/strong&gt; 为了让LSDB保持同步，需要在接收到的LSA序列号上加1，作为最新的序列号标识LSA，并重新在区域内泛洪。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;LSA报文简略总结:&lt;/strong&gt;&lt;code&gt;通过判断头部type、LS ID和ADV来判断是否为同一条LSA&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;种类type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;产生者(ADV)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LS ID(链路状态ID)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;泛洪区域&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Cost&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;作用&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;防环&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Router&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每台路由器(自己的RouterID)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;自己的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;所属区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100/实际带宽(100为参考带宽)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设备的链路状态和开销&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SPF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Network&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DR接口IP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;所属区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无cost字段&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;本网段的链路状态&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SPF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Network-Summary&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络前缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR到目的网段的开销&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域间的路由信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;3类LSA的防环规则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR-Summary&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;非asbr区域的所有区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR到ASBR的开销&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;到ASBR的路由信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;和3类相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AS-External&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络前缀(外部)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;全网(除stub、nssa)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR到目的网段的开销&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;到AS外部的路由&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;依靠3类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSSA-External&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络前缀(外部)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSSA区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR到目的网段的开销&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;到AS外部的路由&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;8&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Link&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每台路由器(自己的RouterID)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;接口编号&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;本链路&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;本接口cost&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;描述本链路的信息(链路本地地址、接口编号和前缀)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SPF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;9&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Inter-Area-Prefix(区域内前缀)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每台路由器(自己的RouterID)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络前缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;所属区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;本接口cost&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;域内路由&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SPF&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;router-lsatype1&#34;&gt;Router-LSA（Type1）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611991285955.png&#34; alt=&#34;Router-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311744247.png&#34; alt=&#34;OSPF-Router-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
OSPF网络里的每一台路由设备都会发布Type1 LSA，这种类型的LSA用于描述设备的链路状态和开销，在路由器所属的区域内传播&lt;br&gt;
一条Router-LSA可以描述多条链接，每条链接由Link ID、Data、Type和Metric描述&lt;br&gt;
&lt;code&gt;报文中3个重要比特位标识设备角色：V代表虚链路，B代表ABR，E代表ASBR&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LinkID&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LinkData&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P2P点对点&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;邻居的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该网段上本地接口的IP地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TransNet传送网络&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DR的接口IP地址&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该网段上本地接口的IP地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;StubNet末梢网络&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该Stub网段的IP网络地址&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该Stub网段的网络掩码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Virtual虚链路&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;虚连接邻居的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;去往该虚连接邻居的本地接口的IP地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;广播类型的接口的链路类型是transnet，环回口链路类型是stubnet，点到点链会生成p2p和stubnet两种类型(所以即使不在同一网段也能建立邻居)。OPSF是先计算p2p和transnet，再计算stubnet&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;哪些接口会通告成stubnet的链路类型？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;逻辑接口&lt;/li&gt;
&lt;li&gt;没有邻居关系的物理接口&lt;/li&gt;
&lt;li&gt;点到点或者虚链路网络类型的接口&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;network-lsatype2&#34;&gt;Network-LSA（Type2）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611992334341.png&#34; alt=&#34;Network-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311827323.png&#34; alt=&#34;OSPF-Network-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由DR产生，描述本网段的链路状态，在所属的区域内传播。&lt;/p&gt;
&lt;h5 id=&#34;network-summary-lsatype3&#34;&gt;Network-summary-LSA（Type3）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611992419998.png&#34; alt=&#34;Network-summary-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587312009002.png&#34; alt=&#34;OSPF-Network-summary-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由ABR发布，用来描述区域间的路由信息。ABR将Network-summary-LSA发布到一个区域，通告该区域到其他区域的目的地址。实际上，&lt;strong&gt;ABR是将区域内部的Type1和Type2的信息收集起来并汇总之后扩散出去&lt;/strong&gt;，这就是Summary的含义&lt;br&gt;
&lt;code&gt;OSPF的防环：不允许直接在两个非骨干区域之间发布路由信息，只允许在一个区域内或者骨干和非骨干区域间发布路由信息&lt;/code&gt;&lt;br&gt;
&lt;code&gt;3类LSA的防环：（水平分割）一条3类LSA的始发区域不会再通告这条LSA（即一条3类LSA不会再通告回始发区域）&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;asbr-summary-lsatype4&#34;&gt;ASBR-summary-LSA（Type4）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611992622385.png&#34; alt=&#34;ASBR-summary-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;报文格式和3类相同，如果是4类，那么LS ID为ASBR的RouterID，且掩码设置为0.0.0.0，无实际意义&lt;/code&gt;&lt;br&gt;
由ABR发布，描述到ASBR的路由信息，并通告给除ASBR所在区域的其他相关区域&lt;br&gt;
&lt;code&gt;传递范围为区域内，只要跨区域了，则需要重新生成4类LSA，主要是metric值不同，当然通告路由器也不通&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;as-external-lsatype5&#34;&gt;AS-External-LSA（Type5）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611992723955.png&#34; alt=&#34;AS-External-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587312103475.png&#34; alt=&#34;OSPF-AS-External-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由ASBR产生，描述到AS外部的路由，通告到除Stub区域和NSSA区域以外所有的区域&lt;br&gt;
&lt;code&gt;tag字段ospf本身很少使用，但是经常用在MPLS VPN的防环中，TAG被填充为AS number，主要作用是防环&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;外部度量值类型（E比特位）&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;OE1&lt;/strong&gt;：第一类外部路由。在传递过程中&lt;strong&gt;开销值累加&lt;/strong&gt;。&lt;code&gt;OE1的路由优先于OE2&lt;/code&gt;。OE1的路由比较的是总开销值，不区分内外。&lt;br&gt;
&lt;strong&gt;OE2&lt;/strong&gt;：第二类外部路由，&lt;strong&gt;默认类型&lt;/strong&gt;。在传递过程中&lt;strong&gt;开销值不会累加&lt;/strong&gt;，只计算引入时的外部开销值，不计算内部开销值。OE2只看外部开销（忽略内部开销）；如果外部开销相同，则比较内部开销；如果内部和外部开销都相同，则进行负载。&lt;code&gt;先看外部cost，再看内部cost&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：&lt;code&gt;OE1是不分内外，加在一起进行比较；OE2是内外分开，先比较外部，外部相等再比较内部&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;外部路由引入可以打上TAG，如果没有指定，则默认等于进程ID，例如引入将rip3的路由引入ospf1，则tag默认等于1；如果是在MPLS VPN场景下，这个是本AS号的哈希值&lt;/code&gt;&lt;/p&gt;
&lt;h6 id=&#34;关于fa地址的4问&#34;&gt;关于FA地址的4问：&lt;/h6&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FA地址作用&lt;/strong&gt;：防止次优路径和环路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;携带FA地址的3个条件&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;出接口类型不能是P2P、P2MP；&lt;/li&gt;
&lt;li&gt;出接口不能配置为静默接口(silent接口)；&lt;/li&gt;
&lt;li&gt;下一跳地址要为域内或者域间可达，即引入的外部路由的下一跳接口所在网段必须宣告进OSPF&lt;br&gt;
&lt;code&gt;OSPF的五类LSA如果携带了FA地址，计算路由时会优先考虑FA地址（即只计算到达FA的距离，不计算到达ASBR的距离）；如果FA地址不可达，则路由无效；如果没有携带FA地址，才会考虑ASBR&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;FA地址如何填充&lt;/strong&gt;(即FA地址是什么地址)：填充为引入外部路由的下一跳地址&lt;code&gt;此地址一般不是域内地址，但其所在网段却宣告进了OSPF&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算FA地址的条件&lt;/strong&gt;：到达&lt;strong&gt;FA地址所在网段&lt;/strong&gt;必须是OSPF域内或者域间路由可达。如果是通过静态、外部路由引入等可达，则不计算&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;nssatype7&#34;&gt;NSSA（Type7）&lt;/h5&gt;
&lt;p&gt;由ASBR产生，描述到AS外部的路由，仅在NSSA区域内传播，报文结构和5类相同。NSSA区域的ABR收到NSSA LSA时，会有选择地将其转化为Type5 LSA，以便将外部路由信息通告到OSPF网络的其它区域。AS-external-LSA是在整个AS泛洪，而NSSA LSA仅在NSSA区域中泛洪。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;P位用于告知转化路由器该条Type7 LSA是否需要转化。&lt;/li&gt;
&lt;li&gt;缺省情况下，&lt;strong&gt;转化路由器是NSSA区域中RouterID最大的ABR&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;只有P置位并且FA（Forwarding Address）不为0的NSSA LSA才能转化为AS-external-LSA。FA用来表示发送的某个目的地址的报文将被转发到FA所指定的地址。&lt;/li&gt;
&lt;li&gt;ASBR产生的NSSA LSA不会置位P位&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FA地址默认会被填充，填充顺序如下&lt;/strong&gt;【其实后两者没有任何意义】：
&lt;ul&gt;
&lt;li&gt;如果满足5类LSA的3大条件，FA地址是ASBR上外部路由的下一跳地址；&lt;/li&gt;
&lt;li&gt;如果没有将引入外部路由下一跳地址所在网段宣告进OSPF，则优选宣告进ospf的逻辑接口IP地址最大的一个；&lt;/li&gt;
&lt;li&gt;如果没有逻辑接口宣告进OSPF，则优选宣告进ospf中活动的物理接口地址较大的一个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5-lsack&#34;&gt;5. LSAck&lt;/h3&gt;
&lt;p&gt;用来对接收到的LSU报文进行确认，内容是需要确认的LSA的Header（一个LSAck报文可对多个LSA进行确认），LSAck报文根据不同的链路以单播或组播的形式发送。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587312186750.png&#34; alt=&#34;OSPF-LSAck&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;ospf支持的网络类型&#34;&gt;OSPF支持的网络类型&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;P2P网络&lt;br&gt;
只把两台路由器直接相连的网络，例如运行PPP的64K串行线路就是一个点到点网络&lt;br&gt;
&lt;strong&gt;不需要选举DR和BDR，hello时间10s，dead时间40s，5种报文全部组播&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Broadcast网络&lt;br&gt;
支持两台以上路由器，并且具有广播能力的网络，例如含有四台路由器的以太网&lt;br&gt;
&lt;strong&gt;需要选举DR和BDR，hello时间10s，dead时间40s，hello报文组播、DBD和LSR是单播、LSU和LSAck有单播也有组播&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;NBMA网络&lt;br&gt;
例如使用SVC进行通信的ATM网络【全连接ATM网络】&lt;br&gt;
&lt;strong&gt;需要选举DR和BDR，hello时间30s，dead时间120s，5种报文均是单播&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;P2MP网络&lt;br&gt;
&lt;strong&gt;不需要选举DR和BDR，hello时间30s，dead时间120s，hello报文组播、其他报文全是单播&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;虚链接&lt;br&gt;
注意事项：虚连接不能配置在骨干区域(Area0)和末节区域(实验中的Area20)，不能跨越多个区域&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;网络类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Hello时间&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;dead时间&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Hello报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DBD报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSR报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSU报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSACK报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;是否选举DR/BDR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NBMA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P2MP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P2P&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Broadcast&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播/组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播/组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;虚链路&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;x&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;P2MP和NBMA的hello时间为30秒的原因：P2MP和NBMA为低速网络，为了保证链路拥塞不会影响邻居的建立，将hello时间调大&lt;/code&gt;&lt;br&gt;
&lt;code&gt;虚链路是跨设备的，所以都是使用单播，TTL为255，而其他的组播报文的TTL为1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;不同的网络类型之间是否可以建立邻接关系是否有路由&#34;&gt;不同的网络类型之间是否可以建立邻接关系？是否有路由？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;能不能建立邻居需要看hello报文时间与发送方式；有没有路由需要看是否有DR和BDR&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;P2P与Broadcast&lt;br&gt;
可以建立邻接关系，但是没有路由。&lt;br&gt;
原因：P2P没有DR和BDR，即没有二类LSA，导致Broadcast无法识别相应报文&lt;/li&gt;
&lt;li&gt;P2MP与Broadcast&lt;br&gt;
因为hello时间不相同，无法建立邻居关系。&lt;br&gt;
如果将P2MP的hello时间修改为10s，可以建立邻接关系，但是没有路由。&lt;strong&gt;原因同上&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;NBMA和Broadcast&lt;br&gt;
因为hello时间不相同，无法建立邻居关系。即使修改hello时间也无法建立邻接关系。&lt;br&gt;
原因：NBMA的hello报文为单播，Broadcast的hello报文为组播&lt;/li&gt;
&lt;li&gt;P2P和P2MP&lt;br&gt;
因为hello时间不相同，无法建立邻居关系。修改P2MP的hello时间为10s之后可以建立邻接关系并且有路由&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;判断一个接口所属的网络类型&#34;&gt;判断一个接口所属的网络类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;通过接口的二层封装协议判断网络类型&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;网络类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;常见链路层协议(二层封装)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Point-to-point&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PPP链路、LAPB链路、HDLC链路&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Broadcast&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以太网链路、802.3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NBMA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;帧中继链路、ATM链路&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;ospf的区域类型&#34;&gt;OSPF的区域类型&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;骨干区域：即区域0&lt;/li&gt;
&lt;li&gt;非骨干区域：非0区域
&lt;ol&gt;
&lt;li&gt;普通区域&lt;/li&gt;
&lt;li&gt;特数区域
&lt;ol&gt;
&lt;li&gt;stub：末节区域&lt;/li&gt;
&lt;li&gt;total stub：完全末节区域&lt;/li&gt;
&lt;li&gt;nssa：次末节区域&lt;/li&gt;
&lt;li&gt;total nssa：完全次末节区域&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;option选项与区域类型&#34;&gt;Option选项与区域类型&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;E&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;N&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;区域类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;stub区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSSA区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;普通或者骨干区域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;影响ospf邻接关系建立的因素&#34;&gt;影响OSPF邻接关系建立的因素&lt;/h1&gt;
&lt;h2 id=&#34;1-route-id&#34;&gt;1. Route ID&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;1类LSA通过序列号+1撤销路由，3类和5类通过3600秒撤销&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-同一区域内&#34;&gt;1. 同一区域内&lt;/h3&gt;
&lt;h4 id=&#34;1-直连设备routerid冲突&#34;&gt;1. 直连设备RouterID冲突&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612188975988.jpg&#34; alt=&#34;同一区域内直连设备RouterID冲突&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;【结果】&lt;/strong&gt;：&lt;br&gt;
无法建立ospf邻居关系，两端的邻居状态机都为down&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【分析】&lt;/strong&gt;：&lt;br&gt;
RouterID不冲突是建立ospf邻居的7个条件之一，如果RouterID冲突，则直接丢弃Hello报文，两端的邻居状态机为down&lt;/p&gt;
&lt;h4 id=&#34;2-非直连设备routerid冲突&#34;&gt;2. 非直连设备RouterID冲突&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612189247363.jpg&#34; alt=&#34;非直连设备RouterID冲突&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;【结果】&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R2会和R1、R3分别建立邻接关系，但是在R2的lsdb中只存在1条来自1.1.1.1的1类lsa；&lt;/li&gt;
&lt;li&gt;在所有设备上会出现1类和2类LSA的翻动，序列号不断增加。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【分析】&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R2会收到R1、R3发送的同一条Router-LSA，原因是R1、R3 的RouterID相同，导致LSA的头部信息一致，被认为是同一条LSA。&lt;/li&gt;
&lt;li&gt;R2需要做一次LSA的新旧比较，假如通过序列号比较R2优选了R1通告的1类LSA（R1通告的序列号比R3 的大），R2将Router-LSA放入到LSDB中，并且将这条最新的Router-LSA转发给R3。&lt;/li&gt;
&lt;li&gt;R3收到后发现这是自己通告的LSA，但是LSA的序列号比自己本地生成的还要大，为了保证LSDB的同步，R3会在接收到的序列号基础上+1作为最新序列号，向R2在通告一条1类lsa。&lt;/li&gt;
&lt;li&gt;这样R2又收到一条R3通告的1类LSA，通告LSA新旧比较，优选了R3。然后将最新的LSA在通告给R1，R1收到后在重复R3的动作。&lt;/li&gt;
&lt;li&gt;这样造成R1、R3 的1类LSA一直在翻动，序列号在不停的增长。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;3-非直连设备和abr的routerid冲突&#34;&gt;3. 非直连设备和ABR的RouterID冲突&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612189206710.jpg&#34; alt=&#34;非直连设备RouterID冲突&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;【结果】&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在R2和R4上会出现1类LSA的翻动，序列号不断增加&lt;code&gt;和同一区域的RouterID冲突原因相同&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;R4收到ABR发送的3类LSA后，会将该3类LSA的老化时间设置为3600秒，并泛洪3类LSA&lt;/li&gt;
&lt;li&gt;R2上3类LSA的序列号不断增加，导致区域1会出现3类LSA的翻动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【分析】&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R3收到R2发送的3类LSA后会转发给R4，R4收到后发现该3类LSA的通告路由器正好是自己的Router-id，会认为该3类LSA是自己发送的，但是R4发现在LSDB中并不存在这条本地通告的LSA。R4会认为这很可能是自己之前已经删除的一条LSA，现在又从邻居收到了。为了同步LSDB和避免环路，R4会将这条3类LSA的LSA AGE配置为3600秒(不会修改LSA 的序列号，只是修改LSA AGE时间为3600S)，并泛洪这条修改后的3类LSA，目的就是让区域内的其它OSPF路由器加速删除这条3类LSA，同步LSDB。&lt;/li&gt;
&lt;li&gt;这样R3又从R4收到一条同样的3类LSA，R3会执行LSA新旧比较过程，由于R4通告的3类LSA中LSA AGE等于MAX AGE(3600S)，R3会优选R4通告的3类LSA，替换本地LSDB，并将最新的3类LSA在通告回R2。由于R2是该3类LSA的始发者，并且该LSA还是有效的，为了同步LSDB，避免这条有效的3类LSA被删除。R2 会马上向区域泛洪一条序列号+1的3类LSA 做为更新。&lt;/li&gt;
&lt;li&gt;R3现在又收到了从R2发送的3类LSA，由于R2发送的LSA序列号较大，R3会优选R2发送的LSA，替换本地LSDB，并将最新的3类LSA再通告给R4，R4再次重复以上步骤，导致LSA的翻动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【解决】&lt;/strong&gt;：&lt;br&gt;
华为的设备如果发现这种冲突，会在一定的冲突时间范围内，将OSPF进程重启，并重新指定一个Router-id，从而避免冲突&lt;/p&gt;
&lt;h3 id=&#34;2-不同区域内&#34;&gt;2. 不同区域内&lt;/h3&gt;
&lt;h4 id=&#34;1-非直连设备routerid冲突&#34;&gt;1. 非直连设备RouterID冲突&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612189271723.jpg&#34; alt=&#34;非直连设备RouterID冲突&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;【结果】&lt;/strong&gt;：&lt;br&gt;
不同区域间的设备RouterID冲突，不会有任何的影响，冲突设备可以接收LSA并选路。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【分析】&lt;/strong&gt;：&lt;br&gt;
1类LSA的泛洪范围是区域内，不同区域间不能交互1类LSA。如果想实现不同区域间的通信，就需要ABR，ABR会将1类LSA中的链路信息转换为3类LSA中的路由信息通告给其它区域，3类LSA的通告路由器会用ABR 的RouterID来标识，这样也就避免了RouterID的冲突问题&lt;br&gt;
&lt;code&gt;但是不能引入外部路由，外部路由通过5类LSA在整个OSPF区域泛洪，R1和R3还是会发现对方的存在，导致所有设备上5类LSA的序列号不断增长（详细分析见下面内容）&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-非直连设备和asbr的routerid冲突&#34;&gt;2. 非直连设备和ASBR的RouterID冲突&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612189196368.jpg&#34; alt=&#34;非直连设备和ASBR的RouterID冲突&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;【结果】&lt;/strong&gt;：&lt;br&gt;
R1上5类LSA的序列号不断增加，导致所有设备上出现5类LSA的翻动&lt;br&gt;
&lt;strong&gt;【分析】&lt;/strong&gt;：&lt;br&gt;
与非直连设备和ABR的RouterID冲突的原因类似，只是针对不同的LSA。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于5类LSA是在整个自治系统内泛洪，R4在收到后同样会发现5类LSA的通告路由器和自己的RouterID一样，但是本地并不存在这条LSA，R4会将这条LSA的LSA AGE设置为3600S，并泛洪该LSA，目的是加速删除，同步LSDB。&lt;/li&gt;
&lt;li&gt;这会造成沿路上的所有转发设备都会认为该5类LSA是最新的，替换LSDB中的LSA，超时后将这条5类LSA从LSDB中删除。当这条LSA会被转发到R1的时候，R1发现5类LSA是本地通告的，并且这条LSA在本地是有效的，LSA AGE在正常范围时间内。&lt;/li&gt;
&lt;li&gt;R1便会将5类LSA的序列号+1，并且重新泛洪5类LSA。保证5类LSA的有效性，同步LSDB，造成5类LSA的翻动&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【解决】&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自动解决&lt;/strong&gt;：华为的设备如果发现这种冲突，会在一定的冲突时间范围内，将OSPF进程重启，并重新指定一个Router-id，从而避免冲突&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;人工解决&lt;/strong&gt;：如果区域0要引入外部路由，可以把区域1配置为Stub区域，因为LSA5不进Stub区域；如果区域1要引入外部路由，可以把区域1设备为NSSA区域，由于LSA7转LSA5后ADV变成ABR。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-区域id&#34;&gt;2. 区域ID&lt;/h2&gt;
&lt;p&gt;区域ID包含在ospf头部，双方不一致时无法建立邻居&lt;/p&gt;
&lt;h2 id=&#34;3-flag位区域类型&#34;&gt;3. flag位（区域类型）&lt;/h2&gt;
&lt;p&gt;主要是区域类型（option字段中的E位与N位）&lt;br&gt;
E位代表能处理外部路由，在OSPF中外部路由就是指5类lsa，N位代表NSSA区域（支持7类LSA）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;E&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;N&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;区域类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;stub区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSSA区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;普通或者骨干区域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;4-hello和dead时间&#34;&gt;4. hello和dead时间&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;网络类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Hello时间&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;dead时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NBMA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P2MP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P2P&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Broadcast&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;虚链路&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;5-认证&#34;&gt;5. 认证&lt;/h2&gt;
&lt;p&gt;包含认证类型和认证密码&lt;br&gt;
认证类型分为不认证（00）、明文认证（01）、MD5认证（02），OSPF的认证放在ospf头部。&lt;br&gt;
如果一边接口认证，一边区域认证，可以认证成功。&lt;br&gt;
接口认证由于区域认证。&lt;/p&gt;
&lt;h2 id=&#34;6-掩码长度&#34;&gt;6. 掩码长度&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;影响广播、NBMA，不影响P2P、P2MP和虚链路&lt;/code&gt;&lt;br&gt;
MA网路中掩码必须一致，因为MA网络中所有路由器共用一个网段，只有一个2类LSA的Network来描述当前的网络拓扑和网络号，所以当掩码不一致时，无法通过一个2类LSA描述不同的掩码。&lt;br&gt;
P2P网络中掩码之所以可以不一致是因为P2P中有1类LSA的stub类型来描述每一个网络的掩码信息，并且在P2P网络在NCP阶段，两台路由器会&lt;strong&gt;互推自己的IP地址&lt;/strong&gt;，并且以32位主机路由的方式加入自己的路由表，所以P2P网络中建立邻居不需要掩码一致。&lt;/p&gt;
&lt;h2 id=&#34;7-网络类型&#34;&gt;7. 网络类型&lt;/h2&gt;
&lt;p&gt;能不能建立邻居需要看hello报文时间与发送方式；能不能建立邻接需要看是否有DR和BDR&lt;br&gt;
双方网络类型不一致，不能建立FULL的邻接关系，但如果修改hello、dead时间，可以建立full的邻居关系（除了NBMA这种网络类型，NBMA即使修改时间也无法和其他网络类型建立邻居关系，因为其收发hello报文都是单播），Broadcast与P2P、P2MP修改时间可以建立FULL的邻居关系，但不能计算路由，因为后两者没有DR，即不能交互2类LSA。&lt;code&gt;只有P2P和P2MP之间通过修改hello和dead时间之后能够建立邻接关系&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;8-其他&#34;&gt;8. 其他&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;MTU：只影响邻接建立，不影响邻居建立&lt;/li&gt;
&lt;li&gt;在广播或NBMA网络中DR优先级不能为零，否则DR选举不成功&lt;/li&gt;
&lt;li&gt;静默端口：silence接口，不收也不发ospf报文&lt;/li&gt;
&lt;li&gt;接口地址未宣告&lt;/li&gt;
&lt;li&gt;ACL&lt;/li&gt;
&lt;li&gt;链路层故障&lt;/li&gt;
&lt;li&gt;版本不匹配&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ospf的环路场景&#34;&gt;OSPF的环路场景&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;虚连接导致的环路场景&lt;/li&gt;
&lt;li&gt;外部路由引入导致的环路场景&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612192876821.png&#34; alt=&#34;外部路由引入导致的环路场景&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;将R5的lo0引入进ospf区域，指定cost设置为100（外部路由，使用5类LSA泛洪）&lt;/li&gt;
&lt;li&gt;在AR3上ISIS引入OSPF的路由，AR3通告给AR4，AR4通告给AR2，在AR2上比较路由的优先级（ospf的外部路由为150，ISIS的路由为15）后，选择ISIS的路由，出现了次优路径，即AR2访问AR5上的路由走的是AR2--AR4--AR3--AR1--AR5&lt;/li&gt;
&lt;li&gt;为了解决次优路径，需要在AR2上&lt;strong&gt;将isis路由引入到ospf，此时出环了&lt;/strong&gt;。因为ospf引入外部路由默认cost为1，那么AR1上想要访问AR5的lo0，（类型都是默认的OE2）优先选择cost小的AR2，接下来的路由是AR2--AR4--AR3--AR1，即形成环路&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ospf的防环机制&#34;&gt;OSPF的防环机制&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;SPF算法只能保证同一个区域内无环&lt;code&gt;即1类和2类LSA的防环&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;多区域场景下，非骨干区域必须和骨干区域互联&lt;/li&gt;
&lt;li&gt;3类LSA的防环：
&lt;ol&gt;
&lt;li&gt;源于虚链路的3类LSA不会再通告回虚链路的所经过的区域&lt;code&gt;虚链路属于区域0且至少一端连接非骨干区域，相当于至少存在一个ABR&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;ABR生成的3类LSA不会在通告回始发区域&lt;code&gt;水平分割原则&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;真ABR&lt;sub&gt;ABR在骨干区域中存在活动的邻接关系&lt;/sub&gt;从非骨干区域收到3类LSA，只接收不选路&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;4类LSA的防环：&lt;br&gt;
ABR生成的4类LSA不会通告回5类LSA的来源区域&lt;code&gt;即4类LSA的作用是通告ASBR的位置，给ASBR所在的区域通告4类LSA完全无意义&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;5类LSA的防环：
&lt;ol&gt;
&lt;li&gt;5类LSA在ospf域内泛洪时，没有区域边界的限制，所以3类的防环规则对5类LSA不适用，但5类LSA能否进入路由表并导致环路，依赖于3类和4类LSA&lt;/li&gt;
&lt;li&gt;5类LSA有FA地址，FA地址有效时，选路使用的是3类LSA的路由信息，FA地址无效时则是依据4类LSA选路，因此只要3类和4类LSA不出现环路，那么5类LSA就不会出现环路&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;MPLS VPN场景：
&lt;ol&gt;
&lt;li&gt;通过DN位防止3类LSA环路。不接收DN位置位的LSA&lt;/li&gt;
&lt;li&gt;通过TAG防止5类LSA的环路。在TAG中包含BGP的AS号，如果在TAG中包含本地的AS号，5类LSA不接收&lt;br&gt;
&lt;code&gt;OSPF接入MPLS VPN之后的防环机制：内部路由up/down比特设置、外部路由利用TAG防环(CE双归属等)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;dn比特位防环问题&#34;&gt;DN比特位防环问题&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612222691678.webp&#34; alt=&#34;DN比特位防环问题&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在CE双归属场景中，PE1、PE2、PE3都已建立iBGP连接，PE和CE之间使用OSPF路由协议；&lt;br&gt;
假设PE1先接收到来自PE3的VPNv4路由，PE1会将BGP路由引入到左侧站点的OSPF区域，PE2从OSPF中学习到该路由，下一跳指向CE1；&lt;br&gt;
PE上做了双向引入，所以PE2会将该OSPF路由引入到BGP形成VPNv4路由，同时将该路由通告给PE1；&lt;br&gt;
这时PE1从PE2和PE3接收到了同一条VPN路由，在链路开销相同的情况下，假设PE2的RouterID小于PE3的Router-ID，那么PE1会优选PE2为下一跳，环路就产生了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过DN比特位防环&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612222874199.png&#34; alt=&#34;通过DN比特位防环&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3/5/7类LSA的Option字段中DN比特位，用于&lt;strong&gt;表明路由是由PE向CE方向传递的&lt;/strong&gt;；&lt;br&gt;
PE发布给CE的路由（3/5/7类LSA）中DN比特位会被置1，同一用户站点的其他PE收到带有DN比特位置位的3/5/7类LSA时，不会进行SPF计算，更不会将其引入到BGP中；&lt;br&gt;
&lt;code&gt;RFC定义的DN比特位只会出现在3类LSA，但是华为在5/7类LSA中也设置了DN比特位&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DN位无法避免某些特定场景下的环路问题&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612223522508.png&#34; alt=&#34;CE双归属&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
CE双归属，CE1连接PE1的链路在Area0中，CE1连接PE2的链路在Area1中；&lt;br&gt;
当PE1以3类LSA的形式向CE1发送OSPF路由时DN比特位置1，由于CE是ABR，当这条3类LSA经过CE再传递到Area1时，DN比特位置0，PE2接收后仍然会计算该路由，造成环路；&lt;br&gt;
&lt;strong&gt;【防环策略】&lt;/strong&gt;：&lt;br&gt;
在华为设备中，5/7类LSA除了可以像3类LSA一样通过DN比特位来防环外，还可以通过Route-tag来防环；&lt;br&gt;
设置了Route-tag的PE路由器将OSPF外部路由发布给CE之前会使路由带上Route-tag；如果同一站点的其他PE路由器收到该OSPF外部路由时发现路由携带的Route-tag跟本端配置的一样，就会忽略该路由；可以通过Route-tag命令来设置路由域标记。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612223663061.png&#34; alt=&#34;Route-tag设置路由域标记&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ospf无效路由场景&#34;&gt;OSPF无效路由场景&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;网络类型不一致导致的无效路由。一端是点到点网络类型，另一端是广播网类型&lt;/li&gt;
&lt;li&gt;帧中继的hub-and-spoke场景，如果hub端不是DR会造成有LSA但是没有路由&lt;/li&gt;
&lt;li&gt;真ABR非骨干区域中收到的3类LSA只接收不选路，即没有路由&lt;/li&gt;
&lt;li&gt;ABR通过虚链路接收到的3类LSA在虚链路的所经过的区域中不存在，3类LSA只接收不选路，即没有路由&lt;code&gt;参考虚链路特点7&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;5类LSA中FA地址所在网段域内或者域间不可达，会造成有5类LSA但没有路由&lt;/li&gt;
&lt;li&gt;通过filter-policy import做路由过滤，有LSA但是没有路由&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ospf快速收敛机制&#34;&gt;OSPF快速收敛机制&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;OSPF按优先级收敛&lt;br&gt;
在大量路由情况下，通过对不同的路由配置不同的收敛优先级，使重要的路由先收敛。&lt;/li&gt;
&lt;li&gt;I-SPF&lt;br&gt;
增强型的SPF算法，当网络拓扑改变时，只对受影响的节点进行路由计算&lt;/li&gt;
&lt;li&gt;PRC&lt;br&gt;
部分路由计算（只针对3、5、7类LSA有效果），当网络上路由发生变化时，只对发生变化的路由进行重新计算&lt;code&gt;ospf中通告路由的LSA包含1、3、5、7类。在部署时，环回口的地址一般不使用network的方式，而使用import-route的方式，即保证接口down之后不去触发SPF，而是触发PRC，从而加速收敛&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;智能定时器&lt;br&gt;
&lt;code&gt;使用指数退避算法，包含3个计时器：初始延迟、增量延迟、最大延迟&lt;/code&gt;&lt;br&gt;
通过智能定时器来控制路由计算的延迟时间（OSPF规定的延迟时间时固定的），既能对低频率变化快速响应，又能对高频率变化进行有效抑制。&lt;/li&gt;
&lt;li&gt;Smart-discover&lt;br&gt;
路由器会周期性地（5秒）发送Hello报文，这种按固定周期发送报文的方式减缓了OSPF邻居关系的建立。&lt;br&gt;
在以下场景中，使能了Smart-discover特性的接口不需要等待Hello Timer到时，可以主动向邻居发送Hello报文：
&lt;ol&gt;
&lt;li&gt;当邻居状态首次到达2-way状态&lt;/li&gt;
&lt;li&gt;当邻居状态从2-way或更高状态迁移到Init状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;dr和bdr的作用&#34;&gt;DR和BDR的作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;减少邻接&lt;/strong&gt;关系的数量，从而&lt;strong&gt;减少链路状态信息以及路由信息的交换次数&lt;/strong&gt;，这样可以节省带宽，减少路由器硬件的负担。&lt;/li&gt;
&lt;li&gt;一个既不是DR也不是BDR的路由器&lt;strong&gt;只与DR和BDR形成邻接关系&lt;/strong&gt;并交换链路状态信息以及路由信息，这样就大大&lt;strong&gt;减少了大型广播型网络和NBMA网络中的邻接关系数量&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dr和bdr的选举&#34;&gt;DR和BDR的选举&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;两端同时进入2-way，开始选举&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先所有的路由器都会变成DR Others，检查Hello报文中的DR字段和BDR字段是否为空，如果都为空（意味着没有DR和BDR），会&lt;strong&gt;首先选举出BDR&lt;/strong&gt;，&lt;strong&gt;选举规则&lt;/strong&gt;：比较优先级，越大越优（默认为1，取置范围为0-255，&lt;code&gt;0表示不参与选举，停留在2-way状态&lt;/code&gt;）；如果相同，比较Router ID，越大越优；&lt;strong&gt;BDR选举出后，会自动升级为DR，然后重新选举BDR，规则和之前一样&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果DR字段为空，BDR不为空，则BDR升级为DR，重新再选举出BDR；如果BDR为空，DR不为空，重新选举出BDR&lt;br&gt;
&lt;code&gt;DR选举成功后会生成一个2类LSA在本区域内泛洪，BDR不会产生；如果DR失效，BDR切换成BDR时也会生成&lt;/code&gt;&lt;br&gt;
&lt;code&gt;如果同一个网段中只有唯一的一台设备通告自己为DR或者BDR，则通告者为DR或者BDR，DR或者BDR角色不抢占&lt;/code&gt;&lt;br&gt;
&lt;code&gt;DR是必须的而BDR可以没有；在同一个网段中只能存在一个DR和一个BDR，如果在同一个网络中存在多个DR和BDR需要进行抢占，重新选举&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf特点&#34;&gt;OSPF特点&lt;/h2&gt;
&lt;p&gt;OSPF，Open Shortest Path First，开放最短路径优先&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;收敛速度快（比较耗资源）&lt;/li&gt;
&lt;li&gt;无类路由协议，支持CIDR（无类域间路由）和VLSM（可变长子网掩码）&lt;/li&gt;
&lt;li&gt;OSPF支持负载均衡&lt;/li&gt;
&lt;li&gt;支持区域划分&lt;/li&gt;
&lt;li&gt;支持协议报文的认证（明文和密文）&lt;/li&gt;
&lt;li&gt;支持触发更新（不仅防环，还能更快的收敛）&lt;/li&gt;
&lt;li&gt;OSPF的路由优先级分内外，内部路由优先级为10，外部路由优先级为150&lt;/li&gt;
&lt;li&gt;OSPF的度量值采用开销cost作为标准&lt;/li&gt;
&lt;li&gt;OSPF是没有环路的协议，但仅限于一个区域内，在一个区域内是绝对无环的，基于算法的天然无环。OSPF在区域内是链路状态协议，在区域间是距离矢量协议。&lt;/li&gt;
&lt;li&gt;OSPF要维护3张表：邻居表、拓扑表、路由表【配置好OSPF之后，设备之间先泛洪LSA构建&lt;strong&gt;邻居表&lt;/strong&gt;，相互交换信息之后构建数据库LSDB，运行SPF算法形成&lt;strong&gt;路由表&lt;/strong&gt;】&lt;/li&gt;
&lt;li&gt;使用IP组播收发协议数据（组播地址：224.0.0.5&lt;sub&gt;AllSPFRouters，即所有开启ospf的设备都会监听此地址&lt;/sub&gt;和224.0.0.6&lt;sub&gt;AllDRouters，所有的指定路由器，即DR和BDR会监听&lt;/sub&gt;）&lt;/li&gt;
&lt;li&gt;OSPF为了确保链路状态数据库的同步，每1800秒（30分钟）更新一次&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;路由计算过程&#34;&gt;路由计算过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;建立邻居关系后泛洪LSA&lt;/li&gt;
&lt;li&gt;SPF算法计算最短路径树&lt;/li&gt;
&lt;li&gt;计算路由形成路由表&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf设备角色和宣告&#34;&gt;OSPF设备角色和宣告&lt;/h2&gt;
&lt;h3 id=&#34;路由器分类&#34;&gt;路由器分类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611550864893.png&#34; alt=&#34;路由器分类&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;内部路由器（IR）&lt;/strong&gt;：内部路由器是指所有所连接的网段都在一个区域的路由器，属于同一个区域的IR维护相同的LSDB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区域边界路由器（ABR）&lt;/strong&gt;：区域边界路由器是指连接到多个区域的路由器，ABR为每一个所连接的区域维护一个LSDB，连接&lt;strong&gt;骨干区域和非骨干区域&lt;/strong&gt;的设备&lt;br&gt;
&lt;code&gt;区分真假ABR的场景：真ABR从非骨干区域收到的3类LSA只接收（更新LSDB）、不选路（即不加入路由表）【因为真ABR是发送3类LSA的，如果接收后再选路可能会出现环路】；假ABR即接收又选路&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;假ABR：连接多个区域，并且有一个口宣告进了骨干区域&lt;/li&gt;
&lt;li&gt;真ABR：满足假ABR的条件后，还需要在骨干区域中有一个活动的邻接关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;骨干路由器（BR)&lt;/strong&gt;：骨干路由器是指至少有一个端口（或者虚连接）连接到骨干区域的路由器，包括所有的ABR和所有端口都在骨干区域的路由器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AS边界路由器ASBR&lt;/strong&gt;：和其他AS中的路由器交换路由信息的路由器，这种路由器向整个AS通告AS外部路由信息。&lt;br&gt;
&lt;code&gt;ABSR一般是位于非OSPF区域和OSPF区域间互联的路由器，而ABR是OSPF多个区域连接区域0间的路由器&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;接口宣告方式&#34;&gt;接口宣告方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程下通过network方式宣告&lt;br&gt;
进程下network宣告时将所有符合条件的接口全部宣告进ospf，宣告格式为&lt;code&gt;network 前缀 通配符&lt;/code&gt;，例如&lt;code&gt;network 192.168.1.0 0.0.0.255&lt;/code&gt;宣告的是192.168.1.0/24这个网段内所有有效地址【ACL的反掩码中的1可以不连续，但是ospf中必须连续】&lt;/li&gt;
&lt;li&gt;接口下宣告&lt;br&gt;
严格宣告，只能将该接口宣告进ospf。如果存在大量接口的情况下会增加工作量。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;【接口方式的选择】：如果地址不连续的情况下进行严格宣告（在接口下宣告），如果IP地址连续使用进程宣告方式&lt;/code&gt;&lt;br&gt;
&lt;code&gt;【宣告的作用】：1. 宣告的接口可以发送和接收ospf报文；2. 通告接口路由&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;router-id如何产生&#34;&gt;Router ID如何产生？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;手工指定&lt;br&gt;
可在ospf进程下或者全局下配置，进程由于全局&lt;/li&gt;
&lt;li&gt;自动选举&lt;br&gt;
比较逻辑接口，选择地址最大的一个；如果没有逻辑接口，比较&lt;strong&gt;活动&lt;/strong&gt;的物理接口IP，选择地址最大的。&lt;br&gt;
如果修改RouterID，不会立即生效，需要重启OSPF进程；多ospf进程可以共用一个Router ID，但是这样会存在问题，如下：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611703407612.png&#34; alt=&#34;自动选举&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
RA运行ospf进程1和2，但是Router ID全部为1.1.1.1，RB运行ospf进程1，Router ID为2.2.2.2，会导致路由震荡，原因参考《影响OSPF邻接关系建立的因素》中的Router ID&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;接口状态机&#34;&gt;接口状态机&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611845727075.png&#34; alt=&#34;接口状态机&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Waiting和2-way有什么关联？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;waiting状态是接口状态机，是开始等待选举DR，设备正在判定网络上的DR和BDR&lt;/li&gt;
&lt;li&gt;2-way状态开始选举DR和BDR&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;虚连接虚链路&#34;&gt;虚连接（虚链路）&lt;/h2&gt;
&lt;h3 id=&#34;特点&#34;&gt;特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;虚链路永远属于区域0&lt;code&gt;虚链路端点都将成为ABR并在区域间传递路由，可以执行聚合/区域间路由过滤&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;虚链路的始发区域永远是区域0，否则没有意义&lt;/li&gt;
&lt;li&gt;虚链路通过单播的方式发送报文，即TTL=255&lt;/li&gt;
&lt;li&gt;虚链路必须配置在两台ABR路由器之间&lt;/li&gt;
&lt;li&gt;虚链路只能配置在普通区域中，不能配置在特殊区域中&lt;code&gt;即传送区域不能是一个末梢区域&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;虚链路的稳定性取决于其经过的区域的稳定性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;虚链路的本质&lt;/strong&gt;：虚链路就是通过非骨干区域打一条通道直接连接骨干区域，即通过一个非骨干区域连接一个区域（或者分段）到骨干区域&lt;/li&gt;
&lt;li&gt;虚链路只能在同一区域内建立，不能跨区域建立&lt;code&gt;虚链路只能穿越一个区域，隧道可以穿越多个区域，虚链路需要有到达对方的路由&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;虚链路属于按需链路，需要将option字段中的DC位置位【但是华为是通过点到点的方式来维护的，不属于按需链路】&lt;/li&gt;
&lt;li&gt;虚链路配置时需要指定邻居的RouterID，通过两次SPF算法确定目标地址和源地址，建立单播连接&lt;/li&gt;
&lt;li&gt;ABR通过虚链路学到的路由，虚链路所经过的区域也应该有此路由条目，否则为无效路由&lt;br&gt;
如下图中路由1.1.1.1/32。在AR2上将去往AR3的1.1.1.1/32的lsa过滤掉，那个AR3上不存在1.1.1.1/32这个路由条目，又因为虚链路的所经过区域为区域1，所以AR4上没有1.1.1.1/32的路由。即使会有，那么AR4发给AR3也会出现路由黑洞，&lt;strong&gt;因为虚链路的流量最终也是通过物理链路转发的&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612011041364.png&#34; alt=&#34;注意&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;虚链路的区域不存在区域0的汇总路由&lt;code&gt;即在所经过的区域内不能对区域0的路由进行汇总，和第7点原理相似，路由聚合之后就没有了路由明细&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612273781443.png&#34; alt=&#34;不存在区域0的汇总路由&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果R2上聚合后产生3类LSA(包含路由10.0.0.0/8)，R4上聚合后产生3类LSA (包含路由10.1.0.0/16)， R3收到R2和R4通告的3类LSA后，R3上10.0.0.0/8路由下一跳指向R2，而10.1.0.0/16 路由下一跳指向R4，若R3收到访问10.1.3.1的数据包，R3路由报文到R4，R4上有虚链路，即R4路由表中有到达区域0中10.1.1.0/24、10.1.2.0/24、10.1.3.0/24的路由且下一跳R3，R4会送流量到R3，R3会送流量到R4，路由环路出现。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;虚连接的远端地址：&lt;br&gt;
虚连接的两个端点需要相互交换协议报文，但是虚连接的邻居是用RouterID来标识的，不能作为协议报文的目的IP地址。&lt;strong&gt;每个虚连接的端点都要计算两个最短路径树，一个是本地最短路径树，另一个是虚连接邻居的最短路径树&lt;/strong&gt;。计算虚连接邻居的最短路径树之后，在最短路径树上查找如何到达本地路由器（通过RouterID来标识），虚连接邻居到达本地路由器的出端口的IP地址为本地路由器发送给虚连接邻居的报文目的IP地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;好处&#34;&gt;好处&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以解决网络设计缺陷&lt;/li&gt;
&lt;li&gt;可以当做后门链路使用，避免次优路径&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;不能针对来自于区域0的路由条目做汇总&lt;/li&gt;
&lt;li&gt;RID冲突或者修改RID会造成虚链路不稳定&lt;/li&gt;
&lt;li&gt;会引发环路的问题&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587917548285.png&#34; alt=&#34;虚连接--环路&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;场景一：&lt;/strong&gt;&lt;br&gt;
为了实现区域2方位区域0，需要在AR1和AR4之间做虚链路。AR4向区域1通告一条3类LSA(5.5.5.5)给AR1【AR4也会给AR3通告一条3类LSA，但是AR3接收后不选路】，AR1会将这条3类LSA传递给AR3，所以AR3访问5.5.5.5走的是AR3--AR2--AR1--AR4--AR5【但物理链路是AR3--AR2--AR1--AR3】，因为做了虚连接，AR1想要访问5.5.5.5，必须走AR4，但是去往AR4，物理上必须经过AR3，但是到了AR3以后，AR3去往5.5.5.5，则把流量又转发到AR2，结果出环。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;虚连接防环&#34;&gt;虚连接防环&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;不能将骨干区域的汇总发布到虚链路穿越的区域&lt;/li&gt;
&lt;li&gt;虚连接所传递的1类LSA不会再传递回虚连接所经过的区域&lt;/li&gt;
&lt;li&gt;源于虚连接的3类LSA不会再通告回虚连接所经过的区域&lt;/li&gt;
&lt;li&gt;虚连接无法在所经过区域对区域0的路由汇总&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;解决非骨干区域没有连接到骨干区域的问题
&lt;ol&gt;
&lt;li&gt;不能在AR3和AR4之间创建虚链路，因为这相当于将区域0分割了，即AR1/2之间和AR3/4上都配置了区域0&lt;/li&gt;
&lt;li&gt;在AR2/3上创建虚连接相当于区域0被延伸，即AR1/2/3都属于区域0&lt;/li&gt;
&lt;li&gt;AR3上会收到来自AR1的1类和3类(只接受不计算)LSA&lt;/li&gt;
&lt;li&gt;AR1上的路由会通过3类LSA通告给哪些区域：&lt;strong&gt;只有区域2&lt;/strong&gt;，因为区域1是这条3类LSA的所经过区域&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;解决骨干区域被分割的问题
&lt;ol&gt;
&lt;li&gt;AR2和AR3是真ABR，只接受3类LSA但不计算路由，导致AR1和AR4不能互访&lt;/li&gt;
&lt;li&gt;在AR2和AR3上创建虚链路，相当于AR2和AR3通过虚链路加入区域0，AR1用1类LSA通告给AR3（AR4会将1类LSA通告给AR2），然后AR3会通告给AR4【在AR3上通过计算1类和2类LSA，不再计算3类LSA，实现AR4和AR1互通】&lt;br&gt;
&lt;code&gt;通过虚链路收到路由条目 而 产生的3类LSA，不会再通告回虚链路的所进过区域&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;解决没有骨干区域的场景（可以建立虚连接充当骨干区域，即虚连接相当于骨干区域，只有华为设备可以，思科设备不支持）
&lt;ol&gt;
&lt;li&gt;AR25针对区域1生成的3类LSA会通告给区域0和区域2；AR25针对区域2生成的3类LSA会通告给区域1&lt;/li&gt;
&lt;li&gt;AR26针对区域3生成的3类LSA会通告给区域0和区域2；AR26针对区域2生成的3类LSA会通告给区域3&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;保障骨干区域的健壮性（预防骨干区域被分割或者ABR只接受三类LSA不选路的问题）&lt;/li&gt;
&lt;li&gt;解决次优路径问题（域内3类LSA优先级低于1类LSA，即内部OSPF优先级(AR19)&amp;gt;外部OSPF优先级(AR18)）
&lt;ol&gt;
&lt;li&gt;场景是AR21访问AR15的10.10.10.10。做虚连接之前，AR21上针对10.10.10.10的LSA有两条，一是区域0中从右边链路通告下来的1类LSA，二是由AR18转换成3类LSA通告给AR20的，所以AR21走1类LSA的路由，即走右边&lt;/li&gt;
&lt;li&gt;做虚连接之后，从AR16传给AR18的1类LSA，AR18也会传给AR20，这样AR20会收到关于10.10.10.10的两条1类LSA，然后cost越小越好，选择左边&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587830850069.png&#34; alt=&#34;虚连接应用场景&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;spf计算过程的两个阶段&#34;&gt;SPF计算过程的两个阶段&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;只在一个区域内计算，即只涉及到1类和2类LSA&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算transit和p2p节点，忽略stub节点，生成一个最短路径树，即构建SPF树。依据Router-LSA和Network-LSA。&lt;/li&gt;
&lt;li&gt;只计算stub节点，将stub网段挂到最短路径树上去，即计算最优路由。依据SPF树干和Router-LSA、Network-LSA中的路由信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;特殊区域&#34;&gt;特殊区域&lt;/h2&gt;
&lt;h3 id=&#34;1-stub&#34;&gt;1. Stub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置stub区域的目的：减少LSA的数量，即减少stub区域内部路由器上lsdb的规模和内存需求，从而避免资源的浪费，同时可以更好的控制LSA的传递和区域的管理（主要用于连接客户端的区域或者性能比较低的设备）&lt;/li&gt;
&lt;li&gt;将区域设置为末节区域，需要在末节区域的所有设备上配置&lt;code&gt;stub&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;末节区域会&lt;strong&gt;过滤五类LSA（四类LSA也会被过滤掉）&lt;/strong&gt;，ABR会向该区域下放一条&lt;strong&gt;默认路由（三类LSA）&lt;/strong&gt;，使其能够正常访问外部路由&lt;/li&gt;
&lt;li&gt;无法配置外部路由（即便强行配置也无法配置上去）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-totally-stub&#34;&gt;2. Totally Stub&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只需要在ABR上配置，区域内其他设备配置为末节区域即可&lt;/li&gt;
&lt;li&gt;完全末节区域不仅会&lt;strong&gt;过滤掉四类和五类LSA，也会过滤掉三类LSA(通过ABR过滤的)&lt;/strong&gt;，同时ABR会向该区域下放一条&lt;strong&gt;默认路由（三类LSA）&lt;/strong&gt;，使其能够正常访问外部路由（一共有三类LSA：一类、二类和下放路由使用的三类）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Stub和Totally Stub的一些条件（特点）&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;建议该区域只能有一个出口，即只有一个ABR&lt;/li&gt;
&lt;li&gt;虚连接不能跨越Stub区域（因为虚连接永远属于区域0）&lt;/li&gt;
&lt;li&gt;Stub区域不能有ASBR（访问外部路由是通过ABR生成的3类LSA通告的默认路由）&lt;/li&gt;
&lt;li&gt;不能将骨干区域配置为Stub区域&lt;/li&gt;
&lt;li&gt;Stub区域发送的Hello报文中的E比特位会置0&lt;/li&gt;
&lt;li&gt;totally stub区域不接收3和5类，只需要在ABR上配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;3-nssa&#34;&gt;3. NSSA&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;产生背景&lt;/strong&gt;：OSPF规定Stub区域不能引入外部路由，这样可以避免大量外部路由对Stub区域路由器带宽和存储资源的消耗。对于&lt;strong&gt;既需要引入外部路由又要避免外部路由带来的资源消耗的场景&lt;/strong&gt;，stub区域就不在满足需求，因此产生了NSSA区域&lt;/li&gt;
&lt;li&gt;将区域设置为NSSA区域，需要在末节区域的所有设备上配置&lt;code&gt;nssa&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;NSSA区域会&lt;strong&gt;过滤五类LSA（四类LSA也会被过滤掉）&lt;/strong&gt;，同时引进七类LSA（即NSSA-LSA，是由五类LSA转换而成），同时ABR会向该区域下放一条&lt;strong&gt;默认路由（七类LSA）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;七类LSA的优先级：ON1（类似OE1）和ON2(类似OE2)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;FA地址&lt;/strong&gt;：对于&lt;strong&gt;五类LSA是可选项&lt;/strong&gt;，但是&lt;strong&gt;七类LSA是必选项&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在五类LSA中&lt;/strong&gt;，FA地址只有满足那三个条件才会携带，携带的是下一条的地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在七类LSA中&lt;/strong&gt;，如果满足5类LSA的3大条件，FA地址是ASBR上外部路由的下一跳地址；如果没有将引入外部路由下一跳地址所在网段宣告进OSPF，则优选宣告进ospf的逻辑接口IP地址最大的一个；如果没有逻辑接口宣告进OSPF，则优选宣告进ospf中活动的物理接口地址较大的一个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;4-totally-nssa&#34;&gt;4. Totally NSSA&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只需要在ABR上设置，区域内其他路由设备设置为naas即可&lt;/li&gt;
&lt;li&gt;过滤掉&lt;strong&gt;三类、四类和五类LSA&lt;/strong&gt;，同时引入外部路由作为七类LSA存在，同时ABR会向该区域通告&lt;strong&gt;两条默认路由：一个是三类sum-net（优先级高），一个是七类nssa&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Nssa和Totally Nssa的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;nssa区域可以包含ASBR，引入外部路由。为了实现可以过滤5类LSA的目的，会将引入的外部路由以7类LSA的方式来通告，7类LSA的传递范围是在NSSA区域内&lt;/li&gt;
&lt;li&gt;在nssa区域中，ABR会以7类LSA通告一条默认路由&lt;/li&gt;
&lt;li&gt;在totally nssa区域中，ABR会以3类和7类LSA各通告一条默认路由&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;lsa在各区域中传播的支持情况&#34;&gt;LSA在各区域中传播的支持情况&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;区域类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Stub&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;TotallyStub&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;NSSA&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;TotallyNSSA&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;普通区域(包含骨干和非骨干)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域中LSA类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1/2/3。ABR产生默认3类(0.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1/2。ABR产生默认3类(0.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1/2/3/7。ABR(ASBR)产生默认7类(0.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1/2/7。ABR(ASBR)产生默认3类(0.0.0.0)和默认7类(0.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1/2/3/4/5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR/ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不允许ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不允许ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;允许部署ABR/ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;允许部署ABR/ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;允许部署ABR和ASBR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;ospf通告默认路由的方式&#34;&gt;OSPF通告默认路由的方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;普通区域：&lt;br&gt;
通过&lt;code&gt;default-route-advertise&lt;/code&gt;命令通告默认路由：
&lt;ol&gt;
&lt;li&gt;追加always参数后，如果本地&lt;strong&gt;不存在&lt;/strong&gt;默认路由，则生成一条&lt;strong&gt;5类LSA&lt;/strong&gt;通告默认路由。&lt;/li&gt;
&lt;li&gt;不追加always参数，只有在本地存在一条&lt;strong&gt;除了OSPF以外其它协议通告的默认路由&lt;/strong&gt;，才&lt;strong&gt;可以生成一条默认路由&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特殊区域
&lt;ol&gt;
&lt;li&gt;Stub区域和Totally Stub区域：由ABR设备生成3类LSA通告默认路由&lt;/li&gt;
&lt;li&gt;Nssa区域：通过&lt;code&gt;nssa default-route-advertise&lt;/code&gt;命令通告一条7类的默认路由，但是在NSSA区域中&lt;strong&gt;没有always参数&lt;/strong&gt;，说明在NSSA区域中必须在存在一条除了ospf以外其它协议通告默认路由的前提下，才能通告一条默认&lt;/li&gt;
&lt;li&gt;Totally Nssa区域：ABR会下放两条缺省的默认路由，分别是3类和7类LSA，3类LSA优先级更高&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf的聚合汇总和过滤&#34;&gt;OSPF的聚合(汇总)和过滤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;路由聚合&lt;br&gt;
&lt;code&gt;只能在ABR和ASBR上进行路由汇总，汇总之后，非本区域设备无法看到相应的明细路由&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;区域间路由汇总(ABR聚合)：在ABR上完成，聚合AS内区域之间的路由，以网段为单位生成3类LSA。需要汇总的网段所在的OSPF区域中进行配置&lt;/li&gt;
&lt;li&gt;外部路由聚合(ASBR聚合)：在ASBR上完成，聚合OSPF引入的外部路由，对引入的聚合地址范围内的5类LSA进行聚合。在OSPF进程下配置&lt;br&gt;
&lt;code&gt;当配置了NSSA区域时，还要对引入的聚合地址范围内的7类LSA进行聚合，如果本地设备既是ASBR又是ABR，则对由7转5的LSA进行聚合处理&lt;/code&gt;&lt;br&gt;
&lt;code&gt;路由聚合后的cost值选择聚合之前最小值&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由过滤&lt;br&gt;
OSPF可以使用路由策略route-policy、访问控制列表（access-list）和地址前缀列表（prefix-list）对路由信息进行过滤，OSPF路由过滤可以应用于以下几个方面：
&lt;ol&gt;
&lt;li&gt;路由引入&lt;br&gt;
OSPF可以引入其它路由协议学习到的路由，在引入时可以通过配置路由策略来过滤路由，只引入满足条件的路由。&lt;/li&gt;
&lt;li&gt;引入路由发布&lt;br&gt;
OSPF引入了路由后会向其它邻居发布引入的路由信息，可以通过配置过滤规则来过滤向邻居发布的路由信息，该过滤规则只在ASBR上配置才有效。&lt;br&gt;
例如：在ASBR上通过filter-policy做export方向过滤，针对从路由表中重分发进OSPF的路由条目做过滤&lt;/li&gt;
&lt;li&gt;路由学习&lt;br&gt;
通过配置过滤规则，可以设置OSPF对接收到的区域内、区域间和自治系统外部的路由进行过滤。该过滤只作用于路由表项的添加与否，即只有通过过滤的路由才被添加到本地路由表中，但所有的路由仍可以在OSPF路由表中被发布出去。&lt;br&gt;
例如：可以在所有设备上使用filter-policy做import方向过滤，只能过滤从OSPF加入到RIB路由表的路由条目，不能过滤入方向LSA，但是会影响3类LSA等发布。例如在&lt;strong&gt;ABR上&lt;/strong&gt;的入方向配置此过滤，虽然不能影响接收LSA，但是会ABR的3类LSA的发布，因为此路由没有加入路由表，也就是说明这条路由无效，那么&lt;strong&gt;肯定不会发布包含此条路由的3类LSA&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;区域间LSA学习&lt;br&gt;
可以在所有设备上使用filter-policy做import方向过滤，只能过滤从OSPF加入到RIB路由表的路由条目，&lt;strong&gt;不能过滤LSA&lt;/strong&gt;。如果该方法在普通设备上，只影响本地；如果在ABR上配置。还会影响其他设备，主要是通过影响3类LSA导致路由无法传递。&lt;br&gt;
&lt;strong&gt;区域间LSA学习和路由学习之间的差异&lt;/strong&gt;：区域间LSA学习直接对进入区域的LSA进行过滤；路由学习不是对LSA进行过滤而是对LSA计算出来的路由是否添加本地路由表进行过滤，学习到的LSA是完整的。&lt;/li&gt;
&lt;li&gt;区域间LSA发布&lt;br&gt;
在ABR上配置路由汇总不通告(即携带参数&lt;code&gt;not-advertise&lt;/code&gt;)或者使用filter命令过滤3类LSA，或者在所有设备的接口上配置ospf filter-lsa-out命令过滤接口上发送的3类、5类、7类&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf的时间&#34;&gt;OSPF的时间&lt;/h2&gt;
&lt;h3 id=&#34;1-lsrefreshtimelsa定时刷新时间&#34;&gt;1. LSRefreshTime（LSA定时刷新时间）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;1800秒&lt;/code&gt;&lt;br&gt;
为确保数据库的准确性，OSPF每隔30分钟对每条LSA记录刷新一次，每刷新一次序列号加1。&lt;br&gt;
收到新的LSA后，LSA将重置计时器，又重新计算时间。如果1小时内，未被刷新，LSA将从数据库中删除。&lt;br&gt;
有时序列号需要循环回最初的值，在这种情况下，LSA提前作废，（最大寿命定时器立即被设置 为1 ）并被删除。然后，LSA重新使用序列号0X800001。&lt;/p&gt;
&lt;h3 id=&#34;2-maxagelsa老化时间&#34;&gt;2. MaxAge（LSA老化时间）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;3600秒&lt;/code&gt;&lt;br&gt;
OSPF每隔1800s定时刷新一次LSA，如果LSA在3600s内未被刷新，LSA将从数据库中删除，即老化掉。&lt;/p&gt;
&lt;h3 id=&#34;3-rxmtinterval邻接重传lsa的间隔时间&#34;&gt;3. RxmtInterval（邻接重传LSA的间隔时间）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;5秒&lt;/code&gt;&lt;br&gt;
没有得到确认的情况下，重传OSPF packet所等待的时间长度，默认为5秒。&lt;/p&gt;
&lt;h3 id=&#34;4-hello相关的时间&#34;&gt;4. Hello相关的时间&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;HelloInterval（发送Hello包的时间间隔）：10s/30s&lt;br&gt;
路由器接口上发送Hello包的时间间隔。&lt;/li&gt;
&lt;li&gt;RouterDeadInterval（未收到Hello后关闭Router的时间）：40s/120s&lt;br&gt;
如果在4倍于HelloInterval间隔里(40秒和120秒内)仍然没有收到来自邻居的新的Hello包，这个邻居将被宣告为无效(dead)。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-waittimerdr的选举等待时间&#34;&gt;5. WaitTimer（DR的选举等待时间）：&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;40秒&lt;/code&gt;&lt;br&gt;
先启动OSPF进程的路由器会等待一段时间，这个时间内没有启动其它路由的OSPF进程的话，第一台路由就认为自己是DR，之后再加进来的也不能在选举了，这个等待时间叫做WaitTimer计时器。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;one-way-是什么状态如何进入-two-way&#34;&gt;one-way 是什么状态，如何进入 two-way&lt;/h2&gt;
&lt;p&gt;当收到一个Hello 包中，没有包含自己的router id时为one-way，当收到的HELLO包中包含自己的 router id则为two-way&lt;/p&gt;
&lt;h2 id=&#34;dr的选举过程及时间&#34;&gt;DR的选举过程及时间&lt;/h2&gt;
&lt;p&gt;首先所有的路由器都会成为DR others，先选举BDR，BDR发现没有DR，自动成为DR，DR others发现没有BDR，再选举出来一个BDR。&lt;br&gt;
DR的选举时间等于40秒（WaitingTimer），不可更改，只有在广播和NBMA中才会选举DR。&lt;/p&gt;
&lt;h2 id=&#34;first-dbd与dbd的区别&#34;&gt;first DBD与DBD的区别&lt;/h2&gt;
&lt;p&gt;firstDD也称为空DD，作用是选举出主从，并且统一1个序列号，保证数据库同步过程的有序可靠&lt;/p&gt;
&lt;h2 id=&#34;如何选举主从选举主从的作用&#34;&gt;如何选举主从，选举主从的作用&lt;/h2&gt;
&lt;p&gt;选择router id大的为主，作用是统一接下来交互的DD报文序列号，保证同步数据库同步的有序可靠&lt;/p&gt;
&lt;h2 id=&#34;ospf协议的可靠性如何保证&#34;&gt;OSPF协议的可靠性如何保证？&lt;/h2&gt;
&lt;p&gt;利用OSPF协议的显示确认（LSAck）和隐式确认机制（Hello、DBD、LSR+LSU）&lt;br&gt;
邻居建立过程中，Hello报文回复对方时会携带对方的Router ID；&lt;br&gt;
DBD报文选举主从后，只有主才能产生序列号，从会确认主的序列号；&lt;br&gt;
发送LSR之后对方回应LSU，如果没有收到LSU，需要重传LSR（5秒钟）。&lt;br&gt;
&lt;code&gt;Retransmit Timer=5秒，这只针对DBD、LSR和LSU，hello和LSAck是没有重传机制的&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Transmit Delay=1秒，转发延时，只用于LSA&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;除了lsa的确认机制外针对发送的lsu还有没有其它确认机制&#34;&gt;除了LSA的确认机制外，针对发送的LSU还有没有其它确认机制&lt;/h2&gt;
&lt;p&gt;DR可以进行隐式确认，当DR收到DR others的LSU时，不需要回复LSACK，因为DR会向其他的DR others发送LSU的更新，这就进行了隐式确认&lt;code&gt;DR others向DR发送更新为224.0.0.6，DR向DR others发送的更新地址为224.0.0.5&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611588642642.jpg&#34; alt=&#34;针对发送的LSU还有没有其它确认机制&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ospf协议为什么先进行bdr选举然后才是dr&#34;&gt;ospf协议为什么先进行BDR选举，然后才是DR&lt;/h2&gt;
&lt;p&gt;因为DR和BDR的切换状态机是：当DR失效时，BDR成为DR。&lt;br&gt;
如果先选举DR，再选举BDR，那么当选举BDR的过程中DR失效，那么此时网络中既没有DR也没有BDR，切换将无法进行，状态机也就没办法做了。所以，先有BDR，后有DR是为了保证状态机能工作。&lt;/p&gt;
&lt;h2 id=&#34;hello报文中的dr和bdr字段为什么是接口地址而不是routerid&#34;&gt;Hello报文中的DR和BDR字段为什么是接口地址而不是RouterID&lt;/h2&gt;
&lt;p&gt;DBD、LSR和LSU是可以通过单播方式发送的，单播报文需要的是DR others与DR或者BDR相连 的 DR或者BDR接口的IP（单播报文的目的地址），而通过RouterID是无法作为单播报文的目的地址的&lt;/p&gt;
&lt;h2 id=&#34;收到lsa之后的处理流程&#34;&gt;收到LSA之后的处理流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;先查看本地是否是否存在此LSA
&lt;ol&gt;
&lt;li&gt;不存在：添加到数据库-&amp;gt;回复LSAck-&amp;gt;泛洪该LSA-&amp;gt;使用SPF算法计算路由&lt;/li&gt;
&lt;li&gt;存在：比较LSA的新旧&lt;br&gt;
1. 新：添加到数据库-&amp;gt;回复LSAck-&amp;gt;泛洪该LSA-&amp;gt;使用SPF算法计算路由&lt;br&gt;
2. 旧：忽略该条LSA，发送本地更新的LSU给发送(LSA)方&lt;br&gt;
3. 相同：忽略&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf路由的优先级&#34;&gt;OSPF路由的优先级&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;首先比较路由类型&lt;/strong&gt;：O(一类和二类) &amp;gt; OIA(三类) &amp;gt; OE1=ON1(比较cost) &amp;gt; OE2=ON2(比较cost)【五类和七类的优先级相同，即华为不区分五类和七类LSA】&lt;br&gt;
如果路由类型相同的情况下&lt;strong&gt;再比较cost值&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;5类lsa为什么需要fa地址&#34;&gt;5类LSA为什么需要FA地址？&lt;/h2&gt;
&lt;p&gt;为了防止次优路径和环路&lt;/p&gt;
&lt;h3 id=&#34;1-次优路径&#34;&gt;1. 次优路径&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612068963552.png&#34; alt=&#34;FA地址&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AR1/2/3通过交换机互联，只在AR1/2之间运行OSPF，在AR2上引入外部路由AR3的3.3.3.3。&lt;br&gt;
AR2是ASBR，然后在区域内泛洪5类LSA，那么AR1想要访问AR3，如果没有FA地址的情况下，则路由为AR1--AR2--AR3，很明显这是次优路径。&lt;br&gt;
如果存在FA地址，那么AR1收到5类LSA之后，只会计算到达FA地址(AR3物理接口地址)的距离矢量，那么路由为AR1--AR3，不需要经过ASBR（AR2）的转发。&lt;/p&gt;
&lt;h3 id=&#34;2-环路&#34;&gt;2. 环路&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612196473018.bmp&#34; alt=&#34;环路&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在R1上引入外部路由1.1.1.0/24，默认为类型2，默认cost为1（即外部cost）&lt;br&gt;
有FA地址的情况：R4访问1.1.1.0/24的路径为R4--R2--R1&lt;br&gt;
没有FA地址的情况：R4访问1.1.1.0/24的路径为R4--R3--R2--R4（环路）&lt;br&gt;
&lt;strong&gt;分析步骤如下&lt;/strong&gt;：&lt;br&gt;
默认情况下进行7转5选择的是RouterID较大的ABR，在此拓扑中为AR3（即AR3为ASBR），则NSSA区域内7类LSA的转发路径为R1--R2--R3。&lt;br&gt;
如果正常携带FA地址，R3转换成的5类LSA携带正常的FA地址，那么R4收到5类LSA时，同时会通告给R2，R4会计算到达FA地址的cost（10+1），优选R1。&lt;br&gt;
如果7类LSA不携带FA地址或者将7转5抑制掉，R2收到之后发现7类LSA中没有LSA，那么只计算到大ASBR的距离，通过5类（R4传给R2的5类LSA）到大ASBR的内部cost为2，通过7类到达ASBR的内部cost为10，所以优选5类LSA，即下一跳为R4。AR2访问1.1.1.0/24的路径为AR2--AR4--AR3--AR2--AR4，因此成环。&lt;/p&gt;
&lt;h2 id=&#34;外部路由选路问题&#34;&gt;外部路由选路问题&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612070863853.bmp&#34; alt=&#34;外部路由选路问题&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在AR2和AR3上将rip路由引入OSPF，分以下场景&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引入时不配置路由类型（默认为OE2）、不指定cost值（默认cost值为1），则在AR4上选路时会进行负载。&lt;/li&gt;
&lt;li&gt;在AR2上指定cost值为2，AR3上指定cost值为1，路由类型都是默认的OE2，则AR4会选择AR3。&lt;/li&gt;
&lt;li&gt;在AR2上指定路由类型为OE1（cost=2），AR3上为默认的OE2（cost=1），则AR4会选择AR2。&lt;/li&gt;
&lt;li&gt;在AR2/3上指定路由类型为OE1，AR2的cost为2，AR3的cost为1，则AR4会选择AR3。&lt;/li&gt;
&lt;li&gt;在AR2/3引入时保持默认，即路由类型为OE2，cost=1，将AR4的g0/0/1（与AR2相连）的cost改为10，g0/0/0（与AR3相连）的cost改为20，则AR4优选AR2&lt;code&gt;OE2在外部cost相同时比较内部cost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果在5的基础上将AR2引入时的cost值改为2，则AR4优先AR3&lt;code&gt;先比较外部cost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在6的基础上将AR3引入的cost改为10、类型为OE1（AR2上cost=2，OE2，内部cost10；AR3上cost为10，OE1，内部cost20），AR4优选AR3&lt;code&gt;首先比较路由类型OE1&amp;gt;OE2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;AR2和AR3上均为OE2、cost=1、内部cost=10，现在将AR2的g0/0/0宣告进ospf，则AR4优选AR3&lt;code&gt;AR2在通告的5类LSA中会携带FA地址，FA地址为引入外部路由下一跳地址，即AR1的g0/0/0接口地址，那么AR4计算到达FA地址的距离10+1=11；而AR3通告的5类LSA没有FA地址，那么只计算到达AR3的距离10，所以会优选AR3&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;引入1211024和1211030两条外部路由会通告几条5类lsa&#34;&gt;引入12.1.1.0/24和12.1.1.0/30两条外部路由，会通告几条5类LSA?&lt;/h2&gt;
&lt;p&gt;两条。&lt;br&gt;
通过判断头部type、ADV和LS ID来判断是否为同一条LSA，这两条5类LSA，通告12.1.1.0/24的前缀仍然为12.1.1.0，但是通告12.1.1.0/30的前缀变为12.1.1.3，即本网段的广播地址，然后通过5类LSA中的网络掩码来恢复地址，即如果&lt;strong&gt;出现LSID冲突&lt;/strong&gt;，会&lt;strong&gt;使用本网段的广播地址来替代网络前缀来通告本网段&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;不同进程下学到同一条路由类别和开销都相同&#34;&gt;不同进程下学到同一条路由(类别和开销都相同)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1612077070764.png&#34; alt=&#34;不同进程下学到同一条路由&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;路由表中会进行负载&lt;/strong&gt;。如果ASBR1引入时路由类型为OE1，ASBR2引入时为OE2，也是负载，因为&lt;strong&gt;不同进程下是不会进行路由类型比较的，由路由表决定，先比较优先级，再比较cost值&lt;/strong&gt;。R1会从2个进程收到同一条路由，每个进程下各自选路装进路由表，等同于两个路由协议之间选择哪条路由进入路由表，决定权在路由表。&lt;/p&gt;
&lt;h2 id=&#34;如何减小ospf的lsdb的大小&#34;&gt;如何减小ospf的lsdb的大小&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;分区域设计：1类和2类LSA只在本区域泛洪，分区域后可以减少每个区域1类和2类LSA的数量&lt;/li&gt;
&lt;li&gt;特殊区域：特殊区域无法传递5类，可以减少ospf域中5类LSA的数量&lt;/li&gt;
&lt;li&gt;过滤的方式有三种：
&lt;ol&gt;
&lt;li&gt;filter命令过滤3类LSA，在区域下使用，可以在 import和export方向&lt;/li&gt;
&lt;li&gt;filter lsa out命令过滤3类、5类、7类或者全部LSA&lt;/li&gt;
&lt;li&gt;filter-policy，在ospf执行了SPF计算后，对加入路由表的路由进行过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;汇总：summary+not-advertise，汇总也可以执行过滤。需要注意做了虚链路的区域不能针对区域0的路由进行汇总，否则可能会产生环路&lt;/li&gt;
&lt;li&gt;2类LSA也可以减小ospf的LSDB，但这不属于我们控制范围&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf的路由选路原则以及负载的场景&#34;&gt;OSPF的路由选路原则以及负载的场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;选路原则：区域内&amp;gt;区域间&amp;gt;区域外（类型1&amp;gt;类型2&lt;code&gt;（默认外部路由类型）&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;外部路由选路：&lt;code&gt;类型1（cost为内外之和）&amp;gt;类型2（cost内外分离，先看外再看内）&lt;/code&gt;&lt;br&gt;
1. 类型1：cost越小越优 &amp;gt; 优选非骨干 &amp;gt; 区域号越大越优&lt;br&gt;
2. 类型2：外部cost越小越优 &amp;gt; 内部cost越小越优 &amp;gt; 优选非骨干 &amp;gt; 区域号越大越优&lt;br&gt;
&lt;code&gt;外部路由负载条件：cost和区域一致&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;举例：R4与R5上分别引入外部路由，问R1如何去往这两条外部路由&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1612453012239.png&#34; alt=&#34;R1如何去往这两条外部路由&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分析4.4.4.4/32外部路由：&lt;br&gt;
R4引入这条外部路由，会在区域0和区域1均发布一条5类LSA但不会发布4类LSA，R1也可以在区域0和区域1收到5类LSA，对于该路由ASBR是R4，R1可以通过区域内路径到达，此时有两条区域内路径，R1按如下顺序优选：&lt;strong&gt;默认为类型2且外部cost一样，首先选择内部cost值较小的，其次优选非骨干，如果以上均相等，则负载分担&lt;/strong&gt;。经过比较优选R3。&lt;/li&gt;
&lt;li&gt;分析5.5.5.5/32这条路由：&lt;br&gt;
R4收到R5发布的5类LSA会向区域0和区域1转发，同时产生一条4类LSA，该4类LSA会向区域0和区域1泛洪。R1在收到5类LSA之后需要根据4类LSA计算路径，R1可以收到两条4类LSA，分别通过区域0和区域1，由于R1自己也是ABR，它不会使用从非骨干区域（此时是区域1）接收到的3类和4类LSA做选路&lt;code&gt;即4类的防环机制：真ABR对从非骨干区域接收到额3类和4类LSA，只接收不选路&lt;/code&gt;，这是OSPF防环设计决定的，因此R1优选R2为下一跳。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;外部路由选路原则详解&#34;&gt;外部路由选路原则详解&lt;/h3&gt;
&lt;p&gt;RFC1583与RFC2328是&lt;strong&gt;针对外部路由由不同选优方式&lt;/strong&gt;：&lt;br&gt;
X（内部开销）=内部设备到转发地址(FA)的开销（FA为0时，X为到ASBR的开销）&lt;br&gt;
Y（外部开销）=外部路由重分发进来时LSA携带的开销值&lt;br&gt;
&lt;strong&gt;RFC2328与RFC1583总结：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于外部路由，type1优于type2
&lt;ol&gt;
&lt;li&gt;如果只是type1选优
&lt;ol&gt;
&lt;li&gt;RFC1583优选X+Y最小的，X+Y相等则负载，只比较X+Y，不单独比较X大小或者Y大小&lt;/li&gt;
&lt;li&gt;RFC2328先比较X的区域，&lt;strong&gt;非骨干优先&lt;/strong&gt;，其次再比较X+Y&lt;br&gt;
&lt;code&gt;即非骨干优先，X+Y越小越优&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果只是type2选优
&lt;ol&gt;
&lt;li&gt;RFC1583优选Y最小，如果Y相等，则比对X，优先X最小，X也相等则负载&lt;/li&gt;
&lt;li&gt;RFC2328先比较X的区域，非骨干优先，再根据RFC1583比对，如果通过RFC1583对比结果是多条都是最小开销，则选择学习到的这些LSA的区域里AreaID最大的&lt;br&gt;
&lt;code&gt;即非骨干优先，外部开销越小越优，内部开销越小越优，区域ID越大越优&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;X的区域比较只当前路由器去往转发地址(FA)的路由（如果FA=0，则是去往ASBR的路由）是否经过骨干区域，而无关ASBR是否在骨干区域&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;正常场景默认oe2&#34;&gt;正常场景（默认OE2）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614090305320.png&#34; alt=&#34;1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614090315432.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614090330296.png&#34; alt=&#34;4&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;下面场景可以按照cost最小考虑，即忽略非骨干优先&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614090322224.png&#34; alt=&#34;3&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;非正常场景需要验证默认oe2&#34;&gt;非正常场景，需要验证（默认OE2）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614090337393.png&#34; alt=&#34;a&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614090344048.png&#34; alt=&#34;b&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614090351344.png&#34; alt=&#34;c&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ospfv2和v3的异同点&#34;&gt;OSPFv2和v3的异同点&lt;/h2&gt;
&lt;h3 id=&#34;相同点&#34;&gt;相同点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;网络类型和接口类型&lt;/li&gt;
&lt;li&gt;接口状态机和邻居状态机&lt;/li&gt;
&lt;li&gt;链路状态数据库&lt;/li&gt;
&lt;li&gt;泛洪机制&lt;/li&gt;
&lt;li&gt;相同类型的报文：Hello报文、DBD报文、LSR报文、LSU报文和 LSAck报文&lt;/li&gt;
&lt;li&gt;路由计算基本相同&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;不同点&#34;&gt;不同点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;v3基于链路，而不是网段&lt;br&gt;
v3运行在IPv6协议上，IPv6是基于链路而不是基于网段的。&lt;br&gt;
在配置v3时，不需要考虑是否配置在同一网段，只要在同一链路，就可以不配置IPv6全局地址而直接建立联系&lt;/li&gt;
&lt;li&gt;v3上移除了IP地址的意义&lt;br&gt;
v3上移除了IP地址的意义，1类和2类LSA中不再有网络信息，这样做的目的是为了使“拓扑与地址分离”。&lt;br&gt;
v3可以不依赖IPv6全局地址的配置来计算OSPFv3的拓扑，IPv6全局地址仅用于虚连接接口&lt;/li&gt;
&lt;li&gt;v3的报文及LSA格式发生改变&lt;br&gt;
v3报文不包含IP地址，v3的1类和2类LSA里不包含IP地址，IP地址部分由&lt;strong&gt;新增的两类LSA&lt;/strong&gt;（Type8: Link-LSA；Type9: Intra-Area-Prefix-LSA）宣告。&lt;br&gt;
v3的Router ID、Area ID和LSA Link State ID不再表示IP地址，但仍保留IPv4地址格式。&lt;br&gt;
广播、NBMA及P2MP网络中，邻居不再由IP地址标识，只由RouterID标识&lt;/li&gt;
&lt;li&gt;v3的LSA报文里添加LSA的洪泛范围&lt;br&gt;
v3在LSA报文头的LSA Type里，添加LSA的洪泛范围，这使得v3的路由器更加灵活，可以处理不能识别的LSA，v3可以存储或泛洪不识别的报文，而v2只丢弃不识别的报文。&lt;br&gt;
v3允许洪泛范围为区域或链路本地，并且设置U位（报文可按泛洪范围为链路本地来处理）的不识别报文存储或通过stub区域。&lt;br&gt;
例如，R1和R2都可识别某类LSA，它们之间通过R3连接，但R3不识别该类LSA，当R1洪泛此类 LSA时，R3虽然不识别，但还是可以洪泛给R2，R2收到后继续处理&lt;/li&gt;
&lt;li&gt;v3支持一个链路上多个进程&lt;br&gt;
一个v2物理接口，只能和一个v2实例绑定，但是一个v3的物理接口，可以和多个v3实例绑定，使用不同的实例ID进行区分。&lt;br&gt;
这些运行在同一条物理链路上的多个v3实例，分别与链路对端设备建立邻居及发送报文，且互不干扰，充分共享同一链路资源。&lt;/li&gt;
&lt;li&gt;v3利用IPv6链路本地地址&lt;br&gt;
IPv6使用链路本地地址在同一链路上发现邻居及自动配置等。运行IPv6的路由器不转发目的地址为链路本地地址的IPv6报文，此类报文只在同一链路有效。链路本地单播地址从FE80/10开始。&lt;br&gt;
v3是运行在IPv6上的路由协议，同样适用链路本地地址来维持邻居、同步LSA数据库。除虚连接外的所有v3接口都使用链路本地地址作为源地址及下一跳来发送v3报文。&lt;br&gt;
这样做的好处是，不需要配置IPv6全局地址，就可以得到v3拓扑，实现拓扑与地址分离。通过在链路上泛洪的报文不会传到其他链路上，来减少报文不必要的泛洪来节省带宽。&lt;/li&gt;
&lt;li&gt;v3移除所有认证字段&lt;br&gt;
v3的认证直接使用IPv6的认证及安全处理，不再需要其自身来完成认证，使用协议时只需关注协议本身即可&lt;/li&gt;
&lt;li&gt;新增两种LSA
&lt;ol&gt;
&lt;li&gt;Link LSA（8类，链路LSA）：&lt;br&gt;
用于路由器宣告各个链路上对应的链路本地地址及其所配置的IPv6全局地址，仅在链路内洪泛。&lt;br&gt;
该类型LSA&lt;strong&gt;仅在本链路上传播&lt;/strong&gt;，具有以下3种目的：向本链路上的其它路由器提供路由器的&lt;strong&gt;本链路地址&lt;/strong&gt;；向本链路上的其它路由器&lt;strong&gt;通告IPv6地址前缀&lt;/strong&gt;，使其与本链路相关联；允许路由器在该类型LSA中插入一些选项比特，与为本链路产生的网络LSA相关联。&lt;/li&gt;
&lt;li&gt;Intra Area Prefix LSA（9类，区域内前缀LSA）：&lt;br&gt;
用于向其他路由器宣告本路由器或本网络（广播网络及NBMA）的IPv6全局地址信息，在区域内洪泛。&lt;br&gt;
该类型LSA在&lt;strong&gt;本区域内传播&lt;/strong&gt;，具有以下两种功能之一：通过参考网络LSA把IPv6地址前缀与传递网络（transit network）相关联；或者通过参考路由器LSA把IPv6地址前缀与路由器相关联。一台路由器可以为给定的区域产生多个该类型的LSA，这些LSA使用链路状态ID字段（Link State ID）区分。DR 为它所代表的链路产生一个或多个该类型的LSA，向整个区域内通告该链路的地址前缀。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;v3只通过路由器ID来标识邻居&lt;br&gt;
v2在广播、NBMA及P2MP网络中是通过IPv4接口地址来标识的。&lt;br&gt;
OSPFv3只通过Router ID来标识邻居，这样即使没有配置IPv6全局地址，或者IPv6全局地址配置都不在同一网段，v3的邻居还是可以建立并维护的，以达到“拓扑与地址分离”的目的&lt;/li&gt;
&lt;/ol&gt;
">IGP协议-OSPF</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/igp-xie-yi-riplu-you-ji-chu/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%9F%BA%E7%A1%80&#34;&gt;路由基础&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%E7%82%B9&#34;&gt;零散知识点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%84%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8A%E7%89%B9%E7%82%B9&#34;&gt;各协议的优先级及特点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%96%E9%83%A8%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;为什么需要外部优先级？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E6%AF%94%E8%BE%83%E5%A4%96%E9%83%A8%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E5%86%85%E9%83%A8%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;什么情况下比较外部优先级和内部优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E9%9C%80%E8%A6%81%E6%AF%94%E8%BE%83%E8%B7%AF%E7%94%B1%E6%9D%A1%E7%9B%AE%E7%9A%84metric%E5%80%BC&#34;&gt;什么情况下需要比较路由条目的metric值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;为什么这么设计优先级&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%8F%E8%AE%AE%E4%BC%98%E5%85%88%E7%BA%A7%E4%B8%BA%E4%BD%95%E8%A6%81%E6%9C%89%E5%86%85%E5%A4%96%E4%B9%8B%E5%88%86&#34;&gt;协议优先级为何要有内外之分&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rip&#34;&gt;RIP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ripv1%E5%92%8Cripv2%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;RIPV1和RIPV2的区别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B1%E5%90%8C%E7%82%B9&#34;&gt;共同点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E5%90%8C%E7%82%B9&#34;&gt;不同点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rip%E8%B7%AF%E7%94%B1%E8%A1%A8%E7%9A%84%E5%BD%A2%E6%88%90&#34;&gt;RIP路由表的形成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ripv1%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%9A%E5%91%8A%E5%92%8C%E6%8E%A5%E6%94%B6%E6%96%B9%E5%BC%8F&#34;&gt;RIPV1的路由通告和接收方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E6%97%B6%E5%99%A8&#34;&gt;定时器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%B2%E7%8E%AF&#34;&gt;防环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%97%E9%87%8D%E6%94%BE%E4%BF%9D%E6%8A%A4%E9%BB%98%E8%AE%A4%E5%85%B3%E9%97%AD&#34;&gt;抗重放保护（默认关闭）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E6%92%AD&#34;&gt;单播&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;路由基础&#34;&gt;路由基础&lt;/h1&gt;
&lt;h2 id=&#34;零散知识点&#34;&gt;零散知识点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;RIP基于UDP，端口号v1和v2是520，ripng是521&lt;/li&gt;
&lt;li&gt;常见IP协议号：1-ICMP、2-IGMP、6-tcp、17-udp、47-gre、50-esp、88-eigrp、89-ospf、103-pim、112-vrrp&lt;/li&gt;
&lt;li&gt;isis是通过802.3承载的。bgp是通过tcp承载的，目的端口号为179。&lt;/li&gt;
&lt;li&gt;路由协议的分类
&lt;ol&gt;
&lt;li&gt;按照应用范围
&lt;ol&gt;
&lt;li&gt;IGP: RIP\OSPF\ISIS，特点：应用在同一个AS内做路由互通，通告路由条目选择最优路径。&lt;/li&gt;
&lt;li&gt;EGP: BGP，特点：BGP的主要特点是针对路由实施策略，可以更好的控制发送和接收的路由条目。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;按照工作原理&lt;br&gt;
&lt;code&gt;矢量：靠邻居学来的路由，仅把最优的放入路由表，路由的metric及下一跳代表矢量&lt;/code&gt;&lt;br&gt;
&lt;code&gt;链路：每台路由器的每个物理链路，根据其网络类型产生至少一个链路状态，链路状态路由协议ospf使用lsa1去携带该路由器上所有的链路状态描述&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;距离矢量DV&lt;code&gt;特点：只通告路由表中最优路由&lt;/code&gt;：RIP(16跳不可达)、BGP(路径矢量更确切)&lt;/li&gt;
&lt;li&gt;链路状态LS：OSPF、ISIS&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由通告方式：
&lt;ol&gt;
&lt;li&gt;有类： RIPV1 (即不通告掩码长度，不支持不连续的子网)&lt;/li&gt;
&lt;li&gt;无类：RIPV2\BGP\OSPF\ISIS&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;RIP属于距离矢量且IGP协议&lt;/li&gt;
&lt;li&gt;不推荐使用RIP的理由：只适应小型网络，跳数少，收敛慢，容易出环，且最好带宽一致&lt;/li&gt;
&lt;li&gt;Null0接口在各路由协议中的作用？有什么区别
&lt;ol&gt;
&lt;li&gt;在BGP中有两点原因：一是为了发布进BGP，二是为了防止环路的出现。因为bgp发布的路由必须是本地存在的路由，并且要求掩码一致，这就造成通过bgp发布聚合路由时，本地没有聚合后的网段路由，一般是通过配置一条黑洞路由，即下一跳为null，来满足这一要求的。&lt;/li&gt;
&lt;li&gt;在IGP中配置指向Null0的汇总路由时均是为了防止环路的出现（ospf不会产生黑洞路由，但是isis在汇总后会产生黑洞路由）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;各协议的优先级及特点&#34;&gt;各协议的优先级及特点&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;协议&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;外部优先级&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;内部优先级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;直连&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;静态&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;60&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;60&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RIP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OSPF&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OSPF ASE和NSSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;150&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;150&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ISIS L1/L2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;15/15&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;15/18&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EBGP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IBGP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;200&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;只能调整外部优先级，不能调整内部优先级&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么需要外部优先级&#34;&gt;为什么需要外部优先级？&lt;/h3&gt;
&lt;p&gt;用来区分不同的路由协议&lt;br&gt;
如果没有外部优先级，或者外部优先级一样，那么会认为认为两条路由是来自同一个路由协议，加入这两条路由来自不同的协议，不同协议之间的算法不同，可能会导致高速链路和低速链路负载分担的情况&lt;/p&gt;
&lt;h3 id=&#34;什么情况下比较外部优先级和内部优先级&#34;&gt;什么情况下比较外部优先级和内部优先级&lt;/h3&gt;
&lt;p&gt;如果同一条路由条目通过不同的路由协议学习到，需要先比较外部优先级，如果外部优先级一样，比较内部优先级&lt;/p&gt;
&lt;h3 id=&#34;什么情况下需要比较路由条目的metric值&#34;&gt;什么情况下需要比较路由条目的metric值&lt;/h3&gt;
&lt;p&gt;如果同一条路由条目通过同一种路由协议的不同邻居学到，需要比较metric值，metric值越小越优&lt;/p&gt;
&lt;h3 id=&#34;为什么这么设计优先级&#34;&gt;为什么这么设计优先级&lt;/h3&gt;
&lt;p&gt;为了避免次优路径&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611497356579.png&#34; alt=&#34;设计优先级&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
左边运行RIP，右边运行OSPF。sw2上的路由2.2.2.2/32，在sw3上从RIP引入到ospf，然后传到sw1时，rip的优先级为100，ospf的外部优先级为150，优选RIP，在sw1上2.2.2.2的路由为&lt;code&gt;sw1-&amp;gt;sw2&lt;/code&gt;。如果ospf的内部和外部优先级都为10，则sw1上会选择ospf，则2.2.2.2的路由为&lt;code&gt;sw1-&amp;gt;sw4-&amp;gt;sw3-&amp;gt;sw2&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;协议优先级为何要有内外之分&#34;&gt;协议优先级为何要有内外之分&lt;/h2&gt;
&lt;p&gt;有时为了控制路由选路需要更改协议优先级，就设定了可以改动的外部优先级， 但因为可以随便更改，就会出现这样一种情况，两种不同的协议优先级被误改为相同的优先级，比如RIP和OSPF优先级都改为一样，但这两种协议不能去比较cost值，因为&lt;strong&gt;两种协议间比较cost值是没有意义的&lt;/strong&gt;，所以此时就设立了内部优先级，并且不能更改，那么&lt;strong&gt;在外部优先级相同情况下就可以去比较内部优先级&lt;/strong&gt;，保证比较优先级就可以比较出来&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;rip&#34;&gt;RIP&lt;/h1&gt;
&lt;p&gt;路由信息协议，基于距离矢量算法的协议，使用跳数作为度量来衡量到达目的网络的距离，适用于规模较小的网络中。&lt;/p&gt;
&lt;h2 id=&#34;ripv1和ripv2的区别&#34;&gt;RIPV1和RIPV2的区别&lt;/h2&gt;
&lt;h3 id=&#34;共同点&#34;&gt;共同点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;IGP协议&lt;/li&gt;
&lt;li&gt;属于距离矢量路由选择协议&lt;/li&gt;
&lt;li&gt;都可以通过广播的方式通告路由条目，也可以通过单播的方式通告&lt;/li&gt;
&lt;li&gt;都是使用UDP协议承载，端口号都为520&lt;/li&gt;
&lt;li&gt;都是使用跳数计算最短路径，最大跳数为15跳，16跳为不可达&lt;/li&gt;
&lt;li&gt;报文类型相同，只有request报文和reponse报文&lt;/li&gt;
&lt;li&gt;都可以接收V1\V2版本的RIP报文&lt;/li&gt;
&lt;li&gt;通告的每条路由条目长度都是20字节&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;不同点&#34;&gt;不同点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;RIPV1
&lt;ol&gt;
&lt;li&gt;有类路由选择协议，不支持VLSM(可变长子网掩码，划分子网)和CIDR(无类别域间路由，聚合子网)&lt;/li&gt;
&lt;li&gt;不支持认证&lt;/li&gt;
&lt;li&gt;使用广播的方式通告报文&lt;/li&gt;
&lt;li&gt;一次最多通告25条路由条目&lt;br&gt;
UDP的报文长度决定的，且UDP不支持分段。UDP头部8字节=源端口+目的端口+长度+校验和各2字节，RIP头部是4字节，UDP规定最大可承载长度为512B，512-8-4=500，500/20=25&lt;/li&gt;
&lt;li&gt;不支持TAG和下一跳&lt;/li&gt;
&lt;li&gt;通告路由不携带子网掩码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;RIPV2
&lt;ol&gt;
&lt;li&gt;无类路由协议，支持VLSM和CIDR&lt;/li&gt;
&lt;li&gt;支持认证，明文（20字节，位于RIP头之后，一条路由长度）和密文（40字节）&lt;/li&gt;
&lt;li&gt;可以使用组播和广播的方式通告报文，&lt;strong&gt;组播地址224.0.0.9&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;无认证时一次最多可以通告25条路由，有明文认证可以通告24条，有密文认证可以通告23条&lt;/li&gt;
&lt;li&gt;支持TAG和下一跳&lt;/li&gt;
&lt;li&gt;通过路由携带子网掩码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;报文格式&#34;&gt;报文格式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;V2只是将V1中必须为0的字段给利用起来&lt;/code&gt;&lt;br&gt;
V1报文格式：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611534626393.png&#34; alt=&#34;V1报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
V2报文格式：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611534634224.png&#34; alt=&#34;V2报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command：表示该报文是一个请求报文还是响应报文，只能取1(请求报文)或者2(响应报文)&lt;/li&gt;
&lt;li&gt;Version：表示RIP的版本信息。对于RIPv1，该字段的值为1&lt;/li&gt;
&lt;li&gt;Address Family Identifier（AFI）：表示地址标识信息，对于IP协议，其值为2（V2还可以用来描述认证信息）&lt;/li&gt;
&lt;li&gt;IP address：表示该路由条目的目的IP地址。这一项可以是网络地址、主机地址&lt;/li&gt;
&lt;li&gt;Metric：标识该路由条目的度量值，取值范围1-16&lt;/li&gt;
&lt;li&gt;Route tag：用于标记外部路由&lt;/li&gt;
&lt;li&gt;Subnet Mask：指定IP地址的子网掩码，定义IP地址的网络或子网部分&lt;/li&gt;
&lt;li&gt;Next Hop：指定通往目的地址的下一跳IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rip路由表的形成&#34;&gt;RIP路由表的形成&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611536110100.png&#34; alt=&#34;RIP路由表的形成&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
RIP启动时的&lt;strong&gt;初始路由表仅包含本设备的一些直连接口路由&lt;/strong&gt;。&lt;br&gt;
RIP协议启动之后，RouterA会向相邻的路由器广播一个Request报文。&lt;br&gt;
当RouterB从接口接收到RouterA发送的Request报文后，把自己的RIP路由表封装在Response报文内，然后向该接口对应的网络广播。&lt;br&gt;
RouterA根据RouterB发送的Response报文，形成自己的路由表。&lt;/p&gt;
&lt;h2 id=&#34;ripv1的路由通告和接收方式&#34;&gt;RIPV1的路由通告和接收方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;路由通告：
&lt;ol&gt;
&lt;li&gt;在同一主类网段，掩码一致直接通告，掩码不一致只通告32位的主机路由，其他则不通告&lt;/li&gt;
&lt;li&gt;不在同一主类网段，则通告此网段的主类网段&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;路由接收：
&lt;ol&gt;
&lt;li&gt;在同一主类网段，如果主机位全为0则路由的掩码为接口地址的掩码，否则为32位主机路由&lt;/li&gt;
&lt;li&gt;不在同一主类网段，接收其主类网段&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611537887553.png&#34; alt=&#34;路由通告&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;主类网络：&lt;br&gt;
A类：第1字节为网络号，第1比特为0，即1.0.0.0~126.0.0.0/8&lt;br&gt;
B类：前2字节为网络号，前2比特为10，即128.1.0.0~191.255.0.0/16&lt;br&gt;
C类：前3字节为网络号，前3比特为110，即192.0.1.0~223.255.255.0/24&lt;br&gt;
D类：多播地址，前4比特为1110&lt;br&gt;
E类：保留地址，前4比特为1111&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;定时器&#34;&gt;定时器&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;更新定时器：定时触发更新报文的发送，默认30秒&lt;/li&gt;
&lt;li&gt;老化定时器：在老化时间内没有收到更新报文则认为该路由不可达，默认180秒&lt;/li&gt;
&lt;li&gt;垃圾收集定时器：在垃圾收集时间内&lt;strong&gt;不可达路由&lt;/strong&gt;没有收到来自同一邻居的更新，则彻底删除该路由，默认120秒&lt;code&gt;一条路由从失效到被清除需要多长时间？300秒=180老化定时器+120垃圾收集定时器&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;抑制定时器：当RIP设备收到对端的路由更新，&lt;strong&gt;其cost为16&lt;/strong&gt;，&lt;strong&gt;对应路由进入抑制状态&lt;/strong&gt;，并启动抑制定时器。为了&lt;strong&gt;防止路由震荡&lt;/strong&gt;，在抑制定时器超时之前，即使再收到对端路由cost小于16的更新，也不接受，当抑制定时器超时后，就重新允许接受对端发送的路由更新报文，默认0秒（&lt;code&gt;虽然存在但是默认没有开启，除非将时间修改为非0才能发挥其作用&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;前3个定时器的关系&lt;/strong&gt;：&lt;br&gt;
RIP的更新信息发布是由更新定时器控制的，每30秒发送一次。&lt;br&gt;
每一条路由表项对应两个定时器：老化定时器和垃圾收集定时器。&lt;br&gt;
当学到一条路由并添加到路由表中时，老化定时器启动，如果在180秒后没有收到邻居发来的更新报文，则把该路由的度量值置为16（表示路由不可达），&lt;br&gt;
并启动垃圾收集定时器，如果在120秒内仍然没有收到更新报文，垃圾收集定时器超时后在路由中删除该表项。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;防环&#34;&gt;防环&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;路由中毒（路由条目失效后设置为16条）不是防止的机制，而是通告路由条目失效的方法&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;水平分割：从某个接口学到的路由，不会从该接口再发回给邻居设备&lt;code&gt;广播和点到点默认开启（NBMA默认不开启），但是不可靠，因为发送方无法确认接收方是否收到路由&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;毒性反转：从某个接口学到路由后，将该路由的开销设置为16，并从原接口发回邻居设备，清除对方路由表中的无用路由&lt;code&gt;接口下如果同时开启水平分割和毒性逆转，只有毒性逆转生效&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最大跳数：16跳即不可达&lt;/li&gt;
&lt;li&gt;触发更新：路由信息发生变化时，立即向邻居发送触发更新报文，通知变化的路由信息&lt;br&gt;
&lt;code&gt;触发更新和更新定时器存在时间差，这个最后是通过最大条数解决环路问题&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611541711315.png&#34; alt=&#34;触发更新和最大跳数&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
sw1的lo0失效之后发送触发更新给sw2(16跳)，现在sw2同时给sw3和sw4发，结果sw3收到后删除，此时sw4还未收到，但是更新定时器到时间了，发送了更新报文，导致sw3又学到了sw1的lo0路由(2跳)，即sw3认为从sw4可以到达sw1(3跳)，然后就开始发送更新报文给sw2，sw2认为从sw3可以到达sw1(4跳)，sw2又给sw1/2/3发送(5跳)，导致出环，跳数不断增加......最后到达16条之后不可达&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;抗重放保护默认关闭&#34;&gt;抗重放保护（默认关闭）&lt;/h2&gt;
&lt;p&gt;假设运行RIP的接口状态变为Down之前发送的最后的RIP报文的Identification为X&lt;code&gt;此部分在IP头部，而不是RIP头部&lt;/code&gt;，该接口状态变为Up后，再次发送RIP报文的Identification会变为0。如果对方没有收到这个Identification为0的RIP报文，那么后续的RIP报文都将被丢弃，直到收到Identification为X＋1的RIP报文。这样就会导致双方的RIP路由信息不同步、丢失。&lt;br&gt;
使能Replay-protect功能后，当接口从Down变为Up之后，再次发送RIP报文的Identification会顺次加一，从而避免了上述情况的发生。&lt;/p&gt;
&lt;h2 id=&#34;单播&#34;&gt;单播&lt;/h2&gt;
&lt;p&gt;需要将端口silent后并指定一个peer，那么此端口将不会以组播和广播的方式发送报文，但是还可以接收&lt;/p&gt;
">IGP协议-路由基础+RIP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/er-ceng-xie-yi-arp/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#arp&#34;&gt;ARP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#arp%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&#34;&gt;ARP报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB&#34;&gt;分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arp%E6%94%BB%E5%87%BB&#34;&gt;ARP攻击&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-arp%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BBdos&#34;&gt;1. ARP泛洪攻击（拒绝服务攻击Dos）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-arp%E6%AC%BA%E9%AA%97%E6%94%BB%E5%87%BB%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB&#34;&gt;2. ARP欺骗攻击（中间人攻击）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mac%E5%9C%B0%E5%9D%80%E6%BC%82%E7%A7%BB&#34;&gt;MAC地址漂移&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E5%BF%B5&#34;&gt;概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mac%E5%9C%B0%E5%9D%80%E6%BC%82%E7%A7%BB%E6%A3%80%E6%B5%8B&#34;&gt;MAC地址漂移检测&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%87%E7%A8%8B&#34;&gt;过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%B2%E6%AD%A2mac%E5%9C%B0%E5%9D%80%E6%BC%82%E7%A7%BB&#34;&gt;防止MAC地址漂移&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%B1%82%E7%8E%AF%E8%B7%AF%E4%B8%8E%E4%B8%89%E5%B1%82%E7%8E%AF%E8%B7%AF%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;二层环路与三层环路的区别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%AF%E8%B7%AF%E5%8E%9F%E5%9B%A0&#34;&gt;环路原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%B1%82%E8%AE%BE%E5%A4%87%E5%92%8C%E4%B8%89%E5%B1%82%E8%AE%BE%E5%A4%87%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%A1%8C%E4%B8%BA%E5%8C%BA%E5%88%AB&#34;&gt;二层设备和三层设备的工作行为区别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%B7%A5%E4%BD%9C%E8%A1%8C%E4%B8%BA&#34;&gt;二层交换机工作行为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%B1%82%E8%AE%BE%E5%A4%87%E5%B7%A5%E4%BD%9C%E8%A1%8C%E4%B8%BA&#34;&gt;三层设备工作行为&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%AF%E8%B7%AF%E7%9A%84%E5%BD%B1%E5%93%8D&#34;&gt;环路的影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%B2%E7%8E%AF%E6%9C%BA%E5%88%B6&#34;&gt;防环机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E6%94%B6%E5%88%B0%E6%9C%AA%E7%9F%A5%E8%A1%A8%E9%A1%B9%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86&#34;&gt;交换机和路由器收到未知表项如何处理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA&#34;&gt;交换机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;路由器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%AB%E4%BA%8C%E5%B1%82%E8%BD%AC%E5%8F%91%E5%92%8C%E4%B8%89%E5%B1%82%E8%BD%AC%E5%8F%91&#34;&gt;交换机如何识别二层转发和三层转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8E%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;三层交换机与路由器的区别&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A1%AC%E4%BB%B6&#34;&gt;硬件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&#34;&gt;数据的处理方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%9F%E8%83%BD&#34;&gt;功能&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#icmp%E7%9A%84%E5%B8%B8%E8%A7%81%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E6%82%A3&#34;&gt;ICMP的常见攻击与防患&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#icmp%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB&#34;&gt;ICMP泛洪攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ping-of-death-%E6%94%BB%E5%87%BB&#34;&gt;Ping of Death 攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#large-icmp-%E6%94%BB%E5%87%BB&#34;&gt;Large-ICMP 攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#icmp-unreachable-%E6%94%BB%E5%87%BB&#34;&gt;ICMP-Unreachable 攻击&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#icmp-redirect-%E6%94%BB%E5%87%BB&#34;&gt;ICMP-Redirect 攻击&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;arp&#34;&gt;ARP&lt;/h1&gt;
&lt;h2 id=&#34;arp报文格式&#34;&gt;ARP报文格式&lt;/h2&gt;
&lt;p&gt;报文的长度是42字节。前14字节的内容表示以太网首部，后28字节的内容表示ARP请求或应答报文的内容&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611465717333.png&#34; alt=&#34;ARP报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以太网目的MAC：以太网目的MAC地址，发送ARP请求报文时，该字段为广播的MAC地址0xffff-ffff-ffff&lt;/li&gt;
&lt;li&gt;以太网源MAC：以太网源MAC地址&lt;/li&gt;
&lt;li&gt;帧类型：数据的类型，对于ARP请求或应答来说，该字段的值为0x0806&lt;/li&gt;
&lt;li&gt;硬件类型：对于以太网，该字段的值为1&lt;/li&gt;
&lt;li&gt;协议类型：发送方要映射的协议地址类型，对于IP地址，该字段的值为0x0800&lt;/li&gt;
&lt;li&gt;硬件地址长度：对于ARP请求或应答来说，该字段值为6&lt;/li&gt;
&lt;li&gt;协议地址长度：对于ARP请求或应答来说，该字段值为4。&lt;/li&gt;
&lt;li&gt;OP：操作类型，1-ARP请求，2-ARP应答，3-RARP请求，4-RARP应答&lt;/li&gt;
&lt;li&gt;源MAC：该源MAC地址与以太网首部中的以太网源MAC相同&lt;/li&gt;
&lt;li&gt;源IP：源IP地址&lt;/li&gt;
&lt;li&gt;目的MAC：目的MAC地址，发送ARP请求报文时，该字段为全0的MAC地址0x0000-0000-0000。&lt;/li&gt;
&lt;li&gt;目的IP：目的IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;正向ARP：将IP解析成MAC&lt;/li&gt;
&lt;li&gt;反向ARP（RARP）：将MAC解析成IP，用于无盘工作站&lt;/li&gt;
&lt;li&gt;代理ARP（ARP Proxy）：&lt;br&gt;
两个互访的节点在同一网段，但广播的ARP报文无法到达，需要使用代理ARP
&lt;ol&gt;
&lt;li&gt;Vlan间代理：用于super vlan&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611465047212.jpg&#34; alt=&#34;Vlan间代理&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Vlan内代理：同一广播域，但是配置了二层或者三层隔离，双方都需要通过网关访问，双方封装的目的mac也是网关的mac&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611465064034.jpg&#34; alt=&#34;Vlan内代理&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;路由式代理：PC1访问PC2，PC1首先会判断PC2的IP是否和自己在同一个广播域，如果在同一个广播域，那么PC1会向中间的路由器发送ARP请求。如果路由器开启代理ARP的功能后，收到PC1的ARP请求，会检查自己的路由表中该路由是否可达，如果可达，路由器会将自己的Mac回复给PC1&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611465337689.jpg&#34; alt=&#34;路由式代理&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;免费ARP：IP地址冲突检测；用于通告一个新的MAC地址；在VRRP备份组中用来通告主备发生变换&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MAC地址表和ARP表的区别&lt;/strong&gt;？&lt;br&gt;
MAC地址表，老化时间300s(5m)，二层转发，接口和MAC关联；ARP地址表：老化时间1200s(20m)，IP和MAC关联&lt;br&gt;
&lt;strong&gt;交换机的一个接口是否可以关联多个MAC&lt;/strong&gt;？&lt;br&gt;
可以。交换机A接口1连接交换机B接口2，交换机B上连接n台设备，此时交换机A的接口1可以学习到交换机B上连接的那n台设备的mac地址&lt;br&gt;
&lt;strong&gt;交换机的多个接口是否可以关联一个MAC&lt;/strong&gt;？&lt;br&gt;
不可以。否则mac地址震荡(flapping)&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：一个接口对应多个mac，一个mac只能对应一个接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;特殊应用&lt;/strong&gt;：在主机没有配置网关的情况下，使用代理ARP实现对外网的访问，即使用代理ARP来实现VRRP的功能，见下图&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611490841175.jpg&#34; alt=&#34;代理ARP特殊应用&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;arp攻击&#34;&gt;ARP攻击&lt;/h2&gt;
&lt;h3 id=&#34;1-arp泛洪攻击拒绝服务攻击dos&#34;&gt;1. ARP泛洪攻击（拒绝服务攻击Dos）&lt;/h3&gt;
&lt;p&gt;攻击者发送大量的ARP报文，侵占设备ARP表项资源，导致系统资源耗尽，从而使正常用户业务受到影响。&lt;br&gt;
可以通过配置ARP表项限制、ARP Miss消息限速、ARP表项严格学习、ARP报文限速来防止ARP泛洪攻击。&lt;/p&gt;
&lt;h3 id=&#34;2-arp欺骗攻击中间人攻击&#34;&gt;2. ARP欺骗攻击（中间人攻击）&lt;/h3&gt;
&lt;p&gt;攻击者通过发送伪造的ARP报文，恶意修改设备或网络内其他用户主机的ARP表项，造成用户或网络的报文通信异常。&lt;br&gt;
可以通过配置ARP表项固化、ARP表项严格学习、发送免费ARP报文、动态ARP检测来防止ARP欺骗攻击。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mac地址漂移&#34;&gt;MAC地址漂移&lt;/h1&gt;
&lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;设备上一个VLAN内有两个端口学习到同一个MAC地址，后学习到的MAC地址表项覆盖原MAC地址表项的现象。&lt;br&gt;
正常情况下，网络中不会在短时间内出现大量MAC地址漂移的情况。出现这种现象一般都意味着网络中存在环路，可以通过查看告警信息和漂移记录，快速定位和排除环路。&lt;/p&gt;
&lt;h2 id=&#34;mac地址漂移检测&#34;&gt;MAC地址漂移检测&lt;/h2&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;利用MAC地址出接口跳变的现象，检测MAC地址是否发生漂移&lt;/p&gt;
&lt;h3 id=&#34;过程&#34;&gt;过程&lt;/h3&gt;
&lt;p&gt;在发生MAC地址漂移时，可以上报包括MAC地址、VLAN，以及跳变的接口等信息的告警。&lt;br&gt;
其中跳变的接口即为可能出现环路的接口&lt;/p&gt;
&lt;h2 id=&#34;防止mac地址漂移&#34;&gt;防止MAC地址漂移&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;为端口配置静态MAC&lt;/li&gt;
&lt;li&gt;为接口配置MAC地址学习优先级&lt;/li&gt;
&lt;li&gt;禁止相同的优先级的接口发生MAC地址漂移&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;二层环路与三层环路的区别&#34;&gt;二层环路与三层环路的区别&lt;/h1&gt;
&lt;h2 id=&#34;环路原因&#34;&gt;环路原因&lt;/h2&gt;
&lt;p&gt;二层环路是由于物理拓扑出现环路，如3台交换机呈三角形连接。&lt;br&gt;
三层环路一般物理拓扑有环路，并且设备之间路由表形成互指（物理拓扑不成环，2 台设备使用静态路由互指也可能成环，这种特殊情况除外）&lt;/p&gt;
&lt;h2 id=&#34;二层设备和三层设备的工作行为区别&#34;&gt;二层设备和三层设备的工作行为区别&lt;/h2&gt;
&lt;h3 id=&#34;二层交换机工作行为&#34;&gt;二层交换机工作行为&lt;/h3&gt;
&lt;p&gt;收到的数据帧查看二层头部，根据&lt;strong&gt;目的MAC地址转发&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;广播：&lt;br&gt;
目的MAC为全1&lt;br&gt;
收到广播报文后除了接收的端口外，向其余所有端口转发 （泛洪）&lt;/li&gt;
&lt;li&gt;组播：&lt;br&gt;
目的MAC的第8位为1&lt;br&gt;
首先判断目的MAC是否本机要接受，如收到STP的BPDU，而自身也运行STP，此报文上送协议处理，不做转发；&lt;br&gt;
如果交换机自身没有运行STP，华为的交换设备也可以识别STP的数据帧，也不做转发&lt;br&gt;
假如此报文自身不需要接受，则处理方式为泛洪，如运行了IGMP SNOOPING则根据snooping表项转发。&lt;/li&gt;
&lt;li&gt;单播：&lt;br&gt;
目的MAC的第8位为0&lt;br&gt;
如果目的MAC在自身MAC表中不存在，即未知单播，处理方式为泛洪&lt;br&gt;
如果目的MAC在自身 MAC表中存在，则向MAC表中的接口转发&lt;br&gt;
如果该接口等于报文的接收端口，则丢弃&lt;br&gt;
所以单播报文的处理方式中有三种形为：转发，泛洪，丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;三层设备工作行为&#34;&gt;三层设备工作行为&lt;/h3&gt;
&lt;p&gt;收到数据包查看三层目的IP，根据&lt;strong&gt;目的IP地址转发&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;广播：&lt;br&gt;
目的IP为全 1&lt;br&gt;
收到广播包，路由器会交给相应的协议去处理，比如DHCP、 RIP、ARP等都是广播的&lt;/li&gt;
&lt;li&gt;组播：&lt;br&gt;
目的IP为224.0.0.0-239.0.0.0&lt;br&gt;
开启相关协议则转发，否则查看本路由器是否加入该组，如果加入了就接收，没有加入就丢弃&lt;/li&gt;
&lt;li&gt;单播：&lt;br&gt;
目的IP在路由表中存在则按出端口转发，&lt;br&gt;
目的IP在路由表中不存在则丢弃，&lt;br&gt;
目的IP是自己的地址，则读取协议号上送协议处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;环路的影响&#34;&gt;环路的影响&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;二层环路：&lt;br&gt;
广播风暴、数据帧复制和MAC地址震荡&lt;br&gt;
例如交换机收到广播帧、组播帧、未知单播帧，会采用泛洪形式处理，数据帧在转发时候产生了拷贝复制，数据帧无休止被转发，最终导致整个网络带宽资源被耗尽&lt;/li&gt;
&lt;li&gt;三层环路：&lt;br&gt;
数据包会在设备之间有限的互相转发，因为在三层IP头部存在TTL字段，所以报文不会无休止转发&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;防环机制&#34;&gt;防环机制&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;二层防环&lt;br&gt;
STP、SMART-LINK等技术，或使用LACP链路捆绑、设备堆叠等技术，使物理拓扑上没有环路&lt;/li&gt;
&lt;li&gt;三层防环：&lt;br&gt;
只要依靠路由协议自身的防环机制&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;二层环路较易产生且环路产生的后果十分严重，需要运行破环机制经过计算，阻塞某些端口实现预防。&lt;br&gt;
三层环路不容易产生且后果并不十分严重，每种路由协议都有比较完善的防环机制，三层环路比较容易发生在特殊的场景下，如双点双向路由引入等&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;交换机和路由器收到未知表项如何处理&#34;&gt;交换机和路由器收到未知表项如何处理&lt;/h1&gt;
&lt;h2 id=&#34;交换机&#34;&gt;交换机&lt;/h2&gt;
&lt;p&gt;根据收到的帧中&lt;strong&gt;目的MAC&lt;/strong&gt;查找设备的MAC表项进行转发。&lt;br&gt;
如果收到帧的目的MAC不在交换机的MAC表项中，交换机会向除了收到该帧的同VLAN所有端口进行泛洪。&lt;/p&gt;
&lt;h2 id=&#34;路由器&#34;&gt;路由器&lt;/h2&gt;
&lt;p&gt;路由器是根据收到报文的&lt;strong&gt;目的IP&lt;/strong&gt;查找本地的路由表进行转发。&lt;br&gt;
如果收到报文的目的IP无法找到相应的路由表项，则路由器会将该报文丢弃。&lt;/p&gt;
&lt;h1 id=&#34;交换机如何识别二层转发和三层转发&#34;&gt;交换机如何识别二层转发和三层转发&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;交换机根据收到的&lt;strong&gt;单播帧的目的MAC&lt;/strong&gt;来判断是进行二层转发或三层转发，当目的MAC是Vlanif对应的MAC时就是三层转发，否则就是二层转发。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;收到组播帧&lt;/strong&gt;，看自身交换机是否运行相应的组播协议，有运行就交给相应的协议处理，例如目的mac地址为01-80-c2-00-00-00提交给stp协议处理；目的mac地址为01-80-c2-00-00-14（15）提交给isis协议处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;收到组播数据&lt;/strong&gt;，如果有运行PIM组播协议，就根据（s，g）表项向下游接口转发，如果在交换 机上没有运行PIM协议，但是使能了igmp-snooping功能，根据snooping表象中的成员端口转发数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;收到广播&lt;/strong&gt;，目的IP为全1。交换机会交给相应的协议去处理，比如DHCP、RIP、ARP 等，三层设备是隔离广播域，不会丢弃广播报文&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;三层交换机与路由器的区别&#34;&gt;三层交换机与路由器的区别&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;交换谋快，路由谋转&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;硬件&#34;&gt;硬件&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;三层交换机在网络收敛上慢于路由器并且抵抗网络震荡的能力也弱&lt;/code&gt;&lt;br&gt;
三层交换机是通过交换芯片转发数据的，路由器则是通过cpu转发数据的&lt;/p&gt;
&lt;h2 id=&#34;数据的处理方式&#34;&gt;数据的处理方式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;三层交换机在数据转发上的速度要优于路由器&lt;/code&gt;&lt;br&gt;
三层交换机的首包通过cpu转发，同时通过arp协议建立交换芯片硬件表项（mac地址与ip地址的映射表），后续报文通过交换芯片直接硬件转发，即&lt;code&gt;一次路由，多次交换&lt;/code&gt;，交换机的硬件三层表项中只包含了目的地址、目的ip对应的mac地址、出口vlan及端口。&lt;br&gt;
路由器通过路由表选择路由后，将该路由下发到FIB（转发信息表）表中，数据到达路由器时，通过FIB表的最长匹配原则查表转发。&lt;/p&gt;
&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;
&lt;p&gt;路由器提供包括分组过滤、分组转发、优先级、复用、加密、 压缩和防火墙等功能，并且接口类型丰富，支持的三层功能强大，支持负载分担、链路备份、nat转换等，路由器在大型网络中的协议计算，路由表大小，收敛时间等都优于三层交换机。&lt;br&gt;
三层交换机的优点在于可以加快局域网内数据的交换，并且加入路由功能也是为这个目的服务的。一般将三层交换机运用于网络的核心层和汇聚层。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;icmp的常见攻击与防患&#34;&gt;ICMP的常见攻击与防患&lt;/h1&gt;
&lt;h2 id=&#34;icmp泛洪攻击&#34;&gt;ICMP泛洪攻击&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;利用频率极快的icmp报文，让被攻击者疲于应付&lt;/code&gt;&lt;br&gt;
攻击者发送速度极快的ICMP报文，被攻击者就会徒劳的回复大量ICMP报文给虚假地址，最终消耗自身的系统资源，最终导致服务器停止相应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设备针对ICMP泛洪攻击进行CAR限速，保证CPU不被攻击，保证网络的正常运行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ping-of-death-攻击&#34;&gt;Ping of Death 攻击&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;利用非常规巨包使被攻击者无法组包&lt;/code&gt;&lt;br&gt;
攻击者发送大于65535字节的ip数据包给对方，被攻击者接收到全部分段并重组报文时总的长度超过了65535字节，导致内存溢出，系统会出现内存分配错误而导致TCP/IP堆栈崩溃，导致死机&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要在防火墙上配置允许通过的ICMP报文的最大长度，在防火墙收到大于此长度的数据包文之后将直接丢弃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;large-icmp-攻击&#34;&gt;Large-ICMP 攻击&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;利用巨包分片后需要组包，使被攻击者疲于应付&lt;/code&gt;&lt;br&gt;
同Ping of Death类似，也是利用一些大尺寸的ICMP报文对系统进行的一种攻击，与ping of death 不同的是，Large-ICMP报文的长度不会超过IP 报文的最大长度65535。&lt;br&gt;
但此数据包在传输的过程中会被分片或在分片之后发出，主机收到之后将进行数据包的重组， 重组数据包的过程非常消耗CPU资源，导致主机的资源被大量占用&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;启用分片报文攻击防范，设备实时检测出分片报文并予以丢弃或者限速处理，实现对本设备的保护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;icmp-unreachable-攻击&#34;&gt;ICMP-Unreachable 攻击&lt;/h2&gt;
&lt;p&gt;攻击者向目标主机发送虚假的ICMP-Unreachable报文，干扰了目标主机的路由信息，影响了报文发送。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;开启ICMP不可达报文攻击防范功能，即收到ICMP不可达报文将直接忽略，依旧认为该主机可达&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;icmp-redirect-攻击&#34;&gt;ICMP-Redirect 攻击&lt;/h2&gt;
&lt;p&gt;和ICMP-Unreachable攻击类似，攻击者跨越网段向另外一个网络的目标主机发送虚假的重定向报文，以改变目标主机的路由表，干扰目标主机的路由信息，影响报文发送&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;启动ICMP重定向攻击防范后，设备将对ICMP重定向报文进行丢弃，并记录攻击日志&lt;/p&gt;
&lt;/blockquote&gt;
">二层协议-最后补充</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/er-ceng-xie-yi-vlan/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A7%E6%A0%BC%E5%BC%8F&#34;&gt;帧格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%93%BE%E8%B7%AF%E7%B1%BB%E5%9E%8B&#34;&gt;接口的链路类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-access%E6%8E%A5%E5%8F%A3&#34;&gt;1. Access接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-trunk%E6%8E%A5%E5%8F%A3&#34;&gt;2. Trunk接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-hybrid%E6%8E%A5%E5%8F%A3&#34;&gt;3. Hybrid接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-qinq%E6%8E%A5%E5%8F%A38021q-in-8021q&#34;&gt;4. QinQ接口（802.1Q-in-802.1Q）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vlan%E5%88%92%E5%88%86&#34;&gt;VLAN划分&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%92%E5%88%86%E6%96%B9%E5%BC%8F&#34;&gt;划分方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%B9%E9%85%8D%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;匹配优先级&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vlan-mappingvlan-translation%E6%88%96vlan%E6%98%A0%E5%B0%84&#34;&gt;VLAN Mapping（VLAN Translation或VLAN映射）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#qinq&#34;&gt;QinQ&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&#34;&gt;实现方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B0%81%E8%A3%85%E6%96%B9%E5%BC%8F&#34;&gt;封装方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vlan%E8%81%9A%E5%90%88super-vlan&#34;&gt;VLAN聚合（Super VLAN）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mux-vlan&#34;&gt;Mux-Vlan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#smart-link%E5%92%8Cmonitor-link&#34;&gt;Smart Link和Monitor Link&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#smart-link%E5%A4%87%E4%BB%BD%E9%93%BE%E8%B7%AF&#34;&gt;Smart Link(备份链路)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#monitor-link%E7%9B%91%E6%8E%A7%E9%93%BE%E8%B7%AF&#34;&gt;Monitor Link(监控链路)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85&#34;&gt;补充&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%8C%E5%B1%82%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82&#34;&gt;二层：数据链路层&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ethernet-ii-%E4%BB%A5%E5%A4%AA%E5%B8%A7&#34;&gt;Ethernet Ⅱ 以太帧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#8023-llc-snap%E4%BB%A5%E5%A4%AA%E5%B8%A7&#34;&gt;802.3 LLC SNAP以太帧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vlan%E7%BB%88%E7%BB%93&#34;&gt;VLAN终结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vlan-damping&#34;&gt;VLAN Damping&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#voice-vlan%E8%AF%AD%E9%9F%B3vlan&#34;&gt;Voice VLAN(语音vlan)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%BB%84%E7%BD%91%E6%96%B9%E6%A1%88&#34;&gt;两种常见组网方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%86%E5%88%AB%E8%AF%AD%E9%9F%B3%E6%95%B0%E6%8D%AE%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F&#34;&gt;识别语音数据流的方式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E5%9F%BA%E4%BA%8Emac%E5%9C%B0%E5%9D%80&#34;&gt;1. 基于MAC地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%9F%BA%E4%BA%8Evlan&#34;&gt;2. 基于VLAN&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96&#34;&gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;帧格式&#34;&gt;帧格式&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611120140933.png&#34; alt=&#34;帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;TPID：表示帧类型，取值为**0x8100(固定值)**时表示IEEE 802.1Q的VLAN数据帧。如果不支持802.1Q的设备收到这样的帧，会将其丢弃&lt;/li&gt;
&lt;li&gt;PRI：表示数据帧的802.1p优先级，取值范围为0～7，值越大优先级越高。当网络阻塞时，交换机优先发送优先级高的数据帧&lt;/li&gt;
&lt;li&gt;CFI：CFI取值为0表示MAC地址以标准格式进行封装，为1表示以非标准格式封装(例如令牌环)。&lt;strong&gt;在以太网中，CFI的值为0&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;VID：VLAN ID取值范围是0～4095。由于0和4095为协议保留取值，所以VLAN ID的有效取值范围是&lt;strong&gt;1～4094&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;接口的链路类型&#34;&gt;接口的链路类型&lt;/h1&gt;
&lt;h2 id=&#34;1-access接口&#34;&gt;1. Access接口&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;应用场景：&lt;br&gt;
Access接口一般用于和&lt;strong&gt;不能识别Tag的用户终端&lt;/strong&gt;（如用户主机、服务器等）相连，或者&lt;strong&gt;不需要区分不同VLAN成员&lt;/strong&gt;时使用&lt;br&gt;
为了防止用户私自更改接口用途，接入其他交换设备，&lt;strong&gt;可以配置接口丢弃入方向带Tag的报文&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;特点：&lt;br&gt;
Access接口大部分情况&lt;strong&gt;只能收发Untagged帧&lt;/strong&gt;，且&lt;strong&gt;只能为Untagged帧添加唯一VLAN的Tag&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;华为的VLAN标签实现方式和思科不同，华为的Access端口收到原始数据帧后会打上端口所属PVID的VLAN标签，而思科只有Trunk端口才会打标签&lt;/code&gt;&lt;br&gt;
必须配置缺省VLAN，该Access接口也就加入了该VLAN，Access端口只能属于一个VLAN&lt;/li&gt;
&lt;li&gt;数据处理：
&lt;ul&gt;
&lt;li&gt;入方向：
&lt;ul&gt;
&lt;li&gt;Access端口收到一个&lt;strong&gt;无标签&lt;/strong&gt;的数据帧，会&lt;strong&gt;打上&lt;/strong&gt;端口PVID的VLAN&lt;strong&gt;标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Access端口收到一个&lt;strong&gt;带标签&lt;/strong&gt;的数据帧，检查数据帧标签中的VLAN ID和接口的PVID是否一致，如果一致则接收数据帧，不一致则丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出方向：
&lt;ul&gt;
&lt;li&gt;Access端口发送&lt;strong&gt;带标签&lt;/strong&gt;的数据帧时，会&lt;strong&gt;先剥离&lt;/strong&gt;数据帧中的&lt;strong&gt;VLAN标签&lt;/strong&gt;，还原成原始数据帧后发送&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-trunk接口&#34;&gt;2. Trunk接口&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;应用场景：&lt;br&gt;
Trunk接口一般用于&lt;strong&gt;连接交换机、路由器、AP以及可同时收发Tagged帧和Untagged帧的语音终端&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;特点：&lt;br&gt;
它可以允许多个VLAN的帧带Tag通过，但只允许一个VLAN的帧从该类接口上发出时不带Tag（即剥除Tag）&lt;/li&gt;
&lt;li&gt;数据处理：
&lt;ul&gt;
&lt;li&gt;入方向：
&lt;ul&gt;
&lt;li&gt;Trunk端口收到一个&lt;strong&gt;无标签&lt;/strong&gt;的数据帧，会&lt;strong&gt;打上&lt;/strong&gt;端口PVID的VLAN&lt;strong&gt;标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Trunk端口收到一个&lt;strong&gt;带标签&lt;/strong&gt;的数据帧，将标签中的VLAN ID和Trunk端口允许通过的VLAN列表做比对，如果允许通过则接收数据帧，否则丢弃数据帧&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出方向：
&lt;ul&gt;
&lt;li&gt;Trunk端口转发一个&lt;strong&gt;带标签&lt;/strong&gt;的数据帧，将标签中的VLAN ID和Trunk端口允许通过的VLAN列表做比对，如果允许通过则转发数据帧，否则丢弃数据帧&lt;code&gt;华为设备Trunk端口默认只允许通过VLAN1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-hybrid接口&#34;&gt;3. Hybrid接口&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;应用场景：&lt;br&gt;
Hybrid接口&lt;strong&gt;既可以用于连接不能识别Tag的用户终端&lt;/strong&gt;（如用户主机、服务器等）和&lt;strong&gt;网络设备&lt;/strong&gt;（如Hub、傻瓜交换机），&lt;strong&gt;也可以用于连接交换机、路由器以及可同时收发Tagged帧和Untagged帧的语音终端、AP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;特点：&lt;code&gt;=1个Trunk+n个Access&lt;/code&gt;&lt;br&gt;
它可以允许多个VLAN的帧带Tag通过，且允许从该类接口发出的帧根据需要配置某些VLAN的帧带Tag（即不剥除Tag）&lt;code&gt;类似Trunk&lt;/code&gt;、某些VLAN的帧不带Tag（即剥除Tag）&lt;code&gt;类似多个Access&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数据处理：
&lt;ul&gt;
&lt;li&gt;入方向：
&lt;ul&gt;
&lt;li&gt;Hybrid端口收到一个&lt;strong&gt;无标签&lt;/strong&gt;的数据帧，会&lt;strong&gt;打上&lt;/strong&gt;端口PVID的VLAN&lt;strong&gt;标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Hybrid端口收到一个&lt;strong&gt;带标签&lt;/strong&gt;的数据帧，将标签中的VLAN ID和Hybrid端口的Tagged List、Untageed List做对比，如果VLAN ID存在于列表中，接收带标签的数据帧，否则丢弃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;出方向：
&lt;ul&gt;
&lt;li&gt;Hybrid端口发送一个&lt;strong&gt;带标签&lt;/strong&gt;的数据帧，如果标签中的VLAN ID在Hybrid端口的&lt;strong&gt;Untagged List&lt;/strong&gt;列表中，则&lt;strong&gt;剥离VLAN标签&lt;/strong&gt;还原成普通数据帧后转发&lt;/li&gt;
&lt;li&gt;Hybrid端口发送一个&lt;strong&gt;带标签&lt;/strong&gt;的数据帧，如果标签中的VLAN ID在Hybrid端口&lt;br&gt;
Tagged List列表中，则&lt;strong&gt;转发带标签&lt;/strong&gt;的数据帧。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Hybrid接口和Trunk接口在很多应用场景下可以通用，但在某些应用场景下，&lt;strong&gt;必须使用Hybrid接口：&lt;/strong&gt;&lt;br&gt;
比如在灵活QinQ中，服务提供商网络的多个VLAN的报文在进入用户网络前，需要剥离外层VLAN Tag，此时Trunk接口不能实现该功能，因为Trunk接口只能使该接口缺省VLAN的报文不带VLAN Tag通过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4-qinq接口8021q-in-8021q&#34;&gt;4. QinQ接口（802.1Q-in-802.1Q）&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;QinQ接口也被称为Dot1q-tunnel接口&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用场景：&lt;br&gt;
一般用于&lt;strong&gt;私网与公网之间的连接&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;特点：&lt;br&gt;
它可以给帧&lt;strong&gt;加上双层Tag&lt;/strong&gt;，即在原来Tag的基础上，给帧加上一个新的Tag，从而可以支持多达4094×4094个VLAN，满足网络对VLAN数量的需求。外层的Tag通常被称作公网Tag，用来标识公网的VLAN；内层Tag通常被称作私网Tag，用来标识私网的VLAN。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;以太网链路包括&lt;strong&gt;接入链路&lt;/strong&gt;（Access Link）和&lt;strong&gt;干道链路&lt;/strong&gt;（Trunk Link）&lt;br&gt;
&lt;strong&gt;接入链路&lt;/strong&gt;用于连接交换机和用户终端（如用户主机、服务器、傻瓜交换机等），&lt;strong&gt;只可以承载1个VLAN&lt;/strong&gt;的数据帧。&lt;br&gt;
&lt;strong&gt;干道链路&lt;/strong&gt;用于交换机间互连或连接交换机与路由器，可以&lt;strong&gt;承载多个不同VLAN的数据帧&lt;/strong&gt;。&lt;br&gt;
在接入链路上传输的帧都是Untagged帧，在干道链路上传输的数据帧必须都打上Tag。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;vlan划分&#34;&gt;VLAN划分&lt;/h1&gt;
&lt;h2 id=&#34;划分方式&#34;&gt;划分方式&lt;/h2&gt;
&lt;p&gt;VLAN划分方式可以基于接口、MAC地址、子网、网络层协议、匹配策略&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于接口&lt;br&gt;
预先给交换机的&lt;strong&gt;每个接口配置不同的PVID&lt;/strong&gt;，当一个数据帧进入交换机时，如果没有带VLAN标签，该数据帧就会被打上接口指定PVID的Tag&lt;/li&gt;
&lt;li&gt;基于协议&lt;br&gt;
预先&lt;strong&gt;配置以太网帧中的协议域和VLAN ID的映射关系表&lt;/strong&gt;，如果收到的是Untagged帧，就依据该表给数据帧添加指定VLAN的Tag&lt;/li&gt;
&lt;li&gt;基于子网&lt;br&gt;
预先&lt;strong&gt;配置IP地址和VLAN ID映射关系表&lt;/strong&gt;，当交换机收到的是Untagged帧，就依据该表给数据帧添加指定VLAN的Tag&lt;/li&gt;
&lt;li&gt;基于MAC地址&lt;br&gt;
预先&lt;strong&gt;配置MAC地址和VLAN ID映射关系表&lt;/strong&gt;，当交换机收到的是Untagged帧时，就依据该表给数据帧添加指定VLAN的Tag&lt;/li&gt;
&lt;li&gt;基于匹配策略（MAC地址、IP地址、接口）&lt;br&gt;
根据配置的策略划分VLAN，能&lt;strong&gt;实现多种组合的划分方式&lt;/strong&gt;，包括接口、MAC地址、IP地址等。预先&lt;strong&gt;配置策略&lt;/strong&gt;，如果收到的是Untagged帧，且匹配配置的策略时，给数据帧添加指定VLAN的Tag&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;匹配优先级&#34;&gt;匹配优先级&lt;/h2&gt;
&lt;p&gt;如果入方向Untagged帧同时匹配多种划分VLAN的方式，则优先级顺序从高至低依次是：&lt;code&gt;匹配策略 &amp;gt; MAC地址 &amp;gt; 子网 &amp;gt; 协议 &amp;gt; 接口&lt;/code&gt;&lt;br&gt;
如果报文同时匹配了基于MAC地址和子网划分VLAN，缺省情况下，优先基于MAC地址划分VLAN，可以通过命令改变基于MAC地址划分VLAN和基于子网划分VLAN的优先级，从而决定优先划分VLAN的方式。&lt;br&gt;
基于接口划分VLAN的优先级最低，但是最常用的VLAN划分方式。&lt;/p&gt;
&lt;h1 id=&#34;vlan-mappingvlan-translation或vlan映射&#34;&gt;VLAN Mapping（VLAN Translation或VLAN映射）&lt;/h1&gt;
&lt;p&gt;通过修改报文携带的VLAN Tag来实现不同VLAN的相互映射&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611137634730.png&#34; alt=&#34;VLAN Mapping&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
使用场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两个VLAN相同的二层用户网络通过骨干网络互联，为了实现用户之间的二层互通，以及二层协议（例如MSTP等）的统一部署，需要实现两个用户网络的无缝连接，此时就需要骨干网可以传输来自用户网络的带有VLAN Tag的二层报文。而在通常情况下，骨干网的VLAN规划和用户网络的VLAN规划是不一致的，所以在骨干网中无法直接传输用户网络的带有VLAN Tag的二层报文。&lt;/li&gt;
&lt;li&gt;如果由于规划的差异，导致两个直接相连的二层网络中部署的VLAN ID不一致。但是用户又希望可以把两个网络作为单个二层网络进行统一管理，例如用户二层互通和二层协议的统一部署。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;qinq&#34;&gt;QinQ&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;作用：使私网 VLAN 透传公网
&lt;ul&gt;
&lt;li&gt;扩展 VLAN，对用户进行隔离和标识不再受到限制&lt;/li&gt;
&lt;li&gt;QinQ 内外层标签可以代表不同的信息，如内层标签代表用户，外层标签代表业务， 更利于业务的部署&lt;/li&gt;
&lt;li&gt;QinQ 封装、终结的方式很丰富，帮助运营商实现业务精细化运营&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;原理 ：打上双层标签，使私网的 VLAN 透传到公网，外层放的是公网的标签，内层放 的是私网的标签，在公网上剥离公网标签，两边设备就可以跨公网互访了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;基本QinQ&lt;br&gt;
基本QinQ是&lt;strong&gt;基于端口&lt;/strong&gt;方式实现的。当端口上配置了基本QinQ功能后，不论从该端口收到报文&lt;strong&gt;是否带有VLAN Tag&lt;/strong&gt;，设备都会为该报文&lt;strong&gt;打上本端口缺省VLAN的Tag&lt;/strong&gt;。&lt;br&gt;
如果收到的是带有VLAN Tag的报文，该报文就成为带双Tag的报文。&lt;br&gt;
如果收到的是不带VLAN Tag的报文，该报文就成为带有本端口缺省VLAN Tag的报文。&lt;/li&gt;
&lt;li&gt;灵活QinQ&lt;br&gt;
灵活QinQ是&lt;strong&gt;基于端口与VLAN相结合&lt;/strong&gt;的方式实现的，即端口对接收的报文，可以通过单层VLAN tag转发，也可以通过双层VLAN tag转发。&lt;br&gt;
指定条件：入方向报文&lt;strong&gt;VLAN的范围&lt;/strong&gt;或&lt;strong&gt;VLAN+802.1P优先级&lt;/strong&gt;。仅指定报文802.1P优先级时，不关注入报文外层VLAN的具体值，只要外层VLAN的802.1P优先级匹配就会打上VLAN tag&lt;br&gt;
另外对于从同一个端口收到的报文，还可以根据VLAN的不同进行不同的操作，包括：
&lt;ol&gt;
&lt;li&gt;为具有不同内层VLAN ID的报文添加不同的外层VLAN Tag&lt;/li&gt;
&lt;li&gt;根据报文内层VLAN的802.1p优先级标记外层VLAN的802.1p优先级和添加不同的外层VLAN Tag&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;基于流的灵活QinQ&lt;br&gt;
基于流的灵活QinQ通过全局配置流分类、流行为，再将流策略绑定流分类和流行为来实现&lt;br&gt;
相对灵活QinQ，基于流的灵活QinQ还可以根据入报文的内层VLAN的属性来加VLAN tag，配置范围更加灵活。如：内层VLAN、内层VLAN+802.1P、外层VLAN、外层VLAN+802.1P等属性&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;封装方式&#34;&gt;封装方式&lt;/h2&gt;
&lt;p&gt;QinQ封装是指如何把单层Q报文转换成双层Q报文，封装主要发生在&lt;strong&gt;城域网面向用户的UPE&lt;sub&gt;靠近用户侧的PE设备，主要作为用户接入VPN的汇聚设备&lt;/sub&gt;接口上进行&lt;/strong&gt;。&lt;br&gt;
根据不同的封装数据，QinQ可以分为几种不同类型，包括基于接口的QinQ和基于流的QinQ两大类，另外，还可以在路由子接口上进行特殊的QinQ封装，具体如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;基于接口的QinQ封装（基本QinQ）&lt;br&gt;
基于接口的封装是指&lt;strong&gt;进入一个接口的所有流量全部封装一个相同的外层VLAN Tag&lt;/strong&gt;，封装方式不够灵活，用户业务区分不够细致，这种封装方式也称作&lt;strong&gt;QinQ二层隧道&lt;/strong&gt;&lt;br&gt;
基于端口的QinQ通过配置端口类型为dot1q-tunnel实现，当端口类型为dot1q-tunnel时，该端口加入的VLAN&lt;strong&gt;不支持二层组播功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;基于流的QinQ封装（基于流的灵活QinQ）&lt;br&gt;
基于流的QinQ封装可以对进入接口的数据首先&lt;strong&gt;进行流分类&lt;/strong&gt;，然后对于不同的数据流选择是否封装外层Tag、封装何种外层Tag，因此这种封装方式也称作&lt;strong&gt;二层灵活QinQ&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在路由子接口上进行QinQ封装&lt;br&gt;
QinQ封装一般在二层接口上进行，但有一种特殊情况，QinQ也可以在路由子接口上进行封装。&lt;br&gt;
当MPLS/IP核心网采用PWE3/VLL/VPLS透传业务数据时，NPE上的路由子接口可以根据用户VLAN ID封装外层VLAN ID，通过外层VLAN ID接入VLL/PWE3。此种方法可以通过一个子接口来透传多个标识用户的VLAN ID，这种子接口也叫&lt;strong&gt;QinQ Stacking子接口&lt;/strong&gt;。&lt;br&gt;
这种封装方式也是基于流的QinQ封装方式，但QinQ Stacking子接口只能和L2VPN(PWE3/VLL/VPLS)业务结合起来才有意义，&lt;strong&gt;不支持三层转发功能&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;vlan聚合super-vlan&#34;&gt;VLAN聚合（Super VLAN）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;主要功能就是&lt;strong&gt;节约IP地址(启用super vlan后，不同的VLAN可以共用一个网关IP，正常的VLAN，一个VLAN就需要一个网关IP)&lt;/strong&gt;，隔离广播风暴，控制端口二层互访&lt;/li&gt;
&lt;li&gt;Super VLAN下关联多个Sub VLAN，Sub VLAN之间二层隔离。所有Sub VLAN共用Super VLAN的VLANIF接口IP地址与外网通信，并且可以通过Super VLAN的VLANIF接口三层互通，从而节约IP地址&lt;/li&gt;
&lt;li&gt;适用于用户多，VLAN多，大量VLAN的IP地址在同一个网段，但是又要实现不同VLAN之间二层隔离的场景。VLAN之间如果有互访的需求，可以对Super VLAN开启ARP代理。常见的场景有宾馆酒店，小区宽带接入等&lt;/li&gt;
&lt;li&gt;注意事项
&lt;ol&gt;
&lt;li&gt;VLAN 1不能配置为Super VLAN&lt;/li&gt;
&lt;li&gt;配置某VLAN为Super VLAN后，该VLAN类型改变为super，不允许任何物理接口加入该VLAN&lt;/li&gt;
&lt;li&gt;如果要实现Vlan之间的互通，需要开启Vlan间的ARP代理&lt;code&gt;arp-proxy inter-sub-vlan-proxy enable&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;与MUX VLAN隔离功能相比，Super VLAN属于三层功能，需要三层交换机支持，MUX VLAN属于二层交换机功能。&lt;br&gt;
Super VLAN的配置较为简单，MUX VLAN配置较为复杂，但对用户间的访问控制灵活性不如MUX VLAN，Super VLAN内需要查询部分暂时离线的用户时，网关需要在每个子VLAN内广播发送报文，可能较大的消耗设备CPU资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;mux-vlan&#34;&gt;Mux-Vlan&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;实现Vlan之间的隔离&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Mux-Vlan划分表&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611151220809.png&#34; alt=&#34;Mux-Vlan划分表&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通信原理&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611151256368.png&#34; alt=&#34;通信原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611151400210.png&#34; alt=&#34;示意图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
根据MUX VLAN特性，企业可以用&lt;strong&gt;Principal port连接企业服务器&lt;/strong&gt;、&lt;strong&gt;Separate port连接企业客户&lt;/strong&gt;、&lt;strong&gt;Group port连接企业员工&lt;/strong&gt;。这样就能够实现企业客户、企业员工都能够访问企业服务器，而企业员工内部可以通信、企业客户间不能通信、企业客户和企业员工之间不能通信的目的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;smart-link和monitor-link&#34;&gt;Smart Link和Monitor Link&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613825844109.png&#34; alt=&#34;Smart Link和Monitor Link&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;smart-link备份链路&#34;&gt;Smart Link(备份链路)&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;在接口下配置Smart Link之前，需要关闭该接口下的生成树协议（STP、RSTP和MSTP）&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目的&lt;br&gt;
Smart Link&lt;strong&gt;常用于双上行组网&lt;/strong&gt;，提供可靠高效的备份和快速的切换机制。将一台下游设备同时连接到两台上游设备，可降低单点故障对网络的影响，提高了可靠性。&lt;/li&gt;
&lt;li&gt;接口角色
&lt;ol&gt;
&lt;li&gt;主接口&lt;br&gt;
主接口又叫Master接口，当两个接口都处于待命状态时，主接口将&lt;strong&gt;优先进入转发状态&lt;/strong&gt;，但主接口并不一直处于转发状态，发生链路切换后，如果从接口已经处于转发状态，那么即使主接口链路恢复正常，也只能处于待命状态（默认不支持抢占），直到再进行一次链路切换（如果配置回切功能，回切时间&lt;sub&gt;(配置回切功能后默认为60秒)&lt;/sub&gt;到时，会切换到主链路）&lt;/li&gt;
&lt;li&gt;从接口&lt;br&gt;
从接口又叫Slave接口，当两个接口都处于待命状态时，从接口保持待命状态。从接口并不一直处于待命状态，当发生链路切换后，从接口将切换到转发状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;组网方式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1613824105102.png&#34; alt=&#34;组网方式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
SwitchD采用双上行方式分别连接到SwitchB和SwitchC，这样SwitchD到达SwitchA的链路就可以有两条（SwitchD-&amp;gt;SwitchB-&amp;gt;SwitchA和SwitchD-&amp;gt;SwitchC-&amp;gt;SwitchA），但是网络中的环路会产生网络风暴。在SwitchA上配置Smart Link，正常情况下，可实现Interface2所在链路作为Interface1所在链路的备份。&lt;br&gt;
优点：
&lt;ol&gt;
&lt;li&gt;能够实现在双上行组网的两条链路正常情况下，一条链路处于转发状态，而另一条处于阻塞待命状态，从而可避免环路的不利影响&lt;/li&gt;
&lt;li&gt;配置和使用更为简洁，便于用户操作&lt;/li&gt;
&lt;li&gt;当主用链路发生故障后，流量会在毫秒级的时间内迅速切换到备用链路上，极大限度地保证了数据的正常转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Flush报文&lt;br&gt;
&lt;strong&gt;当Smart Link组发生链路切换时&lt;/strong&gt;，原有的转发表项将不适用于新的拓扑网络，需要整网进行MAC表项和ARP表项的更新。这时，Smart Link组通过发送Flush报文通知其他设备进行MAC和ARP表项的刷新操作。当链路发生切换时，SwitchD会发送Flush报文通知SwitchB、SwitchC和SwitchA进行MAC和ARP表项的更新。&lt;code&gt;Flush 报文是组播报文，组播地址01-0F-E2-00-00-04&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1611153184049.png&#34; alt=&#34;Flush报文&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;控制VLAN（Control VLAN）
&lt;ol&gt;
&lt;li&gt;发送控制VLAN&lt;br&gt;
发送控制VLAN是Smart Link组用于广播Flush报文的VLAN。如果在SwitchD上开启了Flush报文发送功能，当发生链路切换时，设备会在发送控制VLAN内广播发送Flush报文&lt;/li&gt;
&lt;li&gt;接收控制VLAN&lt;br&gt;
接收控制VLAN是上游设备用于接收并处理Flush报文的VLAN。如果上游设备SwitchA、SwitchB和SwitchC能够识别Flush报文，并开启了Flush报文接收处理功能，当发生链路切换时，上游设备会处理收到的属于接收控制VLAN的Flush报文，进而刷新MAC表和ARP表&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;负载分担&lt;br&gt;
Smart Link支持配置多个负载分担VLAN实例。当Smart Link 组的主从链路均正常时，Smart link&lt;strong&gt;允许两条链路可以转发不同的数据流量&lt;/strong&gt;。&lt;strong&gt;负载分担情况下，两个接口均处于转发状态&lt;/strong&gt;，从接口转发负载分担实例流量（对负载分担实例的数据流量进行转发，对非负载分担实例的数据流量进行阻塞），主接口转发非负载分担的实例流量（与从接口相反）。当其中一条链路故障时，Smart Link组会自动将所有的流量切换到另一条链路上&lt;/li&gt;
&lt;li&gt;Smart Link实例&lt;br&gt;
Smart Link组的备链路通过绑定不同的实例来实现负载分担。Smart Link引用MSTP的实例，每个实例用来绑定若干VLAN，不同的实例绑定不同的VLAN&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;monitor-link监控链路&#34;&gt;Monitor Link(监控链路)&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1613824816996.png&#34; alt=&#34;Monitor Link组&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;定义&lt;br&gt;
通过&lt;strong&gt;监控设备的上行接口&lt;/strong&gt;，根据其Up/Down状态的变化来&lt;strong&gt;触发下行接口Up/Down状态的变化&lt;/strong&gt;，从而触发下游设备上的拓扑协议进行链路的切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Monitor Link组&lt;br&gt;
Monitor Link组也叫监控链路组，由上行接口和下行接口共同组成。&lt;strong&gt;组的成员可以是单接口、静态聚合组、手工聚合组或Smart Link组，其中Smart Link组只能作为上行接口&lt;/strong&gt;。&lt;code&gt;下行接口的状态随上行接口的变化而变化&lt;/code&gt;。Interface1和Interface2组成了一个Monitor Link组；Interface3和Interface4组成了一个Monitor Link组。&lt;/li&gt;
&lt;li&gt;上行接口&lt;br&gt;
上行接口又称为Uplink接口，是Monitor Link组中&lt;code&gt;受监控者&lt;/code&gt;，&lt;strong&gt;上行接口故障则表示该Monitor Link组故障&lt;/strong&gt;，&lt;strong&gt;该组的下行接口将都会被强制设为Down状态&lt;/strong&gt;。Interface1和Interface3为上行接口。&lt;code&gt;上行链路也可以是Smart Link组，当上行链路是Smart Link组时，只有当Smart Link组的两个接口都处于Inactive状态（包括Down）时，才能认为该上行链路故障&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;下行接口&lt;br&gt;
下行接口又称为Downlink接口，是Monitor Link组中&lt;code&gt;监控者&lt;/code&gt;，下行接口故障不影响上行接口，也不影响其他下行接口。Interface2和Interface4为下行接口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基本原理&lt;br&gt;
配置Monitor Link组后，&lt;strong&gt;上行接口将被实时监控&lt;/strong&gt;，一旦上行接口出现故障，包括链路故障、OAM的单通故障、OAM的连接无法建立等，其所在组的所有Up的下行接口都会被强制设为ERROR-DOWN状态。当上行链路恢复正常时，恢复下行接口。&lt;br&gt;
如果Interface1所在的上行链路发生故障，Monitor Link会将Interface2强制设为ERROR-DOWN状态。从而SwitchC可以感知经由SwitchB到达SwitchA的这条链路发生故障。当Interface1所在的上行链路恢复正常后，Monitor Link会取消对Interface2强制设定的ERROR-DOWN状态，开启Interface2&lt;br&gt;
&lt;strong&gt;当上行接口是Smart Link组时&lt;/strong&gt;，只有当Smart Link组的&lt;strong&gt;两个接口都处于Inactive状态&lt;/strong&gt;（包括Down）时，&lt;strong&gt;才能认为该上行接口故障&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;当下行接口是聚合组时&lt;/strong&gt;，&lt;strong&gt;上行故障将会强制将聚合组中的所有接口设为ERROR-DOWN状态&lt;/strong&gt;，同样，恢复时也是对聚合组的所有接口进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;二层数据链路层&#34;&gt;二层：数据链路层&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;当Type字段值&amp;lt;=1500(0x5DC)时为802.3，&amp;gt;=1536(0x0600)为Ethernet Ⅱ 以太帧&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;ethernet-ii-以太帧&#34;&gt;Ethernet Ⅱ 以太帧&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;帧格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586671980508.png&#34; alt=&#34;Ethernet Ⅱ 以太帧&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Type值对应的协议&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586672267977.png&#34; alt=&#34;Type值对应的协议&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8023-llc-snap以太帧&#34;&gt;802.3 LLC SNAP以太帧&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;帧格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586672668442.png&#34; alt=&#34;802.3 LLC SNAP以太帧&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;vlan终结&#34;&gt;VLAN终结&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;定义&lt;br&gt;
指设备对接收到的报文中的VLAN标签进行识别，根据后续的转发行为对报文中的单层或双层VLAN标签进行剥除，然后进行三层转发或其他处理。也就是这些VLAN标签只在终结之前生效，之后的三层转发或其他处理不再依据报文中的这些标签。&lt;/li&gt;
&lt;li&gt;VLAN终结的实质包含两个方面：&lt;br&gt;
对接口接收到报文，剥除VLAN标签后进行三层转发或其他处理。&lt;br&gt;
对接口发出的报文，又将相应的VLAN标签添加到报文中后再发送。&lt;/li&gt;
&lt;li&gt;分类&lt;br&gt;
根据对所终结的VLAN报文处理方式的不同，VLAN终结分为以下两种：
&lt;ol&gt;
&lt;li&gt;Dot1q终结：&lt;br&gt;
对接收到的带有一层或两层VLAN Tag的报文，剥除报文的最外一层VLAN Tag；&lt;br&gt;
对从接口发出的报文，添加一层VLAN Tag。&lt;/li&gt;
&lt;li&gt;QinQ终结：&lt;br&gt;
对接收到的带有两层VLAN Tag的报文，剥除报文的两层VLAN Tag；&lt;br&gt;
对从接口发出的报文，添加两层VLAN Tag。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;VLAN终结&lt;strong&gt;一般在子接口上进行&lt;/strong&gt;，如果子接口是对报文中的单层VLAN标签终结，该子接口就称为Dot1q终结子接口；如果&lt;strong&gt;子接口是对报文中的双层VLAN标签终结&lt;/strong&gt;，该子接口就称为QinQ终结子接口。&lt;br&gt;
&lt;code&gt;Dot1q终结子接口和QinQ终结子接口不支持透传不带VLAN Tag的报文，收到不带VLAN Tag的报文会直接丢弃&lt;/code&gt;&lt;br&gt;
4. 目的（适应场景）&lt;br&gt;
划分VLAN后，VLAN内的主机可以二层互通，而VLAN间的主机不能二层互通。可以在Router上通过VLANIF来实现VLAN间的三层互通，但&lt;strong&gt;当Router的三层以太网接口有限&lt;/strong&gt;，&lt;strong&gt;只使用一个接口接入用户或网络时&lt;/strong&gt;，&lt;strong&gt;一个接口上需要传输多个VLAN报文&lt;/strong&gt;，VLANIF无法实现。此时，可将一个三层以太网接口虚拟成多个逻辑子接口（相对子接口而言，这个三层以太网接口称为主接口）&lt;/p&gt;
&lt;h2 id=&#34;vlan-damping&#34;&gt;VLAN Damping&lt;/h2&gt;
&lt;p&gt;如果指定VLAN已经创建对应的VLANIF接口，当VLAN中所有接口状态变为Down而引起VLAN状态变为Down时，VLAN会向VLANIF接口上报接口Down状态，从而引起VLANIF接口状态变化。&lt;br&gt;
为避免由于VLANIF接口状态变化引起的网络震荡，可以在VLANIF接口上启动VLAN Damping功能，抑制VLANIF接口状态变为Down的时间。&lt;br&gt;
当使能VLAN Damping功能，VLAN中最后一个处于Up状态的接口变为Down后，会抑制一定时间（抑制时间可配置）再上报给VLANIF接口。如果在抑制时间内VLAN中有接口Up，则VLANIF接口状态保持Up状态不变。即VLAN Damping功能可以适当延迟VLAN向VLANIF接口上报接口Down状态的时间，从而抑制不必要的路由震荡。&lt;/p&gt;
&lt;h2 id=&#34;voice-vlan语音vlan&#34;&gt;Voice VLAN(语音vlan)&lt;/h2&gt;
&lt;p&gt;Voice VLAN是为用户的语音流专门划分的VLAN&lt;br&gt;
通过配置Voice VLAN，交换机可识别语音流，将语音流加入到Voice VLAN中传输，并对其进行有针对性的QoS保障，当网络发生拥塞时可以优先保证语音流的传输&lt;/p&gt;
&lt;h3 id=&#34;两种常见组网方案&#34;&gt;两种常见组网方案&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1615095732049.png&#34; alt=&#34;1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615095739746.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;识别语音数据流的方式&#34;&gt;识别语音数据流的方式&lt;/h3&gt;
&lt;p&gt;一般来说，IP电话分为两大类：发送带Tag语音报文的IP电话（如Cisco 7960）、发送untagged语音报文的IP电话（如华为MC850）&lt;br&gt;
若要提高语音数据流的传输优先级，首先要能识别出语音数据流，识别出语音数据流后，再对语音数据流提升优先级后传输。&lt;/p&gt;
&lt;h4 id=&#34;1-基于mac地址&#34;&gt;1. 基于MAC地址&lt;/h4&gt;
&lt;p&gt;设备可以根据进入接口的数据报文中的&lt;strong&gt;源MAC地址&lt;/strong&gt;字段来判断该数据流是否为语音数据流。源MAC地址匹配系统设置的语音设备的组织&lt;strong&gt;唯一标识符OUI&lt;/strong&gt;的报文被认为是语音数据流，&lt;strong&gt;用户需要预先设置OUI&lt;/strong&gt;，&lt;strong&gt;适用于IP电话上送untagged语音报文的场景&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;根据OUI识别IP电话机的原理就是根据IP电话厂商申请的MAC地址段来识别哪些报文是电话机发送的，以此来判断哪些报文属于语音报文&lt;/code&gt;&lt;br&gt;
Voice VLAN中的OUI&lt;strong&gt;有别于上述的通常意义的OUI&lt;/strong&gt;，这个OUI是由&lt;strong&gt;用户来配置的&lt;/strong&gt;，而且&lt;strong&gt;可以使用掩码&lt;/strong&gt;，即&lt;strong&gt;不需要一定是24位掩码的&lt;/strong&gt;，掩码长度用户可以自己指定。OUI的值为voice-vlan mac-address命令中的mac-address和mask参数相与的结果。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615097091211.png&#34; alt=&#34;基于MAC地址&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
交换机接收到PC和IP电话发出的&lt;strong&gt;untagged报文&lt;/strong&gt;后会做如下处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果源MAC匹配交换机上配置的OUI（源MAC地址与配置的OUI掩码进行与运算后等于OUI视为匹配），则为该报文加上Voice VLAN的Tag，并提升报文优先级&lt;/li&gt;
&lt;li&gt;如果不匹配，就会为其加上PVID的VLAN Tag，从而保证语音报文的优先发送&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于MAC地址模式下，接口加入Voice VLAN的方式可分为手动模式和自动模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自动模式&lt;/strong&gt;：当语音设备发出的报文中&lt;strong&gt;源MAC地址匹配配置的OUI&lt;/strong&gt;时，系统会将连接语音设备的接口自动加入到Voice VLAN中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;手动模式&lt;/strong&gt;：当使能Voice VLAN功能后，必须通过&lt;strong&gt;手工将连接语音设备的接口加入到Voice VLAN&lt;/strong&gt;中，这样才能保证Voice VLAN功能生效&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据&lt;strong&gt;使能了Voice VLAN功能的接口&lt;/strong&gt;对接收到的数据包的&lt;strong&gt;过滤机制&lt;/strong&gt;可以将Voice VLAN的工作模式分为安全模式和普通模式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;安全模式&lt;/strong&gt;：只允许收到的&lt;strong&gt;源地址与OUI匹配的语音报文通过&lt;/strong&gt;，该Voice VLAN内的&lt;strong&gt;非语音报文将被直接丢弃&lt;/strong&gt;，其他VLAN内的报文正常转发。只有当通过命令&lt;code&gt;voice-vlan remark-mode mac-address&lt;/code&gt;指定&lt;strong&gt;语音报文基于MAC地址提升优先级&lt;/strong&gt;时，安全模式才会生效&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;普通模式&lt;/strong&gt;：使能了Voice VLAN功能的&lt;strong&gt;入接口允许同时传输语音报文和非语音报文&lt;/strong&gt;，容易受到恶意数据流量的攻击。不建议将语音和数据业务规划在同一个VLAN里面。如确有此需要，请确认Voice VLAN工作在普通模式。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-基于vlan&#34;&gt;2. 基于VLAN&lt;/h4&gt;
&lt;p&gt;若有大量IP电话接入交换机，配置IP电话的OUI就可能会非常繁琐。可在交换机上配置基于VLAN来提升语音报文的优先级，此时设备会根据进入接口的&lt;strong&gt;报文的VLAN ID&lt;/strong&gt;来判断该数据报文是否为语音报文。&lt;strong&gt;当VLAN ID匹配系统配置的Voice VLAN后&lt;/strong&gt;，则认为是语音数据流。这种方式&lt;strong&gt;实现的前提&lt;/strong&gt;是&lt;strong&gt;IP电话支持获取交换机上配置的Voice VLAN信息&lt;/strong&gt;的功能，在大量IP电话接入的情况下，可以简化配置&lt;/p&gt;
&lt;p&gt;IP电话获取交换机上Voice VLAN信息的方法有很多，以下以IP电话通过LLDP获取交换机Voice VLAN信息为例介绍一下实现过程：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1615097479146.png&#34; alt=&#34;基于VLAN&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IP电话上线会主动发送LLDP报文，以获取交换机上配置的Voice VLAN信息&lt;/li&gt;
&lt;li&gt;交换机收到IP电话发送的LLDP报文，会在相关字段填充Voice VLAN信息发给IP电话&lt;/li&gt;
&lt;li&gt;IP电话收到携带Voice VLAN信息的LLDP报文后，再次发送语音报文时就会带Tag发送&lt;/li&gt;
&lt;li&gt;交换机收到带Tag的语音报文，如果Tag和交换机上配置的Voice VLAN匹配，则为其提升优先级后转发&lt;/li&gt;
&lt;li&gt;交换机收到untagged报文，仍然会加入到PVID所在的VLAN中。这样，当发生网络拥塞的时候交换机就能保证语音报文的优先发送。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这两种方式主要区别在于：&lt;br&gt;
当IP电话上送的是&lt;strong&gt;untagged语音报文&lt;/strong&gt;时，&lt;strong&gt;必须配置OUI&lt;/strong&gt;，才能把语音报文和数据报文区分开来&lt;br&gt;
如果IP电话上送的是&lt;strong&gt;带Tag语音报文&lt;/strong&gt;，则&lt;strong&gt;可配置基于VLAN的Voice VLAN&lt;/strong&gt;，这样在大量IP电话接入的情况下，就不用配置繁琐的OUI，&lt;strong&gt;简化配置&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;其他&#34;&gt;其他&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用VLAN的目的：划分广播域，减小广播风暴的范围&lt;/li&gt;
&lt;li&gt;VlanID的配置范围为1到4094&lt;/li&gt;
&lt;li&gt;Hybrid最大的优势在于可以定义&lt;code&gt;Untageed List&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;缺省VLAN又称PVID（Port Default VLAN ID）&lt;/li&gt;
&lt;li&gt;链路类型协商协议LNP用来动态协商以太网接口的链路类型为Access或者Trunk
&lt;ol&gt;
&lt;li&gt;以太网接口的链路类型协商为Access，缺省情况下加入VLAN1&lt;/li&gt;
&lt;li&gt;以太网接口的链路类型协商为Trunk，缺省情况下加入VLAN1～4094&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Vlan划分总体分为两大类：静态划分（接口）和动态划分（终端，例如MAC地址、子网、协议和策略，&lt;code&gt;华为设备要想使用动态划分，接口类型必须是Hybrid&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;代理ARP，分为三层代理ARP（路由ARP）、VLAN间的代理ARP、VLAN内的代理ARP&lt;/li&gt;
&lt;li&gt;Hybrid使用场景：
&lt;ol&gt;
&lt;li&gt;动态VLAN划分&lt;/li&gt;
&lt;li&gt;灵活QinQ和基于流的灵活QinQ&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;一个物理接口最多可以划分4096个子接口。因为在子接口下区分流量使用的是Dot1q，也就是vlanID，因此物理接口划分子接口的数量和vlan一样&lt;/li&gt;
&lt;li&gt;所有VLanIF接口的MAC地址=交换机的背板MAC，即所有的VLanIF使用同一个Mac&lt;/li&gt;
&lt;li&gt;三层交换机收到数据帧之后如何判断进行二层转发还是三层转发？&lt;br&gt;
查看目标Mac。如果目标Mac为本地接口的Mac地址，则进行三层转发，这表明这个数据帧是发给我自己的；如果目标Mac不是本地接口地址，则进行二层转发。&lt;/li&gt;
&lt;li&gt;Smart Link与生成树STP的区别？&lt;br&gt;
Smart Link没有报文交互，只是本地状态切换，切换速度更快，但是只能用在单台设备上&lt;/li&gt;
&lt;/ol&gt;
">二层协议-VLAN</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/er-ceng-xie-yi-mstp/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#mstp%E5%87%BA%E7%8E%B0%E7%9A%84%E8%83%8C%E6%99%AF&#34;&gt;MSTP出现的背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%8C%E4%B8%80%E4%B8%AAmst%E5%9F%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E9%87%8D%E7%82%B9star&#34;&gt;同一个MST域的条件（重点）:star:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%AF%E8%AF%AD%E4%BB%A5%E5%8F%8A%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E5%9B%BE%E8%B0%B1&#34;&gt;术语以及之间的关系图谱&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cist%E4%B8%AD%E7%9A%84%E9%80%89%E4%B8%BE%E8%BF%87%E7%A8%8B&#34;&gt;CIST中的选举过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mstp%E6%8B%93%E6%89%91%E8%AE%A1%E7%AE%97&#34;&gt;MSTP拓扑计算&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%85%88%E7%BA%A7%E5%90%91%E9%87%8F&#34;&gt;优先级向量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%AF%94%E8%BE%83%E5%8E%9F%E5%88%99cist%E9%80%89%E4%B8%BE%E7%9A%84%E9%A1%BA%E5%BA%8F%E9%87%8D%E7%82%B9star&#34;&gt;比较原则（CIST选举的顺序）（重点）:star:&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cist%E7%9A%84%E8%AE%A1%E7%AE%97&#34;&gt;CIST的计算&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#msti%E7%9A%84%E8%AE%A1%E7%AE%97&#34;&gt;MSTI的计算&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#msti%E7%9A%84%E7%89%B9%E7%82%B9&#34;&gt;MSTI的特点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8-mstp&#34;&gt;为什么需要使用 MSTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
多生成树协议MSTP，协议标准IEEE 802.1s，通过生成多个生成树，来解决以太网环路问题。&lt;br&gt;
BPDU包组播地址：&lt;code&gt;01-80-C2-00-00-00&lt;/code&gt;&lt;br&gt;
MSTP的报文是通过802.3（Vlan）承载的。&lt;/p&gt;
&lt;h1 id=&#34;mstp出现的背景&#34;&gt;MSTP出现的背景&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;RSTP和STP还存在&lt;strong&gt;同一个缺陷&lt;/strong&gt;：由于局域网内所有的VLAN共享一棵生成树，因此无法在VLAN间实现数据流量的负载均衡，链路被阻塞后将不承载任何流量，还有可能造成部分VLAN的报文无法转发&lt;/li&gt;
&lt;li&gt;MSTP兼容STP和RSTP，既可以快速收敛，又提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡&lt;/li&gt;
&lt;li&gt;MSTP把一个交换网络划分成多个域，每个域内形成多棵生成树，生成树之间彼此独立。每棵生成树叫做一个多生成树实例MSTI，每个域叫做一个MST域&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;生成树实例是多个VLAN的一个集合。通过将多个VLAN捆绑到一个实例，可以节省通信开销和资源占用率。MSTP各个实例拓扑的计算相互独立，在这些实例上可以实现负载均衡。可以把多个相同拓扑结构的VLAN映射到一个实例里，这些VLAN在端口上的转发状态取决于端口在对应MSTP实例的状态&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此，&lt;strong&gt;MSTP的目的有两个&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;形成多棵无环路的树，解决广播风暴并实现冗余备份&lt;/li&gt;
&lt;li&gt;多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;报文格式&#34;&gt;报文格式&lt;/h1&gt;
&lt;p&gt;MSTP的报文是通过RSTP报文来承载的，因此&lt;code&gt;BPDU Type=02&lt;/code&gt;，只不过是多了一个MST扩展，扩展中包含MSTP的内容。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610959610216.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
无论是域内的MST BPDU还是域间的，前36个字节和RST BPDU相同。从&lt;strong&gt;第37个字节开始是MSTP专有字段&lt;/strong&gt;，最后的MSTI配置信息字段由若干MSTI配置信息组连接而成。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version 3 Length：MSTP的BPDU的长度&lt;/li&gt;
&lt;li&gt;MST Configuration Identifier：MST配置标识，表示MST域的标签信息，包含4个字段。&lt;/li&gt;
&lt;li&gt;CIST Internal Root Path Cost：CIST内部路径开销指从本端口到IST Master交换设备的累计路径开销。CIST内部路径开销根据链路带宽计算&lt;/li&gt;
&lt;li&gt;CIST Bridge Identifier：CIST的指定交换设备ID&lt;/li&gt;
&lt;li&gt;CIST Remaining Hops：BPDU报文在CIST中的剩余跳数&lt;/li&gt;
&lt;li&gt;MSTI Configuration Messages：MSTI配置信息。每个MSTI的配置信息占16 bytes，如果有n个MSTI就占用n×16bytes&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;同一个mst域的条件重点star&#34;&gt;同一个MST域的条件（重点）⭐️&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;都启动了MSTP&lt;/li&gt;
&lt;li&gt;具有相同的域名&lt;/li&gt;
&lt;li&gt;具有相同的VLAN到生成树实例映射配置&lt;/li&gt;
&lt;li&gt;具有相同的MSTP修订级别配置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即&lt;strong&gt;MST配置标识&lt;/strong&gt;必须一致：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610977630582.png&#34; alt=&#34;MST配置标识&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;优先级只能是4096的倍数的原因：&lt;br&gt;
&lt;code&gt;RootID&lt;/code&gt; = &lt;code&gt;PRI(2B)&lt;/code&gt;+&lt;code&gt;背板MAC(6B)&lt;/code&gt; = &lt;code&gt;PRI(4bit)&lt;/code&gt;+&lt;code&gt;SYSID(12bit，这一块就是VlanID，最大4096)&lt;/code&gt;+&lt;code&gt;MAC(6B)&lt;/code&gt;&lt;br&gt;
设置优先级时primary代表优先级为0，secondary代表优先级为4096&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;术语以及之间的关系图谱&#34;&gt;术语以及之间的关系图谱&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1610977943667.png&#34; alt=&#34;图1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610981803137.png&#34; alt=&#34;图2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多生成树实例MSTI&lt;br&gt;
所有运行STP/RSTP/MSTP的交换设备经MSTP协议计算后形成的树状网络&lt;/li&gt;
&lt;li&gt;多生成树域MST域&lt;br&gt;
由交换网络中的多台交换设备以及它们之间的网段所构成&lt;/li&gt;
&lt;li&gt;公共生成树CST&lt;br&gt;
连接交换网络内所有MST域的一棵生成树&lt;br&gt;
如果把每个MST域看作是一个节点，CST就是这些节点通过STP或RSTP协议计算生成的一棵生成树&lt;br&gt;
如图1所示，黑色线条连接各个域构成CST&lt;/li&gt;
&lt;li&gt;内部生成树IST&lt;br&gt;
各MST域内的一棵生成树&lt;br&gt;
IST是一个特殊的MSTI，MSTI的ID为0，通常称为MSTI0，IST是CIST在MST域中的一个片段&lt;br&gt;
如图1所示，深蓝色线条在域中连接该域的所有交换设备构成IST&lt;/li&gt;
&lt;li&gt;单生成树SST：两种情况
&lt;ol&gt;
&lt;li&gt;运行STP或RSTP的交换设备只能属于一个生成树&lt;/li&gt;
&lt;li&gt;MST域中只有一个交换设备，这个交换设备构成单生成树&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;公共内部生成树CIST：所有MST域的IST+CST&lt;/li&gt;
&lt;li&gt;域根，IST域根和MSTI域根
&lt;ul&gt;
&lt;li&gt;IST域根如图1所示，在MST域中IST生成树中距离总根最近的交换设备是IST域根&lt;/li&gt;
&lt;li&gt;MSTI域根是每个多生成树实例的树根，如图2所示，域中不同的MSTI有各自的域根，&lt;code&gt;一个MST域内可以生成多棵生成树，每棵生成树都称为一个MSTI&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;总根&lt;br&gt;
全网中BID最小的为总根&lt;/li&gt;
&lt;li&gt;主桥&lt;br&gt;
域内距离总根最近的交换设备，如图1中的黄色交换机，&lt;code&gt;如果总根在MST域中，则总根为该域的主桥&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;cist中的选举过程&#34;&gt;CIST中的选举过程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;先选举总根&lt;/li&gt;
&lt;li&gt;每个区域需要选举域根。域根是到达总根距离最短的设备，每个区域只能选举一个域根。如果该区域中存在总根，那么总根同时也是该区域的域根&lt;/li&gt;
&lt;li&gt;非总根和域根的设备需要选举一个到达总根距离最短的RP&lt;/li&gt;
&lt;li&gt;每条链路需要选举DP&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mstp拓扑计算&#34;&gt;MSTP拓扑计算&lt;/h1&gt;
&lt;p&gt;MSTP可以将整个二层网络划分为&lt;strong&gt;多个MST域&lt;/strong&gt;，各个&lt;strong&gt;域之间&lt;/strong&gt;通过计算&lt;strong&gt;生成CST&lt;/strong&gt;。&lt;strong&gt;域内则通过计算生成多棵生成树&lt;/strong&gt;，&lt;strong&gt;每棵生成树都被称为是一个多生成树实例&lt;/strong&gt;。&lt;strong&gt;其中实例0被称为IST，其他的多生成树实例为MSTI&lt;/strong&gt;。MSTP同STP一样，使用配置消息进行生成树的计算，只是配置消息中携带的是设备上MSTP的配置信息。&lt;/p&gt;
&lt;h2 id=&#34;优先级向量&#34;&gt;优先级向量&lt;/h2&gt;
&lt;p&gt;MSTI和CIST都是根据优先级向量来计算的，这些优先级向量信息都包含在MST BPDU中。各交换设备互相交换MST BPDU来生成MSTI和CIST。&lt;br&gt;
参与CIST计算的优先级向量为：&lt;code&gt;{ 根交换设备ID，外部路径开销，域根ID，内部路径开销，指定交换设备ID，指定端口ID，接收端口ID }&lt;/code&gt;&lt;br&gt;
参与MSTI计算的优先级向量为：&lt;code&gt;{ 域根ID，内部路径开销，指定交换设备ID，指定端口ID，接收端口ID }&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;比较原则cist选举的顺序重点star&#34;&gt;比较原则（CIST选举的顺序）（重点）⭐️&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;确定设备角色和端口角色；同一向量比较，值最小的向量具有最高优先级&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较CIST的总根的BID，越小越优&lt;/li&gt;
&lt;li&gt;比较CIST中到达总根的ERPC(外部根路径开销)，越小越优&lt;/li&gt;
&lt;li&gt;比较CIST中域根的BID，越小越优&lt;/li&gt;
&lt;li&gt;比较CIST中到达域根的IRPC（内部根路径开销），越小越优&lt;/li&gt;
&lt;li&gt;比较CIST中BPDU包发送者的BID，越小越优&lt;/li&gt;
&lt;li&gt;比较CIST中BPDU包发送者的PORT ID，越小越优&lt;/li&gt;
&lt;li&gt;比较CIST中BPDU包接收者的PORT ID，越小越优&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果端口接收到的BPDU内包含的配置消息&lt;strong&gt;优于&lt;/strong&gt;端口上保存的配置消息，则端口上原来保存的配置消息&lt;strong&gt;被新收到的配置消息替代&lt;/strong&gt;。端口同时更新交换设备保存的全局配置消息。反之，新收到的BPDU被丢弃。&lt;/p&gt;
&lt;h2 id=&#34;cist的计算&#34;&gt;CIST的计算&lt;/h2&gt;
&lt;p&gt;经过比较配置消息后，在整个网络中选择一个优先级最高的交换设备作为CIST的树根。&lt;br&gt;
在每个MST域内MSTP通过计算生成IST；同时MSTP将每个MST域作为单台交换设备对待，通过计算在MST域间生成CST。&lt;br&gt;
CST和IST构成了整个交换设备网络的CIST。&lt;/p&gt;
&lt;h2 id=&#34;msti的计算&#34;&gt;MSTI的计算&lt;/h2&gt;
&lt;p&gt;在MST域内，MSTP根据VLAN和生成树实例的映射关系，针对不同的VLAN生成不同的生成树实例。&lt;br&gt;
每棵生成树独立进行计算，计算过程与STP计算生成树的过程类似。&lt;/p&gt;
&lt;h3 id=&#34;msti的特点&#34;&gt;MSTI的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;每个MSTI独立计算自己的生成树，互不干扰&lt;/li&gt;
&lt;li&gt;每个MSTI的生成树计算方法与STP基本相同&lt;/li&gt;
&lt;li&gt;每个MSTI的生成树可以有不同的根，不同的拓扑&lt;/li&gt;
&lt;li&gt;每个MSTI在自己的生成树内发送BPDU&lt;/li&gt;
&lt;li&gt;每个MSTI的拓扑通过命令配置决定&lt;/li&gt;
&lt;li&gt;每个端口在不同MSTI上的生成树参数可以不同&lt;/li&gt;
&lt;li&gt;每个端口在不同MSTI上的角色、状态可以不同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在运行MSTP协议的网络中，一个VLAN报文将沿着如下路径进行转发：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在MST域内，沿着其对应的MSTI转发&lt;/li&gt;
&lt;li&gt;在MST域间，沿着CST转发&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;MSTP拓扑变化处理与RSTP拓扑变化处理过程类似&lt;/code&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;为什么需要使用-mstp&#34;&gt;为什么需要使用 MSTP&lt;/h2&gt;
&lt;p&gt;MSTP 的作用主要是用来负载，可以通过实例进行 VLAN 内流量的负载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;STP
&lt;ul&gt;
&lt;li&gt;形成&lt;strong&gt;一棵&lt;/strong&gt;无环路的树，解决广播风暴并实现冗余备份，收敛速度较&lt;strong&gt;慢&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;无需区分用户或业务流量，所有VLAN 共享一棵生成树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RSTP
&lt;ul&gt;
&lt;li&gt;形成&lt;strong&gt;一棵&lt;/strong&gt;无环路的树，解决广播风暴并实现冗余备份，收敛速度&lt;strong&gt;快&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;无需区分用户或业务流量，所有VLAN 共享一棵生成树&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSTP
&lt;ul&gt;
&lt;li&gt;形成&lt;strong&gt;多棵&lt;/strong&gt;无环路的树，解决广播风暴并实现冗余备份，收敛速度&lt;strong&gt;快&lt;/strong&gt;，多棵生成树在VLAN间实现&lt;strong&gt;负载均衡&lt;/strong&gt;，不同VLAN的流量按照不同的路径转发&lt;/li&gt;
&lt;li&gt;需要&lt;strong&gt;区分用户或业务流量，并实现负载分担&lt;/strong&gt;。不同的VLAN通过不同的生成树转发流量，&lt;strong&gt;每棵生成树之间相互独立&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">二层协议-MSTP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/er-ceng-xie-yi-stp-he-rstp-de-qu-bie/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%AB%AF%E5%8F%A3%E8%A7%92%E8%89%B2%E5%92%8C%E5%8D%8F%E8%AE%AE%E6%A0%87%E5%87%86&#34;&gt;1. 端口角色和协议标准&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E7%AB%AF%E5%8F%A3%E7%8A%B6%E6%80%81&#34;&gt;2. 端口状态&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E6%98%AFflag%E4%BD%8D%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;3. 报文结构（主要是Flag位的区别）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stp&#34;&gt;STP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rstp&#34;&gt;RSTP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E5%BF%AB%E9%80%9F%E6%94%B6%E6%95%9B%E6%9C%BA%E5%88%B6&#34;&gt;4. 快速收敛机制&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%9B%B4%E8%BF%9E%E6%95%85%E9%9A%9C&#34;&gt;1. 直连故障&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E9%9D%9E%E7%9B%B4%E8%BF%9E%E6%95%85%E9%9A%9C&#34;&gt;2. 非直连故障&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E6%AC%A1%E4%BC%98bpdu%E5%85%B3%E8%81%94pa%E5%8D%8F%E5%95%86&#34;&gt;3. 次优BPDU~关联PA协商~&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-pa%E5%8D%8F%E5%95%86&#34;&gt;4. P/A协商&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3&#34;&gt;5. 边缘端口&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E7%89%B9%E7%82%B9&#34;&gt;1. 特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E4%B8%8D%E8%B6%B3&#34;&gt;2. 不足&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF&#34;&gt;3. 使用场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6&#34;&gt;4. 边缘端口保护机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#5-%E6%8B%93%E6%89%91%E5%8F%98%E6%9B%B4&#34;&gt;5. 拓扑变更&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stp%E6%8B%93%E6%89%91%E5%8F%98%E5%8C%96%E5%A4%84%E7%90%86&#34;&gt;STP拓扑变化处理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rstp%E6%8B%93%E6%89%91%E5%8F%98%E5%8C%96%E5%A4%84%E7%90%86&#34;&gt;RSTP拓扑变化处理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85&#34;&gt;补充&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bpdu%E5%8C%85%E7%9A%84%E5%8F%91%E9%80%81&#34;&gt;BPDU包的发送：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%89%E4%B8%BE%E4%BE%9D%E6%AC%A1%E9%80%89%E4%B8%BE&#34;&gt;选举（依次选举）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%A0%B9%E6%A1%A5rb&#34;&gt;1. 根桥RB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E6%A0%B9%E7%AB%AF%E5%8F%A3rp&#34;&gt;2. 根端口RP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E6%8C%87%E5%AE%9A%E7%AB%AF%E5%8F%A3dp%E4%B8%8Erp%E7%9B%B8%E5%90%8C&#34;&gt;3. 指定端口DP（与RP相同）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-ap%E7%9A%84%E9%80%89%E4%B8%BE%E9%98%BB%E5%A1%9E%E7%AB%AF%E5%8F%A3&#34;&gt;4. AP的选举(阻塞端口)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cst&#34;&gt;CST&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A1%E6%97%B6%E5%99%A8timer&#34;&gt;计时器（Timer）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rstp%E5%92%8Cstp%E7%9A%84%E5%85%BC%E5%AE%B9%E4%BA%92%E6%93%8D%E4%BD%9C&#34;&gt;RSTP和STP的兼容（互操作）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%8A%E8%BF%9E%E6%8E%A5%E7%94%A8%E6%88%B7pc%E7%9A%84%E7%AB%AF%E5%8F%A3%E9%85%8D%E7%BD%AE%E4%B8%BA%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3%E9%82%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3%E8%BF%98%E8%A6%81%E7%BB%A7%E7%BB%AD%E5%8F%91%E9%80%81bpdu%E4%B8%BE%E5%87%BA%E4%B8%80%E4%B8%AA%E7%94%A8%E5%88%B0%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3%E5%8F%91%E9%80%81%E7%9A%84bpdu%E7%9A%84%E5%9C%BA%E6%99%AF&#34;&gt;把连接用户PC的端口配置为边缘端口，那为什么边缘端口还要继续发送BPDU，举出一个用到边缘端口发送的BPDU的场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%B4%E6%97%B6%E7%8E%AF%E8%B7%AF%E7%9A%84%E5%AD%98%E5%9C%A8%E6%97%B6%E9%97%B4&#34;&gt;临时环路的存在时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E6%9E%9C%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%B8%8A%E5%85%B3%E9%97%ADstp%E5%9C%A8%E6%9F%90%E4%B8%80%E7%AB%AF%E5%8F%A3%E5%88%86%E5%88%AB%E5%BC%80%E5%90%AFstp-%E5%85%B3%E9%97%ADstp-%E5%BC%80%E5%90%AFep%E5%93%AA%E7%A7%8Dforwarding%E7%9A%84%E5%BF%AB&#34;&gt;如果交换机上关闭STP，在某一端口分别开启stp、关闭stp、开启EP，哪种forwarding的快？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E6%9E%9C%E6%8A%8A%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3%E5%8E%BB%E6%8E%89%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%90%AC%E7%9A%84updown%E7%94%A8%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3tc%E5%AF%B9%E7%BD%91%E7%BB%9C%E7%9A%84%E5%BD%B1%E5%93%8D&#34;&gt;如果把边缘端口去掉，端口不听的up/down，用什么解决TC对网络的影响&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stp%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E4%B8%8Eip%E7%BD%91%E7%BB%9C%E6%AF%94%E8%BE%83%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BA%8C%E5%B1%82%E9%9C%80%E8%A6%81stp&#34;&gt;STP的作用是什么？与IP网络比较为什么二层需要STP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BE%B9%E7%BC%98%E7%AB%AF%E5%8F%A3%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89%E4%B8%B4%E6%97%B6%E7%8E%AF%E8%B7%AF%E5%87%BA%E7%8E%B0%E7%8E%AF%E8%B7%AF%E7%9A%84%E5%9C%BA%E6%99%AF%E5%B7%B2%E6%9C%89%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B&#34;&gt;边缘端口为什么会有临时环路，出现环路的场景，已有端口的演变过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%A8%E6%94%B6%E6%95%9B%E6%97%B6%E9%97%B4%E4%B8%8Arstp%E7%9B%B8%E5%AF%B9%E4%BA%8Estp%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF&#34;&gt;在收敛时间上，RSTP相对于STP有哪些优势？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rstp%E6%94%B6%E6%95%9B%E6%AF%94stp%E5%9D%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%9C%BA%E5%88%B6%E6%9C%89%E5%93%AA%E4%BA%9B&#34;&gt;RSTP收敛比STP块的基本机制有哪些？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%80%8E%E4%B9%88%E5%8C%BA%E5%88%86%E6%98%AFap%E8%BF%98%E6%98%AFbp&#34;&gt;交换机怎么区分是AP还是BP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88rstp%E5%BF%85%E9%A1%BB%E8%A6%81p2p&#34;&gt;为什么rstp必须要p2p?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AD%A6%E4%B9%A0%E7%8A%B6%E6%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B9%9F%E9%9C%80%E8%A6%8115%E7%A7%92%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E5%AD%A6%E4%B9%A0%E7%8A%B6%E6%80%81&#34;&gt;学习状态为什么也需要15秒，为什么要有学习状态？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;1-端口角色和协议标准&#34;&gt;1. 端口角色和协议标准&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;STP：
&lt;ul&gt;
&lt;li&gt;RP、AP(状态Blocking，是RP的备份，状态切换需要2个转发延时)、DP&lt;/li&gt;
&lt;li&gt;协议标准为IEEE 802.1D&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RSTP：
&lt;ul&gt;
&lt;li&gt;RP、AP、DP、BP、EP&lt;/li&gt;
&lt;li&gt;AP是RP的备份，RP失效后，AP立即变为RP；&lt;br&gt;
BP是DP的备份，DP端口失效后，即3个hello时间内没有收到BPDU报文，然后BP口需要等待一个转发延时才能切换到DP口，切换到DP口之后，还需要一个转发延时才能切换到forwarding状态&lt;/li&gt;
&lt;li&gt;EP端口变为转发状态不需要经过两个forwarding daly&lt;/li&gt;
&lt;li&gt;协议标准为IEEE 802.1w，&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-端口状态&#34;&gt;2. 端口状态&lt;/h1&gt;
&lt;p&gt;STP的Forwarding转发流量和BPDU、Learning学习Mac地址但不转发流量、Listening转发BPDU但不转发流量、Blocking不转发BPDU和流量但是能接收BPDU、Disabled啥也不干。&lt;br&gt;
RSTP的状态把STP的5种状态缩减为3种。根据端口是否转发用户流量和学习 MAC地址来划分 :&lt;br&gt;
如果不转发用户流量也不学习MAC地址，那么端口状态就是 Discarding状态；&lt;br&gt;
如果不转发用户流量但是学习MAC地址，那么端口状态就是 Learning状态；&lt;br&gt;
如果既转发用户流量又学习MAC地址，那么端口状态就是 Forwarding状。&lt;br&gt;
Learning状态：&lt;code&gt;非必须阶段，如果没有此阶段，可能出现大量未知单播帧的泛洪&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;STP端口状态&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;RSTP端口状态&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;端口在拓扑中的角色&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Forwarding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Forwarding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RP和DP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Learning&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Learning&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RP和DP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Listening&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Discarding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RP和DP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Blocking&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Discarding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AP和BP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Disabled&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Discarding&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Disable端口&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;3-报文结构主要是flag位的区别&#34;&gt;3. 报文结构（主要是Flag位的区别）&lt;/h1&gt;
&lt;h2 id=&#34;stp&#34;&gt;STP&lt;/h2&gt;
&lt;p&gt;BPDU Verison=00&lt;br&gt;
BPDU Type=00（配置BPDU，比如TCA BPDU、TC BPDU）和80（TCN BPDU）&lt;br&gt;
BPDU Flags如下：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610866823408.png&#34; alt=&#34;STP&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最高位为TCA（确认接收到TCN）；最低位为TC（通告拓扑改变），只有STP配置BPDU包才允许将TCA和TC置位&lt;/p&gt;
&lt;h2 id=&#34;rstp&#34;&gt;RSTP&lt;/h2&gt;
&lt;p&gt;BPDU Verison=02（01没有使用，03是MSTP）&lt;br&gt;
BPDU Type=02（RSTP/MSTP BPDU）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610866844250.png&#34; alt=&#34;RSTP&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第4和5位组合：
&lt;ul&gt;
&lt;li&gt;00表示发送bpdu的端口的端口状态为discarding&lt;/li&gt;
&lt;li&gt;01表示发送bpdu的端口的端口状态为learning&lt;/li&gt;
&lt;li&gt;11表示发送bpdu的端口的端口状态为forwarding&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第2和3位组合：
&lt;ul&gt;
&lt;li&gt;00表示端口角色为unknown&lt;/li&gt;
&lt;li&gt;01表示端口角色为AP/BP
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;交换机怎么区分是AP还是BP：根据端口收到更优的转发BID的来判断&lt;/code&gt;&lt;br&gt;
如果收到的更优的BPDU的BID不是自己，那么这个端口是AP（说明自己不是RB，自己用来转发的端口是RP，那么备份的AP）；否则就是BP（说明自己是RB，那么自己用来转发的端口是DP，那么备份的是BP）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;10表示端口角色为RP&lt;/li&gt;
&lt;li&gt;11表示端口角色为DP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TAC是无作用的，原因是RSTP中无TCN&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;4-快速收敛机制&#34;&gt;4. 快速收敛机制&lt;/h1&gt;
&lt;h2 id=&#34;1-直连故障&#34;&gt;1. 直连故障&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1616166496271.png&#34; alt=&#34;直连故障&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设：SW1和SW3之间的链路断开&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;STP处理：sw3的AP变为RP，状态从blocking需要经过两个转发延时变为forwarding状态，&lt;code&gt;即需要30秒的收敛时间&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RSTP处理：sw3的AP变为RP之后，状态会立即变成forwarding&lt;code&gt;即收敛时间很短&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-非直连故障&#34;&gt;2. 非直连故障&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1616166509648.png&#34; alt=&#34;非直连故障&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设：SW1和SW3之间插入一台HUB，HUB与SW1之间故障（没有生成树功能，只是透传报文）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;STP处理：需要进过MaxAge之后才感受到故障，然后AP变为RP、状态从blocking需要经过两个转发延时变为forwarding状态&lt;code&gt;发现问题20秒，状态转换30秒，即收敛时间需要50秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RSTP处理：连续丢失3个BPDU包后说明链路故障，然后AP变为RP之后、状态会立即变成forwarding&lt;code&gt;发现问题6秒，状态转换时间忽略不计，即收敛时间6秒（华为就这个场景需要时间因子，即18秒）。为什么需要时间因子？为了防止因为链路阻塞导致没有收到BPDU报文&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-次优bpdu关联pa协商&#34;&gt;3. 次优BPDU&lt;sub&gt;关联PA协商&lt;/sub&gt;&lt;/h2&gt;
&lt;p&gt;当一个端口收到上游的指定桥发来的BPDU报文时，该端口会将自身存储的BPDU与收到的BPDU进行比较。&lt;br&gt;
如果该端口存储的BPDU的优先级高于收到的BPDU，那么该端口会直接丢弃收到的BPDU，&lt;strong&gt;立即回应&lt;/strong&gt;自身存储的 BPDU【STP需要20秒之后回复】。当上游设备收到下游设备回应的BPDU后，上游设备会根据收到的BPDU报文中相应的字段立即更新自己存储的BPDU。由此，RSTP 处理次优BPDU报文不再依赖于任何定时器通过超时解决拓扑收敛，从而加快了拓扑收敛。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1616166526263.png&#34; alt=&#34;非直连故障&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设：SW1和SW2之间的链路断开&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;STP处理：由于sw2上没有AP，只有RP和DP，RP down之后，认为根桥故障，因此认为自己是根桥，发送次优BPDU，sw3的AP收到次优BPDU，sw3发现跟本地的不一致且没有本地缓存的更优，直接丢弃掉，经过MaxAge之后才感受到sw1和sw2之间的链路故障，则sw3的AP变为DP后发送BDPU，sw2会从DP变为RP&lt;code&gt;发现问题20秒，状态转换30秒，即收敛时间需要50秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;RSTP处理：sw3的&lt;strong&gt;AP收到次优BDPU后直接变为DP口&lt;/strong&gt;，马上发送更优的BPDU(不需要经过延时)&lt;code&gt;触发PA协商，即收敛时间很快&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-pa协商&#34;&gt;4. P/A协商&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;灵魂拷问&lt;/strong&gt;：&lt;br&gt;
&lt;strong&gt;1. 发送&lt;/strong&gt;proposal置位的BDPU包的场景：DP口处在Discarding或者Learning状态&lt;br&gt;
&lt;strong&gt;2. 响应&lt;/strong&gt;proposal置位的BDPU包的场景：只有在P2P的链路类型，同时是RP端口角色情况下，才会响应proposal置位的BDPU包&lt;br&gt;
&lt;strong&gt;3. 什么是P2P的链路类型&lt;/strong&gt;：通过端口的双工模式来判断，全双工的端口链路类型为P2P，半双工为Share(共享型)&lt;br&gt;
【如果一端为P2P，一端为Share，则需要经过30秒转发延时，端口状态才能由Discarding变为Forwarding，此时P/A机制不生效】&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1616332634653.jpg&#34; alt=&#34;P/A 机制&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
P/A 机制协商过程如下：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;因为SW3的DP口不是forwarding状态，那么会触发PA机制，SW3会发送proposal=1的BPDU给SW2，其中的BID是使用SW1的，即更优的BPDU&lt;/li&gt;
&lt;li&gt;SW2收到之后，发现自己的BPDU不是最优的，然后将非EP全部阻塞掉，然后将收到更优BPDU报文的DP口转换成RP口，并转换成Forwarding状态，最后发送Agreement=1的BPDU给SW3&lt;/li&gt;
&lt;li&gt;SW3收到回应之后，将该DP的状态转换成Forwarding状态&lt;/li&gt;
&lt;li&gt;然后SW3的DP口因为还处在Discarding状态，会继续往下进行PA协商，知道发送的proposal=1的BPDU没有回应则结束，例如这个DP口接的是一个PC，无法收到Agreement=1的BPDU，该PA协商结束，该DP口会进过两个转发延时从Discarding状态变为Forwarding状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上P/A 过程可以向下游继续传递。&lt;br&gt;
事实上对于STP，DP的选择可以很快完成&lt;sub&gt;即端口角色可以在短时间内确定&lt;/sub&gt;，主要的&lt;strong&gt;速度瓶颈&lt;/strong&gt;在于：&lt;code&gt;为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发&lt;/code&gt;。而RSTP的主要目的就是消除这个瓶颈，通过&lt;code&gt;阻塞自己的非根端口来保证不会出现环路&lt;/code&gt;。而使用 P/A 机制加快了上游端口转到Forwarding状态的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;增强型的P/A协商&lt;/strong&gt;（华为私有方案）：发送的每个BPDU都会将Agreement=1，即发送方也会将Agreement置位，收到此BPDU的端口立刻进入转发状态&lt;/p&gt;
&lt;h2 id=&#34;5-边缘端口&#34;&gt;5. 边缘端口&lt;/h2&gt;
&lt;h3 id=&#34;1-特点&#34;&gt;1. 特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;接入设备进入Forwarding状态，&lt;strong&gt;避免等待30秒延迟，直接转发&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;EP进入Forwarding状态时不产生TC BPDU，即不会触发拓扑改变&lt;/li&gt;
&lt;li&gt;EP不转发TC BPDU包，但是EP可以往外发BPDU&lt;code&gt;为什么还会发送bpdu？因为需要让下游设备感知到交换机的存在&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;收到TC BPDU不删除MAC地址表&lt;/li&gt;
&lt;li&gt;进行P/A协商时不会被阻塞EP&lt;/li&gt;
&lt;li&gt;收到BPDU后，会变为普通端口，执行STP计算&lt;code&gt;边缘端口也会发送配置BPDU&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-不足&#34;&gt;2. 不足&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;临时环路&lt;br&gt;
（2个端口直接连起来，或者下游接入的交换机不支持生成树）&lt;br&gt;
临时环路持续0-2秒，收到对方端口发出的BPDU后同时进入阻塞状态，进行生成树的选举，决出一个DP和一个BP，DP在30秒之后进入转发状态，BP维持阻塞状态。&lt;/li&gt;
&lt;li&gt;当边缘端口收到BPDU后，会丧失边缘端口的特性，变成普通端口并进行生成树计算，引起网络震荡。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-使用场景&#34;&gt;3. 使用场景&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;大型公司内网有很多电脑，上下班时产生大量的TC，造成所有交换机的MAC地址表频繁删除，以至于持续泛洪所有的数据帧，启用边缘端口可以改善网络品质&lt;/li&gt;
&lt;li&gt;接DHCP客户端的端口，使其能快速得到地址&lt;/li&gt;
&lt;li&gt;接重要服务器和IP电话接口，否则在生成树拓扑发生变化时，将被阻塞掉，30秒后才能再次提供服务&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-边缘端口保护机制&#34;&gt;4. 边缘端口保护机制&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;rstp在加快收敛速度的同时，也带来了不少风险，所以设计了很多保护机制来规避这些风险。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为了加快收敛，设计了EP，但是边缘端口收到BPDU之后会变为普通端口，触发TC，因此设计了BPDU保护，来防止EP属性的改变，从而防止TC引发的网络不稳定&lt;/li&gt;
&lt;li&gt;为了加快收敛，RP失效后，AP变为RP，且不需要等待两个转发延时端口就进入转发状态，这样设计在链路拥塞时，可能导致环路的出现，所以设计了环路保护&lt;/li&gt;
&lt;li&gt;为了加快收敛，所有的设备都可以发送TC BPDU报文，这带来的风险就是所有的设备都可以通过发送TC BPDU来让其他设备删除mac表项，为了规避这个风向，所以设计TC BPDU防护&lt;/li&gt;
&lt;li&gt;因为收敛更快，抢根也更加快速，所以设计了根保护&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;BPDU保护（全局配置，作用于边缘端口）：&lt;code&gt;EP收到BPDU后会被Error-Down&lt;/code&gt;&lt;br&gt;
在交换设备上，通常将直接与用户终端或文件服务器等非交换设备相连的端口配置为EP。正常情况下，EP不会收到BPDU。如果有人伪造BPDU恶意攻击交换设备，当EP接收到BPDU时，交换设备会自动将EP设置为非边缘端口，并重新进行生成树计算，从而引起网络震荡。&lt;br&gt;
交换设备上启动了BPDU保护功能后，如果EP收到BPDU，EP将被Error-Down，但是EP属性不变，同时通知网管系统。&lt;br&gt;
&lt;strong&gt;恢复方式有两种&lt;/strong&gt;：1. 手动恢复（shutdown/undo shutdown）;2. 自动恢复（error-down auto-recovery cause bpdu-protection interval 时长）&lt;code&gt;这个命令为什么这么设计，为什么不把bpdu-protection放在前面？因为导致端口error-down的方式不止有bpdu保护，还有monitor-link、auto-defend、l2-loop-occurred等&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;根保护（只能在DP口下开启）：&lt;code&gt;在DP开启根保护，保证根桥不被抢占&lt;/code&gt;&lt;br&gt;
由于维护人员的错误配置或网络中的恶意攻击，网络中合法根桥有可能会收到优先级更高的BPDU，使得合法根桥失去根地位，从而引起网络拓扑结构的错误变动。这种不合法的拓扑变化，会导致原来应该通过高速链路的流量被牵引到低速链路上，造成网络拥塞。&lt;br&gt;
对于启用根保护功能的DP，其端口角色只能保持为DP。一旦启用根保护功能的DP收到优先级更高的BPDU 时，端口状态将进入Discarding状态，不再转发报文。经过一段时间（通常为两倍的 Forward Delay），如果端口一直没有再收到优先级较高的BPDU，端口会自动恢复到正常的 Forwarding 状态。&lt;br&gt;
&lt;strong&gt;【说明】&lt;/strong&gt;： Root 保护功能只能在DP上配置生效&lt;/li&gt;
&lt;li&gt;环路保护（在RP或AP下配置，环路保护功能和根保护功能不能同时配置在同一端口）&lt;sub&gt;关联直连故障和非直连故障&lt;/sub&gt;：&lt;code&gt;为了防止单向链路故障，在BPDU包的接收端配置（如AP/RP）,如果在规定时间范围内在开启了环路防护的端口没有收到BPDU包，会通知网管，并将端口discarding，但是环路防护容易出现误判&lt;/code&gt;&lt;br&gt;
在运行RSTP协议的网络中，根端口和其他阻塞端口状态是依靠不断接收来自上游交换设备的BPDU维持。当由于链路拥塞或者单向链路故障（多出现在光纤网络中）导致这些端口收不到来自上游交换设备的BPDU时，此时交换设备会重新选择根端口。原先的根端口会转变为指定端口，而原先的阻塞端口会迁移到转发状态，从而造成交换网络中可能产生环路。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610889689059.jpg&#34; alt=&#34;环路保护&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如图所示，当 BP2-CP1 之间的链路发生拥塞时（或者是单向链路故障） ，DeviceC由于CP1（RP）在超时时间内收不到来自上游设备的 BPDU 报文，CP2（AP） 转变成了RP，CP1（RP） 转变成DP，从而形成了环路。&lt;/li&gt;
&lt;li&gt;防TC-BPDU攻击（全局配置）：&lt;code&gt;指定处理TC包的阈值，在规定时间内只处理阈值范围内的TC包，超出的次数按一次处理&lt;/code&gt;&lt;br&gt;
交换设备在接收到TC-BPDU 报文后，会执行MAC地址表项和ARP表项的删除操作。如果有人伪造TC-BPDU 报文恶意攻击交换设备时，交换设备短时间内会收到很多TC-BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。启用防TC-BPDU 报文攻击功能后，在单位时间内，交换设备处理TC -BPDU报文的次数可配置。如果在单位时间内，交换设备在收到TC-BPDU报文数量大于配置的阈值，那么设备只会处理阈值指定的次数。对于其他超出阈值的TC-BPDU 报文，定时器到期后设备只对其统一处理一次。这样可以避免频繁的删除MAC地址表项和ARP表项，从而达到保护设备的目的。&lt;/li&gt;
&lt;li&gt;BPDU过滤：&lt;code&gt;接口不发送也不接收BPDU包，如果应用在EP上，很可能会造成永久环路&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;5-拓扑变更&#34;&gt;5. 拓扑变更&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;灵魂拷问&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;TC BPDU包的主要作用&lt;/strong&gt;：告知下游设备拓扑发生变化，快速刷新MAC地址表，实现快速转发数据&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCN BPDU报文主要作用&lt;/strong&gt;：用来向上游设备乃至根桥通知拓扑变化&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCA BPDU报文主要作用&lt;/strong&gt;：上游设备用来告知下游设备已经知道拓扑变化，通知下游设备停止发送TCN BPDU报文&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;stp拓扑变化处理&#34;&gt;STP拓扑变化处理&lt;/h2&gt;
&lt;p&gt;在STP中检测拓扑&lt;strong&gt;是否发生变化的标准（即发送TCN的条件）&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;非根桥的DP口收到TCN BPDU包&lt;/li&gt;
&lt;li&gt;Forwarding端口进入disable或者blocking状态（例如PC关机）&lt;/li&gt;
&lt;li&gt;一个端口进入Forwarding状态，并且本地已经存在一个DP（例如PC开机）&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1610892294546.jpg&#34; alt=&#34;TC 处理机制&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在网络拓扑发生变化后，下游设备会不间断地向上游设备发送TCN BPDU报文&lt;/li&gt;
&lt;li&gt;上游设备收到下游设备发来的TCN BPDU报文后，&lt;strong&gt;只有指定端口处理&lt;/strong&gt;TCN BPDU报文，其它端口也有可能收到TCN BPDU报文，但不会处理&lt;/li&gt;
&lt;li&gt;上游设备会把配置BPDU报文中的Flags的TCA位设置1，然后发送给下游设备，告知下游设备停止发送 TCN BPDU报文&lt;/li&gt;
&lt;li&gt;上游设备复制一份TCN BPDU报文，向根桥方向发送&lt;/li&gt;
&lt;li&gt;重复步骤 1、2、3、4，直到根桥收到TCN BPDU报文&lt;/li&gt;
&lt;li&gt;根桥把配置BPDU报文中的Flags的TC位置1后发送，&lt;strong&gt;通知下游设备直接删除桥MAC地址表项&lt;/strong&gt;&lt;code&gt;连续发送35秒=转发延时15秒+MaxAge的20秒，当然RB在发TC时也会设置MaxAge为15秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他设备收到TC置位的BPDU后，知道网络拓扑发生变化，会检测MAC地址的老化时间。&lt;strong&gt;如果MAC地址的老化时间（Maxage）大于15秒，均将老化时间设置为15秒，如果MAC地址的老化时间小于15秒，保持不变。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;只有根桥才能发从TC BPDU，其余设备只能发送TCN和TCA BPDU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;rstp拓扑变化处理&#34;&gt;RSTP拓扑变化处理&lt;/h2&gt;
&lt;p&gt;在RSTP中检测拓扑是否发生变化&lt;strong&gt;只有一个标准&lt;/strong&gt;：&lt;code&gt;一个非边缘端口(只有DP)迁移到Forwarding状态&lt;/code&gt;&lt;br&gt;
一旦检测到拓扑发生变化，将进行如下处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为本交换设备的所有非边缘指定端口启动一个TC While Timer，该计时器值是Hello Time的两倍&lt;/li&gt;
&lt;li&gt;在这个时间内，&lt;strong&gt;清空状态发生变化的端口上学习到的 MAC 地址&lt;/strong&gt;。&lt;br&gt;
同时，由这些端口向外发送RST BPDU，其中TC置位。&lt;strong&gt;一旦TC While Timer超时，则停止发送 RST BPDU&lt;/strong&gt;&lt;code&gt;即TC置位的BPDU称为RST BPDU&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他交换设备接收到RST BPDU后，&lt;strong&gt;清空所有端口学习到MAC地址&lt;/strong&gt;，除了收到RST BPDU的端口。然后也为自己&lt;strong&gt;所有的非边缘指定端口和根端口启动TC While Timer&lt;/strong&gt;，重复上述过程，网络中就会产生 RST BPDU 的泛洪&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MAC地址清除机制&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;发生拓扑改变的设备&lt;/strong&gt;：只会将&lt;strong&gt;除了EP&lt;/strong&gt;以外的其他端口的MAC地址马上清除&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;接收到TC BPDU的设备&lt;/strong&gt;：会将除了&lt;strong&gt;EP和收到TC BPDU的端口&lt;/strong&gt;之外的其他端口的MAC地址马上清除&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;每台设备都能发从TC BPDU&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;bpdu包的发送&#34;&gt;BPDU包的发送：&lt;/h2&gt;
&lt;p&gt;在RSTP中RP、BP、AP只能接受不能发送BPDU包；DP是发送BPDU，收敛以后不接收&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置BPDU包：
&lt;ul&gt;
&lt;li&gt;STP中只有根桥会周期的发送配置BPDU包，非根桥接收以后从指定端口转发&lt;/li&gt;
&lt;li&gt;RSTP中每台设备都会周期发送配置BPDU包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;TC BPDU包：
&lt;ul&gt;
&lt;li&gt;STP中只有根桥才会发送TC置位的配置BPDU包，而其他的非根桥只能发从TCN BPDU和收到TCN BPDU后回复TCA置位的配置BPDU包&lt;/li&gt;
&lt;li&gt;RSTP中每台设备都可以发送TC置位的配置BPDU包&lt;code&gt;因此RSTP没有TCN和TCA，完全不需要&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;选举依次选举&#34;&gt;选举（依次选举）&lt;/h2&gt;
&lt;h3 id=&#34;1-根桥rb&#34;&gt;1. 根桥RB&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;BID，一共8字节=4bit优先级+12bit扩展系统ID+6字节的背板最小MAC。本质上，优先级范围为0-15，默认是8&lt;/code&gt;&lt;br&gt;
比较BID（越小越优），有三部分级成：优先级+扩展系统ID+MAC，&lt;strong&gt;华为的扩展系统ID是0&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优先级越小越优&lt;code&gt;优先级为0，仅是最大可能会成为根桥，不一定是根桥，且该值必须是4096的倍数，默认优先级为32768（=8*4096，最大是15*4096）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;MAC地址越小越优&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-根端口rp&#34;&gt;2. 根端口RP&lt;/h3&gt;
&lt;p&gt;PID由端口优先级+端口编号组成&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根路径开销RPC越小越优&lt;/li&gt;
&lt;li&gt;发送设备BID越小越优&lt;/li&gt;
&lt;li&gt;发送端口PID越小越优（先看优先级，再看编号）&lt;/li&gt;
&lt;li&gt;接收端口PID越小越优（先看优先级，再看编号）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-指定端口dp与rp相同&#34;&gt;3. 指定端口DP（与RP相同）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;根路径开销RPC越小越优&lt;/li&gt;
&lt;li&gt;发送设备BID越小越优&lt;/li&gt;
&lt;li&gt;发送端口PID越小越优&lt;/li&gt;
&lt;li&gt;接收端口PID越小越优&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-ap的选举阻塞端口&#34;&gt;4. AP的选举(阻塞端口)&lt;/h3&gt;
&lt;p&gt;非DP，非RP就是AP，端口会被阻塞掉&lt;/p&gt;
&lt;h2 id=&#34;cst&#34;&gt;CST&lt;/h2&gt;
&lt;p&gt;STP和RSTP只有一棵树，就是CST（公共生成树），不管有多少个Vlan，因此产生MSTP。&lt;/p&gt;
&lt;h2 id=&#34;计时器timer&#34;&gt;计时器（Timer）&lt;/h2&gt;
&lt;p&gt;RSTP更短的BPDU超时计时，如果一个端口连续3个Hello Time(2秒)时间内没有收到上游设备发送过来的配置BPDU，那么该设备认为与此邻居之间的协商失败【只需要等待6秒】。而不像STP那样需要先等待一个Max Age(20秒)【再加上30秒的转发延时，一共需要50秒】。&lt;br&gt;
【默认情况下华为有一个时间因子，数值为3，所以超时时间为18秒=&lt;code&gt;2*3*3&lt;/code&gt;】&lt;/p&gt;
&lt;h2 id=&#34;rstp和stp的兼容互操作&#34;&gt;RSTP和STP的兼容（互操作）&lt;/h2&gt;
&lt;p&gt;RSTP可以和STP互操作，但此时RSTP会丧失快速收敛等优势。&lt;br&gt;
当一个网段里既有运行STP的交换设备，又有运行RSTP的交换设备时，&lt;strong&gt;STP交换设备会忽略RSTP的BPDU&lt;/strong&gt;；而运行&lt;strong&gt;RSTP&lt;/strong&gt;的交换设备在某端口上&lt;strong&gt;收到STP的配置BPDU时，会在两个Hello Time时间之后把自己的端口转换到STP工作模式&lt;/strong&gt;，发送配置BPDU。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;把连接用户pc的端口配置为边缘端口那为什么边缘端口还要继续发送bpdu举出一个用到边缘端口发送的bpdu的场景&#34;&gt;把连接用户PC的端口配置为边缘端口，那为什么边缘端口还要继续发送BPDU，举出一个用到边缘端口发送的BPDU的场景&lt;/h2&gt;
&lt;p&gt;交换机的边缘端口发出的BPDU是用来让下游设备感受到交换机的存在。比如一个设备的两个边缘端口连接在一起，需要靠检测BPDU来重新确定端口角色，否则就出现永久环路。&lt;/p&gt;
&lt;h2 id=&#34;临时环路的存在时间&#34;&gt;临时环路的存在时间&lt;/h2&gt;
&lt;p&gt;bpdu发送时间+网络传输延时+CPU处理时间&lt;/p&gt;
&lt;h2 id=&#34;如果交换机上关闭stp在某一端口分别开启stp-关闭stp-开启ep哪种forwarding的快&#34;&gt;如果交换机上关闭STP，在某一端口分别开启stp、关闭stp、开启EP，哪种forwarding的快？&lt;/h2&gt;
&lt;p&gt;关闭stp &amp;gt; 开启EP &amp;gt; 开启stp&lt;br&gt;
关闭stp的端口up后即可传输数据；边缘端口上运行stp，所以进入转发状态需要时间，但是很短；开启stp，需要经历两个转发延时之后才能进入转发状态。&lt;/p&gt;
&lt;h2 id=&#34;如果把边缘端口去掉端口不听的updown用什么解决tc对网络的影响&#34;&gt;如果把边缘端口去掉，端口不听的up/down，用什么解决TC对网络的影响&lt;/h2&gt;
&lt;p&gt;开启TC-BPDU功能，设置规定时间内处理TC-BPDU的阈值，超出阈值之外的次数在定时器到期后统一进行一次处理。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stp tc-protection
stp tc-protection interval interval-value +指定时间
stp tc-protection threshold threshold +指定时间内可以处理的此时
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stp的作用是什么与ip网络比较为什么二层需要stp&#34;&gt;STP的作用是什么？与IP网络比较为什么二层需要STP&lt;/h2&gt;
&lt;p&gt;STP是二层的链路管理协议，提供链路冗余的同时防止网络产生环路&lt;br&gt;
IP网络中，使用各种路由协议来传递路由信息，各种路由协议都有自己的防环方法。二层网络如果不启用STP，在出现冗余路径时会导致环路。&lt;br&gt;
IP使用TTL能防环，但是以太帧没有类似TTL的字段用来防环，而且交换机处理数据帧的方法决定了泛洪比较多，交换机处理未知单播帧、组播、广播均采用泛洪的方式，更容易造成数据包环路和广播风暴。&lt;/p&gt;
&lt;h2 id=&#34;边缘端口为什么会有临时环路出现环路的场景已有端口的演变过程&#34;&gt;边缘端口为什么会有临时环路，出现环路的场景，已有端口的演变过程&lt;/h2&gt;
&lt;p&gt;将两个边缘端口直接或间接连接在一起&lt;br&gt;
两个边缘端口均进入转发状态会形成环路，但如果EP收到BPDU后，会阻塞一个端口，环路消失&lt;/p&gt;
&lt;h2 id=&#34;在收敛时间上rstp相对于stp有哪些优势&#34;&gt;在收敛时间上，RSTP相对于STP有哪些优势？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;stp是基于定时器的，stp中端口角色判定为DP和RP后，需要经过两个转发延时才能进入转发状态，全网收敛至少需要30秒&lt;/li&gt;
&lt;li&gt;rstp是基于P/A协商的，rstp中端口角色判定为DP后，只要DP收到agreement置位的bpdu后，接口状态理解变为转发状态；判定为RP后，发送agreement置位的bpdu时，端口就变为了转发状态，全网收敛只需要几秒&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;rstp收敛比stp块的基本机制有哪些&#34;&gt;RSTP收敛比STP块的基本机制有哪些？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;rstp重新定义了RP和AP之间的转换，RP失效之后，AP马上变为RP，并进入转发状态&lt;/li&gt;
&lt;li&gt;rstp使用P/A机制可以快速收敛&lt;/li&gt;
&lt;li&gt;rstp检测到拓扑变化后，以拓扑变化的设备为中心向外泛洪TC BPDU，更快的通知全网拓扑变化&lt;/li&gt;
&lt;li&gt;rstp的端口在3个hello时间内没有收到配置BPDU，认为链路失效，链路检测更快&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;交换机怎么区分是ap还是bp&#34;&gt;交换机怎么区分是AP还是BP&lt;/h2&gt;
&lt;p&gt;根据端口收到更优的转发BID的来判断。&lt;br&gt;
如果收到的更优的BPDU的BID不是自己，那么这个端口是AP（说明自己不是RB，自己用来转发的端口是RP，那么备份的AP）；否则就是BP（说明自己是RB，那么自己用来转发的端口是DP，那么备份的是BP）&lt;/p&gt;
&lt;h2 id=&#34;为什么rstp必须要p2p&#34;&gt;为什么rstp必须要p2p?&lt;/h2&gt;
&lt;p&gt;如果不是p2p，P/A协商很复杂，时间会很长，例如一端是share一端p2p，则需要进过两个转发延时才收敛。&lt;/p&gt;
&lt;h2 id=&#34;学习状态为什么也需要15秒为什么要有学习状态&#34;&gt;学习状态为什么也需要15秒，为什么要有学习状态？&lt;/h2&gt;
&lt;p&gt;监听状态期间（生成树拓扑改变期间），根桥发送TC=1的配置BPDU，MAC地址表会受TC BPDU的影响进行提前老化，清除错误的MAC地址信息，导致错误的MAC地址老化，也导致空闲的MAC地址老化，如果此时要转发数据帧就会导致大量未知单播帧的泛洪现象，影响网络性能。&lt;br&gt;
通过继续牺牲15秒的收敛时间，设计出学习状态能让交换机在此期间重新构建MAC地址表项，减少单播帧在STP收敛期间产生的大量泛洪行为&lt;code&gt;即通过牺牲收敛时间，来提高网路的转发性能&lt;/code&gt;&lt;br&gt;
基于以上两种原因，STP的收敛是完全依赖计时器完成的，收敛速度慢，为了解决临时环路和收敛期间单播帧泛洪，被逼无奈需要等待30秒。&lt;/p&gt;
">二层协议-STP和RSTP的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/er-ceng-xie-yi-ppp/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#ppp%E4%BA%8C%E5%B1%82&#34;&gt;PPP（二层）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84&#34;&gt;报文结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lcp%E6%8A%A5%E6%96%87&#34;&gt;LCP报文&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ncp%E6%8A%A5%E6%96%87&#34;&gt;NCP报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E9%98%B6%E6%AE%B5%E4%B8%8D%E8%83%BD%E5%8F%AB%E7%8A%B6%E6%80%81%E6%9C%BA&#34;&gt;工作阶段（不能叫状态机）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BB%BA%E9%93%BE%E8%BF%87%E7%A8%8B&#34;&gt;建链过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lcp%E5%8D%8F%E5%95%86&#34;&gt;LCP协商&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ncp%E5%8D%8F%E5%95%86&#34;&gt;NCP协商&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%99%E6%80%81%E5%8D%8F%E5%95%86ip%E5%9C%B0%E5%9D%80%E4%BA%92%E6%8E%A8%E5%9C%B0%E5%9D%80&#34;&gt;静态协商IP地址(互推地址)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A8%E6%80%81%E5%8D%8F%E5%95%86ip%E5%9C%B0%E5%9D%80%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9D%80&#34;&gt;动态协商IP地址(获得地址)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A4%E8%AF%81&#34;&gt;认证&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pap%E8%AE%A4%E8%AF%81%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AEpassword-authentication-protocol&#34;&gt;PAP认证（密码认证协议，Password Authentication Protocol）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pap%E9%AA%8C%E8%AF%81%E6%8A%A5%E6%96%87%E5%B8%A7%E6%A0%BC%E5%BC%8F&#34;&gt;PAP验证报文帧格式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chap%E8%AE%A4%E8%AF%81%E6%8C%91%E6%88%98%E6%8F%A1%E6%89%8B%E8%AE%A4%E8%AF%81%E5%8D%8F%E8%AE%AEchallenge-handshake-authentication-protocol&#34;&gt;CHAP认证（挑战握手认证协议，Challenge Handshake Authentication Protocol）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#chap%E7%9A%843%E7%A7%8D%E8%AE%A4%E8%AF%81%E6%96%B9%E5%BC%8F%E9%85%8D%E7%BD%AE%E6%80%BB%E7%BB%93&#34;&gt;CHAP的3种认证方式配置总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#chap%E6%8A%A5%E6%96%87&#34;&gt;CHAP报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ppp%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5&#34;&gt;PPP同步与异步&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bcp%E5%8D%8F%E8%AE%AE&#34;&gt;BCP协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mp%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&#34;&gt;MP基本原理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mp%E6%96%B9%E5%BC%8F%E4%B8%8B%E9%93%BE%E8%B7%AF%E5%8D%8F%E5%95%86%E8%BF%87%E7%A8%8B&#34;&gt;MP方式下链路协商过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F&#34;&gt;实现方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pppoe&#34;&gt;PPPoE&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E7%B1%BB%E5%9E%8B&#34;&gt;报文类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&#34;&gt;基本原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4&#34;&gt;配置步骤&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%85%8D%E7%BD%AE&#34;&gt;1. 服务端配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE&#34;&gt;2. 客户端配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%BD%E9%97%AE&#34;&gt;追问&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#lcp-%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;LCP 的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mru-%E7%9A%84%E4%BD%9C%E7%94%A8%E9%AD%94%E6%9C%AF%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;MRU 的作用，魔术字的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E8%AE%A4%E8%AF%81%E7%AB%AF%E4%B8%8E%E8%A2%AB%E8%AE%A4%E8%AF%81%E7%AB%AFlcp-%E9%98%B6%E6%AE%B5&#34;&gt;如何区分认证端与被认证端（LCP 阶段）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A4%E8%AF%81%E4%B8%ADid%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8C%E6%A0%87%E8%AF%86&#34;&gt;认证中ID的作用，为什么要进行标识&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8C%91%E6%88%98%E6%8A%A5%E6%96%87%E4%B8%AD%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;挑战报文中的随机数的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A4%E8%AF%81%E7%AB%AF%E4%B8%8E%E8%A2%AB%E8%AE%A4%E8%AF%81%E7%AB%AF%E5%90%84%E8%87%AA%E7%9A%84%E5%AF%86%E7%A0%81%E5%A6%82%E4%BD%95%E8%8E%B7%E5%BE%97&#34;&gt;认证端与被认证端各自的密码如何获得&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A2%AB%E8%AE%A4%E8%AF%81%E7%AB%AF%E7%94%A8%E6%88%B7%E5%90%8D%E7%9A%84%E4%BD%9C%E7%94%A8%E8%AE%A4%E8%AF%81%E7%AB%AF%E5%AF%86%E7%A0%81%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;被认证端用户名的作用？认证端密码的作用？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81&#34;&gt;什么叫双向认证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ncp-%E4%B8%AD%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%8D%8F%E8%AE%AE&#34;&gt;NCP 中包含哪些协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipcp-%E4%B8%AD%E4%BA%92%E6%8E%A8%E5%9C%B0%E5%9D%80%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;IPCP 中互推地址的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8C%E6%96%B9%E6%98%AF%E5%90%A6%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9D%80&#34;&gt;双方是否都可以自动获得地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8pppoe&#34;&gt;为什么需要使用PPPOE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#p2p%E7%BD%91%E7%BB%9C%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%BE%E7%BD%AE30%E4%BD%8D%E6%8E%A9%E7%A0%81&#34;&gt;p2p网络中为什么要设置30位掩码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ppp%E4%B8%AD%E8%B7%AF%E7%94%B1%E5%AD%A6%E4%B9%A0&#34;&gt;PPP中路由学习&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#aaa%E7%9A%84%E5%85%A8%E7%A7%B0%E9%99%A4%E4%BA%86aaa%E5%A4%96%E8%BF%98%E8%83%BD%E7%94%A8%E4%BB%80%E4%B9%88%E6%96%B9%E5%BC%8F%E8%8E%B7%E5%BE%97%E5%AF%86%E7%A0%81&#34;&gt;AAA的全称，除了AAA外还能用什么方式获得密码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ppp%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81arp&#34;&gt;PPP为什么不需要ARP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;ppp二层&#34;&gt;PPP（二层）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;点到点链路层协议（除了PPP，还有HDLC和Cisco HDLC）&lt;/li&gt;
&lt;li&gt;3个协议簇：
&lt;ol&gt;
&lt;li&gt;链路控制协议簇LCP：主要用来建立、拆除、监控PPP数据链路。&lt;br&gt;
自动检测链路环境，如是否存在环路；协商链路参数，如最大数据包长度、认证协议等。与其他协议相比，ppp协议的一个重要特点就是提供认证功能，链路两端可以协商使用何种认证协议并实施认证过程，只有认证成功才会建立连接，这使得PPP协议很适合被运营商用来接入分散的用户。&lt;/li&gt;
&lt;li&gt;网络控制协议簇NCP：主要用来协商在该数据链路上所传输的数据包的格式与类型。&lt;/li&gt;
&lt;li&gt;PPP扩展协议簇：主要用于提供对PPP功能的进一步支持，例如PPP提供了用于网络安全方面的认证协议簇CHAP（挑战握手协议）和PAP（简单密钥认证）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;报文结构&#34;&gt;报文结构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1610793637770.png&#34; alt=&#34;报文结构&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;Flag域：标识一个物理帧的起始和结束，该字节为&lt;strong&gt;0x7E&lt;/strong&gt;。
&lt;ol&gt;
&lt;li&gt;如果在数据中出现0x7E，则采用硬件完比特填充(原理跟HDLC) ，只要发现5个连续的1，则立即填入0&lt;/li&gt;
&lt;li&gt;在数据中，直接能看到的现象是数据中的0x7E被拆分成0x7D+0x5E&lt;/li&gt;
&lt;li&gt;那如果数据中出现0x7D怎么办呢？再把0x7D拆成0x7D+0x5D&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Address域：Address域可以唯一标识对端。&lt;br&gt;
PPP协议是被运用在点对点的链路上，因此，使用PPP协议互连的两个通信设备无须知道对方的数据链路层地址。按照协议的规定将该字节填充为全1的广播地址，对于PPP协议来说，该字段&lt;strong&gt;无实际意义&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Control域：该字段默认值为&lt;strong&gt;0x03&lt;/strong&gt;，表明为无序号帧，PPP默认没有采用序列号和确认来实现可靠传输。&lt;br&gt;
Address和Control域一起标识此报文为PPP报文，&lt;strong&gt;即PPP报文头为FF03&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Protocol域：用来区分PPP数据帧中信息域所承载的数据报类型。&lt;strong&gt;只能为奇数&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;常见的协议代码：
0281：MPLS单播
0283：MPLS组播
8021：IP
8057：IPv6
C021：LCP
C023：PAP
C223：CHAP
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Information域：信息域最大长度是1500字节，其中包括填充域的内容。信息域的最大长度称为最大接收单元MRU，缺省值为1500字节，在实际应用当中可根据实际需要进行MRU的协商。&lt;/li&gt;
&lt;li&gt;FCS域：对PPP数据帧传输的正确性进行检测。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lcp报文&#34;&gt;LCP报文&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Code域：代码域的长度为1个字节，主要是用来标识LCP数据报文的类型。&lt;br&gt;
在链路建立阶段，接收方接收到LCP数据报文。当其代码域的值无效时，就会向对端发送一个LCP的代码拒绝报文（Code-Reject报文）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;常见code值：
0x01：Configure-Request，包含发送者试图使用的、没有使用默认值的参数列表。3秒重传时间内未收到Configure-Ack，则重传Configure-Request，最多连续重传10次，10次之后重新建立。
0x02：Configure-Ack，表示完全接受对端发送的Configure-Request的参数取值
0x03：Configure-Nak，表示对端发送的Configure-Request中的参数取值在本地不合法
0x04：Configure-Reject，表示对端发送的Configure-Request中的参数本地不能识别

0x05：Terminate-Request，用于请求对端关闭连接。3秒重传时间内未收到Terminate-Ack，则重传Terminate-Request，最多连续重传2次，2次之后认为对端不可用，连接关闭。
0x06：Terminate-Ack

0x09：Echo-Request，LCP建立连接之后，使用Echo-Request和Echo-Reply检测链路状态，10秒发送一次Echo-Request
0x0A：Echo-Reply
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Identifier域：标识域为1个字节，用来匹配请求和响应，当标识域值为非法时，该报文将被丢弃。&lt;br&gt;
&lt;strong&gt;通常一个配置请求报文的ID是从0x01开始逐步加1的&lt;/strong&gt;。当对端接收到该配置请求报文后，无论使用何种报文回应对方，但必须要求&lt;strong&gt;回应报文中的ID要与接收报文中的ID一致&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Length域：长度域的值就是&lt;strong&gt;该LCP报文的总字节数据&lt;/strong&gt;。它是代码域、标志域、长度域和数据域四个域长度的总和。&lt;br&gt;
长度域所指示字节数之外的字节将被当作填充字节而忽略掉，而且该域的内容不能超过MRU的值。&lt;/li&gt;
&lt;li&gt;Data域：数据域所包含的是协商报文的内容，这个内容包含以下字段：&lt;br&gt;
Type为协商选项类型。Length为协商选项长度，它是指Data域的总长度，也就是包含Type、Length和Data。Data为协商的选项具体内容。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ncp报文&#34;&gt;NCP报文&lt;/h3&gt;
&lt;p&gt;此部分和LCP基本一致&lt;br&gt;
IPCP，用于协商控制IP参数，使PPP可用于传输IP数据包。IPCP使用和LCP相同的协商机制、报文类型，但IPCP并非调用LCP，只是工作过程、报文等和LCP相同。&lt;/p&gt;
&lt;h2 id=&#34;工作阶段不能叫状态机&#34;&gt;工作阶段（不能叫状态机）&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt;：此处列出的是PPP的工作阶段，并非PPP的协议状态，由于PPP是由一组协议组成的，因此PPP本身没有协议状态，只有特定的协议如LCP和NCP等才有协议状态和状态转换（协议状态机）。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Dead：这是PPP工作的开始和结束的阶段。&lt;br&gt;
当物理层变为可用状态之后，PPP进入Establish状态&lt;/li&gt;
&lt;li&gt;Establish：PPP在此阶段使用LCP协商链路层参数。&lt;br&gt;
链路层参数协商不成功则PPP连接建立不成功，PPP退回到Dead阶段；链路层参数协商成功则PPP进入Authenticate阶段&lt;/li&gt;
&lt;li&gt;Authenticate阶段：PPP在此阶段认证对端，失败则进入Terminate阶段，成功或者没有认证则进入Network阶段&lt;/li&gt;
&lt;li&gt;Network：PPP在此阶段使用NCP协商网络层参数。&lt;br&gt;
协商成功则PPP连接建立成功，开始传输网络层数据包。当上层协议认为应当关闭此连接或者管理员手动关闭PPP链接，则PPP进入Terminate阶段&lt;/li&gt;
&lt;li&gt;Terminate：PPP在此阶段使用LCP关闭PPP连接。&lt;br&gt;
PPP连接关闭后，PPP进入Dead阶段。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;建链过程&#34;&gt;建链过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1610795517606.png&#34; alt=&#34;建链过程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;PPP协议运行总是以Dead阶段开始和结束。通常处在这个状态的时间很短，仅仅是检测到硬件设备后（即硬件连接状态为Up）就进入Establish阶段。&lt;/li&gt;
&lt;li&gt;在Establish阶段，PPP链路进行LCP协商。协商内容包括最大接收单元MRU、认证协议、魔术字（防环）、协议字段压缩、多链路捆绑、链路质量监控、地址和控制字段压缩等选项。LCP协商成功后进入Opened状态，表示底层链路已经建立。&lt;/li&gt;
&lt;li&gt;如果配置了验证，将进入Authenticate阶段，开始CHAP或PAP验证。如果没有配置验证，则直接进入Network阶段。&lt;/li&gt;
&lt;li&gt;对于Authenticate阶段，如果验证失败，进入Terminate阶段，拆除链路，LCP状态转为Closed。如果验证成功，进入Network阶段，此时LCP状态仍为Opened，而NCP状态从Initial转到Starting。&lt;/li&gt;
&lt;li&gt;在Network阶段，PPP链路进行NCP协商，NCP协商包括IPCP（IP Control Protocol）、MPLSCP（MPLS Control Protocol）等协商。IPCP协商主要包括双方的IP地址。通过NCP协商来选择和配置一个网络层协议。只有相应的网络层协议协商成功后（相应协议的NCP协商状态为Opened），该网络层协议才可以通过这条PPP链路发送报文。例如：IPCP协商通过后，这条PPP链路才可以承载IP报文。&lt;/li&gt;
&lt;li&gt;PPP运行过程中，可以随时中断连接，物理链路断开、认证失败、超时定时器时间到、管理员通过配置关闭连接等动作都可能导致进入链路进入Terminate阶段。进入Terminate阶段后且资源释放完，即进入Dead阶段。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lcp协商&#34;&gt;LCP协商&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611391971933.png&#34; alt=&#34;LCP协商&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;ncp协商&#34;&gt;NCP协商&lt;/h3&gt;
&lt;p&gt;协商网络层参数使用&lt;strong&gt;IPCP协商&lt;/strong&gt;，分为静态协商IP地址（互推地址）、动态协商IP地址（获得地址）&lt;/p&gt;
&lt;h4 id=&#34;静态协商ip地址互推地址&#34;&gt;静态协商IP地址(互推地址)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611392549998.jpg&#34; alt=&#34;互推地址&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;R1先向R2发送configure-Request，里面有个字段就是接口的IP地址，不带掩码信息&lt;/li&gt;
&lt;li&gt;对端收到后，如果认为这个地址合法的（地址不冲突且非0.0.0.0）就回复ACK，回复 ACK 的同时把 12.1.1.1以一个32位主机路由添加到IGP表里去，R2需要ping 12.1.1.1的时候，直接从接口转。&lt;code&gt;这就是PPP链路不在同一个段里也能通信的原因&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;R2收到Request后就进入NCP的Open，R2 也会把地址推给 R1。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;动态协商ip地址获得地址&#34;&gt;动态协商IP地址(获得地址)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1611392800674.jpg&#34; alt=&#34;动态协商IP地址&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;R1接口不配IP地址，需要敲一条指令，&lt;code&gt;ip address ppp-negotiate&lt;/code&gt;才会发送configure-Request，因为接口没有地址，所以地址字段会填充为0.0.0.0&lt;/li&gt;
&lt;li&gt;R2收到Request后&lt;strong&gt;回复NAK&lt;/strong&gt;，NAK中会包含分配给对方的地址， 这就需要在被认证方配置一条 &lt;code&gt;remote address x.x.x.x ；ppp ipcp remote-address forced&lt;/code&gt; 可以跟一个静态的IP，也可以跟一个dhcp pool，R1收到后会重新发送 Request，地址变为之前分配的地址，对端会送ACK，这个过程R2也会给R1发，然后进入Open状态&lt;br&gt;
&lt;code&gt;NAK分配地址之后，接下来的阶段和静态协商IP地址过程相同&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;认证&#34;&gt;认证&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;PAP是由被认证端发请求，CHAP是由认证端发请求&lt;/li&gt;
&lt;li&gt;接口下配置&lt;code&gt;ppp mode PAP/CHAP&lt;/code&gt;的为&lt;strong&gt;认证方&lt;/strong&gt;，配置&lt;code&gt;ppp PAP/CHAP username&lt;/code&gt;为被认证方&lt;code&gt;配置在物理接口或者AAA中&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;被认证方是接口优先，接口没有配置用户或密码，再查全局；&lt;strong&gt;认证方只使用全局用户名和密码&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;pap认证密码认证协议password-authentication-protocol&#34;&gt;PAP认证（密码认证协议，Password Authentication Protocol）&lt;/h3&gt;
&lt;p&gt;PAP验证协议为&lt;strong&gt;两次握手验证&lt;/strong&gt;，口令为&lt;strong&gt;明文&lt;/strong&gt;。验证过程&lt;strong&gt;仅在链路初始建立阶段进行&lt;/strong&gt;。&lt;br&gt;
当链路建立阶段结束后，用户名和密码将由被验证方重复地在链路上发送给验证方，直到验证被通过或者链路连接终止。&lt;br&gt;
如果必须在远端主机上使用明文密码进行模拟登录，这种验证方式是最合适的。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610800329875.png&#34; alt=&#34;PAP认证&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
被验证方把本地用户名和口令发送到验证方，验证方根据本地用户表查看是否有被验证方的用户名以及口令是否正确，然后返回不同的响应（接受或拒绝）。&lt;br&gt;
PAP不是一种安全的验证协议。当验证时，口令以明文方式在链路上发送，并且由于完成PPP链路建立后，被验证方会不停地在链路上反复发送用户名和口令，直到身份验证过程结束，所以&lt;strong&gt;不能防止攻击&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;pap验证报文帧格式&#34;&gt;PAP验证报文帧格式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1610800788192.png&#34; alt=&#34;PAP验证报文帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Code：标识PAP数据报的类型
&lt;ul&gt;
&lt;li&gt;1表示是Authenticate-Request报文&lt;/li&gt;
&lt;li&gt;2表示是Authenticate-Ack报文&lt;/li&gt;
&lt;li&gt;3表示是Authenticate-Nak报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Identifier：标识请求报文和应答报文的匹配。&lt;/li&gt;
&lt;li&gt;Length：表示包括Code、Identifier、Length和Data域在内的PAP报文长度。超出此长度的报文将被认为是填充字节并被丢弃。&lt;/li&gt;
&lt;li&gt;Data：Data域的帧由Code域来决定&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Authenticate-Request&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610802162354.png&#34; alt=&#34;Authenticate-Request&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Authenticate-Ack和Authenticate-Nak&lt;br&gt;
如果在验证-请求报文中的用户名和密码都能被验证方验证通过，验证方必须返回Code值是2的Authenticate-Ack报文，表示验证通过。&lt;br&gt;
如果验证-请求报文中用户名或密码有一项没有通过验证，验证方必须返回Code值是3的Authenticate-Nak报文，表示验证失败。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610802240353.png&#34; alt=&#34;Authenticate-Ack和Authenticate-Nak&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;chap认证挑战握手认证协议challenge-handshake-authentication-protocol&#34;&gt;CHAP认证（挑战握手认证协议，Challenge Handshake Authentication Protocol）&lt;/h3&gt;
&lt;p&gt;CHAP验证协议为&lt;strong&gt;三次握手&lt;/strong&gt;验证协议。它&lt;strong&gt;只在网络上传输用户名&lt;/strong&gt;，而并不传输用户密码，因此安全性要比PAP高。CHAP协议是在链路建立的开始就完成的。在链路建立完成后的任何时间都可以重复发送进行再验证。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610802351851.png&#34; alt=&#34;CHAP认证&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
CHAP单向验证是指一端作为验证方，另一端作为被验证方。双向验证是单向验证的简单叠加，即两端都是既作为验证方又作为被验证方。在实际应用中&lt;strong&gt;一般只采用单向验证&lt;/strong&gt;。&lt;br&gt;
CHAP单向验证过程分为两种情况：验证方配置了用户名和验证方没有配置用户名。推荐使用验证方配置用户名的方式，这样可以对验证方的用户名进行确认。&lt;br&gt;
&lt;strong&gt;认证方的报文根据配置情况不同会有所改变，但是被认证方只有一种报文&lt;/strong&gt;&lt;code&gt;(ID+challenge值+password)三者的hash+ID+用户名&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;验证方&lt;strong&gt;配置了用户名&lt;/strong&gt;的验证过程
&lt;ol&gt;
&lt;li&gt;验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge报文，保报文中携带随机值），并同时将本端的用户名附带上一起发送给被验证方。&lt;code&gt;Challenge作用：1.HASH；2.抗重放&lt;/code&gt;&lt;br&gt;
&lt;code&gt;验证方--用户名+ID+challenge--&amp;gt;被验证方&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;被验证方接到验证方的验证请求后，先检查本端接口上是否配置了ppp chap password命令，
&lt;ol&gt;
&lt;li&gt;如果&lt;strong&gt;配置了密码&lt;/strong&gt;，则被验证方用报文ID、命令中配置的用户密码和MD5算法对该随机报文进行加密，将生成的密文和自己的用户名发回验证方（Response）&lt;br&gt;
&lt;code&gt;被验证方--（ID+密码+challenge）三者的HASH+ID+用户名--&amp;gt;验证方&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果接口上&lt;strong&gt;未配置密码&lt;/strong&gt;，则根据此报文中验证方的用户名在本端的用户表查找该用户对应的密码，用报文ID、此用户的密钥（密码）和challenge进行HASH，将生成的密文和被验证方自己的用户名发回验证方（Response）&lt;br&gt;
&lt;code&gt;被验证方在用户表中查找验证方用户对应的密码，被验证方--（ID+密码+challenge）三者HASH+ID+接口下用户名--&amp;gt;验证方&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;验证方用自己保存的被验证方密码和MD5算法对原随机报文加密，比较二者的密文，根据比较结果返回不同的响应。&lt;br&gt;
&lt;code&gt;验证方（同样需要在用户列表中查找验证方发来的用户名对应的密码）--success或者fail--&amp;gt;被验证方&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;验证方&lt;strong&gt;没有配置用户名&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;验证方主动发起验证请求，验证方向被验证方发送一些随机产生的报文（Challenge）&lt;br&gt;
&lt;code&gt;验证方--user（空）+ID+challenge值--&amp;gt;被验证方&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;被验证方接到验证方的验证请求后，利用报文ID、ppp chap password命令配置的CHAP密码和MD5算法对该随机报文进行加密，将生成的密文和自己的用户名发回验证方（Response）&lt;br&gt;
&lt;code&gt;被验证方--(ID+challenge值+password)三者的hash+ID+用户名--&amp;gt;验证方&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;验证方用自己保存的被验证方密码和MD5算法对原随机报文加密，比较二者的密文，根据比较结果返回不同的响应。&lt;br&gt;
&lt;code&gt;验证方--success或者fail--&amp;gt;被验证方&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;chap的3种认证方式配置总结&#34;&gt;CHAP的3种认证方式配置总结&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;认证方必须配置AAA和认证模式，被认证方必须在接口下配置用户名&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;认证方接口下配置用户名&lt;br&gt;
&lt;code&gt;配置的用户名仅仅只是发送给被认证方，被认证方在没有配置接口的密码的时候才会使用到，但是校验是否通过是根据被认证方接口下配置的用户名和认证方的AAA中的数据&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;被认证方接口下配置用户名和&lt;strong&gt;密码&lt;/strong&gt;，交互步骤如下：
&lt;ol&gt;
&lt;li&gt;认证方发送接口下用户名&lt;/li&gt;
&lt;li&gt;被认证方发送接口下用户名和密码&lt;/li&gt;
&lt;li&gt;认证方根据被认证方的用户名，使用AAA的数据进行检查&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;被认证方接口下只配置用户名，交互步骤如下：
&lt;ol&gt;
&lt;li&gt;认证方还是使用接口下用户名&lt;/li&gt;
&lt;li&gt;被认证方根据用户名查找AAA中的密码，然后使用接口下的用户名&lt;code&gt;即本地接口用户名和AAA中认证方用户的密码，也就是说用户名和密码是无联系的&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;认证方根据被认证方接口下用户名查找AAA中密码&lt;code&gt;即需要认证方的用户名需要在被认证方的AAA中存在，被认证方的用户名需要在认证方的AAA中存在&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;认证方接口下没有配置用户名&lt;br&gt;
&lt;code&gt;此时被认证方接口下必须配置用户名和密码，否则无法根据认证方发来的信息检索到密码&lt;/code&gt;&lt;br&gt;
交互步骤如下：
&lt;ol&gt;
&lt;li&gt;认证方用户名为空&lt;/li&gt;
&lt;li&gt;被认证方使用接口下用户名和密码&lt;/li&gt;
&lt;li&gt;认证方在AAA中进行检查&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;chap报文&#34;&gt;CHAP报文&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1610805005794.png&#34; alt=&#34;CHAP报文&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Code：表示CHAP数据报文的类型
&lt;ul&gt;
&lt;li&gt;1表示Challenge报文&lt;/li&gt;
&lt;li&gt;2表示Response报文&lt;/li&gt;
&lt;li&gt;3表示Success报文&lt;/li&gt;
&lt;li&gt;4表示Failure报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;Challenge报文和Response报文&lt;br&gt;
用来发起CHAP验证&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610805171398.png&#34; alt=&#34;Challenge报文和Response报文&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Success报文和Failure报文&lt;br&gt;
验证通过或验证失败&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610805225702.png&#34; alt=&#34;Success报文和Failure报文&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ppp同步与异步&#34;&gt;PPP同步与异步&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1610858666098.png&#34; alt=&#34;PPP同步与异步&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;异步传输&lt;/strong&gt;是以字节为单位传输数据，并且需要采用额外的起始位和停止位来标记每个字节的开始和结束。起始位为二进制0，停止位为二进制1。在这种传输模式下，开始和停止位占据发送数据相当大的比例，每个字节的发送都需要额外的开销。&lt;/li&gt;
&lt;li&gt;同步传输是以帧为单位，在通信时需要使用时钟来同步本端和对端的设备通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;bcp协议&#34;&gt;BCP协议&lt;/h2&gt;
&lt;p&gt;桥接控制协议，实现以太网数据帧在PPP链路上传输&lt;br&gt;
先协商LCP，需要保证NCP可达，再协商BCP&lt;/p&gt;
&lt;h1 id=&#34;mp基本原理&#34;&gt;MP基本原理&lt;/h1&gt;
&lt;p&gt;Multilink PPP允许将报文分片，分片将从多个点对点链路上送到同一个目的地。&lt;br&gt;
增加带宽，将多个PPP链路捆绑使用。&lt;/p&gt;
&lt;h2 id=&#34;mp方式下链路协商过程&#34;&gt;MP方式下链路协商过程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;LCP阶段，也需要验证对端接口是否工作在MP方式下&lt;/li&gt;
&lt;li&gt;NCP阶段，根据MP-Group接口或指定虚拟接口模板的各项NCP参数（如IP地址等）进行NCP协商&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;虚拟接口模板模式&lt;/li&gt;
&lt;li&gt;MP-Group方式&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;pppoe&#34;&gt;PPPoE&lt;/h1&gt;
&lt;p&gt;在以太网上面承载PPP 协议，PPPoE 协议提供了在以太网网络中多台主机连接到远端的宽带接入服务器上的一种标准。以太网不支持身份认证、加密等功能，所以将PPP的特点融入到以太网中。&lt;br&gt;
&lt;code&gt;PPPoE认证配置在是VT和dialer接口&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610861914640.png&#34; alt=&#34;PPPoE&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;报文类型&#34;&gt;报文类型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;头部：以太网封装的，目的MAC一般为广播或单播&lt;/li&gt;
&lt;li&gt;字段：
&lt;ul&gt;
&lt;li&gt;版本号、类型、代码表明是PPPoE报文，并表示了报文类型&lt;/li&gt;
&lt;li&gt;会话ID：以太网源目MAC定义了一个PPPoE的会话&lt;/li&gt;
&lt;li&gt;长度：表明PPPoE的载荷长度&lt;/li&gt;
&lt;li&gt;载荷：内部数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;PPPoE拨号可分为三个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Discovery发现阶段：发现对方MAC，确定唯一的PPPoE会话
&lt;ol&gt;
&lt;li&gt;PADI&lt;code&gt;PPPOE Active Discovery Initiation&lt;/code&gt;：初始报文，广播发送，主机探测PPPoE服务器&lt;/li&gt;
&lt;li&gt;PADO&lt;code&gt;PPPOE Active Discovery Offer&lt;/code&gt;：提供报文，单播，服务器收到探测报文回应的&lt;/li&gt;
&lt;li&gt;PADR&lt;code&gt;PPPOE Active Discovery Request&lt;/code&gt;：请求报文，单播，主机向服务器发送请求&lt;/li&gt;
&lt;li&gt;PADS&lt;code&gt;PPPOE Active Discovery Session-confirmation&lt;/code&gt;：会话确认报文，单播，服务器向主机分配一个会话ID，后面的会话均一直使用此ID，除非断开该链接&lt;br&gt;
&lt;code&gt;举例：家用路由器性能比较低的时候，长期开机导致网速变慢，或者为了防辐射等等原因，会设置定时开关机，每次开机之后会进行重新拨号，重新拨号之后，会话ID就会变&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Session会话阶段：进行PPP协商，传输PPP数据报文&lt;/li&gt;
&lt;li&gt;Terminate会话终止阶段：会话建立的任意时刻，可以发送结束报文关闭会话
&lt;ol&gt;
&lt;li&gt;PADT&lt;code&gt;PPPOE Active Discovery Terminate&lt;/code&gt;：终止报文，单播，主机向服务器发送，表示断开会话&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610863435148.png&#34; alt=&#34;基本原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;路由器上拨号接口的MTU为1492，为什么？以太网承载，其协议簇为ethernet+pppoe+ppp+ip+payload，多了pppoe和ppp头部，6B的pppoe头部（1B的版本和类型+1B的code+2B的会话ID+2B的长度） 和 2B的ppp头部（只有头部协议字段，省略了0x7EFF03，即flag+address+control）。为什么省略flag？flag的作用是标识报文的开始与结束，在pppoe中可以使用长度字段来标识开始与结束，所以flag字段没有存在的必要了&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置步骤&#34;&gt;配置步骤&lt;/h2&gt;
&lt;p&gt;Virtual-template为了L2层协议的以太网承载PPP，可以封装多种同层协议的虚拟接口&lt;br&gt;
dialer虚拟拨号接口：用来控制拨号的接口，在这个接口下配置封装协议。ppp认证、ip地址自动获得、dialer接口拨号使用的用户名、pppoe连接建立的等待时间、dialer所属的组、指定dialer接口的编号、nat地址转换等等的配置，都在是该拨号接口下完成的&lt;/p&gt;
&lt;h3 id=&#34;1-服务端配置&#34;&gt;1. 服务端配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;配置dhcp server pool&lt;/li&gt;
&lt;li&gt;配置aaa下用户名、密码，服务类型为PPP&lt;/li&gt;
&lt;li&gt;创建Virtual-Template接口，配置ip地址、remote分配地址池、PPP认证模式&lt;/li&gt;
&lt;li&gt;物理接口调用pppoe-server bind virtual-template&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-客户端配置&#34;&gt;2. 客户端配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建dialer接口（创建PPPoE的接口）&lt;/li&gt;
&lt;li&gt;接口下配置链路封装协议ppp，ip地址为PPP自动协商，指定dialer接口拨号所使用的用户和认证方式等&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;追问&#34;&gt;追问&lt;/h1&gt;
&lt;h2 id=&#34;lcp-的作用&#34;&gt;LCP 的作用&lt;/h2&gt;
&lt;p&gt;控制链路的建立，维护与拆除&lt;/p&gt;
&lt;h2 id=&#34;mru-的作用魔术字的作用&#34;&gt;MRU 的作用，魔术字的作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;最大接收单元，控制报文的最大接收大小，作用与 MTU 一样，协调最小的值。&lt;/li&gt;
&lt;li&gt;魔术字的作用是防环&lt;code&gt;当收到报文的魔术字与发送报文的魔术字一样时就认为有环路，此时会回复 NAK，并携带一个新的魔术字&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何区分认证端与被认证端lcp-阶段&#34;&gt;如何区分认证端与被认证端（LCP 阶段）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置了authehtication-mode命令的一端为认证端&lt;/li&gt;
&lt;li&gt;在LCP阶段协商认证类型时，只有认证端才会携带认证类型，被认证端不会携带&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;认证中id的作用为什么要进行标识&#34;&gt;认证中ID的作用，为什么要进行标识&lt;/h2&gt;
&lt;p&gt;ID用于标识会话，并参与HASH运算。每一次的认证里都携带了不能的随机数， 随机数也是参与HASH运算的一个因子，所以需要使用ID来关联。&lt;/p&gt;
&lt;h2 id=&#34;挑战报文中的随机数的作用&#34;&gt;挑战报文中的随机数的作用&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;防重放攻击&lt;/code&gt;&lt;br&gt;
设备会保存之前使用的随机数，缺点是记录时间段比较长的情况下，则保存和查询的开销比较大&lt;br&gt;
&lt;code&gt;如果发现报文中有以前使用过的随机数，就认为是重放攻击&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;认证端与被认证端各自的密码如何获得&#34;&gt;认证端与被认证端各自的密码如何获得&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;认证端：只能在AAA下面配置，通过被认证端发送过来的Response消息中的用户名找到全局AAA下面的密码。不会使用接口下面的密码。&lt;/li&gt;
&lt;li&gt;被认证端：可在接口与全局 AAA下面配置，接口优于全局。当接口没有配置密码时，&lt;strong&gt;认证端接口必须配置用户名&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;模拟器实验时：被验证方接口下用户名和验证方用户名不一致时无法正常建立连接，只有验证方和被验证方的AAA中都有相同的用户，且双方接口下均配置这个用户的用户名时才能正常建立邻居&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;被认证端用户名的作用认证端密码的作用&#34;&gt;被认证端用户名的作用？认证端密码的作用？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;被认证端发送的 response 消息中会携带此用户名，认证端收到后会用这个用户名查到全局AAA 找到密码，完成HASH运算。&lt;/li&gt;
&lt;li&gt;认证端密码只能在全局AAA配置，使用也是完成HASH运算。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;什么叫双向认证&#34;&gt;什么叫双向认证&lt;/h2&gt;
&lt;p&gt;认证端也是被认证端&lt;/p&gt;
&lt;h2 id=&#34;ncp-中包含哪些协议&#34;&gt;NCP 中包含哪些协议&lt;/h2&gt;
&lt;p&gt;IPCP、MPLSCP、IPV6CP、OSICP（上层运行 ISIS 时）&lt;/p&gt;
&lt;h2 id=&#34;ipcp-中互推地址的作用&#34;&gt;IPCP 中互推地址的作用&lt;/h2&gt;
&lt;p&gt;使对方能获得本端的路由，从而使得p2p网络中不在同一个网段也能通信&lt;/p&gt;
&lt;h2 id=&#34;双方是否都可以自动获得地址&#34;&gt;双方是否都可以自动获得地址&lt;/h2&gt;
&lt;p&gt;可以，双方都可以配置 remote-address&lt;/p&gt;
&lt;h2 id=&#34;为什么需要使用pppoe&#34;&gt;为什么需要使用PPPOE&lt;/h2&gt;
&lt;p&gt;一个站点上的多台主机连接到同一台远程接入设备，同时接入设备能够提供与拨号上网类似的访问控制和计费功能，于是产生了在以太网上传输PPP报文的技术&lt;/p&gt;
&lt;h2 id=&#34;p2p网络中为什么要设置30位掩码&#34;&gt;p2p网络中为什么要设置30位掩码&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;节省IP&lt;/li&gt;
&lt;li&gt;可防止环路，如果两端都是配置的24位掩码的地址，一端是10.1.1.1 别外一端是10.1.1.2，此时在任意一台路由上ping 10.1.1.3 就会产生环路。环路原因是因为路由表中存在24位的路由， 出接口就是连接对端的接口。而p2p网络中只需要出接口就可以转发数据包，但在MA中需要对端的MAC地址，所以在MA网络中没有环路&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614427782574.png&#34; alt=&#34;PPP的环路问题&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ppp中路由学习&#34;&gt;PPP中路由学习&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1614429487175.png&#34; alt=&#34;PPP中路由学习&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1614429624861.png&#34; alt=&#34;AR7的路由表&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AR7上路由：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1.1.1.0/30：通过直连形成的，下一跳1.1.1.1&lt;/li&gt;
&lt;li&gt;1.1.1.1/32：本地接口的&lt;/li&gt;
&lt;li&gt;2.2.2.2/32：通过IPCP学习到的&lt;/li&gt;
&lt;li&gt;2.2.2.0/30：只能通过OSPF的1类LSA学习到（通过p2p知道邻居为2.2.2.2，查2.2.2.2的1类LSA，通过stubnet知道2.2.2.0/30）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;aaa的全称除了aaa外还能用什么方式获得密码&#34;&gt;AAA的全称，除了AAA外还能用什么方式获得密码&lt;/h2&gt;
&lt;p&gt;AAA是Authentication（认证）、Authorization（授权）和 Accounting（计费）的简称，是网络安全的一种管理机制，提供了认证、授权、计费三种安全功能。AAA可以通过多种协议来实现，目前设备支持基于RADIUS或HWTACACS 方式来实现AAA，在实际应用中，&lt;strong&gt;最常使用 RADIUS 协议&lt;/strong&gt;。在认证中我们所讲的是 AAA 的本地数据库认证，除了这种外还有基于RADIUS或HWTACACS（HUAWEI Terminal Access Controller Access Control System，华为终端访问控制器控制系统协议）的方式。&lt;/p&gt;
&lt;h2 id=&#34;ppp为什么不需要arp&#34;&gt;PPP为什么不需要ARP&lt;/h2&gt;
&lt;p&gt;使用IPCP解析，不需要ARP&lt;/p&gt;
">二层协议-PPP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/lab-mian-shi-jiang-jie/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%A2%E8%AF%95%E9%A1%BB%E7%9F%A5&#34;&gt;面试须知&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%A2%E8%AF%95%E6%B5%81%E7%A8%8B&#34;&gt;面试流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7&#34;&gt;面试技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lab%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86&#34;&gt;LAB知识点整理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rpf%E6%A3%80%E6%9F%A5%E9%A1%BA%E5%BA%8F&#34;&gt;RPF检查顺序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rp%E9%80%89%E4%B8%BE%E9%A1%BA%E5%BA%8F&#34;&gt;RP选举顺序&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;面试须知&#34;&gt;面试须知&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;LAB考试出成绩后便可以预约面试，第一次面试不需要交钱，面试费用包含在LAB考试费中。&lt;/li&gt;
&lt;li&gt;LAB成绩的有效期只有三个月（从LAB出成绩之日开始计算），必须要在三个月内进行一次面试（第一次面试为免费，包括在LAB费用中）。如果没有约到面试位置，可以给华为发邮件要求加位置。如果一面未通过，LAB有效期会自动延时三个月，在LAB有效期范围内可以补考面试，需要购买面试券，费用为5000人民币。如果第二次面试未通过，LAB有效期再延长三个月，可以继续补考面试。如果在九个月内面试没有通过，LAB成绩失效，需要重新考LAB&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;面试流程&#34;&gt;面试流程&lt;/h1&gt;
&lt;p&gt;面试为远程面试，类似于笔试，考试环境为一个独立的小房间，需要带上耳机与考官交流，而不是和考官面对面，所以不用紧张。面试环境会为你提供一个画图和记事本工具，方便你画图和记录（电脑屏幕为触屏，可以用手写笔或者直接手写）。你需要在1个小时内回答三道题，每道题的回答时间为20分钟。&lt;/p&gt;
&lt;h1 id=&#34;面试技巧&#34;&gt;面试技巧&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;平静心情，给自己一个整理思路的时间&lt;/li&gt;
&lt;li&gt;回答问题，先易后难&lt;/li&gt;
&lt;li&gt;先列大纲，再填细节&lt;/li&gt;
&lt;li&gt;多画图，少说话&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;lab知识点整理&#34;&gt;LAB知识点整理&lt;/h1&gt;
&lt;h2 id=&#34;rpf检查顺序&#34;&gt;RPF检查顺序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;优先级优先（比较优先级，默认模式）
&lt;ol&gt;
&lt;li&gt;如果同时存在单播和组播路由，比较优先级，优先级越小越优&lt;/li&gt;
&lt;li&gt;如果优先级一样，组播静态(1)&amp;gt;MBGP(255)&amp;gt;单播&lt;/li&gt;
&lt;li&gt;如果都是单播路由，比较掩码长度，掩码长度越长越优&lt;/li&gt;
&lt;li&gt;如果掩码长度一致，比较下一跳IP地址，越大越优&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;掩码长度优先（优先比较掩码长度）
&lt;ol&gt;
&lt;li&gt;如果同时存在单播和组播路由，比较掩码长度，掩码长度越长越优&lt;/li&gt;
&lt;li&gt;如果掩码长度一样，比较协议优先级，优先级越小越优&lt;/li&gt;
&lt;li&gt;如果优先级一样，组播静态(1)&amp;gt;MBGP(255)&amp;gt;单播&lt;/li&gt;
&lt;li&gt;如果都是单播路由，比较下一跳IP地址，越大越优&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;rp选举顺序&#34;&gt;RP选举顺序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;组播组掩码长度，掩码长度越长越优&lt;/li&gt;
&lt;li&gt;如果组掩码长度一样，比较优先级，优先级越小越优&lt;/li&gt;
&lt;li&gt;如果优先级一样，比较HASH值（组地址+RP地址+HASH MASK），越大越优&lt;/li&gt;
&lt;li&gt;如果HASH一样，比较RP的IP地址，越大越优&lt;/li&gt;
&lt;/ol&gt;
">lab面试讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/cha-hua-hui-nei-rong/"" data-c="
          &lt;h1 id=&#34;ipv4向ipv6过渡&#34;&gt;IPv4向IPv6过渡&lt;/h1&gt;
&lt;p&gt;在IPv4网络向IPv6网络过度的过程中，IPv6过渡技术可以实现IPv6网络孤岛之间（IPv4网络孤岛之间）、IPv6网络和IPv4网络之间的互通&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610633695351.png&#34; alt=&#34; IPv4向IPv6过渡技术&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
双栈协议：设备必须支持IPv4/IPV6协议栈，连接双栈网络的接口必须同时配置IPv4地址和IPv6地址，常用的IPv6的路由协议OSPFv3、ISIS多拓扑、多协议BGP&lt;/p&gt;
&lt;h1 id=&#34;ipv6overipv4&#34;&gt;IPv6overIPv4&lt;/h1&gt;
&lt;p&gt;IPv6overIPv4手动隧道，用于解决IPv6孤岛问题，用于任何IPv6穿越IPv4的环境，通用性好&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;6over4手工隧道的一种，源地址和目的地址均需要手工指定，用于边界路由器与边界路由器，或者主机与边界路由器之间&lt;/li&gt;
&lt;li&gt;转发机制：&lt;br&gt;
当隧道边界设备的IPv6侧收到一个IPv6报文后，&lt;br&gt;
根据IPv6报文的目的地址查找IPv6路由转发表，如果该报文是从此虚拟隧道接口转发出去，则根据隧道接口配置的隧道源端和目的端的IPv4地址进行封装。&lt;br&gt;
封装后的报文变成一个IPv4报文，交给IPv4协议栈处理。&lt;br&gt;
报文通过IPv4网络转发到隧道终点。&lt;br&gt;
隧道终点收到隧道协议报文后，进行隧道解封装，并将解封装后的报文交给IPv6协议栈处理。&lt;/li&gt;
&lt;li&gt;6to4隧道：6over4自动隧道的一种，是使用内嵌在IPv6地址中的IPv4地址建立的，支持router到router、host到router、router到host、host到host。采用6to4专用地址，6to4地址可以表示为 2002::/16，内嵌IPv4后为2002:IPv4::/48&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;vxlan&#34;&gt;VxLAN&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Overlay在网络技术领域，指的是一种网络架构上叠加的虚拟化技术模式，其大体框架是对基础网络不进行大规模修改的条件下，实现应用在网络上的承载，并能与其他网络业务分离，并且以基于IP的基础网络技术为主。Overlay技术是在现有的物理网络之上构建一个虚拟网络，上层应用知识虚拟网络相关（比如GRE隧道等技术）。&lt;/li&gt;
&lt;li&gt;Overlay网络主要由3部分组成：
&lt;ol&gt;
&lt;li&gt;边缘设备：是指与虚拟机直接相连的设备&lt;/li&gt;
&lt;li&gt;控制平面：主要负责虚拟隧道的建立维护以及主机可达性信息的通告&lt;/li&gt;
&lt;li&gt;转发平面：承载Overlay报文的物理网络&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;VxLAN是业界Overlay技术的事实标准&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610718936187.png&#34; alt=&#34;VxLAN是业界Overlay技术的事实标准&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
VxLAN在支持SDN，多租户等方面能力更强，因此成为业界的技术热点。&lt;/li&gt;
&lt;li&gt;优点&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1610719342614.png&#34; alt=&#34;优点&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;概念
&lt;ol&gt;
&lt;li&gt;Overlay网络定义将一个计算网络构建在另一个网络之上&lt;/li&gt;
&lt;li&gt;核心是实现封装，将网络业务与底层设施解耦&lt;/li&gt;
&lt;li&gt;封装技术使用的VxLAN&lt;/li&gt;
&lt;li&gt;VxLAN隧道封装的端点就叫NVE（网络虚拟边界），负责原始以太报文的VxLAN封装和解封装。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">茶话会内容</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/xue-xi-shun-xu/"" data-c="
          &lt;h1 id=&#34;1-lab题-20161111&#34;&gt;1. LAB题-2016.11.11&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3261188&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3261188&#34;&gt; 01. LAB面试题讲解第一天-1【2021.01.13 快进略过】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3708989&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3708989&#34;&gt; 02. LAB面试题讲解第一天-2【2021.01.13 快进略过】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4147141&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4147141&#34;&gt; 03. LAB面试题讲解第二天-1【2021.01.13 快进略过】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1767705&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1767705&#34;&gt; 04. LAB面试题讲解第二天-2【2021.01.16】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4204791&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4204791&#34;&gt; 05. LAB面试题讲解第三天【2021.01.16】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;2-乾颐堂技术茶话会-最后&#34;&gt;2. 乾颐堂技术茶话会-最后&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6580586&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6580586&#34;&gt; 乾颐堂安德技术大咖茶话会-HCIEv3.0-2019.4考试新动态1【2021.01.14】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5534317&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5534317&#34;&gt; Pv4向IPv6过渡技术【2021.01.14】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1694715&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1694715&#34;&gt; VXALN【2021.01.15】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;以下为面试重点内容&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;3-二层协议-20161115&#34;&gt;3. 二层协议-2016.11.15&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8065547&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8065547&#34;&gt; 06. 二层协议第一天：STP和RSTP区别-1【2021.01.17】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2841403&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2841403&#34;&gt; 07. 二层协议第二天：STP和RSTP区别-2【2021.01.18】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-7014434&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-7014434&#34;&gt; 08. 二层协议第二天：STP和RSTP区别-3【2021.01.18】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9731564&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9731564&#34;&gt; 09. 二层协议第三天：MSTP【2021.01.18】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4241364&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4241364&#34;&gt; 10. 二层协议第三天：VLAN特性【2021.01.20】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5146597&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5146597&#34;&gt; 11. 二层协议第四天：Super VLAN&amp;MUX VLAN&amp;Smart-link【2021.01.21】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;22-24号整理大量二层追问和视频中没有的知识点，作为二层的结尾。二层知识点多且杂，但主要的部分是STP、VLAN、PPP，其他的也准备一下，但适可而止&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-igp协议-20161118&#34;&gt;4. IGP协议-2016.11.18&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6145595&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6145595&#34;&gt; 12. IGP协议第一天：路由基础&amp;RIP-1【2021.01.24】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-670434&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-670434&#34;&gt; 13. IGP协议第一天：RIP-2【2021.01.25】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-798460&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-798460&#34;&gt; 14. IGP协议第二天：OSPF-1【2021.01.26】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6818196&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6818196&#34;&gt; 15. IGP协议第二天：OSPF-2【2021.01.27】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-649842&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-649842&#34;&gt; 16. IGP协议第三天：OSPF-3【2021.01.28】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5435996&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5435996&#34;&gt; 17. IGP协议第三天：OSPF-4【2021.01.30】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8732869&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8732869&#34;&gt; 18. IGP协议第四天：OSPF-5【2021.01.30】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1821539&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1821539&#34;&gt; 19. IGP协议第四天：OSPF-6【2021.01.31】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5397513&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5397513&#34;&gt; 20. IGP协议第五天：OSPF-7【2021.01.31】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-279949&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-279949&#34;&gt; 21. IGP协议第五天：OSPF-8【2021.02.01】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1540252&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1540252&#34;&gt; 22. IGP协议第六天：集成IS-IS-1【2021.02.06】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4812932&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4812932&#34;&gt; 23. IGP协议第六天：集成IS-IS-2【2021.02.07】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5799984&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5799984&#34;&gt; 24. IGP协议第六天：集成IS-IS-3【2021.02.08】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2829349&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2829349&#34;&gt; 25. IGP协议第六天：集成IS-IS-4【2021.02.08】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5-bgp协议-20161126&#34;&gt;5. BGP协议-2016.11.26&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1317042&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1317042&#34;&gt; 26. BGP协议第一天：BGP-1【2021.02.11】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5423602&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5423602&#34;&gt; 27. BGP协议第二天：BGP-2【2021.02.11】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3493957&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3493957&#34;&gt; 28. BGP协议第二天：BGP-3【2021.02.12】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5945190&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5945190&#34;&gt; 29. BGP协议第三天：BGP-4【2021.02.12】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;6-组播-20161129&#34;&gt;6. 组播-2016.11.29&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1808596&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1808596&#34;&gt; 30. 组播第一天：组播基础&amp;IGMPV1、V2【2021.02.13】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-747557&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-747557&#34;&gt; 31. 组播第二天：IGMPV3【2021.02.13】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8391725&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8391725&#34;&gt; 32. 组播第二天：IGMP Snooping&amp;Proxy【2021.02.14】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2846661&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2846661&#34;&gt; 33. 组播第三天：组播PIM-DM【2021.02.14】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8415003&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8415003&#34;&gt; 34. 组播第三天：组播PIM-SM&amp;MSDP【2021.02.15】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;7-特性-20161208&#34;&gt;7. 特性-2016.12.08&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6236495&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6236495&#34;&gt; 35. DHCP&amp;DHCP Snooping&amp;DAI&amp;IP源防护【2021.02.16】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-156166&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-156166&#34;&gt; 36. FTP主被模式【2021.02.16】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;8-ipv6-20161211&#34;&gt;8. IPv6-2016.12.11&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6979260&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6979260&#34;&gt; 37. IPV6第一天：IPV6基础-1【2021.02.17】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1180753&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1180753&#34;&gt; 38. IPV6第一天：IPV6基础-2【2021.02.18】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-7668078&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-7668078&#34;&gt; 39. IPV6第二天：IPV6隧道技术-1【2021.02.18】&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3159510&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3159510&#34;&gt; 40. IPV6第二天：IPV6隧道技术-2&amp;移动IPV6特性【2021.02.18】&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;9-新加-201907&#34;&gt;9. 新加-2019.07&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9864647&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9864647&#34;&gt; 41. 乾颐堂面试-堆叠&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1096603&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1096603&#34;&gt; 42. 乾颐堂面试-路由撤销&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5474257&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5474257&#34;&gt; 43. 乾颐堂面试资料-V3相比V2增加&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-7139934&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-7139934&#34;&gt; 44. 乾颐堂面试资料-LSA问题&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9321230&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9321230&#34;&gt; 45. 乾颐堂面试资料-PPP&lt;/label&gt;&lt;/li&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-7135143&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-7135143&#34;&gt; 46. 乾颐堂面试-跨域&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
">学习顺序</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-lian-xi-ji-lu/"" data-c="
          &lt;ul&gt;
&lt;li&gt;20201202
&lt;ul&gt;
&lt;li&gt;20201202/TS-A_20201202_64.7z&lt;/li&gt;
&lt;li&gt;20201202/TS-A差异&lt;/li&gt;
&lt;li&gt;20201202/TS-B_20201202_89.7z&lt;/li&gt;
&lt;li&gt;20201202/TS-B差异&lt;/li&gt;
&lt;li&gt;20201202/ts_A配置导出.7z&lt;/li&gt;
&lt;li&gt;20201202/ts_B配置导出.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201206
&lt;ul&gt;
&lt;li&gt;20201206/TS_A_1206.7z&lt;/li&gt;
&lt;li&gt;20201206/TS_A_1206导出配置.7z&lt;/li&gt;
&lt;li&gt;20201206/TS_B_1206.7z&lt;/li&gt;
&lt;li&gt;20201206/TS_B_1206导出配置.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201214
&lt;ul&gt;
&lt;li&gt;20201214/B.7z&lt;/li&gt;
&lt;li&gt;20201214/TAC1.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201215
&lt;ul&gt;
&lt;li&gt;20201215/A.7z&lt;/li&gt;
&lt;li&gt;20201215/LABv2.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201216
&lt;ul&gt;
&lt;li&gt;20201216/A@60.7z&lt;/li&gt;
&lt;li&gt;20201216/B@72.7z&lt;/li&gt;
&lt;li&gt;20201216/LABv2@115.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201217
&lt;ul&gt;
&lt;li&gt;20201217/LABv1.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201218
&lt;ul&gt;
&lt;li&gt;20201218/LABv1.7z&lt;/li&gt;
&lt;li&gt;20201218/LABv2.7z&lt;/li&gt;
&lt;li&gt;20201218/TSA.7z&lt;/li&gt;
&lt;li&gt;20201218/TSB.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201219
&lt;ul&gt;
&lt;li&gt;20201219/LABv1.7z&lt;/li&gt;
&lt;li&gt;20201219/LABv2.7z&lt;/li&gt;
&lt;li&gt;20201219/TSA.7z&lt;/li&gt;
&lt;li&gt;20201219/TSB.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201220
&lt;ul&gt;
&lt;li&gt;20201220/LABv1@108min.7z&lt;/li&gt;
&lt;li&gt;20201220/LABv2@84min.7z&lt;/li&gt;
&lt;li&gt;20201220/TSA@57min.7z&lt;/li&gt;
&lt;li&gt;20201220/TSB@72min.7z&lt;/li&gt;
&lt;li&gt;20201220/导出配置2020-12-20.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201221
&lt;ul&gt;
&lt;li&gt;20201221/LABv1@96min.7z&lt;/li&gt;
&lt;li&gt;20201221/差别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201222
&lt;ul&gt;
&lt;li&gt;20201222/LABv1@111min.7z&lt;/li&gt;
&lt;li&gt;20201222/LABv2@93.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201223
&lt;ul&gt;
&lt;li&gt;20201223/tac1.txt&lt;/li&gt;
&lt;li&gt;20201223/tac2.txt&lt;/li&gt;
&lt;li&gt;20201223/tac3.txt&lt;/li&gt;
&lt;li&gt;20201223/tac4.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201224
&lt;ul&gt;
&lt;li&gt;20201224/LABv1@100min.7z&lt;/li&gt;
&lt;li&gt;20201224/LABv2@97min.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201225
&lt;ul&gt;
&lt;li&gt;20201225/TSA@64min.7z&lt;/li&gt;
&lt;li&gt;20201225/TSB@88min.7z&lt;/li&gt;
&lt;li&gt;20201225/导出配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201226
&lt;ul&gt;
&lt;li&gt;20201226/LABv1.7z&lt;/li&gt;
&lt;li&gt;20201226/LABv2.7z&lt;/li&gt;
&lt;li&gt;20201226/tac5-1.txt&lt;/li&gt;
&lt;li&gt;20201226/tac5-2.txt&lt;/li&gt;
&lt;li&gt;20201226/tac6-1.txt&lt;/li&gt;
&lt;li&gt;20201226/tac6-2.txt&lt;/li&gt;
&lt;li&gt;20201226/tac6-3.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201227
&lt;ul&gt;
&lt;li&gt;20201227/tac1.txt&lt;/li&gt;
&lt;li&gt;20201227/tac2.txt&lt;/li&gt;
&lt;li&gt;20201227/tac3.txt&lt;/li&gt;
&lt;li&gt;20201227/TSA.7z&lt;/li&gt;
&lt;li&gt;20201227/TSB.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201228
&lt;ul&gt;
&lt;li&gt;20201228/LABv1.7z&lt;/li&gt;
&lt;li&gt;20201228/LABv2xx.7z&lt;/li&gt;
&lt;li&gt;20201228/tac4-2.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201229
&lt;ul&gt;
&lt;li&gt;20201229/LABv1@102min.7z&lt;/li&gt;
&lt;li&gt;20201229/LABv2@92min.7z&lt;/li&gt;
&lt;li&gt;20201229/tac5-1.txt&lt;/li&gt;
&lt;li&gt;20201229/tac5-2.txt&lt;/li&gt;
&lt;li&gt;20201229/tac6-1.txt&lt;/li&gt;
&lt;li&gt;20201229/TSA@52min.7z&lt;/li&gt;
&lt;li&gt;20201229/TSB@77min.7z&lt;/li&gt;
&lt;li&gt;20201229/导出配置20201229.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201230
&lt;ul&gt;
&lt;li&gt;20201230/LABv1@110min.7z&lt;/li&gt;
&lt;li&gt;20201230/LABv2@95min.7z&lt;/li&gt;
&lt;li&gt;20201230/tac1.txt&lt;/li&gt;
&lt;li&gt;20201230/tac2.txt&lt;/li&gt;
&lt;li&gt;20201230/tac3.txt&lt;/li&gt;
&lt;li&gt;20201230/tac6-2.txt&lt;/li&gt;
&lt;li&gt;20201230/tac6-3.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20201231
&lt;ul&gt;
&lt;li&gt;20201231/tac4-2.txt&lt;/li&gt;
&lt;li&gt;20201231/tac5-1.txt&lt;/li&gt;
&lt;li&gt;20201231/tac5-2.txt&lt;/li&gt;
&lt;li&gt;20201231/tac6-1.txt&lt;/li&gt;
&lt;li&gt;20201231/tac6-2.txt&lt;/li&gt;
&lt;li&gt;20201231/tac6-3.txt&lt;/li&gt;
&lt;li&gt;20201231/TSA.7z&lt;/li&gt;
&lt;li&gt;20201231/TSB.7z&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20210101
&lt;ul&gt;
&lt;li&gt;20210101/LABv1@107min.7z&lt;/li&gt;
&lt;li&gt;20210101/LABv2@96min.7z&lt;/li&gt;
&lt;li&gt;20210101/TSA@54min.7z&lt;/li&gt;
&lt;li&gt;20210101/TSB@62min.7z&lt;/li&gt;
&lt;li&gt;20210101/配置导出20210101&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20210102
&lt;ul&gt;
&lt;li&gt;20210102/tac1.txt&lt;/li&gt;
&lt;li&gt;20210102/tac2.txt&lt;/li&gt;
&lt;li&gt;20210102/tac3.txt&lt;/li&gt;
&lt;li&gt;20210102/tac4.txt&lt;/li&gt;
&lt;li&gt;20210102/tac5-1.txt&lt;/li&gt;
&lt;li&gt;20210102/tac5-2.txt&lt;/li&gt;
&lt;li&gt;20210102/tac6-1.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20210103
&lt;ul&gt;
&lt;li&gt;20210103/LABv1@97min.7z&lt;/li&gt;
&lt;li&gt;20210103/LABv2@89min.7z&lt;/li&gt;
&lt;li&gt;20210103/TSA@59min.7z&lt;/li&gt;
&lt;li&gt;20210103/TSB@74min.7z&lt;/li&gt;
&lt;li&gt;20210103/配置导出20210103&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20210104
&lt;ul&gt;
&lt;li&gt;20210104/tac1.txt&lt;/li&gt;
&lt;li&gt;20210104/tac2.txt&lt;/li&gt;
&lt;li&gt;20210104/tac3.txt&lt;/li&gt;
&lt;li&gt;20210104/tac6-2.txt&lt;/li&gt;
&lt;li&gt;20210104/tac6-3.txt&lt;/li&gt;
&lt;li&gt;20210104/tac提纲整理.md&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;20210105
&lt;ul&gt;
&lt;li&gt;20210105/LABv1@101min.7z&lt;/li&gt;
&lt;li&gt;20210105/LABv2@94min.7z&lt;/li&gt;
&lt;li&gt;20210105/tac提纲整理.md&lt;/li&gt;
&lt;li&gt;20210105/TSA@51min.7z&lt;/li&gt;
&lt;li&gt;20210105/TSB@68min.7z&lt;/li&gt;
&lt;li&gt;20210105/配置导出20210105&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">HCIE 实验练习记录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/tac-ti-gang-jin-jie/"" data-c="
          &lt;h1 id=&#34;tac1&#34;&gt;TAC1&lt;/h1&gt;
&lt;p&gt;AR29无法访问AR28&lt;/p&gt;
&lt;h2 id=&#34;步骤&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：不通&lt;/li&gt;
&lt;li&gt;检查路由表：无路由&lt;/li&gt;
&lt;li&gt;检查ospf邻居：无邻居&lt;/li&gt;
&lt;li&gt;检查AR27的路由和邻居：都有&lt;/li&gt;
&lt;li&gt;对比AR27和AR29的ospf进程信息：AR29配置正确&lt;/li&gt;
&lt;li&gt;检查ospf错误情况：无任何错误&lt;/li&gt;
&lt;li&gt;检查三层连通性：从AR27的arp列表中获取地址，不通&lt;/li&gt;
&lt;li&gt;检查ARP列表和二层单播测试：无表项且不通&lt;/li&gt;
&lt;li&gt;检查接口状态：物理和协议都正常&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
LSW6的vlan配置错误&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性&#34;&gt;高可能性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;LSW6配置mux-vlan&lt;/li&gt;
&lt;li&gt;AR29与AR28的ospf进程下的区域认证不一致&lt;/li&gt;
&lt;li&gt;AR29与AR28的ospf进程下存在路由过滤&lt;/li&gt;
&lt;li&gt;AR29与AR28互联接口下存在流量过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac2&#34;&gt;TAC2&lt;/h1&gt;
&lt;p&gt;AR29无法访问AR33&lt;/p&gt;
&lt;h2 id=&#34;步骤-2&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：不通&lt;/li&gt;
&lt;li&gt;检查路由表：无路由&lt;/li&gt;
&lt;li&gt;检查ospf邻居：无邻居&lt;/li&gt;
&lt;li&gt;尝试检查三层连通性：lldp和arp均获取不到三层地址&lt;/li&gt;
&lt;li&gt;检查ospf错误情况：hello时间不一致&lt;/li&gt;
&lt;li&gt;查看调试信息：hello时间和区域类型不一致，获取三层地址&lt;/li&gt;
&lt;li&gt;测试三层的连通性&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR33的hello时间和ospf区域类型配置错误&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-2&#34;&gt;高可能性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR33的loopback0接口地址没有宣告进ospf区域2&lt;/li&gt;
&lt;li&gt;AR33和AR29之间的ospf区域认证不一致&lt;/li&gt;
&lt;li&gt;AR33与AR29互联接口的ospf认证不一致&lt;/li&gt;
&lt;li&gt;AR33与AR29互联接口的mtu不一致&lt;/li&gt;
&lt;li&gt;AR33与AR29的ospf进程下配置路由过滤&lt;/li&gt;
&lt;li&gt;AR33与AR29的互联接口下存在流量过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac3&#34;&gt;TAC3&lt;/h1&gt;
&lt;p&gt;AR32无法访问AR28&lt;/p&gt;
&lt;h2 id=&#34;步骤-3&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：不通&lt;/li&gt;
&lt;li&gt;检查路由表：无&lt;/li&gt;
&lt;li&gt;检查ospf邻居：正常&lt;/li&gt;
&lt;li&gt;检查ospf链路状态数据库：只有1类lsa&lt;/li&gt;
&lt;li&gt;查看1类lsa：没有描述loopback0&lt;/li&gt;
&lt;li&gt;查看AR27的链路状态数据库和相应的一类lsa：有描述loopback0信息&lt;/li&gt;
&lt;li&gt;测试AR28的路由表中是否存在AR32的loopback0接口的路由：存在&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR28的ospf的区域0中配置区域间路由汇总加了关键字not-advertise，汇总后不通告&lt;br&gt;
AR28的ospf进程下使用filter命令过滤掉了loopback0的3类lsa，可以配置在区域0的出方向或者区域1的入方向&lt;br&gt;
AR28在g2/0/0接口下配置ospf filter-lsa-out summary acl xxx，过滤掉了3类lsa&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-3&#34;&gt;高可能性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR28与AR32的ospf进程下存在路由过滤&lt;/li&gt;
&lt;li&gt;AR28与AR32互联接口下存在流量过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac4-1&#34;&gt;TAC4-1&lt;/h1&gt;
&lt;p&gt;AR32无法访问isis区域所有设备&lt;/p&gt;
&lt;h2 id=&#34;步骤-4&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：都不通&lt;/li&gt;
&lt;li&gt;检查路由表：没有isis区域的路由，但存在AR28的loopback0，即ospf邻居正常&lt;/li&gt;
&lt;li&gt;检查ospf的链路状态数据库：没有5类lsa&lt;/li&gt;
&lt;li&gt;检查AR27的链路状态数据库：没有5类lsa&lt;/li&gt;
&lt;li&gt;检查AR31和AR34的路由表：有ospf区域的路由&lt;/li&gt;
&lt;li&gt;检查AR31、AR34、AR32是否存在流量过滤策略：无ACL，无traffic-policy&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR28的ospf进程下没有引入isis或者引入错误的isis进程&lt;br&gt;
AR28在ospf区域下配置外部路由汇总并添加关键字not-advertise&lt;br&gt;
AR28在ospf进程下使用filter-policy命令过滤掉出方向的5类lsa&lt;br&gt;
AR28在g0/0/0和g2/0/0接口下配置ospf filter-lsa-out ase，过滤5类lsa&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-4&#34;&gt;高可能性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR28和AR32的ospf进程下存在路由过滤&lt;/li&gt;
&lt;li&gt;AR28、AR30相关接口下存在流量过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac4-2&#34;&gt;TAC4-2&lt;/h1&gt;
&lt;p&gt;AR32无法访问isis区域所有设备&lt;/p&gt;
&lt;h2 id=&#34;步骤-5&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：都不通&lt;/li&gt;
&lt;li&gt;检查路由表：没有isis区域的路由，但存在AR28的loopback0，即ospf邻居正常&lt;/li&gt;
&lt;li&gt;检查ospf的链路状态数据库：没有5类lsa&lt;/li&gt;
&lt;li&gt;检查AR27的链路状态数据库：有5类lsa&lt;/li&gt;
&lt;li&gt;检查AR27的路由表并测试与isis区域的连通性：有，并且通&lt;/li&gt;
&lt;li&gt;检查AR31和AR34的路由表：有ospf区域路由，主要是有AR32的路由&lt;/li&gt;
&lt;li&gt;检查AR31、AR34、AR32是否存在流量过滤：无ACL，无traffic-policy&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR28在g2/0/0接口下配置ospf filter-lsa-out ase，过滤5类lsa&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-5&#34;&gt;高可能性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR28和AR32的ospf进程下存在路由过滤&lt;/li&gt;
&lt;li&gt;AR28、AR30相关接口下存在流量过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac5-1&#34;&gt;TAC5-1&lt;/h1&gt;
&lt;p&gt;AR32无法访问isis区域部分设备&lt;/p&gt;
&lt;h2 id=&#34;步骤-6&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：无法访问AR31的所有接口和AR34的g0/0/1&lt;/li&gt;
&lt;li&gt;检查路由表：有&lt;/li&gt;
&lt;li&gt;检查AR31和AR34的路由表：有，路由控制层面无问题&lt;/li&gt;
&lt;li&gt;不带源进行路由追踪：都通&lt;/li&gt;
&lt;li&gt;带源进行路由追踪：第二跳无法回显，故障在AR28于AR31之间&lt;/li&gt;
&lt;li&gt;单播测试前后AR31的g0/0/2接口的收报情况：没有收到报文&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR28的g0/0/2接口的出方向上针对AR32的loopback0接口流量配置过滤策略&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-6&#34;&gt;高可能性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR31的g0/0/2、g0/0/1和AR34的g0/0/1接口下配置流量过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac5-2&#34;&gt;TAC5-2&lt;/h1&gt;
&lt;p&gt;AR32无法访问isis区域部分设备&lt;/p&gt;
&lt;h2 id=&#34;步骤-7&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：无法访问AR34的loopback0和g0/0/0&lt;/li&gt;
&lt;li&gt;检查路由表：有&lt;/li&gt;
&lt;li&gt;检查AR34的路由表：默认路由&lt;/li&gt;
&lt;li&gt;检查AR31的路由表：有，路由控制无问题&lt;/li&gt;
&lt;li&gt;不带源路由追踪：通，两条等价路由&lt;/li&gt;
&lt;li&gt;带源路由追踪：g0/0/0第3跳无法回显，lo 0第三跳缺少一条路由，故障在AR34于AR31之间&lt;/li&gt;
&lt;li&gt;单播测试前后AR34的g0/0/0的收报情况：没收到&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR30的g0/0/0接口在出方向上配置了针对AR32的loopback0接口流量的过滤策略&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-7&#34;&gt;高可能性&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR34的g0/0/0存在流量过滤策略&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac6-1&#34;&gt;TAC6-1&lt;/h1&gt;
&lt;p&gt;AR34没有两条等价默认路由&lt;/p&gt;
&lt;h2 id=&#34;步骤-8&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：只有AR30&lt;/li&gt;
&lt;li&gt;检查接口的cost值：一样&lt;/li&gt;
&lt;li&gt;检查isis邻居：只有AR30&lt;/li&gt;
&lt;li&gt;测试三层连通性：正常&lt;/li&gt;
&lt;li&gt;检查isis错误情况：区域ID错误&lt;/li&gt;
&lt;li&gt;检查AR31和AR34的链路状态数据库：区域ID确实错误，AR31只有l1的lsp&lt;/li&gt;
&lt;li&gt;检查AR31的isis进程信息和邻居：级别为level-1，无邻居&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR31的isis区域ID配置错误，isis级别配置错误&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-8&#34;&gt;高可能性&lt;/h2&gt;
&lt;p&gt;与AR31与AR28之间的邻居有关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AR28的g0/0/2接口下没有使能isis&lt;/li&gt;
&lt;li&gt;AR28和AR31的isis进程下domain认证不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31互联接口的mtu不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31互联接口的链路类型不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31互联接口的isis认证不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31的isis进程下的cost类型不一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;与AR31和AR34之间的邻居有关：&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;AR31和AR34的互联接口下isis认证不一致&lt;/li&gt;
&lt;li&gt;AR31与AR34的isis进程下的cost类型不一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他因素：&lt;/p&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;AR31的isis进程下配置不发布ATT置1的lsp&lt;/li&gt;
&lt;li&gt;AR34的isis进程下针对下一跳配置不同的weight&lt;/li&gt;
&lt;li&gt;AR34的isis进程下设置负载分担的等价路由的最大条数为1&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac6-2&#34;&gt;TAC6-2&lt;/h1&gt;
&lt;p&gt;AR34没有两条等价默认路由&lt;/p&gt;
&lt;h2 id=&#34;步骤-9&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：只有AR30的&lt;/li&gt;
&lt;li&gt;检查接口cost值：都一样&lt;/li&gt;
&lt;li&gt;检查isis邻居：两个都存在&lt;/li&gt;
&lt;li&gt;检查isis链路状态数据库：AR31的lsp的ATT未置1&lt;/li&gt;
&lt;li&gt;检查AR34的isis进程信息：level-1&lt;/li&gt;
&lt;li&gt;检查AR31的isis邻居：没有AR28&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR31的isis级别配置错误&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-9&#34;&gt;高可能性&lt;/h2&gt;
&lt;p&gt;与AR31和AR28的isis邻居有关:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AR28的g0/0/2接口下没有使能isis&lt;/li&gt;
&lt;li&gt;AR28与AR31的isis下的domain认证不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31互联接口的mtu不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31互联接口链路类型不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31互联接口isis认证不一致&lt;/li&gt;
&lt;li&gt;AR28与AR31的isis进程下配置的cost类型不一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他因素：&lt;/p&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;AR31的isis进程下配置不发布ATT置1的lsp&lt;/li&gt;
&lt;li&gt;AR34的isis进程下针对下一跳设置不同的weight&lt;/li&gt;
&lt;li&gt;AR34的isis进程下设置负载分担的等价路由的最大条数为1&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;tac6-3&#34;&gt;TAC6-3&lt;/h1&gt;
&lt;p&gt;AR34没有两条等价默认路由&lt;/p&gt;
&lt;h2 id=&#34;步骤-10&#34;&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;故障重现：只有AR30&lt;/li&gt;
&lt;li&gt;检查接口的cost值：相同&lt;/li&gt;
&lt;li&gt;检查isis邻居：只有AR30&lt;/li&gt;
&lt;li&gt;检查三层连通性：通&lt;/li&gt;
&lt;li&gt;检查isis错误情况：区域ID配置错误&lt;/li&gt;
&lt;li&gt;检查AR31和AR34的链路状态数据库：区域ID不一样&lt;/li&gt;
&lt;li&gt;检查AR31的isis进程信息和邻居：level-1-2，有AR28&lt;/li&gt;
&lt;li&gt;结论&lt;br&gt;
AR31的区域ID配置错误&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;高可能性-10&#34;&gt;高可能性&lt;/h2&gt;
&lt;p&gt;与AR34和AR31之间的邻居相关：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AR31与AR34的互联接口的isis认证不一致&lt;/li&gt;
&lt;li&gt;AR31与AR34的isis进程下的cost类型不一致&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;其他因素：&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;AR31的isis进程下配置不发布ATT置1的lsp&lt;/li&gt;
&lt;li&gt;AR34的isis进程下针对下一跳配置不同的weight&lt;/li&gt;
&lt;li&gt;AR34的isis进程下设置负载分担的等价路由的最大条数为1&lt;/li&gt;
&lt;/ol&gt;
">TAC 提纲进阶</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-suo-you-shi-yan-dui-bi-jiu-cuo-2/"" data-c="
          &lt;h1 id=&#34;lab&#34;&gt;LAB&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;lab中使用明细策略的总结
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;labv1中全部使用明细路由&lt;/strong&gt;。包含RR1和P1上ipv4、ipv6的isis渗透、ASBR上的将isis的lo0的路由引入bgp（允许本AS内的&lt;code&gt;172.16.1.x&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;labv2&lt;/strong&gt;中只有一个地方使用明细，其他地方不用明细。在实施方案二时，需要&lt;strong&gt;将BGP的路由引入IGP&lt;/strong&gt;（isis）时使用明细路由（允许对方AS内的&lt;code&gt;172.16.1.x&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;RR2/P2双点双向引入，&lt;code&gt;route-policy I2O&lt;/code&gt;中不需要写&lt;code&gt;apply cost-type xxxx&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;lab中bfd最小故障检测时间那个值为40，原因是&lt;code&gt;40*3&amp;lt;150&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;labv1中的Qos中的PE4的g0/0/1上的命令&lt;code&gt;trust 8021p override&lt;/code&gt;，不能忘记&lt;strong&gt;override&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ts&#34;&gt;TS&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;tsa中的vrrp中，vrrp6的link-local地址均改为&lt;code&gt;FF80::1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tsb的AR18的&lt;code&gt;t 0/0/100&lt;/code&gt; 上需要添加&lt;code&gt;ipv6 address FE80::18 link-local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;tsa的sw3中的e0/0/1接口下关于stp in 0的配置删除，e0/0/21和e0/0/22通过修改cost值来实现，改为10万&lt;code&gt;100000&lt;/code&gt;吧&lt;/li&gt;
&lt;li&gt;tsb中AR7的bgp中的ipv6需要反射，AR9的bgp中的ipv6删除无效地址&lt;code&gt;2002:100:9:1::1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
">HCIE 所有实验对比纠错2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/tac-ti-gang-gao-ke-neng-bu-chong/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;
TAC1:AR29无法访问AR28
-----------
LSW6的交换机配置错误
-----------
1. 故障重现
2. 检查路由表 # 无路由
3. 检查ospf邻居 # 无邻居 
4. 检查AR27的邻居与路由 # 有邻居有路由
5. 对比AR27/AR29的ospf配置 # 配置正确
6. 检查ospf错误信息 # 无错误
7. 测试三层连通性 # 不通
8. 查看ARP列表和二层连通性 # 无Mac且不通
9. 检查接口状态 # 正常
------------
1. LSW6配置mux-vlan
2. AR29的ospf区域认证错误
    #interface xxx，undo ospf authentication-mode；先删除接口下认证
    #ospf xx，area 0，authentication-mode md5 1 cipher xxx
3. AR29/AR28的ospf进程下存在路由过滤 
    # ospf xx ，undo filter-policy {import|export}
4. LSW6/AR29/AR28互联接口存在流量过滤 
    # interface xx , undo {traccfic-filter|traffic-policy} {outbound|inbound}






TAC2: AR29无法访问AR33
------------
AR33的区域类型配置错误，hello时间配置错误
    # undo nssa，undo ospf timer hello
-----------
1. 故障重现
2. 检查路由表 # 无路由
3. 检查ospf邻居 # 无邻居
4. 检查接口宣告情况 #接口正常宣告【mtu=1500】
5. 测试三层连通性 # 三层通，三层地址获取通过arp或者lldp。如果获取不到，此步骤放在第7步之后，第7步的调试信息可以获取到三层地址
6. 检查ospf错误信息 # hello时间报错
7. 查看调试信息
------------
1. AR33的lo0没有宣告进ospf
2. AR29的ospf区域认证错误
3. AR29/AR33互联接口下ospf认证不一致
4. AR29/AR33互联接口的MTU不一致
5. AR29/AR33的ospf进程下存在路由过滤
6. AR29/AR33互联接口存在流量过滤






TAC3: AR32无法访问AR28
------------
AR28在区域0中配置了区域间路由汇总并加关键字not-advertise，过滤掉3类lsa
AR28在ospf区域中使用filter命令针对自身loopback0接口的3类lsa进行过滤(a0的出方向或者a1的入方向)
AR28的g2/0/0配置ospf filter-lsa-out summary acl xxx，过滤3类lsa
    # ospf filter-lsa-out
-----------
1. 故障重现
2. 检查路由表 # 无
3. 检查ospf邻居 # 无
4. 检查ospf的链路状态数据库 # 无3类lsa
5. 查看1类lsa #无lo0藐视
6. 在AR27上查看1类lsa #有lo0描述
7. 在AR32上测试AR28是否存在AR32的lo0路由 #通
	ping -a 10.5.1.32 10.5.232.28
------------
1. AR28/AR32的ospf进程下存在路由过滤
2. AR28/AR32互联接口下存在流量过滤






TAC4-1: AR32无法访问ISIS所有
------------
AR28在g2/0/0配置ospf filter-lsa-out ase过滤5类lsa
-----------
1. 故障重现
2. 检查路由表 # 无
3. 检查ospf的链路状态数据库 # 无5类lsa
4. 在AR27上查看ospf的链路状态数据库 # 有5类lsa
5. 查看AR27的路由表并测试与ISIS内设备通连情况 # 有路由，能通
6. 查看AR31/AR34的路由表 # 有路由
7. 查看AR31/AR34/AR32是否存在流量过滤 # 无acl，无traffic-policy
------------
1. AR28的ospf进程下存在路由过滤
2. AR28/AR30互联接口下存在流量过滤






TAC4-2: AR32无法访问ISIS所有
------------
AR28在ospf进程下没有引入isis路由或者引入错误的isis进程号
AR28在ospf进程下配置了外部路由汇总并添加关键字not-advertise，汇总后不通告，过滤掉了5类lsa
    # undo asbr-summary 10.5.0.0 255.255.0.0
AR28在ospf进行下使用filter-policy命令过滤掉了出方向的5类lsa
    # undo filter-policy export
AR28正确的引入了isis路由，但在g2/0/0和g0/0/0配置ospf filter-lsa-out ase过滤5类lsa
-----------
1. 故障重现
2. 检查路由表 # 无
3. 检查ospf的链路状态数据库 # 无5类lsa
4. 在AR27上查看ospf的链路状态数据库 # 无5类lsa
5. 查看AR31/AR34的路由表 # 有路由
6. 查看AR31/AR34/AR32是否存在流量过滤 # 没有acl和traffic-policy
------------
1. AR28/AR32的ospf进程下存在路由过滤
2. AR28/AR30互联接口下存在流量过滤




TAC5-1: AR32无法访问ISIS部分
  x AR31的所有和AR34的g0/0/1
------------
AR28的g0/0/2接口在出方向上配置了针对AR32的lo0接口的流量过滤策略
-----------
1. 故障重现
2. 检查路由表 # 有路由
3. 查看AR31/AR34的路由表 #至此路由控制没问题
4. 不带源路由追踪 # 通
5. 带源路由追踪 # 1跳后无法回显
6. 查看AR31的g0/0/2是否收到ping包  # 收不到
7. 在AR34上反向测试 # 通
------------
1. AR31的g0/0/2和g0/0/1、AR34的g0/0/1接口下存在流量过滤






TAC5-2: AR32无法访问ISIS部分
  x AR34的g0/0/0和lo0
------------
AR30的g0/0/0接口在出方向上配置了针对AR32的lo0接口的流量过滤策略
-----------
1. 故障重现
2. 检查路由表 #有
3. 查看AR34的路由表 # 至此34、32路由控制没问题】
4. 查看AR31的路由表 # 31和28都正常
4. 不带源路由追踪 # 通
5. 带源路由追踪 #2跳后无法回显
6. 查看AR34的g0/0/0是否收到ping包  # 收不到
7. 在AR34上反向测试 # 通
------------
1. AR34的g0/0/0下存在流量过滤






TAC6-1: AR34没有两条等价默认路由
------------
AR31的isis区域ID错误，isis级别错误
    # undo network-entity 49.0005.xxxxxx.......，is-level level-1-2
-----------
1. 故障重现（检查路由表）
2. 检查接口的cost值 # 相同
3. 检查isis邻居 # 只有AR30
4. 检查三层连通性 # 通
5. 检查isis错误信息 # 区域ID错误
6. 检查AR34/AR31的自身的isis链路状态数据库 # 区域ID不同之外，31只有level-1级别的lsp
7. 检查AR31的isis进程信息和邻居 # level级别错误，没有AR28
------------
与默认路由产生直接相关：
1. AR31上isis配置强制ATT不能置1
    # undo attached-bit advertise
2. AR34的isis针对下一跳配置不同的weight
    # undo nexthop 10.5.x.x
3. AR34的isis配置最大负载
    # undo maximum load-balancing
与AR28之间的邻居相关：
4. AR28的g0/0/2没有使能isis
    # int g0/0/2 ，isis enable xx
5. AR28的isis进程中配置domain认证
    # undo domain-authentication-mode
6. AR28与AR31互联接口mtu不一致
    # AR28：int g0/0/2 , mtu 1497 
7. AR28与AR31互联接口链路类型不一致
    # int g0/0/2 , undo isis circuit-type
8. AR28与AR31的互联接口配置isis认证
    # int xxx，undo isis authentication-mode
9. AR28与AR31的isis进程下cost类型不一致
    # isis xxx，cost-style xx
与AR34之间的邻居相关：
10. AR31与AR34的互联接口配置isis认证
    # int xxx，undo isis authentication-mode
11. AR31与AR34的isis进程下cost类型不一致
    # isis xxx，cost-style xx

# 下面的变种可根据某个邻居的有无适当删减高可能性






TAC6-2: AR34没有两条等价默认路由
------------
AR31的isis区域ID错误
-----------
1. 故障重现（检查路由表）
2. 检查接口的cost值 # 相同
3. 检查isis邻居 # 只有AR30
4. 检查三层连通性 # 通
5. 检查isis错误信息 # 区域ID错误
6. 检查AR34/AR31的自身的isis链路状态数据库 #区域ID错误，31有level-2的lsp
7. 检查AR31的isis进程信息和邻居  # level-1-2，有AR28，高可能涉及AR28删除
------------
1. AR31与AR34的互联接口配置isis认证
2. AR31与AR34isis进程下cost类型不一致
3. AR31上isis配置强制ATT不能置1
4. AR34的isis针对下一跳配置不同的weight
5. AR34的isis配置最大负载






TAC6-3: AR34没有两条等价默认路由
------------
AR31的isis级别错误
-----------
1. 故障重现（检查路由表）
2. 检查接口的cost值 # 相同
3. 检查isis邻居 #正常
4. 检查isis的链路状态数据库 # ATT位没有置1
5. 检查AR31的isis进程信息和邻居 # level-1，只有AR34
------------
1. AR28的g0/0/2没有使能isis
2. AR28的isis进程中配置domain认证
3. AR28与AR31互联接口mtu不一致
4. AR28与AR31链路类型不一致
5. AR28与AR31、AR31与AR34的互联接口配置isis认证
6. AR28、AR31、AR34的isis进程下cost类型不一致
7. AR31上isis配置强制ATT不能置1
8. AR34的isis针对下一跳配置不同的weight
9. AR34的isis配置最大负载
&lt;/code&gt;&lt;/pre&gt;
">TAC 提纲+高可能补充</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-suo-you-shi-yan-dui-bi-jiu-cuo/"" data-c="
          &lt;h1 id=&#34;labv1&#34;&gt;labv1：&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;将isis的loopback0引入bgp&lt;br&gt;
v1使用明细的前缀列表，分别只允许自己域内的通过（v2使用的是acl）&lt;/li&gt;
&lt;li&gt;CE1-ISP的链路断开时，CE1仍能访问ISP；CE2-ISP的链路断开时，CE2仍能访问ISP&lt;br&gt;
CE1/2分别在自己的master VRRP上针对去往ISP和对方的链路开启track&lt;/li&gt;
&lt;li&gt;RR2和P2的isis和ospf路由双点双向引入时：&lt;br&gt;
ospf需要开启default cost inherit-metric，同时策略I2O per no 10中需要加apply cost-type type-1&lt;/li&gt;
&lt;li&gt;MPLS VPN 方案一：&lt;br&gt;
PE针对RR，在vpnv4中不需要下一跳不变，和V2不同的只有一点就是开启label能力&lt;br&gt;
V1和V2都需要undo掉ipv4 unicast的RR之间的邻居&lt;br&gt;
RR在vpnv4中针对PE的反射&lt;br&gt;
RR1不需要针对RR2的allow-as-loop，RR2上才做（因为要求4、5）&lt;/li&gt;
&lt;li&gt;QoS:&lt;br&gt;
使用acl高级规则指定ip des，不是基本规则指定source&lt;/li&gt;
&lt;li&gt;VRRP：&lt;br&gt;
SW1/2与CE1/2互联接口放行出v 1所有的v&lt;/li&gt;
&lt;li&gt;isis ipv6&lt;br&gt;
路由渗透使用前缀列表只放行loop0的&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;labv2&#34;&gt;labv2&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;IPv6组播：&lt;br&gt;
PE1的e0/0/0也需要isis ipv6 enable&lt;/li&gt;
&lt;li&gt;同labv1中的2、3、6、7&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;tsa&#34;&gt;tsa&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;AR12修改了as号之后，还需要修改更新源为lo0&lt;/li&gt;
&lt;li&gt;AR9的ipv6不需要反射、AR7不需要宣告IPv6【不考ipv6 BGP】&lt;/li&gt;
&lt;li&gt;LSW3的E0/0/1需要undo stp in 0 cost&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;tsb&#34;&gt;tsb&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;loop 0接口的pim不需要开启，只有AR7和AR9需要开启&lt;/li&gt;
&lt;li&gt;AR9上删除ipv6中宣告的&lt;code&gt;network 2002:100:9:1::1 128&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;telnet：&lt;br&gt;
都不需要ospf network-type broadcast和undo fr inarp&lt;br&gt;
修改osfp配置中的邻居peer地址 AR17 AR18&lt;/li&gt;
&lt;/ol&gt;
">HCIE 所有实验对比纠错1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-labv1-yao-qiu-zheng-li/"" data-c="
          &lt;h1 id=&#34;labv1&#34;&gt;LabV1&lt;/h1&gt;
&lt;h2 id=&#34;1-l2vrrp&#34;&gt;1. L2+VRRP&lt;/h2&gt;
&lt;h3 id=&#34;11-链路聚合&#34;&gt;1.1 链路聚合&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;假设S1不支持LACP，S1和S2互联的接口需要合成一个二层逻辑接口，逻辑接口的成员链路根据源-目的MAC进行负载分担&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;12-link-type&#34;&gt;1.2 Link-type&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4互联接口的链路类型为trunk，允许除VLAN1外的所有vlan通过&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.1.254，为PC1的网关，CE1会周期性发送Sender IP为10.3.1.254，源MAC为00-00-5E-00-01-01的免费ARP。PC1与网关之间的数据包封装在VLAN10中&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.2.254，为PC2的网关，CE2会周期性发送Sender IP为10.3.2.254，源MAC为00-00-5E-00-01-02的免费ARP。PC2与网关之间的数据包封装在VLAN20中&lt;/li&gt;
&lt;li&gt;VRRP的master设备重启时，在g0/0/2变为up 1分钟后，才能重新成为master&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-mstp&#34;&gt;1.3 MSTP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4都运行MSTP。Vlan 10在instance 10，S1作为primary root，S2作为secondary root。Vlan 20在instance 20，S2作为primary root，S1作为secondary root。MSTP的region name是HUAWEI，Revision-level 12。&lt;/li&gt;
&lt;li&gt;除了交换机的互联端口，其他端口要确保不参与MSTP计算，由disabled会直接转到Forwarding状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14-wan&#34;&gt;1.4 WAN&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PE1-RR1的互联Serial接口，绑定为一个逻辑接口，成员链路采用HDLC，逻辑接口的IPv4地址、IPv6地址请按照图1、图5配置&lt;/li&gt;
&lt;li&gt;PE3-CE3的互联POS接口，绑定为一个逻辑接口，成员链路采用PPP，逻辑接口的IPv4地址，请按照图1配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-ipv4-igp&#34;&gt;2. IPv4 IGP&lt;/h2&gt;
&lt;h3 id=&#34;21-基本配置&#34;&gt;2.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有设备的接口IPv4地址按照图1配置（除PE1-RR1的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;Route-id与loopback0的IPv4地址相同。MPLS域各设备的loopback0为172.16.0.0/16的32位主机地址（已预配置），未来扩容的MPLS域各设备的loopback0，从172.16.0.0/16去可用的主机地址，比如172.16.1.21/32可能分布在AS100，也可能分布在AS200。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-ospf&#34;&gt;2.2 OSPF&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1和CE2之间的链路，及该两台设备的loopback0通告入OSPF区域0（已预配置）&lt;/li&gt;
&lt;li&gt;CE1的g0/0/2.10和g0/0/2.20、CE2的g0/0/2.10和g0/0/2.20，直连网段通告入OSPF区域0，这些接口不能收发OSPF报文&lt;/li&gt;
&lt;li&gt;RR2、P2、PE3、PE4在OSPF区域0中，cost如图2配置（已预配置）&lt;/li&gt;
&lt;li&gt;PE3-PE4的OSPF链路类型为P2P&lt;/li&gt;
&lt;li&gt;PE4上将loopback0地址引入OSPF。AS200中，各OSPF网元到PE4 loopback0的路由，要累加内部cost&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-isis&#34;&gt;2.3 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;AS100内loopback0和互联网接口全部开启ISIS协议，其中PE1、PE2的路由类型为L1，区域号为49.0001，RR1、P1路由类型为L12，区域号为49.0001，ASBR1、ASBR2路由类型为L2，区域号为49.0002。各网元system-id唯一，cost-style为wide，cost值如图2配置（除PE1-RR1之外的逻辑接口外，已预配置）【AS200内，RR2、P2、ASBR3、ASBR4的loopback0和互联接口全部开启isis协议，IS类型为L2，区域号为49.0003。各网元system-id唯一，cost-style为wide，cost值如图2配置（已预配置）】&lt;/li&gt;
&lt;li&gt;RR2-P2的ISIS链路类型为P2P&lt;/li&gt;
&lt;li&gt;在RR2、P2上，ISIS和OSPF双向引入前缀为172.16.0.0/16的主机路由。被引入的协议的cost要继承到引入后的协议中，P2和PE4的loopback0互访走最优路径。配置要求有最好的扩展性&lt;/li&gt;
&lt;li&gt;P1的ISIS进程，产生LSP的最大延迟时间是1S，初始延迟为50ms，递增时间为50ms。使能LSP的快速扩散特性。SPF计算间隔为1s，初始延迟为100ms，递增时间为100ms。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-mpls-vpn&#34;&gt;3. MPLS VPN&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CE1、CE2为VPN1的Hub-CE，PE1、PE2为Hub-CE，CE3、CE4为VPN1的spoke站点，PE3、PE4为SpokePE&lt;/li&gt;
&lt;li&gt;CE4位Multi-VPN-instance CE，CE4的VPN实例VPN1，通过g0/0/1连接PE4&lt;/li&gt;
&lt;li&gt;合理设置VPN1参数，使得Spoke站点互访的数据必须经过Hub-CE设备，当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由（PE3上VPN1的RD为100:13，ExportRT为100:1，ImportRT为200:1）&lt;/li&gt;
&lt;li&gt;如图4，CE1通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE1，CE1通过g0/0/1.2向PE1通告的BGP update中，某些路由的as path中有200。在CE1上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;如图4，CE2通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE2，CE2通过g0/0/1.2向PE2通告的BGP update中，某些路由的as path中有200。在CE2上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;CE3通过OSPF区域1接入PE3通过PE3-CE3的逻辑接口互通，通告CE3的各环回口；CE4通过OSPF区域0接入PE4，通过PE4-CE4的g0/0/1.1接口互通，通告CE4的各环回口&lt;/li&gt;
&lt;li&gt;如图4，在AS100、AS200内建立IBGP IPv4邻居关系，RR1是PE1、PE2、P1、ASBR1、ASBR2的反射器，RR2是PE3、PE4、P2、ASBR3、ASBR4的反射器。ASBR1-ASBR3、ASBR2-ASBR4建立EBGP IPv4邻居关系（已预配置）。&lt;/li&gt;
&lt;li&gt;在ASBR上，将ISIS的loopback0路由引入BGP。&lt;/li&gt;
&lt;li&gt;如图3，AS100、AS200内各网元配置MPLS LSR ID，全局使能MPLS，MPLS LDP（已预配置）。AS100、AS200内各直连链路建立LDP邻居。（除PE1-RR1之外的逻辑链路外，已预配置）&lt;/li&gt;
&lt;li&gt;如图4，各站点通过MPLS BGP VPN 跨域 Option C 方案一，能够相互学习路由。MPLS不能出现次优路径。&lt;/li&gt;
&lt;li&gt;在CE1、CE2上配置EBGP的协议优先级为120&lt;/li&gt;
&lt;li&gt;在CE1、CE2上面，将BGP导入OSPF。保证配置有最好的扩展性&lt;/li&gt;
&lt;li&gt;在PE3、PE4上修改BGP local preference属性。实现CE3、CE4访问直连的10.3.x.0/24网段时，若x为奇数，PE3、PE4优选下一跳为PE1，若x为偶数，PE3、PE4优选下一跳为PE2，不用考虑来回路径是否一致&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-feature&#34;&gt;4. Feature&lt;/h2&gt;
&lt;h3 id=&#34;41-ha&#34;&gt;4.1 HA&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1配置静态的默认路由访问ISP，下一跳IP为100.0.1.2.该默认路由要与CE1-ISP链路的BFD状态绑定（CE1的对端设备不支持BFD），感知故障的时间要小于150ms&lt;/li&gt;
&lt;li&gt;CE2配置静态的默认路由访问ISP，下一跳IP为200.0.2.2.该默认路由要与CE2-ISP链路的NQA ICMP测试绑定，间隔3S测试执行1次&lt;/li&gt;
&lt;li&gt;CE3、CE4能够通过默认路由访问ISP。CE1-ISP的链路断开时，CE1仍能访问ISP；CE2-ISP的链路断开时，CE2仍能访问ISP&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-nat&#34;&gt;4.2 NAT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/1访问ISP。在CE2上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/2访问ISP。Server1拥有单独的公网地址102.0.1.1，对ISP提供FTP和HTTP服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-qos&#34;&gt;4.3 Qos&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1的g2/0/1、CE2的g2/0/2的出方向，周一至周五的8:00-18:00，对TCP目的端口号为6881-6999的流量，承诺的平均速率为1Mbps&lt;/li&gt;
&lt;li&gt;CE4-PE4的Qos规则如下表所示：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1607328085867.png&#34; alt=&#34;Qos&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在CE4的g0/0/1出方向对流量进行802.1p标记。在PE4的g0/0/1的入方向，继承CE4的802.1p值&lt;/li&gt;
&lt;li&gt;PE4的g0/0/0和g0/0/2匹配DSCP值，根据表1，配置拥塞管理和拥塞避免&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-ipv6&#34;&gt;5. IPv6&lt;/h2&gt;
&lt;h3 id=&#34;51-基本配置&#34;&gt;5.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有相关设备接口的IPv6地址，按照图6配置（除PE1-RR1的逻辑接口外，已预配置）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-ipv6-isis&#34;&gt;5.2 IPv6 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图6，PE1、PE2、RR1、P1、ASBR1、ASBR2运行isis协议，各直连网段通告入isis，配置各链路cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
int ip 1
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 cost 20 
# PE2
int g0/0/0
    isis ipv6 cost 20
int g0/0/2
    isis ipv6 cost 1500
# RR1
int ip 1
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 cost 860
# P1
int g0/0/2
    isis ipv6 cost 1500
int g0/0/0
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 cost 1000
# ASBR1
int g0/0/1
    isis ipv6 cost 860
int g0/0/0
    isis ipv6 cost 100
# ASBR2
int g0/0/1
    isis ipv6 cost 1000
int g0/0/0
    isis ipv6 cost 100
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-ipv6-bgp&#34;&gt;5.3 IPv6 BGP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图7，ASBR1-ASBR3通过直连链路建立eBGP4+邻居，PE1、PE2、P1是RR1的BGP4+客户端（已预配置）&lt;/li&gt;
&lt;li&gt;在ASBR1将ISIS IPv6的路由导入BGP4+，只向ASBR3通告前缀为xxxxxxxxxx的路由，不能使用route-policy，将ASBR3的loopback0通告入BGP4+&lt;/li&gt;
&lt;li&gt;PE1、PE2学习到ASBR3 loopback0的BGP4+明细路由&lt;/li&gt;
&lt;li&gt;请在PE1使能某特性，以确保PE1在启动过程（从物理接口up，到协议xx建立）中，PE2-ASBR3的IPv6 ping不丢包&lt;/li&gt;
&lt;/ol&gt;
">HCIE 实验LABv1要求整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-labv2-yao-qiu-zheng-li/"" data-c="
          &lt;h2 id=&#34;1-l2vrrp&#34;&gt;1. L2+VRRP&lt;/h2&gt;
&lt;h3 id=&#34;11-链路聚合&#34;&gt;1.1 链路聚合&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;假设S1不支持LACP，S1和S2互联的接口需要合成一个二层逻辑接口，逻辑接口的成员链路根据源-目的MAC进行负载分担&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;12-link-type&#34;&gt;1.2 Link-type&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4互联接口的链路类型为trunk，允许除VLAN1外的所有vlan通过&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.1.254，为PC1的网关，CE1会周期性发送Sender IP为10.3.1.254，源MAC为00-00-5E-00-01-01的免费ARP。PC1与网关之间的数据包封装在VLAN10中&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.2.254，为PC2的网关，CE2会周期性发送Sender IP为10.3.2.254，源MAC为00-00-5E-00-01-02的免费ARP。PC2与网关之间的数据包封装在VLAN20中&lt;/li&gt;
&lt;li&gt;VRRP的master设备重启时，在g0/0/2变为up 1分钟后，才能重新成为master&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-mstp&#34;&gt;1.3 MSTP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4都运行MSTP。Vlan 10在instance 10，S1作为primary root，S2作为secondary root。Vlan 20在instance 20，S2作为primary root，S1作为secondary root。MSTP的region name是HUAWEI，Revision-level 12。&lt;/li&gt;
&lt;li&gt;除了交换机的互联端口，其他端口要确保不平参与MSTP计算，由disabled会直接转到Forwarding状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14-wan&#34;&gt;1.4 WAN&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PE1-RR1的互联Serial接口，绑定为一个逻辑接口，成员链路采用HDLC，逻辑接口的IPv4地址、IPv6地址请按照图1、图5配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#PE1
10.1.13.1 30
2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1300 127
# RR1
10.1.13.2 30
2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1301 127
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;PE3-CE3的互联POS接口，绑定为一个逻辑接口，成员链路采用PPP，逻辑接口的IPv4地址，请按照图1配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3
10.2.33.1 30
# CE3
10.2.33.2 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-ipv4-igp&#34;&gt;2. IPv4 IGP&lt;/h2&gt;
&lt;h3 id=&#34;21-基本配置&#34;&gt;2.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有设备的接口IPv4地址按照图1配置（除PE1-RR1的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;Route-id与loopback0的IPv4地址相同。MPLS域各设备的loopback0为172.16.0.0/16的32位主机地址（已预配置），未来扩容的MPLS域各设备的loopback0，从172.16.0.0/16去可用的主机地址，比如172.16.1.21/32可能分布在AS100，也可能分布在AS200。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-ospf&#34;&gt;2.2 OSPF&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1和CE2之间的链路，及该两台设备的loopback0通告入OSPF区域0（已预配置）&lt;/li&gt;
&lt;li&gt;CE1的g0/0/2.10和g0/0/2.20、CE2的g0/0/2.10和g0/0/2.20，直连网段通告入OSPF区域0，这些接口不能收发OSPF报文&lt;/li&gt;
&lt;li&gt;RR2、P2、PE3、PE4在OSPF区域0中，cost如图2配置（已预配置）&lt;/li&gt;
&lt;li&gt;PE3-PE4的OSPF链路类型为P2P&lt;/li&gt;
&lt;li&gt;PE4上将loopback0地址引入OSPF。AS200中，各OSPF网元到PE4 loopback0的路由，要累加内部cost&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;23-isis&#34;&gt;2.3 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;AS100内loopback0和互联网接口全部开启ISIS协议，其中PE1、PE2的路由类型为L1，区域号为49.0001，RR1、P1路由类型为L12，区域号为49.0001，ASBR1、ASBR2路由类型为L2，区域号为49.0002。各网元system-id唯一，cost-style为wide，cost值如图2配置（除PE1-RR1之外的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;AS200内，RR2、P2、ASBR3、ASBR4的loopback0和互联接口全部开启isis协议，IS类型为L2，区域号为49.0003。各网元system-id唯一，cost-style为wide，cost值如图2配置（已预配置）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
ip-trunk 1
isis cost 1500

# RR1
ip-trunk 1
isis cost 1500
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;RR2-P2的ISIS链路类型为P2P&lt;/li&gt;
&lt;li&gt;P1的ISIS进程，产生LSP的最大延迟时间是1S，初始延迟为50ms，递增时间为50ms。使能LSP的快速扩散特性。SPF计算间隔为1s，初始延迟为100ms，递增时间为100ms。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-mpls-vpn&#34;&gt;3. MPLS VPN&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CE1、CE2为VPN1的Hub-CE，PE1、PE2为Hub-CE，CE3、CE4为VPN1的spoke站点，PE3、PE4为SpokePE&lt;/li&gt;
&lt;li&gt;CE4位Multi-VPN-instance CE，CE4的VPN实例VPN1，通过g0/0/1连接PE4&lt;/li&gt;
&lt;li&gt;合理设置VPN1参数，使得Spoke站点互访的数据必须经过Hub-CE设备，当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由（PE3上VPN1的RD为100:13，ExportRT为100:1，ImportRT为200:1）&lt;/li&gt;
&lt;li&gt;如图4，CE1通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE1，CE1通过g0/0/1.2向PE1通告的BGP update中，某些路由的as path中有200。在CE1上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;如图4，CE2通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE2，CE2通过g0/0/1.2向PE2通告的BGP update中，某些路由的as path中有200。在CE2上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;CE3通过OSPF区域1接入PE3通过PE3-CE3的逻辑接口互通，通告CE3的各环回口；CE4通过OSPF区域0接入PE4，通过PE4-CE4的g0/0/1.1接口互通，通告CE4的各环回口&lt;/li&gt;
&lt;li&gt;如图3，AS100、AS200内各网元配置MPLS LSR ID，全局使能MPLS，MPLS LDP（已预配置）。AS100、AS200内各直连链路建立LDP邻居。（除PE1-RR1之外的逻辑链路外，已预配置）&lt;/li&gt;
&lt;li&gt;ASBR1-ASBR3，ASBR2-ASBR4之间通过直连接口建立BGP邻居关系。在ASBR上，将ISIS的loopback0路由引入BGP。假设AS100和AS200中的loopback0地址为172.16.1.Y/32。当Y为奇数时，对端设备访问本AS设备的loopback0，优选ASBR1-ASBR3；当Y为偶数时，对端设备访问本AS设备的loopback0，优选ASBR2-ASBR4.保证配有有最好的扩展性&lt;/li&gt;
&lt;li&gt;在RR2、P2上，ISIS和OSPF双向引入前缀为172.16.0.0/16的主机路由。被引入的协议的cost要继承到引入后的协议中，P2和PE4的loopback0互访走最优路径。配置要求有最好的扩展性&lt;/li&gt;
&lt;li&gt;如图4，各站点通过MPLS BGP VPN 跨域 Option C 方案二，能够相互学习路由。PE1-RR1、PE2-RR1、PE3-RR2、PE4-RR2之间建立MP-IBGP连接的源接口为loopback0。RR1-RR2之间建立MP-EBGP邻居的源接口为loopback0。&lt;/li&gt;
&lt;li&gt;在CE1、CE2上配置EBGP的协议优先级为120&lt;/li&gt;
&lt;li&gt;在CE1、CE2上面，将BGP导入OSPF。保证配置有最好的扩展性&lt;/li&gt;
&lt;li&gt;在PE3、PE4上修改BGP local preference属性。实现CE3、CE4访问直连的10.3.x.0/24网段时，若x为奇数，PE3、PE4优选下一跳为PE1，若x为偶数，PE3、PE4优选下一跳为PE2，不用考虑来回路径是否一致&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-feature&#34;&gt;4. Feature&lt;/h2&gt;
&lt;h3 id=&#34;41-ha&#34;&gt;4.1 HA&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1配置静态的默认路由访问ISP，下一跳IP为100.0.1.2.该默认路由要与CE1-ISP链路的BFD状态绑定（CE1的对端设备不支持BFD），感知故障的时间要小于150ms&lt;/li&gt;
&lt;li&gt;CE2配置静态的默认路由访问ISP，下一跳IP为200.0.2.2.该默认路由要与CE2-ISP链路的NQA ICMP测试绑定，间隔5S测试执行1次&lt;/li&gt;
&lt;li&gt;CE3、CE4能够通过默认路由访问ISP。CE1-ISP的链路断开时，CE1仍能访问ISP；CE2-ISP的链路断开时，CE2仍能访问ISP&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-nat&#34;&gt;4.2 NAT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/1访问ISP。在CE2上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/2访问ISP。Server1拥有单独的公网地址102.0.1.1，对ISP提供FTP和HTTP服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-qos&#34;&gt;4.3 Qos&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1的g2/0/1、CE2的g2/0/2的出方向，周一至周五的8:00-18:00，对TCP目的端口号为6881-6999的流量，承诺的平均速率为1Mbps&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-ipv6&#34;&gt;5. IPv6&lt;/h2&gt;
&lt;h3 id=&#34;51-基本配置&#34;&gt;5.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有相关设备接口的IPv6地址，按照图6配置（除PE1-RR1的逻辑接口外，已预配置）&lt;code&gt;在WAN那道题中已经配置&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-ipv6-isis&#34;&gt;5.2 IPv6 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图6，PE1、PE2、RR1、P1、ASBR1、ASBR2运行isis协议，各直连网段通告入isis，配置各链路cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
int ip 1
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 cost 20 
# PE2
int g0/0/0
    isis ipv6 cost 20
int g0/0/2
    isis ipv6 cost 1500
# RR1
int ip 1
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 cost 860
# P1
int g0/0/2
    isis ipv6 cost 1500
int g0/0/0
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 cost 1000
# ASBR1
int g0/0/1
    isis ipv6 cost 860
int g0/0/0
    isis ipv6 cost 100
# ASBR2
int g0/0/1
    isis ipv6 cost 1000
int g0/0/0
    isis ipv6 cost 100
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-ipv6-multicast&#34;&gt;5.3 IPv6 Multicast&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图7，AS100中，相邻设备建立PIM IPv6 SM的邻居关系。PE1的E0/0/0静态加入组FF1E::AA&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
int E0/0/0   
	ipv6 addr 3000:E85A:8CA2:BF40:C45A:89EE:CBDF:ADD1/112
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ASBR1的loopback0、ASBR2的loopback0为C-BSR且都为FF1E::/112的C-RP。ASBR1的loopback0成为BSR，ASBR2的loopback0成为FF1E::/112的RP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ASBR1 
2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5
# ASBR2
2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;无论哪个C-RP成为RP，都要确保PIM IPv6域生成（*，G）表项无次优路径&lt;/li&gt;
&lt;/ol&gt;
">HCIE 实验Labv2要求整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-labv2-bu-zou-jian-hua/"" data-c="
          &lt;h1 id=&#34;labv2&#34;&gt;LabV2&lt;/h1&gt;
&lt;h2 id=&#34;1-l2vrrp&#34;&gt;1. L2+VRRP&lt;/h2&gt;
&lt;h3 id=&#34;11-链路聚合&#34;&gt;1.1 链路聚合&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;假设S1不支持LACP，S1和S2互联的接口需要合成一个二层逻辑接口，逻辑接口的成员链路根据源-目的MAC进行负载分担&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1/SW2
int eth-trunk 12
    load-balance src-dst-mac
    trunkport g0/0/23 0/0/24
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-link-type&#34;&gt;1.2 Link-type&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4互联接口的链路类型为trunk，允许除VLAN1外的所有vlan通过&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1/SW:SW3/SW4
port-group group-member g0/0/1 g0/0/12 eth 12:g0/0/1 g0/0/2
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.1.254，为PC1的网关，CE1会周期性发送Sender IP为10.3.1.254，源MAC为00-00-5E-00-01-01的免费ARP。PC1与网关之间的数据包封装在VLAN10中&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.2.254，为PC2的网关，CE2会周期性发送Sender IP为10.3.2.254，源MAC为00-00-5E-00-01-02的免费ARP。PC2与网关之间的数据包封装在VLAN20中&lt;/li&gt;
&lt;li&gt;VRRP的master设备重启时，在g0/0/2变为up 1分钟后，才能重新成为master&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1
int g0/0/2.10
    vrrp vrid 1 virtual-ip 10.3.1.254
    vrrp vrid 1 priority 120
    vrrp vrid 1 preempt-mode timer delay 60
    arp broadcast enable
int g0/0/2.20
    vrrp vrid 2 virtual-ip 10.3.2.254
    arp broadcast enable
# CE2
int g0/0/2.10
    vrrp vrid 1 virtual-ip 10.3.1.254
    arp broadcast enable
int g0/0/2.20
    vrrp vrid 2 virtual-ip 10.3.2.254
    vrrp vrid 2 priority 120
    vrrp vrid 2 preempt-mode timer delay 60
    arp broadcast enable
# SW1/SW2 : 放行除vlan1所有vlan
vlan batch 10 20
int g0/0/2
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1
# SW3:SW4
vlan batch 10 20
int e0/0/1  
    port link access
    port default vlan 10:20  
# 测试------------------
# CE1/2
dis vrrp bri
# PC1/2
ping 10.3.2.254
ping 10.3.1.254
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-mstp&#34;&gt;1.3 MSTP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4都运行MSTP。Vlan 10在instance 10，S1作为primary root，S2作为secondary root。Vlan 20在instance 20，S2作为primary root，S1作为secondary root。MSTP的region name是HUAWEI，Revision-level 12。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1/SW2/SW3/SW4
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
# SW1
stp instance 10 root primary
stp instance 20 secondary primary
# SW2
stp instance 10 root secondary 
stp instance 20 root primary
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;除了交换机的互联端口，其他端口要确保不参与MSTP计算，由disabled会直接转到Forwarding状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1/SW2:SW3/SW4
stp edged-port default
port-group group-member eth 12 g0/0/1 g0/0/12:g0/0/1 g0/0/2
    stp edged-port disable
# 检查
# SW1/2/3/4
dis stp bri 
# sw1端口均是forwarding，eth12为vlan20的root
# sw2端口均是forwarding，eth12为vlan10的root
# sw3端口g0/0/1是vlan10的root，g0/0/2是vlan20的root
# sw4端口g0/0/1是vlan20的root，g0/0/2是vlan10的root
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-wan&#34;&gt;1.4 WAN&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PE1-RR1的互联Serial接口，绑定为一个逻辑接口，成员链路采用HDLC，逻辑接口的IPv4地址、IPv6地址请按照图1、图5配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#PE1/RR1
ipv6 
int ip-trunk 1
    ipv6 enable 
    ip addr 10.1.13.1/2 30
    ipv6 addr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1300/1 127
int s0/0/1
    link-protocol hdlc
    ip-trunk 1
int s0/0/2
    link-protocol hdlc
    ip-trunk 1
# 测试-----------------------
# RR1
ping 10.1.13.1
ping ipv6 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1300
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;PE3-CE3的互联POS接口，绑定为一个逻辑接口，成员链路采用PPP，逻辑接口的IPv4地址，请按照图1配置&lt;code&gt;注意PE3的mp接口需要先绑定VPN1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3/CE3
int mp-group 0/0/1
    dis cu conf vpn
    ip binding vpn-instance VPN1 # CE3不需要配置
    ip add 10.2.33.1/2 30
    q
int p4/0/0
    ppp mp mp-group 0/0/1
int p6/0/0
    ppp mp mp-group 0/0/1
# 测试
# CE3
ping 10.2.33.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-ipv4-igp&#34;&gt;2. IPv4 IGP&lt;/h2&gt;
&lt;h3 id=&#34;21-基本配置&#34;&gt;2.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有设备的接口IPv4地址按照图1配置（除PE1-RR1的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;Route-id与loopback0的IPv4地址相同。MPLS域各设备的loopback0为172.16.0.0/16的32位主机地址（已预配置），未来扩容的MPLS域各设备的loopback0，从172.16.0.0/16去可用的主机地址，比如172.16.1.21/32可能分布在AS100，也可能分布在AS200。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1/CE2/CE3/CE4
router id 172.17.1.1/2/3/4
# PE1/PE2/RR1/P1/ASBR1/ASBR2/ASBR3/ASBR4/RR2/P2/PE3/PE4
router id 172.16.1.1/20/3/4/5/6/7/8/9/10/11/2 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-ospf&#34;&gt;2.2 OSPF&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1和CE2之间的链路，及该两台设备的loopback0通告入OSPF区域0（已预配置）&lt;/li&gt;
&lt;li&gt;CE1的g0/0/2.10和g0/0/2.20、CE2的g0/0/2.10和g0/0/2.20，直连网段通告入OSPF区域0，这些接口不能收发OSPF报文&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1/CE2
int g0/0/2.10
    ospf enable 1 a 0
int g0/0/2.20
    ospf enable 1 a 0
ospf 1 router-id 172.17.1.1/2
    a 0
        network 172.17.1.1/2 0.0.0.0
        network 10.2.12.1/2 0.0.0.0
        network 10.3.1.1/2 0.0.0.0
        network 10.3.2.1/2 0.0.0.0
        q
    silent-int g0/0/2.10
    silent-int g0/0/2.20
# 检查-------------------
# CE1/2
dis ospf peer bri
dis ospf int 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;RR2、P2、PE3、PE4在OSPF区域0中，cost如图2配置（已预配置）&lt;code&gt;PE4不能宣告lo0，原因为次优路径，涉及考点5&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RR2/P2/PE3/PE4
ospf 1 router-id  172.16.1.9/10/11/12
    a 0
        network 172.16.1.9/10/11 0.0.0.0   # PE4不能宣告lo0
        network 10.1.91/112.1/2 0.0.0.0
        network 10.1.119/102.1/2 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;PE3-PE4的OSPF链路类型为P2P&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3/PE4
int g0/0/0
    ospf network-type p2p
# 检查-----------------
# 所有设备
dis ospf int 
dis ospf peer bri
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;PE4上将loopback0地址引入OSPF。AS200中，各OSPF网元到PE4 loopback0的路由，要累加内部cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE4
ip ip-prefix L0 permit 172.16.1.2 32
route-policy L0 permit node 10
    if-match ip-prefix L0
    apply tag 2
ospf 1
    import-route direct type 1 route-policy L0   
# 检查-----------------
# P2
dis ip rou 172.16.1.2 verbose  # 172.16.1.2的cost变为1501，tag为2
# RR2
dis ip rou 172.16.1.2 verbose  # 172.16.1.2的cost变为1511，tag为2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-isis&#34;&gt;2.3 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;AS100内loopback0和互联网接口全部开启ISIS协议，其中PE1、PE2的路由类型为L1，区域号为49.0001，RR1、P1路由类型为L12，区域号为49.0001，ASBR1、ASBR2路由类型为L2，区域号为49.0002。各网元system-id唯一，cost-style为wide，cost值如图2配置（除PE1-RR1之外的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;AS200内，RR2、P2、ASBR3、ASBR4的loopback0和互联接口全部开启isis协议，IS类型为L2，区域号为49.0003。各网元system-id唯一，cost-style为wide，cost值如图2配置（已预配置）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1/PE2/RR1/P1/ASBR1/ASBR2/ASBR3/ASBR4/RR2/P2
int loo 0
    isis  enable 
int ip 1:g0/0/0:g0/0/1:g0/0/2
    isis  enable 
    isis cost xxxx
# 检查-----------------
dis isis int
dis isis peer
# RR1
dis ip rou pro isis # 有1/20/4/5/6的路由
# ASBR3
dis ip rou pro isis # 有8/9/10的路由
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;RR2-P2的ISIS链路类型为P2P&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RR2/P2
int g0/0/0
    isis circuit-type p2p
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;P1的ISIS进程，产生LSP的最大延迟时间是1S，初始延迟为50ms，递增时间为50ms。使能LSP的快速扩散特性。SPF计算间隔为1s，初始延迟为100ms，递增时间为100ms。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# P1
isis 1
    timer lsp-generation 1 50 50
    flash-flood
    timer spf 1 100 100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-mpls-vpn&#34;&gt;3. MPLS VPN&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CE1、CE2为VPN1的Hub-CE，PE1、PE2为Hub-CE，CE3、CE4为VPN1的spoke站点，PE3、PE4为SpokePE&lt;/li&gt;
&lt;li&gt;CE4位Multi-VPN-instance CE，CE4的VPN实例VPN1，通过g0/0/1连接PE4&lt;code&gt;CE4的OSPF需要做vrf-lite&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE4
ospf 1 router-id  172.17.1.4 vpn-instance VPN1
	vpn-instance-capability simple
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;合理设置VPN1参数，使得Spoke站点互访的数据必须经过Hub-CE设备，当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由（PE3上VPN1的RD为100:13，ExportRT为100:1，ImportRT为200:1）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#PE1/PE2
ip vpn-instance HUB
	# 如果没有配置RD，则需要自行配置：
	# route-distinguisher 100:134/234
    vpn-target 200:1 export
ip vpn-instance VPN1
	# 如果没有配置RD，则需要自行配置：
	route-distinguisher 100:11/12
    vpn-target 100:1 200:1 import
# PE3/PE4
ip vpn-instance VPN1
	# 如果没有配置RD，则需要自行配置：
	# route-distinguisher 100:13/14
    vpn-target 100:1 export
    vpn-target 200:1 import
# CE4的RD值和PE4相同
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如图4，CE1通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE1，CE1通过g0/0/1.2向PE1通告的BGP update中，某些路由的as path中有200。在CE1上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;如图4，CE2通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE2，CE2通过g0/0/1.2向PE2通告的BGP update中，某些路由的as path中有200。在CE2上，将OSPF路由导入BGP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#CE1/CE2
bgp  65000
    router-id 172.17.1.1/2
    peer 10.2.11/22.2 as 100
    peer 10.2.11/22.6 as 100
    import ospf 1
#PE1/PE2
bgp 100
    router-id 172.16.1.1/20
    ipv4-family vpn-instance VPN1
        peer 10.2.11/22.1 as 65000
    ipv4-family vpn-instance HUB
        peer 10.2.11/22.5 as 65000
        peer 10.2.11/22.5 allow-as-loop
# 检查-----------------
# 所有设备
dis bgp vpnv4 all peer
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;CE3通过OSPF区域1接入PE3通过PE3-CE3的逻辑接口互通，通告CE3的各环回口；CE4通过OSPF区域0接入PE4，通过PE4-CE4的g0/0/1.1接口互通，通告CE4的各环回口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3
ospf 2 vpn-instance VPN1
    a 1
        network 10.2.33.1 0.0.0.0
# CE3
ospf 1 router-id 172.17.1.3 #不需要绑定VPN
    area 1
        net 10.2.33.2 0.0.0.0
        net 172.17.1.3 0.0.0.0
        net 10.3.3.3 0.0.0.0
# PE4
ospf 2 vpn-instance VPN1
    a 0
        net 10.2.44.1 0.0.0.0
# CE4
ospf 1 vpn-instance VPN1
    area 0
        net 10.2.44.2 0.0.0.0
        net 172.17.1.4 0.0.0.0
        net 10.4.4.4 0.0.0.0
# 检查-----------------
# 所有设备
dis ospf peer bri
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;如图3，AS100、AS200内各网元配置MPLS LSR ID，全局使能MPLS，MPLS LDP（已预配置）。AS100、AS200内各直连链路建立LDP邻居。（除PE1-RR1之外的逻辑链路外，已预配置）&lt;br&gt;
如图4，在AS100、AS200内建立IBGP IPv4邻居关系，RR1是PE1、PE2、P1、ASBR1、ASBR2的反射器，RR2是PE3、PE4、P2、ASBR3、ASBR4的反射器。ASBR1-ASBR3、ASBR2-ASBR4建立EBGP IPv4邻居关系（已预配置）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# MPLS--------------------
# AS100和AS200内所有设备
mpls lsr-id 172.16.1.1/20/3/4/5/6/7/8/9/10/11/2
mpls
mpls ldp
int ip 1:g0/0/0:g0/0/1:g0/0/2  # AS之间的接口只开启mpls
    mpls 
    mpls ldp
# 检查------
dis mpls int
dis mpls ldp int
dis mpls ldp peer

# BGP------------------------
# ---------IBGP
# PE1/PE2/P1/ASBR1/ASBR2：ASBR3/ASBR4/P2/PE3/PE4
bgp 100：200  # 只需要配置RR更新源
    router-id 172.16.1.1/20/4/5/6：7/8/10/11/2
    peer 172.16.1.3:9 as 100：200
    peer 172.16.1.3：9 connect lo 0
# RR1：RR2
bgp 100  # 需要更新源+反射
    router-id 172.16.1.3：9
    peer 172.16.1.1/20/4/5/6：7/8/10/11/12 as 100：200 # 配置邻居
    peer 172.16.1.1/20/4/5/6：7/8/10/11/12 co lo 0 # 配置更新源
    peer 172.16.1.1/20/4/5/6：7/8/10/11/12 re # 配置反射器

# ASBR1/ASBR2：ASBR3/ASBR4
bgp 100:200 # ASBR针对RR的下一跳自我
	peer 172.16.1.3：9 next-hop-local

# ----------EBGP
# ASBR1/ASBR2/ASBR3/ASBR4
bgp 100/200  # 只需要指定AS号
    peer 10.1.57/68.2/1  as 200/100
    
# RR1/2
bgp 100/200 
	# 更新源 + ebgp多跳 
	# 关闭ipv4中的邻居 + vpnv4中undo policy、下一跳不变
    peer 172.16.1.9/3 as 200/100
    peer 172.16.1.9/3 co lo 0
    peer 172.16.1.9/3 ebgp-max-hop # 配置EBGP多跳
    ipv4-family unicast
        undo peer 172.16.1.9/3 enable  # 关闭RR之间的ipv4邻居
    ipv4-family vpnv4
        undo policy vpn-target # 这个必须undo掉
        peer 172.16.1.9/3 enable # RR之间
        peer 172.16.1.9/3 next-hop-invariable
        
# ----------RR2:允许4、5要求中的路由回去
bgp 100/200
    ipv4-family vpnv4
        peer 172.16.1.3 allow-as-loop  # 允许路由回去  

# 检查-----------------
# RR1/2:ASBR1/2/3/4
dis bgp peer  # 5个邻居建立
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;ASBR1-ASBR3，ASBR2-ASBR4之间通过直连接口建立BGP邻居关系。在ASBR上，将ISIS的loopback0路由引入BGP。假设AS100和AS200中的loopback0地址为172.16.1.Y/32。当Y为奇数时，对端设备访问本AS设备的loopback0，优选ASBR1-ASBR3；当Y为偶数时，对端设备访问本AS设备的loopback0，优选ASBR2-ASBR4.保证配有有最好的扩展性&lt;code&gt;做本题之前先做第9题&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ASBR1/ASBR2/ASBR3/ASBR4
acl 2000 
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
# ASBR1/ASBR3
route-policy AB permit node 10
    if-match acl 2000
    apply cost 200
route-policy AB permit node 20
    if-match acl 2001
    apply cost 100
bgp 100/200
    import-route isis 1 route-policy AB
# ASBR2/ASBR4
route-policy AB permit node 10
    if-match acl 2000
    apply cost 100
route-policy AB permit node 20
    if-match acl 2001
    apply cost 200
bgp 100/200
    import-route isis 1 route-policy AB
# 检查-----------------
# 4台ASBR
dis bgp rou # 奇数路由走1/3，反之亦然。例如ASBR1上172.16.1.1的下一跳0.0.0.0（默认为ASBR3）,172.16.1.2的下一跳就是172.16.1.6
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;在RR2、P2上，ISIS和OSPF双向引入前缀为172.16.0.0/16的主机路由。被引入的协议的cost要继承到引入后的协议中，P2和PE4的loopback0互访走最优路径。配置要求有最好的扩展性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RR2/P2
ip ip-prefix 172 permit 172.16.0.0 16 greater-equal 32
# RR2
route-policy O2I deny node 10
    if-match tag 100
route-policy O2I permit node 20
    if-match ip-prefix 172
    apply tag 200
route-policy I2O deny node 10
    if-match tag 101
route-policy I2O permit node 20
    if-match ip-prefix 172
    apply cost-type type-1
    apply tag 201
route-policy OASE permit node 10
    if-match tag 2
    apply preference 14
# P2
route-policy O2I deny node 10
    if-match tag 201
route-policy O2I permit node 20
    if-match ip-prefix 172
    apply tag 101
route-policy I2O deny node 10
    if-match tag 200
route-policy I2O permit node 20
    if-match ip-prefix 172
    apply cost-type type-1
    apply tag 100
route-policy OASE permit node 10
    if-match tag 2
    apply preference 14  
# RR2/P2
ospf 1
	default cost inherit-metric
    import-route isis 1 type 1 route-policy I2O 
    preference ase route-policy OASE
isis 1
    import-route ospf 1 inherit-cost route-policy O2I
# 检查-----------------
# RR2/P2
dis route-policy  # 此时匹配的路由条数不应该有0
# P2
dis ip rou # 到达PE4(172.16.1.2)的路由应该为O_ASE，接口为g0/0/2，即OSPF的外部路由而不是ISIS的路由
# PE4
dis ip rou pro ospf # 到达P2(172.16.1.10)为g0/0/2接口
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;如图4，各站点通过MPLS BGP VPN 跨域 Option C 方案二，能够相互学习路由。PE1-RR1、PE2-RR1、PE3-RR2、PE4-RR2之间建立MP-IBGP连接的源接口为loopback0。RR1-RR2之间建立MP-EBGP邻居的源接口为loopback0。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# --------路由处理
# RR1/P1：isis的路由泄露
ip ip-prefix 172 permit 172.16.0.0 16 gr 32
isis 1
    import isis level-2 into level-1 filter-policy ip-prefix 172
# PE3/PE4：vpn路由的相互引入
bgp 200
    ipv4-family vpn-instance VPN1
        import ospf 2
ospf 2
    import bgp type 1

# ASBR1/2/3/4：将bgp路由导入IGP同时优选IGP，修改bgp优先级
ip ip-prefix 172 permit 172.16.0.0 16 great 32 
route-policy 172 permit node 10
    if-match ip-prefix 172
    apply tag 1234
route-policy AB deny node 5  # 重要
    if-match tag 1234
isis
    import-route bgp inherit-cost route-policy 172
bgp 100/200
	preference 12 255 255

# -------vpnv4邻居
# PE1/2/3/4 
bgp 100  #  PE上只需要en
    ipv4-family vpnv4
        peer 172.16.1.3/9 enable
        
# RR1：RR2 
bgp 100/200  # RR上需要en + re + ne
    ipv4-family vpnv4
        peer 172.16.1.1/20:11/2 enable # RR和PE之间
        peer 172.16.1.1/20:11/2 re
        peer 172.16.1.1/20:11/2 next-hop-invariable 

# -----------标签能力（只在ASBR之间）
# ASBR1/2/3/4
mpls
    lsp-trigger bgp-label-route ip-prefix 172
route-policy MPLS permit no 10
    apply mpls-label 
bgp 100/200  # ASBR之间
    peer 10.1.57/68.2/1 route-policy MPLS export
    peer 10.1.57/68.2/1 label-route-capability
            
# 检查-----------------
# RR1/P1
dis ip rou pro isis  # 是否学习到isis level2的路由，主要是192.168.1.11/2
# RR1/2
dis bgp vpnv4 all peer #各有3个邻居
dis bgp peer # 查看两个RR之间的邻居
# RR2/PE3/PE4:RR1/PE1/PE2
dis bgp vpnv4 all rou  # 是否学到CE1/2/3/4上的路由10.3.1.0、10.3.2.0、10.3.3.3、10.4.4.4

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;在CE1、CE2上配置EBGP的协议优先级为120&lt;/li&gt;
&lt;li&gt;在CE1、CE2上面，将BGP导入OSPF。保证配置有最好的扩展性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1/2：修改eBGP的优先级
bgp 65000
    preference 120 255 255
ospf 1
    import bgp type 1  # 引入之前先做PE1/2上面的soo
# PE1/PE2：为了防环，需要配置soo属性
bgp 100
    ipv4-family vpn-instance HUB
        peer 10.2.11/22.5 soo 100:12
    ipv4-family vpn-instance VPN1
        peer 10.2.11/22.1 soo 100:12
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;在PE3、PE4上修改BGP local preference属性。实现CE3、CE4访问直连的10.3.x.0/24网段时，若x为奇数，PE3、PE4优选下一跳为PE1，若x为偶数，PE3、PE4优选下一跳为PE2，不用考虑来回路径是否一致&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3/4
acl 2000
    rule permit source 10.3.0.0 0.0.254.0
acl 2001
    rule permit source 10.3.1.0 0.0.254.0
ip ip-prefix NH-PE1 permit 172.16.1.1 32
ip ip-prefix NH-PE2 permit 172.16.1.20 32
route-policy AB permit node 10
    if-match acl 2000
    if-match ip next-hop ip-prefix NH-PE2
    apply local-preference 200   # 本地优先级越大越优，cost越小越优
route-policy AB permit node 20
    if-match acl 2001
    if-match ip next-hop ip-prefix NH-PE1
    apply local-preference 200
route-policy AB permit node 30  # 放行其他路由
bgp 200
    ipv4-family vpnv4
    peer 172.16.1.9 route-policy AB import  # 从反射器来的路由应用上面的条件
    
# 检查-----------------
# PE3/4
dis bgp vpnv4 all rou #10.3.1.0下一跳为172.16.1.1，本地优先级为200；10.3.2.0下一条为172.16.1.20，本地优先级为200

# 整个大题最后的测试
# CE3/4
tracert -a 10.3.3.3 10.4.4.4 # CE4：9hop
tracert -a 10.3.3.3 10.3.1.10 # PC1：8hop
tracert -a 10.3.3.3 10.3.2.20 # PC2：8hop

# CE4
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.3.3  # CE3：9hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.1.10 # PC1：8hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.2.20 # PC2：8hop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-feature&#34;&gt;4. Feature&lt;/h2&gt;
&lt;h3 id=&#34;41-ha&#34;&gt;4.1 HA&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1配置静态的默认路由访问ISP，下一跳IP为100.0.1.2.该默认路由要与CE1-ISP链路的BFD状态绑定（CE1的对端设备不支持BFD），感知故障的时间要小于150ms&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1
bfd # 开启全局bfd
bfd huawei bind peer-ip 100.0.1.2 int g2/0/1 one-arm-echo 
    discriminator local 1  # 配置本地设备标示为1
    min-echo-rx-interval 40 # 40的3倍小于150
    commit
    q
ip route-static 0.0.0.0 0.0.0.0 100.0.1.2 track bfd-session huawei

# 检测---------
dis bfd session all
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CE2配置静态的默认路由访问ISP，下一跳IP为200.0.2.2.该默认路由要与CE2-ISP链路的NQA ICMP测试绑定，间隔5S测试执行1次&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE2
nqa test-instance huawei huawei
    test-type icmp
    destination-address ipv4 200.0.2.2
    frequency 5
    start now
ip route-static 0.0.0.0 0.0.0.0 200.0.2.2 track nqa huawei huawei

# 检测---------
dis nqa history
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;CE3、CE4能够通过默认路由访问ISP。CE1-ISP的链路断开时，CE1仍能访问ISP；CE2-ISP的链路断开时，CE2仍能访问ISP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1:CE2
ospf 1
    default-route-advertise
bgp 65000
    network 0.0.0.0
int g0/0/2.10:20
	# 分别在自己的master VRRP上针对去往ISP和对方的链路开启track
    vrrp vrid 1:2 track int g0/0/0 reduced 15
    vrrp vrid 1:2 track int g2/0/1:2 reduced 15
    
# PE3/PE4
ospf 2
    default-route-advertise
    
# 检测--------
# CE3
dis ip rou   # 查看是否有默认路由
# CE4
dis ip rou vpn-instance VPN1 # 查看是否有默认路由
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-nat&#34;&gt;4.2 NAT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/1访问ISP。   在CE2上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/2访问ISP。 Server1拥有单独的公网地址102.0.1.1，对ISP提供FTP和HTTP服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#  CE1/CE2
acl 2000
    rule deny source 10.3.2.10 0
    rule permit source 10.3.0.0 0.0.255.255
nat address-group 1 102.0.1.2 102.0.1.6
int g2/0/1:2
    nat outbound 2000 address-group 1
    nat server protocol tcp global 102.0.1.1 www inside 10.3.2.10 www
    nat server protocol tcp global 102.0.1.1 ftp inside 10.3.2.10 ftp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;43-qos&#34;&gt;4.3 Qos&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1的g2/0/1、CE2的g2/0/2的出方向，周一至周五的8:00-18:00，对TCP目的端口号为6881-6999的流量，承诺的平均速率为1Mbps&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1/CE2
time-range WORKING 8:00 to 18:00 working-day
acl 3000
    rule permit tcp desination-port range 6881 6999 timer-range WORKING
traffic classifiter HUAWEI
    if-match acl 3000
traffic behavior HUAWEI
    car cir 1000
traffic policy HUAWEI
    classifier HUAWEI behavior HUAWEI
interface g2/0/1:2
    traffic-policy HUAWEI outbound

# 检查-----
dis traffic policy user-defied
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-ipv6&#34;&gt;5. IPv6&lt;/h2&gt;
&lt;h3 id=&#34;51-基本配置&#34;&gt;5.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有相关设备接口的IPv6地址，按照图6配置（除PE1-RR1的逻辑接口外，已预配置）&lt;code&gt;在WAN那道题中已经配置&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-ipv6-isis&#34;&gt;5.2 IPv6 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图6，PE1、PE2、RR1、P1、ASBR1、ASBR2运行isis协议，各直连网段通告入isis，配置各链路cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1/PE2/RR1/P1/ASBR1/ASBR2
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int ip 1:g0/0/0:g0/0/2
    isis ipv6 enable 
    isis ipv6 cost xx
# RR1/P1：ISIS路由渗透
ip ip-prefix 66 permit 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA0 128 gr 128
isis 1
    ipv6 import-route isis level-2 into level-1 filter-policy ipv6-prefix 66

# 检查---------
dis ipv6 rou pro isis # 可以查看到AS100内所有其他设备环回口路由，建议在PE2上查看
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-ipv6-multicast&#34;&gt;5.3 IPv6 Multicast&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图7，AS100中，相邻设备建立PIM IPv6 SM的邻居关系。PE1的E0/0/0静态加入组FF1E::AA&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1/PE2/RR1/P1/ASBR1/ASBR2
multicast ipv6 routing-enabel
int loo 0
    pim ipv6 sm
int ip 1:g0/0/1:g0/0/2:g0/0/3
	ipv6 enable
    pim ipv6 sm
# PE1
int E0/0/0   
	ipv6 enable
	ipv6 addr 3000:E85A:8CA2:BF40:C45A:89EE:CBDF:ADD1/112
    isis ipv6 enable
    pim ipv6 sm  # 先开启
    pim ipv6 silent  # 保障安全
    mld enable   # 后开启
    mld static-group FF1E::AA  # 静态加组
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ASBR1的loopback0、ASBR2的loopback0为C-BSR且都为FF1E::/112的C-RP。ASBR1的loopback0成为BSR，ASBR2的loopback0成为FF1E::/112的RP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ASBR1/ASBR2
acl ipv6 2000
    rule permit source FF1E::AA/112  # 定义RP的服务组范围
acl ipv6 3000
    rule permit ipv6 source 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5/128 destination FF1E::AA/112
    rule permit ipv6 source 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6/128 destination FF1E::AA/112
# ASBR1/ASBR2 :bsr优先级是越大越优  rp优先级是越小越优
pim-ipv6
    c-bsr priority 200/100
    c-bsr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5/6
    c-rp 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5/6 group-po 2000 pri 200/100
    crp-policy 3000
    
# 检查--------------
# PE1
dis pim ipv6 bsr-info  # BSR地址为xxxxxxDCA5，优先级为200，C-RP数量2个
dis pim ipv6 rp-info  # RP地址为xxxxxxDCA5，优先级为200；下一个RP地址为xxxxxxDCA6，优先级为100
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;无论哪个C-RP成为RP，都要确保PIM IPv6域生成（*，G）表项无次优路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
pim-ipv6
    spt-switch-threshold infinity
#ASBR1/2
dis pim ipv6 rou  # 只有（*，FF1E::AA）
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验LABv2步骤简化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-tac-zong-jie/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1608428682287.png&#34; alt=&#34;考点拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;题目一&#34;&gt;题目一&lt;/h1&gt;
&lt;h2 id=&#34;要求&#34;&gt;要求&lt;/h2&gt;
&lt;p&gt;AR29的loopback0口无法访问AR28的loopback0口&lt;br&gt;
&lt;code&gt;直连不通，广播域的问题&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
LSW6上连接AR29与AR28的接口VLAN划分错误，导致AR29与AR28用于建立OSPF邻居关系的接口不在同一个广播域中。
二、故障分析
2.1 故障重现
2.2 检查路由表
2.3 检查OSPF邻居情况
2.4 检查AR27的邻居和路由
2.5 对比检查AR27/AR29的OSPF配置
2.6 检查邻居建立过程的错误报文
2.7 测试三层地址连通性
2.8 检查ARP映射表
2.9 检查互联接口状态
三、故障处理
3.1 LSW6上vlan划分错误的故障处理，需在LSW6上执行以下命令：
3.2 如果执行以上命令未解决故障，则有可能存在以下几种高可能性故障：
3.2.1 LSW6上配置了MuxVlan
3.2.2 LSW6和AR28上配置了过滤策略
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目二&#34;&gt;题目二&lt;/h1&gt;
&lt;h2 id=&#34;要求-2&#34;&gt;要求&lt;/h2&gt;
&lt;p&gt;AR29的loopback0口无法访问AR33的loopback0口&lt;br&gt;
&lt;code&gt;直连能通，OSPF配置问题&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;解答1&#34;&gt;解答1&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
1. AR29与AR33的OSPF区域类型不匹配，AR29配置为普通区域类型，而AR33配置为NSSA类型；
2. AR29和AR33的Hello间隔不一致，AR29配置为10秒，AR33配置为15秒。
二、故障分析
2.1 故障重现
2.2 检查路由表
2.3 检查OSPF邻居情况
2.4 检查接口宣告情况
2.5 测试三层地址连通性
2.6 检查邻居建立过程的错误报文
2.7 查看调试信息
3.1 AR33上OSPF区域类型和hello时间配置错误，需要在AR33上执行以下命令：
3.2 如果执行以上命令未能解决故障，则有可能存在以下几种高可能性故障：
3.2.1 AR33上loopback0接口没有加入到ospf进程
3.2.2 AR29或AR33在OSPF进程下配置了过滤策略
3.2.3 AR33与AR29的互联接口存在过滤策略
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答2&#34;&gt;解答2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;AR29和AR33的Hello间隔不一致，AR29配置为10秒，AR33配置为15秒
# 排障步骤和变种3相同，都是通过最后的调试信息找到错点
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答3&#34;&gt;解答3&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;AR29与AR33的OSPF区域类型不匹配，AR29配置为普通区域类型，而AR33配置为NSSA类型
# 排障步骤和变种3相同，都是通过最后的调试信息找到错点
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目三&#34;&gt;题目三&lt;/h1&gt;
&lt;h2 id=&#34;要求-3&#34;&gt;要求&lt;/h2&gt;
&lt;p&gt;AR32的loopback0与AR28的loopback0口无法访问&lt;br&gt;
&lt;code&gt;OSPF区域间路由传递使用3类LSA&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;解答1-2&#34;&gt;解答1&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
1.1 AR28上OSPF进程中配置filter-policy import命令，针对loopback0接口的路由进行过滤；
1.2 AR28在区域0中配置了区域间路由汇总，并加上了not-advertise，过滤掉了3类LSA；
1.3 AR28上使用filter命令调用ACL或者piefix-list，针对loopback0接口的3类LSA进行过滤（可以配置在区域0的export方向或者区域1的import方向）；
1.4 AR28的g2/0/0接口上配置了ospf filter-lsa-out summary acl xxx，过滤3类LSA泛洪。
二、故障分析
2.1 故障重现
2.2 检查路由表
2.3 检查OSPF邻居情况
2.4 查看OSPF的LSDB
2.5 查看1类LSA
2.6 在AR27上查看1类LSA
三、故障处理
3.1 AR28上配置了路由过滤策略
3.2 如果执行以上命令未能解决故障，则有可能存在以下几种高可能性故障：
3.2.1 能收到路由，但无法ping通，则可能是AR28或AR32上做了流量过滤策略
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答2-2&#34;&gt;解答2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 排障方法见变种1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答3-2&#34;&gt;解答3&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 排障方法见变种1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目四&#34;&gt;题目四&lt;/h1&gt;
&lt;h2 id=&#34;要求-4&#34;&gt;要求&lt;/h2&gt;
&lt;p&gt;AR32的loopback0无法访问ISIS区域内的任何设备&lt;br&gt;
&lt;code&gt;OSPF的外部路由传递是使用5类LSA&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;解答1-3&#34;&gt;解答1&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
AR28在与AR32直连的g2/0/0接口上配置了ospf filter-lsa-out ase，在出方向上过滤掉5类LSA。
二、故障分析
2.1 故障重现
2.2 检查路由表
2.3 查看OSPF的LSDB
2.4 在AR27上查看OSPF的LSDB
2.5 在AR27检查路由表
三、解决方案
3.1 AR32在g2/0/0接口的出方向上过滤掉5类LSA
3.2 如果执行以上命令未能解决故障，则有可能存在以下几种高可能性：
3.2.1 AR32的OSPF进程下配置了路由过滤策略
3.2.2 在AR32/AR28/AR30/AR31/AR34的接口上配置了流量过滤策略
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答2-3&#34;&gt;解答2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
1.1 AR28在OSPF区域下没有引入ISIS路由（或者引入错误的ISIS进行号）；
1.2 AR28正确引入了ISIS路由，但是配置了过滤5类LSA策略
二、故障分析
2.1 故障重现
2.2 检查路由表
2.3 查看OSPF的LSDB
2.4 在AR27上查看OSPF的LSDB
2.5 查看AR31的路由表
三、解决方案
3.1 AR28在OSPF区域下没有引入ISIS路由（或者引入错误的ISIS进行号）或者在引入ISIS路由情况下配置过滤5类LSA策略
3.2 如果执行以上命令未能解决故障，则有可能存在以下几种高可能性：
3.2.1 在AR28/AR32/AR27互联接口下配置了过滤策略
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目五&#34;&gt;题目五&lt;/h1&gt;
&lt;h2 id=&#34;要求-5&#34;&gt;要求&lt;/h2&gt;
&lt;p&gt;AR34没有学习到两条等价默认路由，只从AS30学习到一条&lt;/p&gt;
&lt;h2 id=&#34;解答1-4&#34;&gt;解答1&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
1.1 AR31配置了错误的区域ID；
1.2 AR31配置了错误的ISIS类型。
二、故障分析
2.1 故障重现
2.2 查看ISIS邻居关系
2.3 查看邻居建立过程中的错包情况
2.4 查看ISIS协议的路由级别
2.5 在AR34/AR31上查看自身LSP
2.6 查看AR31的ISIS配置
三、故障处理
3.1 AR31区域ID配置错误和ISIS类型配置错误
3.2 如果执行以上命令未能解决故障，则有可能存在以下几种高可能性：
3.2.1 AR28的g0/0/2接口没有使能ISIS
3.2.2 AR28的g0/0/2接口配置了ISIS认证
3.2.3 AR31的ISIS进程下配置了禁止ATT置1的命令
3.2.4 AR34在ISIS进程下，针对下一跳设置不同的weight
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答2-4&#34;&gt;解答2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因判断
AR31配置了错误的ISIS路由器级别（Level-1），应该配置为级别Level-1-2。
二、故障分析
2.1 故障重现
2.2 检查邻居关系
2.3 查看ISIS数据库
2.4 查看AR31的邻居情况
2.5 检查AR31和AR28的连通性
2.6 查看AR31的ISIS配置
2.7 查看AR31的g0/0/2上ISIS的信息
三、故障处理
3.1 AR31的路由器类型配置错误，可以在AR31上执行以下命令：
3.2 如果执行以上命令未能成功排除故障，存在以下几种高可能性：
3.2.1 AR28与AR31直连的接口没有使能ISIS
3.2.2 AR28与AR31直连的接口配置了isis认证
3.2.3 AR31的ISIS进程下配置了不产生ATT置1的LSP的命令
3.2.4 在AR34的进程下，针对下一跳配置了不同的weight值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答3-3&#34;&gt;解答3&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
AR31配置了错误的区域ID，导致AR31与AR34无法建立ISIS邻居关系。
二、故障分析
2.1 确认故障存在
2.2 检查ISIS邻居
2.3 查看ISIS配置参数
2.4 检查三层是否互通
2.5 检查AR31的邻居
2.6 查看AR31的ISIS参数
2.7 查看AR31上ISIS接口信息
2.8 查看邻居建立过程中的错包情况
2.9 对比查区域配置信息
三、故障处理
3.1 AR31区域ID配置错误，需要在AR31上执行以下命令：
3.2 如果执行以上命令未能解决故障，则有可能存在以下几种高可能性：
3.2.1 AR31的ISIS进程下配置了不产生ATT置1的LSP的命令
3.2.2 在AR34的进程下，针对下一跳配置了不同的weight值
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;题目六&#34;&gt;题目六&lt;/h1&gt;
&lt;h2 id=&#34;要求-6&#34;&gt;要求&lt;/h2&gt;
&lt;p&gt;AR32的loopback0无法访问ISIS区域的部分设备&lt;/p&gt;
&lt;h2 id=&#34;解答1-5&#34;&gt;解答1&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
AR28的g0/0/2接口在出方向上配置了针对AR32的loopback0接口流量过滤策略
二、故障分析
2.1 故障重现
2.2 查看路由表
2.3 查看AR31和AR34的路由表
2.4 不带源追踪路由
2.5 带源追踪路由
2.6 查看AR31的g0/0/2是否收到ping包
2.7 查看AR31和AR34上是否调用ACL
2.8 在AR34上测试与AR32的连通性
三、故障处理
3.1 AR28的g0/0/2接口在出方向上配置了针对AR32的loopback0接口流量过滤策略
3.2 如果执行以上命令未能解决故障，则有可能存在以下几种高可能性：
3.2.1 如果在ping测试后，某些地址还是无法访问，则存在使用高级ACL过滤报文的可能，需要删除这些高级ACL
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;解答2-5&#34;&gt;解答2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因
AR30在g0/0/0口出方向，做了基于源地址为AR32的loopback0的流量过滤策略
二、故障分析
2.1 故障重现
2.2 查看路由表
2.3 查看AR34的路由表
2.4 查看AR31路由表
2.5 不带源和带源进行路由追踪10.5.1.34
2.6 查看AR34的g0/0/0是否收到ping包
2.7 查看AR34是否配置策略
2.8 测试针对反向访问数据包是否有过滤行为
三、故障处理
3.1 登陆R30路由器，删除流量过滤策略
经过上述操作后，若R32可以正常访问R31所有接口和R34 G0/0/1口，说明故障排除，其他高可能性。
高可能性一：如果在ping测试后，某些地址还是无法访问，则存在使用高级ACL过滤报文的可能，需要删除这些高级ACL。
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TAC总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-tac-6/"" data-c="
          &lt;h1 id=&#34;诊断六&#34;&gt;诊断六&lt;/h1&gt;
&lt;p&gt;AR34没有两条等价默认路由&lt;/p&gt;
&lt;h2 id=&#34;tac6-1变种1&#34;&gt;TAC6-1:变种1&lt;/h2&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

AR31的区域ID配置错误和isis进程级别配置错误。

二、故障分析
2.1 故障重现
查看AR34的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display ip routing-table
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 14       Routes : 14       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

        0.0.0.0/0   ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.30/32  ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.34/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.134.0/24  Direct  0    0           D   10.5.134.34     GigabitEthernet
0/0/0
    10.5.134.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.134.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.230.0/24  ISIS-L1 15   20          D   10.5.134.30     GigabitEthernet
0/0/0
     10.5.234.0/24  Direct  0    0           D   10.5.234.34     GigabitEthernet
0/0/1
    10.5.234.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34的路由表中只存在一条指向AR30的默认路由，缺少指向AR31的默认路由。

2.2 检查接口的cost值
接口下的cost值会影响等价默认路由的产生，检查AR34与AR31、AR30互联接口下的cost值是否一致，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis interface verbose

                       Interface information for ISIS(1)
                       ---------------------------------
 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 GE0/0/0         001         Up                 Down         1497 L1/L2 No/No 
  Circuit MT State            : Standard 
  Description                 : HUAWEI, AR Series, GigabitEthernet0/0/0 Interfac
e
  SNPA Address                : 00e0-fc83-528a
  IP Address                  : 10.5.134.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L1    10  L2    10
  Hello Timer Value           :  L1    10  L2    10
  DIS Hello Timer Value       :  L1     3  L2     3
  Hello Multiplier Value      :  L1     3  L2     3
  LSP-Throttle Timer          :  L12    50
  Cost                        :  L1    10  L2    10
  Ipv6 Cost                   :  L1    10  L2    10
  Priority                    :  L1    64  L2    64
  Retransmit Timer Value      :  L12    5
  Bandwidth-Value             :  Low 1000000000  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO

 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 GE0/0/1         002         Up                 Down         1497 L1/L2 No/No 
  Circuit MT State            : Standard 
  Description                 : HUAWEI, AR Series, GigabitEthernet0/0/1 Interfac
e
  SNPA Address                : 00e0-fc83-528b
  IP Address                  : 10.5.234.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L1    10  L2    10
  Hello Timer Value           :  L1    10  L2    10
  DIS Hello Timer Value       :  L1     3  L2     3
  Hello Multiplier Value      :  L1     3  L2     3
  LSP-Throttle Timer          :  L12    50
  Cost                        :  L1    10  L2    10
  Ipv6 Cost                   :  L1    10  L2    10
  Priority                    :  L1    64  L2    64
  Retransmit Timer Value      :  L12    5
  Bandwidth-Value             :  Low 1000000000  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO

 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 Loop0           001         Up                 Down         1500 L1/L2 -- 
  Circuit MT State            : Standard 
  Circuit Parameters          : passive 
  Description                 : HUAWEI, AR Series, LoopBack0 Interface
  SNPA Address                : 0000-0000-0000
  IP Address                  : 10.5.1.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L12   10
  Hello Timer Value           :        10
  DIS Hello Timer Value       :
  Hello Multiplier Value      :         3
  Cost                        :  L1     0  L2     0
  Ipv6 Cost                   :  L1     0  L2     0
  Retransmit Timer Value      :  L12    5
  LSP-Throttle Timer          :  L12   50
  Bandwidth-Value             :  Low          0  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34与AR30互联的接口GE0/0/0接口的cost值为10，与AR31互联的接口GE0/0/1接口的cost值也为10，即这两个接口下cost值相等。

2.3 检查isis邻居
由于AR34与AR31、AR30之间运行isis协议，查看AR34上的isis邻居是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis peer 

                          Peer information for ISIS(1)

  System Id     Interface          Circuit Id       State HoldTime Type     PRI
-------------------------------------------------------------------------------
0000.0000.0030  GE0/0/0            0000.0000.0030.01 Up   7s       L1       64 

Total Peer(s): 1

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34上只存在AR30的level-1级别的邻居，无AR31无任何邻居关系。

2.4 检查三层连通性
isis邻居的建立依赖三层的连通性，检查AR31与AR34之间三层通信是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# 从AR31上获取AR31的g0/0/1接口的地址
&amp;lt;AR31&amp;gt;display ip interface brief 
*down: administratively down
^down: standby
(l): loopback
(s): spoofing
The number of interface that is UP in Physical is 4
The number of interface that is DOWN in Physical is 1
The number of interface that is UP in Protocol is 4
The number of interface that is DOWN in Protocol is 1

Interface                         IP Address/Mask      Physical   Protocol  
GigabitEthernet0/0/0              unassigned           down       down      
GigabitEthernet0/0/1              10.5.234.31/24       up         up        
GigabitEthernet0/0/2              10.5.231.31/24       up         up        
LoopBack0                         10.5.1.31/32         up         up(s)     
NULL0                             unassigned           up         up(s)     

# 在AR34上测试与AR31的连通性
&amp;lt;AR34&amp;gt;ping 10.5.234.31
  PING 10.5.234.31: 56  data bytes, press CTRL_C to break
    Reply from 10.5.234.31: bytes=56 Sequence=1 ttl=255 time=70 ms
    Reply from 10.5.234.31: bytes=56 Sequence=2 ttl=255 time=20 ms
    Reply from 10.5.234.31: bytes=56 Sequence=3 ttl=255 time=20 ms
    Reply from 10.5.234.31: bytes=56 Sequence=4 ttl=255 time=40 ms
    Reply from 10.5.234.31: bytes=56 Sequence=5 ttl=255 time=20 ms

  --- 10.5.234.31 ping statistics ---
    5 packet(s) transmitted
    5 packet(s) received
    0.00% packet loss
    round-trip min/avg/max = 20/34/70 ms
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34与AR31之间的三层通信正常。

2.5 检查isis错误情况
在AR34上检查其与AR31互联接口的isis报错情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis error interface GigabitEthernet 0/0/1
Statistics of errored packets for GE0/0/1:
--------------------------------------------------------------------
LSP packet errors:
Longer LSP              : 0           Smaller LSP             : 0           
Mismatched Level        : 0           Invalid Sysid           : 0           
Zero Sequence Number    : 0           Illegal IS Type         : 0           
Zero Checksum           : 0           Incorrect Checksum      : 0           
Bad Authentication      : 0           Bad Auth Count          : 0           
More Protocol TLV       : 0           Bad Nbr TLV             : 0           
Bad Extended IS TLV     : 0           Bad IF Addr TLV         : 0           
Bad Reach TLV           : 0           Bad Inter Domain TLV    : 0           
Mismatched Area Id(L1)  : 0           Bad TLV Length          : 0          
Bad Alias TLV           : 0           Bad Area TLV            : 0           
Bad SRLG TLV            : 0           Unknown Adjacency       : 0           
Bad Protocol ID         : 0           Bad Version             : 0           
Zero Lifetime           : 0           Bad Ext Reach TLV       : 0           
Bad TE Router ID TLV    : 0           Bad TE Sub TLV          : 0           

Hello packet errors:
Bad Packet Length       : 0           Reserved CircType       : 0           
Repeated System ID      : 0           Bad Circuit Type        : 0           
Longer packet           : 0           More Area Addr          : 0           
Longer Area Addr        : 0           Bad Area Addr TLV       : 0           
More IF Addr            : 0           Bad Formatted IF TLV    : 0           
More Nbr SNPA(LAN)      : 0           Invalid Sysid           : 0           
Bad TLV Length          : 0           Zero HoldingTime        : 0           
Unusable IP Addr        : 0           Repeated IPv4 Addr      : 0           
Mismatched Area Addr(L1): 129         Mismatched Proto        : 0           
SNPA Conflicted(LAN)    : 0           Mismatched Level        : 0           
Mismatched Max Area Addr: 0           Bad Authentication      : 0           
More Auth TLV           : 0           3-Way Option Error(P2P) : 0           
No Area Addr TLV        : 0           Bad Protocol ID         : 0           
Bad Version             : 0           Invalid IPv6 Addr       : 0           
More IPv6 IF Addr       : 0           Duplicate IPv6 Addr     : 0           
More Optional Checksum  : 0           Bad Optional Checksum   : 0           
--------------------------------------------------------------------

&amp;quot;&amp;quot;&amp;quot;
结果显示，“Mismatched Area Addr(L1): 129 ”表明AR31与AR34之间有交互level-1级别的hello报文，但故障的原因是isis的区域ID不一致。

2.6 查看AR31和AR34的链路状态数据库
为确认AR31和AR34之间isis区域ID不一致的情况，需要进一步查看AR31和AR34的链路状态数据库，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# AR34的链路状态数据库
&amp;lt;AR34&amp;gt;display isis lsdb verbose

                        Database information for ISIS(1)
                        --------------------------------

                          Level-1 Link State Database

LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL
-------------------------------------------------------------------------------
0000.0000.0030.00-00  0x00000009   0xe6e6        648           102     1/0/0   
 SOURCE       0000.0000.0030.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.30
 INTF ADDR    10.5.230.30
 INTF ADDR    10.5.134.30
 NBR  ID      0000.0000.0030.01  COST: 10        
 IP-Internal  10.5.1.30       255.255.255.255  COST: 0         
 IP-Internal  10.5.230.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.134.0      255.255.255.0    COST: 10        

0000.0000.0030.01-00  0x00000002   0xdb1e        648           55      0/0/0   
 SOURCE       0000.0000.0030.01
 NLPID        IPV4
 NBR  ID      0000.0000.0030.00  COST: 0         
 NBR  ID      0000.0000.0034.00  COST: 0         

0000.0000.0034.00-00* 0x00000007   0xd2ea        605           102     0/0/0   
 SOURCE       0000.0000.0034.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.34
 INTF ADDR    10.5.134.34
 INTF ADDR    10.5.234.34
 NBR  ID      0000.0000.0030.01  COST: 10        
 IP-Internal  10.5.1.34       255.255.255.255  COST: 0         
 IP-Internal  10.5.134.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.234.0      255.255.255.0    COST: 10        

Total LSP(s): 3
    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), 
           ATT-Attached, P-Partition, OL-Overload
           
# AR31的链路状态数据库
&amp;lt;AR31&amp;gt;display isis lsdb verbose 

                        Database information for ISIS(1)
                        --------------------------------

                          Level-1 Link State Database

LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL
-------------------------------------------------------------------------------
0000.0000.0031.00-00* 0x00000005   0x20b5        618           88      0/0/0   
 SOURCE       0000.0000.0031.00
 NLPID        IPV4
 AREA ADDR    49.0006 
 INTF ADDR    10.5.1.31
 INTF ADDR    10.5.234.31
 INTF ADDR    10.5.231.31
 IP-Internal  10.5.1.31       255.255.255.255  COST: 0         
 IP-Internal  10.5.234.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.231.0      255.255.255.0    COST: 10        

Total LSP(s): 1
    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), 
           ATT-Attached, P-Partition, OL-Overload
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34的区域ID为49.0005，AR31的区域ID为49.0006，区域ID不相同影响level-1级别邻居的建立，但是不影响level-2级别邻居的建立，因此AR31的区域ID配置错误。同时还发现，AR34上只收到来自AR30的ATT置1的lsp，并未收到任何来自AR31的lsp。AR34上如果要产生指向AR31的默认路由，不仅需要AR34与AR31之间建立level-1级别的邻居，还需要AR31与AR28之间建立level-2级别的邻居，因此AR31的isis级别只能为level-1-2，但是上面结果显示的AR31的链路状态数据库只产生level-1级别的lsp，初步断定AR31的isis级别也是错误的。

2.7 查看AR31的isis进程信息和邻居
为确认AR31的isis级别是否错误，需要查看AR31的isis进程信息，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# isis进程信息
&amp;lt;AR31&amp;gt;display isis brief 

                     ISIS Protocol Information for ISIS(1)
                     -------------------------------------
SystemId: 0000.0000.0031      System Level: L1    
Area-Authentication-mode: NULL
Domain-Authentication-mode: NULL
Ipv6 is not enabled
ISIS is in invalid restart status
ISIS is in protocol hot standby state: Real-Time Backup

Interface: 10.5.234.31(GE0/0/1)
Cost: L1 10        L2 10                Ipv6 Cost: L1 10   L2 10   
State: IPV4 Up                          IPV6 Down
Type: BROADCAST                         MTU: 1497      
Priority: L1 64   L2 64   
Timers:     Csnp: L1 10    L2 10    ,Retransmit: L12 5   , Hello: L1 10 L2 10  ,
 
Hello Multiplier: L1 3    L2 3     , LSP-Throttle Timer: L12 50  

Interface: 10.5.231.31(GE0/0/2)
Cost: L1 10        L2 10                Ipv6 Cost: L1 10   L2 10   
State: IPV4 Up                          IPV6 Down
Type: BROADCAST                         MTU: 1497      
Priority: L1 64   L2 64   
Timers:     Csnp: L1 10    L2 10    ,Retransmit: L12 5   , Hello: L1 10 L2 10  ,
 
Hello Multiplier: L1 3    L2 3     , LSP-Throttle Timer: L12 50  

Interface: 10.5.1.31(Loop0)
Cost: L1 0         L2 0                 Ipv6 Cost: L1 0    L2 0    
State: IPV4 Up                          IPV6 Down
Type: P2P                               MTU: 1500      
Priority: L1 64   L2  64   
Timers:     Csnp: L12 10  , Retransmit: L12 5   , Hello: 10  ,
Hello Multiplier: 3            , LSP-Throttle Timer: L12 50  

# isis邻居
&amp;lt;AR31&amp;gt;dis isis peer

&amp;lt;AR31&amp;gt;
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR31的isis级别为level-1，配置错误，因此无法与AR28之间建立level-2级别的邻居，需要修改成level-1-2。

2.8 结论
通过上述分析，故障的根本原因为AR31的区域ID配置错误和isis进程级别配置错误。

三、故障解决
3.1 AR31的区域ID配置错误和isis进程级别配置错误，需要在AR31上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
undo network-entity 49.0006.0000.0000.0031.00 //删除错误的区域ID
network-entity 49.0005.0000.0000.0031.00 //配置正确的区域ID
is-level level-1-2 //修改isis级别为level-1-2

执行完以上命令之后，需要在AR31上执行以下命令进行检查：
display isis peer //查看是否与AR28建立level-2级别的邻居，与AR34建立level-1级别的邻居
需要在AR34上执行以下命令进行检查：
display isis peer //查看是否与AR31建立level-1级别的邻居
display isis lsdb verbose //查看是否收到来自AR31的ATT位置1的lsp
display ip routing-table //查看故障是否解决

3.2 如果执行以上命令未能解决故障，则存在以下高可能性故障：
与AR31和AR28之间的isis邻居相关：
3.2.1 AR28的g0/0/2接口下没有使能isis，需要在AR28上执行以下命令：
system-view
interface GigabitEthernet 0/0/2
display this
isis enable {isis进程ID}

3.2.2 AR28的isis进程下配置domain认证，需要在AR31上执行以下命令：
system-view
interface GigabitEthernet 0/0/2
undo isis authentication-mode
isis xx
domain-authentication-mode md5 1 cipher xx

3.2.3 AR28与AR31互联接口下isis认证不一致，需要在AR31和AR28上执行以下命令：
system-view
interface GigabitEthernet 0/0/2
undo isis authentication-mode

3.2.4 AR28与AR31互联接口下的mtu不一致，需要在AR28上执行以下命令：
system-view
interface GigabitEthernet 0/0/2
mtu 1497

3.2.5 AR28与AR31互联接口的链路类型不一致，需要在AR31和AR28上执行以下命令：
system-view
interface GigabitEthernet 0/0/2
isis circuit-type xxx

3.2.6 AR28与AR31的isis进程下的cost类型不一致，需要在AR31和AR28上执行以下命令：
system-view
isis xx
cost-style xxx

执行完以上命令之后，需要在AR31上执行以下命令进行检查：
display isis peer //查看是否与AR28建立level-2级别的邻居

与AR31和AR34之间的isis邻居相关：
3.2.7 AR31与AR34互联接口下的isis认证不一致，需要在AR31和AR34上执行以下命令：
system-view
interface GigabitEthernet 0/0/1
undo isis authentication-mode

3.2.8 AR31与AR34的isis进程下的cost类型不一致，需要在AR31和AR34上执行以下命令：
system-view
isis xx
cost-style xxx

需要在AR34上执行以下命令进行检查：
display isis peer //查看是否与AR31建立level-1级别的邻居


其他因素：
3.2.9 AR31的isis进程下设置强制ATT不能置1，需要在AR31上执行以下命令：
system-view
isis xx
undo attached-bit advertise

3.2.10 AR34的isis进程下针对下一跳设置不同的weight，需要在AR34上执行以下命令：
system-view
isis xx
undo nexthop 10.5.x.x

3.2.11 AR34在isis进程下设置最大负载为1，需要在AR34上执行以下命令：
system-view
isis xx
undo maximum load-balancing

执行完以上命令之后，需要在AR31上执行以下命令进行检查：
display isis peer //查看是否与AR28建立level-2级别的邻居，与AR34建立level-1级别的邻居
需要在AR34上执行以下命令进行检查：
display isis peer //查看是否与AR31建立level-1级别的邻居
display isis lsdb verbose //查看是否收到来自AR31的ATT位置1的lsp
display ip routing-table //查看故障是否解决

3.3 如果执行以上命令成功排除故障，则需要在执行过命令的设备上继续执行以下命令：
return //回到用户视图
save //保存修改之后的配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助，谢谢！
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tac6-2变种2&#34;&gt;TAC6-2:变种2&lt;/h2&gt;
&lt;h2 id=&#34;解答-2&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

AR31的区域ID配置错误，与AR34的区域ID不一致，导致AR31与AR34之间无法建立level-1的isis邻居。

二、故障分析
2.1 故障重现
查看AR34的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 14       Routes : 14       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

        0.0.0.0/0   ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.30/32  ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.34/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.134.0/24  Direct  0    0           D   10.5.134.34     GigabitEthernet
0/0/0
    10.5.134.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.134.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.230.0/24  ISIS-L1 15   20          D   10.5.134.30     GigabitEthernet
0/0/0
     10.5.234.0/24  Direct  0    0           D   10.5.234.34     GigabitEthernet
0/0/1
    10.5.234.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34的路由表中只存在一条指向AR30的默认路由，缺少指向AR31的默认路由，故障存在。

2.2 检查接口的cost值
接口下的cost值会影响等价默认路由的产生，首先检查AR34与AR31、AR30互联接口下的cost值，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis interface verbose

                       Interface information for ISIS(1)
                       ---------------------------------
 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 GE0/0/0         001         Up                 Down         1497 L1/L2 No/No 
  Circuit MT State            : Standard 
  Description                 : HUAWEI, AR Series, GigabitEthernet0/0/0 Interfac
e
  SNPA Address                : 00e0-fc83-528a
  IP Address                  : 10.5.134.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L1    10  L2    10
  Hello Timer Value           :  L1    10  L2    10
  DIS Hello Timer Value       :  L1     3  L2     3
  Hello Multiplier Value      :  L1     3  L2     3
  LSP-Throttle Timer          :  L12    50
  Cost                        :  L1    10  L2    10
  Ipv6 Cost                   :  L1    10  L2    10
  Priority                    :  L1    64  L2    64
  Retransmit Timer Value      :  L12    5
  Bandwidth-Value             :  Low 1000000000  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO

 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 GE0/0/1         002         Up                 Down         1497 L1/L2 No/No 
  Circuit MT State            : Standard 
  Description                 : HUAWEI, AR Series, GigabitEthernet0/0/1 Interfac
e
  SNPA Address                : 00e0-fc83-528b
  IP Address                  : 10.5.234.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L1    10  L2    10
  Hello Timer Value           :  L1    10  L2    10
  DIS Hello Timer Value       :  L1     3  L2     3
  Hello Multiplier Value      :  L1     3  L2     3
  LSP-Throttle Timer          :  L12    50
  Cost                        :  L1    10  L2    10
  Ipv6 Cost                   :  L1    10  L2    10
  Priority                    :  L1    64  L2    64
  Retransmit Timer Value      :  L12    5
  Bandwidth-Value             :  Low 1000000000  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO

 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 Loop0           001         Up                 Down         1500 L1/L2 -- 
  Circuit MT State            : Standard 
  Circuit Parameters          : passive 
  Description                 : HUAWEI, AR Series, LoopBack0 Interface
  SNPA Address                : 0000-0000-0000
  IP Address                  : 10.5.1.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L12   10
  Hello Timer Value           :        10
  DIS Hello Timer Value       :
  Hello Multiplier Value      :         3
  Cost                        :  L1     0  L2     0
  Ipv6 Cost                   :  L1     0  L2     0
  Retransmit Timer Value      :  L12    5
  LSP-Throttle Timer          :  L12   50
  Bandwidth-Value             :  Low          0  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34与AR31互联的GE0/0/1、与AR30互联的GE0/0/0接口的cost值均为10。

2.3 检查isis邻居
AR34与AR31、AR30之间运行isis路由协议，检查AR34上的isis邻居是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis peer 

                          Peer information for ISIS(1)

  System Id     Interface          Circuit Id       State HoldTime Type     PRI
-------------------------------------------------------------------------------
0000.0000.0030  GE0/0/0            0000.0000.0030.01 Up   9s       L1       64 

Total Peer(s): 1
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34只和AR30之间建立level-1级别的邻居，缺少了与AR31之间的isis邻居关系。

2.4 检查三层连通性
isis邻居的建立依赖三层的连通性，检查AR34与AR31之间三层通信是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# 获取AR31与AR34互联接口的地址
&amp;lt;AR31&amp;gt;display ip interface brief 
*down: administratively down
^down: standby
(l): loopback
(s): spoofing
The number of interface that is UP in Physical is 4
The number of interface that is DOWN in Physical is 1
The number of interface that is UP in Protocol is 4
The number of interface that is DOWN in Protocol is 1

Interface                         IP Address/Mask      Physical   Protocol  
GigabitEthernet0/0/0              unassigned           down       down      
GigabitEthernet0/0/1              10.5.234.31/24       up         up        
GigabitEthernet0/0/2              10.5.231.31/24       up         up        
LoopBack0                         10.5.1.31/32         up         up(s)     
NULL0                             unassigned           up         up(s)     
&amp;lt;AR31&amp;gt;

# 测试三层通信情况
&amp;lt;AR34&amp;gt;ping 10.5.234.31
  PING 10.5.234.31: 56  data bytes, press CTRL_C to break
    Reply from 10.5.234.31: bytes=56 Sequence=1 ttl=255 time=70 ms
    Reply from 10.5.234.31: bytes=56 Sequence=2 ttl=255 time=10 ms
    Reply from 10.5.234.31: bytes=56 Sequence=3 ttl=255 time=10 ms
    Reply from 10.5.234.31: bytes=56 Sequence=4 ttl=255 time=10 ms
    Reply from 10.5.234.31: bytes=56 Sequence=5 ttl=255 time=10 ms

  --- 10.5.234.31 ping statistics ---
    5 packet(s) transmitted
    5 packet(s) received
    0.00% packet loss
    round-trip min/avg/max = 10/22/70 ms

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34与AR31三层通信正常。

2.5 检查isis报错情况
在AR34上检查与AR31互联接口下的isis报错情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis error interface GigabitEthernet 0/0/1
Statistics of errored packets for GE0/0/1:
--------------------------------------------------------------------
LSP packet errors:
Longer LSP              : 0           Smaller LSP             : 0           
Mismatched Level        : 0           Invalid Sysid           : 0           
Zero Sequence Number    : 0           Illegal IS Type         : 0           
Zero Checksum           : 0           Incorrect Checksum      : 0           
Bad Authentication      : 0           Bad Auth Count          : 0           
More Protocol TLV       : 0           Bad Nbr TLV             : 0           
Bad Extended IS TLV     : 0           Bad IF Addr TLV         : 0           
Bad Reach TLV           : 0           Bad Inter Domain TLV    : 0           
Mismatched Area Id(L1)  : 0           Bad TLV Length          : 0          
Bad Alias TLV           : 0           Bad Area TLV            : 0           
Bad SRLG TLV            : 0           Unknown Adjacency       : 0           
Bad Protocol ID         : 0           Bad Version             : 0           
Zero Lifetime           : 0           Bad Ext Reach TLV       : 0           
Bad TE Router ID TLV    : 0           Bad TE Sub TLV          : 0           

Hello packet errors:
Bad Packet Length       : 0           Reserved CircType       : 0           
Repeated System ID      : 0           Bad Circuit Type        : 0           
Longer packet           : 0           More Area Addr          : 0           
Longer Area Addr        : 0           Bad Area Addr TLV       : 0           
More IF Addr            : 0           Bad Formatted IF TLV    : 0           
More Nbr SNPA(LAN)      : 0           Invalid Sysid           : 0           
Bad TLV Length          : 0           Zero HoldingTime        : 0           
Unusable IP Addr        : 0           Repeated IPv4 Addr      : 0           
Mismatched Area Addr(L1): 85          Mismatched Proto        : 0           
SNPA Conflicted(LAN)    : 0           Mismatched Level        : 0           
Mismatched Max Area Addr: 0           Bad Authentication      : 0           
More Auth TLV           : 0           3-Way Option Error(P2P) : 0           
No Area Addr TLV        : 0           Bad Protocol ID         : 0           
Bad Version             : 0           Invalid IPv6 Addr       : 0           
More IPv6 IF Addr       : 0           Duplicate IPv6 Addr     : 0           
More Optional Checksum  : 0           Bad Optional Checksum   : 0           
--------------------------------------------------------------------

&amp;quot;&amp;quot;&amp;quot;
结果显示，“Mismatched Area Addr(L1): 85 ”表明AR34与AR31之间有交互Level-1级别的hello报文的能力，邻居未建立的原因是isis的区域ID不一致。

2.6 查看AR34与AR31的链路状态数据库
为了确认AR34与AR31之间区域ID是否一致，需要对比查看AR31与AR34的链路状态数据库，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# AR34
&amp;lt;AR34&amp;gt;display isis lsdb verbose

                        Database information for ISIS(1)
                        --------------------------------

                          Level-1 Link State Database

LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL
-------------------------------------------------------------------------------
0000.0000.0030.00-00  0x00000007   0xeae4        1011          102     1/0/0   
 SOURCE       0000.0000.0030.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.30
 INTF ADDR    10.5.230.30
 INTF ADDR    10.5.134.30
 NBR  ID      0000.0000.0030.01  COST: 10        
 IP-Internal  10.5.1.30       255.255.255.255  COST: 0         
 IP-Internal  10.5.230.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.134.0      255.255.255.0    COST: 10        

0000.0000.0030.01-00  0x00000002   0xdb1e        1011          55      0/0/0   
 SOURCE       0000.0000.0030.01
 NLPID        IPV4
 NBR  ID      0000.0000.0030.00  COST: 0         
 NBR  ID      0000.0000.0034.00  COST: 0         

0000.0000.0034.00-00* 0x00000006   0xd4e9        1119          102     0/0/0   
 SOURCE       0000.0000.0034.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.34
 INTF ADDR    10.5.134.34
 INTF ADDR    10.5.234.34
 NBR  ID      0000.0000.0030.01  COST: 10        
 IP-Internal  10.5.1.34       255.255.255.255  COST: 0         
 IP-Internal  10.5.134.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.234.0      255.255.255.0    COST: 10        

Total LSP(s): 3
    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), 
           ATT-Attached, P-Partition, OL-Overload

# AR31
&amp;lt;AR31&amp;gt;display isis lsdb verbose

                        Database information for ISIS(1)
                        --------------------------------

                          Level-1 Link State Database

LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL
-------------------------------------------------------------------------------
0000.0000.0031.00-00* 0x00000008   0x5474        1037          88      1/0/0   
 SOURCE       0000.0000.0031.00
 NLPID        IPV4
 AREA ADDR    49.0006 
 INTF ADDR    10.5.1.31
 INTF ADDR    10.5.231.31
 INTF ADDR    10.5.234.31
 IP-Internal  10.5.1.31       255.255.255.255  COST: 0         
 IP-Internal  10.5.231.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.234.0      255.255.255.0    COST: 10        

Total LSP(s): 1
    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), 
           ATT-Attached, P-Partition, OL-Overload


                          Level-2 Link State Database

LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL
-------------------------------------------------------------------------------
0000.0000.0028.00-00  0x00000009   0x1829        974           97      0/0/0   
 SOURCE       0000.0000.0028.00
 NLPID        IPV4
 AREA ADDR    49.0006 
 INTF ADDR    10.5.230.28
 INTF ADDR    10.5.231.28
 NBR  ID      0000.0000.0030.02  COST: 10        
 NBR  ID      0000.0000.0031.02  COST: 10        
 IP-Internal  10.5.230.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.231.0      255.255.255.0    COST: 10        

0000.0000.0028.00-01  0x00000005   0xb97e        974           89      0/0/0   
 SOURCE       0000.0000.0028.00
 IP-External  10.5.1.28       255.255.255.255  COST: 64        
 IP-External  10.5.128.0      255.255.255.0    COST: 64        
 IP-External  10.5.232.0      255.255.255.0    COST: 64        
 IP-External  10.5.1.32       255.255.255.255  COST: 64        
 IP-External  10.5.1.27       255.255.255.255  COST: 64        

0000.0000.0030.00-00  0x00000007   0xb8b8        984           126     0/0/0   
 SOURCE       0000.0000.0030.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.30
 INTF ADDR    10.5.230.30
 INTF ADDR    10.5.134.30
 NBR  ID      0000.0000.0030.02  COST: 10        
 IP-Internal  10.5.1.30       255.255.255.255  COST: 0         
 IP-Internal  10.5.230.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.134.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.1.34       255.255.255.255  COST: 10        
 IP-Internal  10.5.234.0      255.255.255.0    COST: 20        

0000.0000.0030.02-00  0x00000002   0x8381        984           55      0/0/0   
 SOURCE       0000.0000.0030.02
 NLPID        IPV4
 NBR  ID      0000.0000.0030.00  COST: 0         
 NBR  ID      0000.0000.0028.00  COST: 0         

0000.0000.0031.00-00* 0x00000008   0x5fa4        1036          102     0/0/0   
 SOURCE       0000.0000.0031.00
 NLPID        IPV4
 AREA ADDR    49.0006 
 INTF ADDR    10.5.1.31
 INTF ADDR    10.5.231.31
 INTF ADDR    10.5.234.31
 NBR  ID      0000.0000.0031.02  COST: 10        
 IP-Internal  10.5.1.31       255.255.255.255  COST: 0         
 IP-Internal  10.5.231.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.234.0      255.255.255.0    COST: 10        

0000.0000.0031.02-00* 0x00000002   0x8c76        1036          55      0/0/0   
 SOURCE       0000.0000.0031.02
 NLPID        IPV4
 NBR  ID      0000.0000.0031.00  COST: 0         
 NBR  ID      0000.0000.0028.00  COST: 0         

Total LSP(s): 6
    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), 
           ATT-Attached, P-Partition, OL-Overload
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34的区域ID为49.0005，而AR31的区域ID为49.0006，区域ID不相同无法建立level-1级别邻居的建立，但是不影响level-2级别邻居的建立。同时也看到AR34的链路状态数据库中只接受到了来自AR30的ATT位置1的lsp，并未收到来自AR31的ATT位置1的lsp，因此无法产生指向AR31的默认路由。

2.7 查看AR31的isis进程信息与邻居
AR31想要产生ATT置1的lsp，不仅需要与AR34建立level-1级别的isis邻居，同样还需要与不同区域的AR28建立level-2级别的isis邻居，因此AR34的isis级别只能为level-1-2，查看isis进程信息，确认AR31的isis级别是否配置正确，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# isis进程信息
&amp;lt;AR31&amp;gt;display isis brief 

                     ISIS Protocol Information for ISIS(1)
                     -------------------------------------
SystemId: 0000.0000.0031      System Level: L12   
Area-Authentication-mode: NULL
Domain-Authentication-mode: NULL
Ipv6 is not enabled
ISIS is in invalid restart status
ISIS is in protocol hot standby state: Real-Time Backup

Interface: 10.5.234.31(GE0/0/1)
Cost: L1 10        L2 10                Ipv6 Cost: L1 10   L2 10   
State: IPV4 Up                          IPV6 Down
Type: BROADCAST                         MTU: 1497      
Priority: L1 64   L2 64   
Timers:     Csnp: L1 10    L2 10    ,Retransmit: L12 5   , Hello: L1 10 L2 10  ,
 
Hello Multiplier: L1 3    L2 3     , LSP-Throttle Timer: L12 50  

Interface: 10.5.231.31(GE0/0/2)
Cost: L1 10        L2 10                Ipv6 Cost: L1 10   L2 10   
State: IPV4 Up                          IPV6 Down
Type: BROADCAST                         MTU: 1497      
Priority: L1 64   L2 64   
Timers:     Csnp: L1 10    L2 10    ,Retransmit: L12 5   , Hello: L1 10 L2 10  ,
 
Hello Multiplier: L1 3    L2 3     , LSP-Throttle Timer: L12 50  

Interface: 10.5.1.31(Loop0)
Cost: L1 0         L2 0                 Ipv6 Cost: L1 0    L2 0    
State: IPV4 Up                          IPV6 Down
Type: P2P                               MTU: 1500      
Priority: L1 64   L2  64   
Timers:     Csnp: L12 10  , Retransmit: L12 5   , Hello: 10  ,
Hello Multiplier: 3            , LSP-Throttle Timer: L12 50

# isis邻居情况
&amp;lt;AR31&amp;gt;display isis peer 

                          Peer information for ISIS(1)

  System Id     Interface          Circuit Id       State HoldTime Type     PRI
-------------------------------------------------------------------------------
0000.0000.0028  GE0/0/2            0000.0000.0031.02 Up   28s      L2       64 

Total Peer(s): 1

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR31的isis级别确实为level-1-2，同时与AR28成功建立level-2级别的isis邻居。

2.8 结论
通过以上分析，故障的根本原因为AR31的区域ID配置错误，与AR34的区域ID不一致，导致AR31与AR34之间无法建立level-1的isis邻居。


三、故障解决
3.1 AR31的区域ID配置错误，需要在AR31上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo network-entity 49.0006.0000.0000.0031.00 //删除错误的区域ID
network-entity 49.0005.0000.0000.0031.00 //配置正确的区域ID

执行完上述命令之后，需要在AR34上执行以下命令进行检查：
display isis peer //查看AR34与AR31之间的isis邻居是否正常
display isis lsdb verbose //查看是否存在来自AR31的ATT位置1的lsp
display ip routing-table //查看等价默认路由情况，故障是否排除

3.2 如果执行以上命令未能排除故障，则存在以下高可能性故障
3.2.1 AR31在isis进程下配置ATT位不能置1的命令，需要在AR31上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo attached-bit advertise //删除ATT不置1的配置

3.2.2 AR34在isis进程下对不同的下一跳设备不同的weight，需要在AR34上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo nexthop 10.5.x.x //删除针对下一跳设置weight
 
3.2.3 AR34在isis进程下配置最大负载为1，需要在AR34上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo maximum load-balancing //删除最大负载设置

3.2.4 AR34与AR31互联接口的isis认证不一致，需要在AR31和AR34上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/1 //进入接口视图
display this //查看当前配置
undo isis authentication-mode //删除接口认证
isis authentication-mode {AR31和AR34之间使用相同的认证} //或者修改成一致的认证

3.2.5 AR34与AR31的isis进程下的cost类型不一致，需要在AR31和AR34上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
cost-style {AR34与AR31之间相同的cost类型} //修改cost类型

3.3 如果执行以上命令成功排除故障，则需要在执行过命令的设备上继续执行以下命令：
return //返回用户视图
save //保存修改之后的配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助。
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tac6-2变种3&#34;&gt;TAC6-2:变种3&lt;/h2&gt;
&lt;h2 id=&#34;解答-3&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

AR31的isis级别配置错误，导致无法与AR28之间建立level-2级别的isis邻居。

二、故障分析
2.1 故障重现
查看AR34的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 16       Routes : 16       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

        0.0.0.0/0   ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.30/32  ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.31/32  ISIS-L1 15   10          D   10.5.234.31     GigabitEthernet
0/0/1
      10.5.1.34/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.134.0/24  Direct  0    0           D   10.5.134.34     GigabitEthernet
0/0/0
    10.5.134.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.134.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.230.0/24  ISIS-L1 15   20          D   10.5.134.30     GigabitEthernet
0/0/0
     10.5.231.0/24  ISIS-L1 15   20          D   10.5.234.31     GigabitEthernet
0/0/1
     10.5.234.0/24  Direct  0    0           D   10.5.234.34     GigabitEthernet
0/0/1
    10.5.234.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34的路由表中只存在一条指向AR30的默认路由，缺少指向AR31的默认路由，故障存在。

2.2 检查接口的cost值
AR34与AR31、AR30互联接口下的cost值会影响等价默认路由的产生，在AR34上检查这两个接口下的cost值，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis interface verbose

                       Interface information for ISIS(1)
                       ---------------------------------
 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 GE0/0/0         001         Up                 Down         1497 L1/L2 No/No 
  Circuit MT State            : Standard 
  Description                 : HUAWEI, AR Series, GigabitEthernet0/0/0 Interfac
e
  SNPA Address                : 00e0-fc83-528a
  IP Address                  : 10.5.134.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L1    10  L2    10
  Hello Timer Value           :  L1    10  L2    10
  DIS Hello Timer Value       :  L1     3  L2     3
  Hello Multiplier Value      :  L1     3  L2     3
  LSP-Throttle Timer          :  L12    50
  Cost                        :  L1    10  L2    10
  Ipv6 Cost                   :  L1    10  L2    10
  Priority                    :  L1    64  L2    64
  Retransmit Timer Value      :  L12    5
  Bandwidth-Value             :  Low 1000000000  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO

 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 GE0/0/1         002         Up                 Down         1497 L1/L2 No/No 
  Circuit MT State            : Standard 
  Description                 : HUAWEI, AR Series, GigabitEthernet0/0/1 Interfac
e
  SNPA Address                : 00e0-fc83-528b
  IP Address                  : 10.5.234.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L1    10  L2    10
  Hello Timer Value           :  L1    10  L2    10
  DIS Hello Timer Value       :  L1     3  L2     3
  Hello Multiplier Value      :  L1     3  L2     3
  LSP-Throttle Timer          :  L12    50
  Cost                        :  L1    10  L2    10
  Ipv6 Cost                   :  L1    10  L2    10
  Priority                    :  L1    64  L2    64
  Retransmit Timer Value      :  L12    5
  Bandwidth-Value             :  Low 1000000000  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO

 Interface       Id      IPV4.State          IPV6.State      MTU  Type  DIS   
 Loop0           001         Up                 Down         1500 L1/L2 -- 
  Circuit MT State            : Standard 
  Circuit Parameters          : passive 
  Description                 : HUAWEI, AR Series, LoopBack0 Interface
  SNPA Address                : 0000-0000-0000
  IP Address                  : 10.5.1.34
  IPV6 Link Local Address     :
  IPV6 Global Address(es)     :
  Csnp Timer Value            :  L12   10
  Hello Timer Value           :        10
  DIS Hello Timer Value       :
  Hello Multiplier Value      :         3
  Cost                        :  L1     0  L2     0
  Ipv6 Cost                   :  L1     0  L2     0
  Retransmit Timer Value      :  L12    5
  LSP-Throttle Timer          :  L12   50
  Bandwidth-Value             :  Low          0  High          0
  Static Bfd                  :  NO
  Dynamic Bfd                 :  NO
  Fast-Sense Rpr              :  NO
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34与AR31互联的GE0/0/1接口、与AR30互联的GE0/0/0接口的cost值均为10。

2.3 检查isis邻居
AR34与AR31、AR30之间运行isis路由协议，检查AR34上的isis邻居是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis peer 

                          Peer information for ISIS(1)

  System Id     Interface          Circuit Id       State HoldTime Type     PRI
-------------------------------------------------------------------------------
0000.0000.0030  GE0/0/0            0000.0000.0030.01 Up   9s       L1       64 
0000.0000.0031  GE0/0/1            0000.0000.0031.01 Up   8s       L1       64 

Total Peer(s): 2
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34与AR31、AR30之间均存在level-1级别的isis邻居。

2.4 检查isis的链路状态数据库
AR34上想要产生默认路由，需要isis接收到ATT位置1的lsp，查看AR34的链路状态数据库确认是否存在来自AR31的ATT置1的lsp，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display isis lsdb verbose

                        Database information for ISIS(1)
                        --------------------------------

                          Level-1 Link State Database

LSPID                 Seq Num      Checksum      Holdtime      Length  ATT/P/OL
-------------------------------------------------------------------------------
0000.0000.0030.00-00  0x0000000a   0xe4e7        942           102     1/0/0   
 SOURCE       0000.0000.0030.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.30
 INTF ADDR    10.5.230.30
 INTF ADDR    10.5.134.30
 NBR  ID      0000.0000.0030.01  COST: 10        
 IP-Internal  10.5.1.30       255.255.255.255  COST: 0         
 IP-Internal  10.5.230.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.134.0      255.255.255.0    COST: 10        

0000.0000.0030.01-00  0x00000003   0xd91f        942           55      0/0/0   
 SOURCE       0000.0000.0030.01
 NLPID        IPV4
 NBR  ID      0000.0000.0030.00  COST: 0         
 NBR  ID      0000.0000.0034.00  COST: 0         

0000.0000.0031.00-00  0x00000007   0xdfb         837           102     0/0/0   
 SOURCE       0000.0000.0031.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.31
 INTF ADDR    10.5.234.31
 INTF ADDR    10.5.231.31
 NBR  ID      0000.0000.0031.01  COST: 10        
 IP-Internal  10.5.1.31       255.255.255.255  COST: 0         
 IP-Internal  10.5.234.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.231.0      255.255.255.0    COST: 10        

0000.0000.0031.01-00  0x00000003   0xe018        836           55      0/0/0   
 SOURCE       0000.0000.0031.01
 NLPID        IPV4
 NBR  ID      0000.0000.0031.00  COST: 0         
 NBR  ID      0000.0000.0034.00  COST: 0         

0000.0000.0034.00-00* 0x0000000a   0xee3         762           113     0/0/0   
 SOURCE       0000.0000.0034.00
 NLPID        IPV4
 AREA ADDR    49.0005 
 INTF ADDR    10.5.1.34
 INTF ADDR    10.5.134.34
 INTF ADDR    10.5.234.34
 NBR  ID      0000.0000.0030.01  COST: 10        
 NBR  ID      0000.0000.0031.01  COST: 10        
 IP-Internal  10.5.1.34       255.255.255.255  COST: 0         
 IP-Internal  10.5.134.0      255.255.255.0    COST: 10        
 IP-Internal  10.5.234.0      255.255.255.0    COST: 10        

Total LSP(s): 5
    *(In TLV)-Leaking Route, *(By LSPID)-Self LSP, +-Self LSP(Extended), 
           ATT-Attached, P-Partition, OL-Overload

&amp;quot;&amp;quot;&amp;quot;
结果显示，来自AR31的lsp的ATT位均为置1。要想产生ATT位置1的lsp，需要AR31与AR34之间建立level-1级别的isis邻居，同时还需要AR31与不同区域的AR28之间建立level-2级别的邻居，即AR31的isis级别只能为level-1-2。

2.5 查看AR31的isis进程信息和邻居
为确认AR31的isis级别是否正确，需要查看AR31的isis进程信息，同时查看AR31与AR28之间的isis邻居是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# isis进程信息
&amp;lt;AR31&amp;gt;display isis brief 

                     ISIS Protocol Information for ISIS(1)
                     -------------------------------------
SystemId: 0000.0000.0031      System Level: L1    
Area-Authentication-mode: NULL
Domain-Authentication-mode: NULL
Ipv6 is not enabled
ISIS is in invalid restart status
ISIS is in protocol hot standby state: Real-Time Backup

Interface: 10.5.234.31(GE0/0/1)
Cost: L1 10        L2 10                Ipv6 Cost: L1 10   L2 10   
State: IPV4 Up                          IPV6 Down
Type: BROADCAST                         MTU: 1497      
Priority: L1 64   L2 64   
Timers:     Csnp: L1 10    L2 10    ,Retransmit: L12 5   , Hello: L1 10 L2 10  ,
 
Hello Multiplier: L1 3    L2 3     , LSP-Throttle Timer: L12 50  

Interface: 10.5.231.31(GE0/0/2)
Cost: L1 10        L2 10                Ipv6 Cost: L1 10   L2 10   
State: IPV4 Up                          IPV6 Down
Type: BROADCAST                         MTU: 1497      
Priority: L1 64   L2 64   
Timers:     Csnp: L1 10    L2 10    ,Retransmit: L12 5   , Hello: L1 10 L2 10  ,
 
Hello Multiplier: L1 3    L2 3     , LSP-Throttle Timer: L12 50  

Interface: 10.5.1.31(Loop0)
Cost: L1 0         L2 0                 Ipv6 Cost: L1 0    L2 0    
State: IPV4 Up                          IPV6 Down
Type: P2P                               MTU: 1500      
Priority: L1 64   L2  64   
Timers:     Csnp: L12 10  , Retransmit: L12 5   , Hello: 10  ,
Hello Multiplier: 3            , LSP-Throttle Timer: L12 50  

# isis邻居
&amp;lt;AR31&amp;gt;display isis peer 

                          Peer information for ISIS(1)

  System Id     Interface          Circuit Id       State HoldTime Type     PRI
-------------------------------------------------------------------------------
0000.0000.0034  GE0/0/1            0000.0000.0031.01 Up   25s      L1       64 

Total Peer(s): 1

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR31的isis级别为level-1，配置错误，同时AR31上无法产生level-2的lsp，因此，无法与AR28之间建立level-2级别的isis邻居关系。

2.6 结论
通过以上分析，故障的根本原因为AR31的isis级别配置错误，导致无法与AR28之间建立level-2级别的isis邻居。

三、故障解决
3.1 AR31的isis级别配置错误，需要在AR31上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
is-level level-1-2 //修改正确的isis级别

执行完以上命令需要在AR31上执行以下命令进程检查：
display isis peer //查看AR34与AR28之间是否建立level-2级别的邻居
在AR34上执行以下命令进程检查：
display isis lsdb verbose //查看是否存在ATT位置1的来自AR31的lsp
display ip routing-table //查看等价默认路由情况，故障是否排除

3.2 如果执行以上命令未能排除故障，则存在以下高可能性故障：
与AR31和AR28之间的isis邻居相关：
3.2.1 AR28的GigabitEthernet 0/0/2没有使能isis，需要在AR28上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/2 //进入接口视图
display this //查看当前配置
isis enable {isis进程id} //接口下使能isis

3.2.2 AR28的isis进程下配置domain认证(AR31没有配置)，需要在AR28上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo domain-authentication-mode //删除domain认证

3.2.3 AR28与AR31互联接口下的mtu不一致，需要在AR28上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/2 //进入接口视图
display this //查看当前配置
mtu 1497 //修改AR28的接口下mtu值，保持与AR31一致

3.2.4 AR28与AR31互联接口下链路类型不一致，需要在AR28上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/2 //进入接口视图
display this //查看当前配置
undo isis circuit-type //删除接口下链路类型的设置，保持与AR31一致的广播类型

3.2.5 AR28与AR31互联接口下isis认证不一致，需要在AR28和AR31上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/2 //进入接口视图
display this //查看当前配置
undo isis authentication-mode //删除接口认证

3.2.6 AR28与AR31的isis进程下的cost类型不一致，需要在AR28和AR31上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
cost-style {相同的cost类型} //修改成相同的cost类型

执行完以上命令需要在AR31上执行以下命令进程检查：
display isis peer //查看AR34与AR28之间是否建立level-2级别的邻居
在AR34上执行以下命令进程检查：
display isis lsdb verbose //查看是否存在ATT位置1的来自AR31的lsp
display ip routing-table //查看等价默认路由情况，故障是否排除

与不能产生ATT位置1的lsp有关：
3.2.7 AR31在isis进程下配置ATT位不置1的命令，需要在AR31上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo attached-bit advertise //删除ATT位不置1的命令

3.2.8 AR34在isis进程下针对下一跳配置不同的weight，需要在AR34上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo nexthop 10.5.x.x //删除针对下一跳配置不同的weight

3.2.9 AR34在isis进程下配置最大负载为1，需要在AR34上执行以下命令：
system-view //进入系统视图
isis {isis进程ID} //进入isis进程下
display this //查看当前配置
undo maximum load-balancing //删除最大负载设置

执行完以上命令需要在AR34上执行以下命令进程检查：
display isis lsdb verbose //查看是否存在ATT位置1的来自AR31的lsp
display ip routing-table //查看等价默认路由情况，故障是否排除

3.3 如果执行以上命令成功排除故障，则需要在执行过命令的设备上继续执行以下命令：
return //返回用户视图
save //保存修改之后的配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场故障排除，同时拨打华为400服务热线请求华为专家的协助，谢谢！

&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TAC-6</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-tac-5/"" data-c="
          &lt;h1 id=&#34;诊断五&#34;&gt;诊断五&lt;/h1&gt;
&lt;p&gt;AR32无法访问isis区域部分设备&lt;/p&gt;
&lt;h2 id=&#34;tac5-1变种1&#34;&gt;TAC5-1:变种1&lt;/h2&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

AR30的g0/0/0接口的出方向上存在着针对AR32的loopback0接口流量的过滤规则。

二、故障分析
2.1 故障重现
由于未确定不能访问哪些设备，需要进行逐一测试，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.134.30
  PING 10.5.134.30: 56  data bytes, press CTRL_C to break
    Reply from 10.5.134.30: bytes=56 Sequence=1 ttl=254 time=40 ms
    Reply from 10.5.134.30: bytes=56 Sequence=2 ttl=254 time=30 ms
    Reply from 10.5.134.30: bytes=56 Sequence=3 ttl=254 time=30 ms
    Reply from 10.5.134.30: bytes=56 Sequence=4 ttl=254 time=40 ms
    Reply from 10.5.134.30: bytes=56 Sequence=5 ttl=254 time=20 ms

  --- 10.5.134.30 ping statistics ---
    5 packet(s) transmitted
    5 packet(s) received
    0.00% packet loss
    round-trip min/avg/max = 20/32/40 ms
....省略部分能够正常通信的测试结果
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.1.34
  PING 10.5.1.34: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.1.34 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.134.34
  PING 10.5.134.34: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.134.34 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32无法访问AR34的g0/0/0接口和loopback0接口，故障存在。

2.2 检查路由表
AR32想要访问上述两个接口，首先需要在路由表中存在上述接口地址的路由，检查AR32的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 18       Routes : 18       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.27/32  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.28/32  OSPF    10   1           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.30/32  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.31/32  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.32/32  Direct  0    0           D   127.0.0.1       LoopBack0
      10.5.1.34/32  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.128.0/24  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.134.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.230.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.231.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.232.0/24  Direct  0    0           D   10.5.232.32     GigabitEthernet
0/0/0
    10.5.232.32/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.232.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.234.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32的路由表中存在AR34的上述两个接口地址的路由，同时存在AR28的loopback0接口的路由，这说明AR28和AR32的ospf邻居正常，并且AR28上正确的将isis区域的路由引入ospf进程下。

2.3 检查AR34的路由表
通信是双向的，不仅需要AR32上存在对方的路由，同样需要AR34上存在AR32的loopback0接口地址的路由，查看AR34的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 16       Routes : 17       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

        0.0.0.0/0   ISIS-L1 15   10          D   10.5.234.31     GigabitEthernet
0/0/1
                    ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.30/32  ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.31/32  ISIS-L1 15   10          D   10.5.234.31     GigabitEthernet
0/0/1
      10.5.1.34/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.134.0/24  Direct  0    0           D   10.5.134.34     GigabitEthernet
0/0/0
    10.5.134.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.134.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.230.0/24  ISIS-L1 15   20          D   10.5.134.30     GigabitEthernet
0/0/0
     10.5.231.0/24  ISIS-L1 15   20          D   10.5.234.31     GigabitEthernet
0/0/1
     10.5.234.0/24  Direct  0    0           D   10.5.234.34     GigabitEthernet
0/0/1
    10.5.234.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34上并不存在AR32的loopback0接口地址的路由，但是存在两条等价默认路由，分别指向AR31和AR30。

2.4 查看AR31的路由表
由于AR30无法的登录，只能查看AR31的路由表中是否存在AR32的loopback0接口地址的路由，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR31&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 20       Routes : 20       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.27/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.28/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.30/32  ISIS-L1 15   20          D   10.5.234.34     GigabitEthernet
0/0/1
      10.5.1.31/32  Direct  0    0           D   127.0.0.1       LoopBack0
      10.5.1.32/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.34/32  ISIS-L1 15   10          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.128.0/24  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
     10.5.134.0/24  ISIS-L1 15   20          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.230.0/24  ISIS-L1 15   30          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.231.0/24  Direct  0    0           D   10.5.231.31     GigabitEthernet
0/0/2
    10.5.231.31/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/2
   10.5.231.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/2
     10.5.232.0/24  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
     10.5.234.0/24  Direct  0    0           D   10.5.234.31     GigabitEthernet
0/0/1
    10.5.234.31/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR31的路由表中存在AR32的loopback0接口地址的路由，这说明AR34与AR30、AR31之间的level-1级别的isis邻居正常，AR28与AR30、AR31之间的level-2级别的isis邻居正常，AR28上将ospf区域路由成功进入isis进程。至此，路由控制层面不存在问题，下面需要检查数据层面的问题。

2.5 不带源进行路由追踪
在AR34上，以AR34上无法访问的两个接口地址为目的地址，进行路由追踪，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;tracert 10.5.134.34

 traceroute to  10.5.134.34(10.5.134.34), max hops: 30 ,packet length: 40,press 
CTRL_C to break 

 1 10.5.232.28 30 ms  20 ms  10 ms 

 2 10.5.230.30 30 ms  20 ms  30 ms 

 3 10.5.134.34 50 ms  20 ms  20 ms 

&amp;lt;AR32&amp;gt;tracert 10.5.1.34

 traceroute to  10.5.1.34(10.5.1.34), max hops: 30 ,packet length: 40,press CTRL
_C to break 

 1 10.5.232.28 30 ms  20 ms  30 ms 

 2 10.5.230.30 20 ms 10.5.231.31 30 ms 10.5.230.30 20 ms 

 3 10.5.234.34 30 ms 10.5.134.34 40 ms 10.5.234.34 30 ms 
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34在不带源地址的情况下能够正常访问上述两个接口，并且访问AR34的loopback0接口的两条等价路由均正常。

2.6 带源进行路由追踪
在AR34上，以loopback0接口地址为源地址，以AR34上无法访问的两个接口地址为目的地址，进行路由追踪，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;tracert -a 10.5.1.32 10.5.134.34

 traceroute to  10.5.134.34(10.5.134.34)
, max hops: 30 ,packet length: 40,press CTRL_C to break 

 1 10.5.232.28 20 ms  20 ms  30 ms 

 2 10.5.230.30 30 ms  20 ms  20 ms 

 3  *  *  * 

&amp;lt;AR32&amp;gt;tracert -a 10.5.1.32 10.5.1.34

 traceroute to  10.5.1.34(10.5.1.34), max hops: 30 ,packet length: 40,press CTRL
_C to break 

 1 10.5.232.28 20 ms  20 ms  10 ms 

 2 10.5.231.31 40 ms 10.5.230.30 30 ms 10.5.231.31 20 ms 

 3  * 10.5.234.34 40 ms  * 

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34在带有源地址的情况下进行路由追踪，追踪AR34的g0/0/0接口时，在第三跳出现无法正常回显的情况，追踪loopback0接口时，第三跳中两条等价的默认路由，经过AR30的那条没有正常回显。种种迹象表明AR34与AR30之间存在针对AR32的loopback0接口的流量过滤

2.7 检查AR34的g0/0/0接口测试前后的接收报文情况
在AR32以loopback0接口地址为源地址，以AR34的g0/0/0接口地址为目的地址，执行ping测试，观察测试前后AR34的g0/0/0接口下的接收报文情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# 测试前AR34的g0/0/0接口情况
&amp;lt;AR34&amp;gt;display interface GigabitEthernet 0/0/0
GigabitEthernet0/0/0 current state : UP
Line protocol current state : UP
Last line protocol up time : 2021-01-02 16:44:00 UTC-08:00
Description:HUAWEI, AR Series, GigabitEthernet0/0/0 Interface
Route Port,The Maximum Transmit Unit is 1500
Internet Address is 10.5.134.34/24
IP Sending Frames&#39; Format is PKTFMT_ETHNT_2, Hardware address is 00e0-fc83-528a
Last physical up time   : 2021-01-02 16:44:00 UTC-08:00
Last physical down time : 2021-01-02 16:43:50 UTC-08:00
Current system time: 2021-01-02 17:06:16-08:00
Port Mode: FORCE COPPER
Speed : 1000,  Loopback: NONE
Duplex: FULL,  Negotiation: ENABLE
Mdi   : AUTO
Last 300 seconds input rate 7576 bits/sec, 0 packets/sec
Last 300 seconds output rate 1208 bits/sec, 0 packets/sec
Input peak rate 12112 bits/sec,Record time: 2021-01-02 16:49:09
Output peak rate 7456 bits/sec,Record time: 2021-01-02 16:44:09

Input:  957 packets, 1245067 bytes
  Unicast:                  5,  Multicast:                 950
  Broadcast:                2,  Jumbo:                       0
  Discard:                  0,  Total Error:                 0

# 测试
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.1.34
  PING 10.5.1.34: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.1.34 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss

# 测试后AR34的g0/0/0接口情况
&amp;lt;AR34&amp;gt;display interface GigabitEthernet 0/0/0
GigabitEthernet0/0/0 current state : UP
Line protocol current state : UP
Last line protocol up time : 2021-01-02 16:44:00 UTC-08:00
Description:HUAWEI, AR Series, GigabitEthernet0/0/0 Interface
Route Port,The Maximum Transmit Unit is 1500
Internet Address is 10.5.134.34/24
IP Sending Frames&#39; Format is PKTFMT_ETHNT_2, Hardware address is 00e0-fc83-528a
Last physical up time   : 2021-01-02 16:44:00 UTC-08:00
Last physical down time : 2021-01-02 16:43:50 UTC-08:00
Current system time: 2021-01-02 17:07:15-08:00
Port Mode: FORCE COPPER
Speed : 1000,  Loopback: NONE
Duplex: FULL,  Negotiation: ENABLE
Mdi   : AUTO
Last 300 seconds input rate 7576 bits/sec, 0 packets/sec
Last 300 seconds output rate 1208 bits/sec, 0 packets/sec
Input peak rate 12112 bits/sec,Record time: 2021-01-02 16:49:09
Output peak rate 7456 bits/sec,Record time: 2021-01-02 16:44:09

Input:  1000 packets, 1301877 bytes
  Unicast:                  5,  Multicast:                 993
  Broadcast:                2,  Jumbo:                       0
  Discard:                  0,  Total Error:                 0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34的g0/0/0接口在Input方向上的Unicast报文数量在测试前后一致，即AR34上并没有收到单播测试报文，因此断定流量过滤策略的位置在AR30的g0/0/0接口下。

2.8 检查是否存在反向流量策略
在AR34上以loopback0接口地址为源，以AR32的loopback0接口地址为目的，检查是否存在反方向的流量过滤，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;tracert -a 10.5.1.34 10.5.1.32

 traceroute to  10.5.1.32(10.5.1.32), max hops: 30 ,packet length: 40,press CTRL
_C to break 

 1 10.5.234.31 20 ms  20 ms  20 ms 

 2 10.5.231.28 20 ms  30 ms 10.5.230.28 20 ms 

 3 10.5.232.32 20 ms  30 ms  30 ms 
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34能够成功访问AR32的loopback0接口地址的路由，并且两条等价默认路由均正常。

2.9 结论
通过以上分析，故障的根本原因为AR30的g0/0/0接口的出方向上存在着针对AR32的loopback0接口流量的过滤规则。


三、故障解决
3.1 AR30的g0/0/0接口的出方向上存在着针对AR32的loopback0接口流量的过滤规则，需要在AR30上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/0  //进入接口视图
display this  //查看当前配置
undo traffic-policy outbound  //删除出方向的流量过滤策略
undo traffic-filter outbound

执行完以上命令，需要在AR34上执行以下命令进行检查：
ping -a 10.5.1.32 10.5.1.34 //查看故障是否解决

3.2 如果执行以上命令未能排除故障，则存在以下高可能性故障：
3.2.1 AR34的g0/0/0接口下存在流量过滤策略
system-view //进入系统视图
interface GigabitEthernet 0/0/0  //进入接口视图
display this  //查看当前配置
undo traffic-policy outbound  //删除出方向的流量过滤策略
undo traffic-filter outbound
undo traffic-filter inbound
undo traffic-filter inbound

执行完以上命令，需要在AR34上执行以下命令进行检查：
ping -a 10.5.1.32 10.5.1.34 //查看故障是否解决

3.3 如果执行以上命令排除了故障，则需要在执行过命令的设备上继续执行以下命令：
return //返回用户视图
save //保存修改之后的配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助，谢谢！
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tac5-2变种2&#34;&gt;TAC5-2:变种2&lt;/h2&gt;
&lt;h2 id=&#34;解答-2&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

AR28的g0/0/2接口在出方向上配置了针对AR32的loopback0接口的流量过滤策略。

二、故障分析
2.1 故障重现
由于未知哪些设备无法访问，需要在AR32上逐一进行测试，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.230.30
  PING 10.5.230.30: 56  data bytes, press CTRL_C to break
    Reply from 10.5.230.30: bytes=56 Sequence=1 ttl=254 time=50 ms
    Reply from 10.5.230.30: bytes=56 Sequence=2 ttl=254 time=30 ms
    Reply from 10.5.230.30: bytes=56 Sequence=3 ttl=254 time=20 ms
    Reply from 10.5.230.30: bytes=56 Sequence=4 ttl=254 time=30 ms
    Reply from 10.5.230.30: bytes=56 Sequence=5 ttl=254 time=30 ms

  --- 10.5.230.30 ping statistics ---
    5 packet(s) transmitted
    5 packet(s) received
    0.00% packet loss
    round-trip min/avg/max = 20/32/50 ms
.......省略部分能够ping通的结果
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.231.31
  PING 10.5.231.31: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.231.31 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.1.31
  PING 10.5.231.31: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.231.31 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.234.31
  PING 10.5.231.31: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.231.31 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.234.34
  PING 10.5.231.31: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.231.31 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32无法访问AR31的所有接口和AR34的g0/0/1接口，故障存在。

2.2 检查AR32的路由表
AR32想要访问AR31的所有接口和AR34的g0/0/1接口，首先需要在路由表中有其路由，查看AR32的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 18       Routes : 18       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.27/32  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.28/32  OSPF    10   1           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.30/32  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.31/32  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.32/32  Direct  0    0           D   127.0.0.1       LoopBack0
      10.5.1.34/32  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.128.0/24  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.134.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.230.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.231.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.232.0/24  Direct  0    0           D   10.5.232.32     GigabitEthernet
0/0/0
    10.5.232.32/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.232.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.234.0/24  O_ASE   150  1           D   10.5.232.28     GigabitEthernet
0/0/0
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32的路由表中存在AR31的所有接口和AR34的g0/0/1接口的路由，并且存在AR28的loopback0接口的路由，表明与AR28的ospf邻居正常，并且AR28上正确的将isis区域的路由引入ospf进程中。

2.3 检查AR31和AR34的路由表
通信是双向的，不仅需要AR32的路由表中存在AR31的所有接口和AR34的g0/0/1接口的路由，同样需要AR31和AR34的路由表中存在AR32的loopback0接口地址的路由，检查AR31和AR34的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# AR31的路由表
&amp;lt;AR31&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 20       Routes : 20       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.27/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.28/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.30/32  ISIS-L1 15   20          D   10.5.234.34     GigabitEthernet
0/0/1
      10.5.1.31/32  Direct  0    0           D   127.0.0.1       LoopBack0
      10.5.1.32/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.34/32  ISIS-L1 15   10          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.128.0/24  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
     10.5.134.0/24  ISIS-L1 15   20          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.230.0/24  ISIS-L1 15   30          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.231.0/24  Direct  0    0           D   10.5.231.31     GigabitEthernet
0/0/2
    10.5.231.31/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/2
   10.5.231.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/2
     10.5.232.0/24  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
     10.5.234.0/24  Direct  0    0           D   10.5.234.31     GigabitEthernet
0/0/1
    10.5.234.31/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

# AR34的路由表
&amp;lt;AR34&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 16       Routes : 17       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

        0.0.0.0/0   ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
                    ISIS-L1 15   10          D   10.5.234.31     GigabitEthernet
0/0/1
      10.5.1.30/32  ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.31/32  ISIS-L1 15   10          D   10.5.234.31     GigabitEthernet
0/0/1
      10.5.1.34/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.134.0/24  Direct  0    0           D   10.5.134.34     GigabitEthernet
0/0/0
    10.5.134.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.134.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.230.0/24  ISIS-L1 15   20          D   10.5.134.30     GigabitEthernet
0/0/0
     10.5.231.0/24  ISIS-L1 15   20          D   10.5.234.31     GigabitEthernet
0/0/1
     10.5.234.0/24  Direct  0    0           D   10.5.234.34     GigabitEthernet
0/0/1
    10.5.234.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR31的路由表中存在AR32的loopback0接口地址的路由，AR34的路由表中虽然不存在，但是存在两条等价的默认路由，分别指向AR31和AR30，这表明AR34与AR31、AR30之间的level-1级别的isis邻居正常，AR28与AR31、AR30之间的level-2级别的isis邻居正常，AR28上正确的将ospf区域的路由引入isis进程下。至此，路由控制层面不存在问题，接下来需要检查数据层面的问题。

2.4 不带源进行路由追踪
在AR32上不带源追踪AR31的所有接口和AR34的g0/0/1接口的路由，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;tracert 10.5.231.31

 traceroute to  10.5.231.31(10.5.231.31), max hops: 30 ,packet length: 40,press 
CTRL_C to break 

 1 10.5.232.28 20 ms  20 ms  20 ms 

 2 10.5.231.31 30 ms  30 ms  30 ms 
&amp;lt;AR32&amp;gt;tracert 10.5.1.31

 traceroute to  10.5.1.31(10.5.1.31), max hops: 30 ,packet length: 40,press CTRL
_C to break 

 1 10.5.232.28 20 ms  30 ms  20 ms 

 2 10.5.231.31 20 ms  20 ms  20 ms 
&amp;lt;AR32&amp;gt;tracert 10.5.234.31

 traceroute to  10.5.234.31(10.5.234.31), max hops: 30 ,packet length: 40,press 
CTRL_C to break 

 1 10.5.232.28 30 ms  20 ms  20 ms 

 2 10.5.231.31 20 ms  20 ms  20 ms 
&amp;lt;AR32&amp;gt;tracert 10.5.234.34

 traceroute to  10.5.234.34(10.5.234.34), max hops: 30 ,packet length: 40,press 
CTRL_C to break 

 1 10.5.232.28 20 ms  30 ms  20 ms 

 2 10.5.231.31 20 ms  20 ms  20 ms 

 3 10.5.234.34 30 ms  20 ms  40 ms 
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32在不带源地址的情况下均能正常追踪到AR31的所有接口和AR34的g0/0/1接口的路由。

2.5 带源进行路由追踪
在AR32上以loopback0接口地址为源地址，追踪AR31的所有接口和AR34的g0/0/1接口的路由，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;tracert -a 10.5.1.32 10.5.231.31

 traceroute to  10.5.231.31(10.5.231.31)
, max hops: 30 ,packet length: 40,press CTRL_C to break 

 1 10.5.232.28 10 ms  10 ms  10 ms 

 2  *  *  * 
 
&amp;lt;AR32&amp;gt;tracert -a 10.5.1.32 10.5.1.31

 traceroute to  10.5.1.31(10.5.1.31), max hops: 30 ,packet length: 40,press CTRL
_C to break 

 1 10.5.232.28 20 ms  20 ms  30 ms 

 2  *  *  * 
 
&amp;lt;AR32&amp;gt;tracert -a 10.5.1.32 10.5.234.31

 traceroute to  10.5.234.31(10.5.234.31)
, max hops: 30 ,packet length: 40,press CTRL_C to break 

 1 10.5.232.28 20 ms  10 ms  10 ms 

 2  *  * 
 
&amp;lt;AR32&amp;gt;tracert -a 10.5.1.32 10.5.234.34

 traceroute to  10.5.234.34(10.5.234.34)
, max hops: 30 ,packet length: 40,press CTRL_C to break 

 1 10.5.232.28 10 ms  10 ms  10 ms 

 2  *  * 
&amp;quot;&amp;quot;&amp;quot;
结果显示，在AR32带源地址的情况下，路由追踪第二跳出现无法正常回显的状况，这表明AR28与AR31之间存在着针对AR32的loopback0接口的流量过滤策略。

2.6 查看AR31的g0/0/2接口在测试前后接收报文情况
在AR32上以loopback0接口地址为源地址，以AR31的g0/0/2接口地址为目的地址，执行ping测试，查看AR31的g0/0/2接口在测试前后的接收报文情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# 测试之前AR31的g0/0/2接口情况
&amp;lt;AR31&amp;gt;display interface GigabitEthernet 0/0/2
GigabitEthernet0/0/2 current state : UP
Line protocol current state : UP
Last line protocol up time : 2021-01-02 17:18:42 UTC-08:00
Description:HUAWEI, AR Series, GigabitEthernet0/0/2 Interface
Route Port,The Maximum Transmit Unit is 1500
Internet Address is 10.5.231.31/24
IP Sending Frames&#39; Format is PKTFMT_ETHNT_2, Hardware address is 00e0-fcba-5c14
Last physical up time   : 2021-01-02 17:18:42 UTC-08:00
Last physical down time : 2021-01-02 17:18:34 UTC-08:00
Current system time: 2021-01-02 18:02:14-08:00
Port Mode: COMMON COPPER
Speed : 1000,  Loopback: NONE
Duplex: FULL,  Negotiation: ENABLE
Mdi   : AUTO
Last 300 seconds input rate 1224 bits/sec, 0 packets/sec
Last 300 seconds output rate 7512 bits/sec, 0 packets/sec
Input peak rate 7624 bits/sec,Record time: 2021-01-02 17:18:48
Output peak rate 12344 bits/sec,Record time: 2021-01-02 17:24:43

Input:  309 packets, 407959 bytes
  Unicast:                 16,  Multicast:                 290
  Broadcast:                3,  Jumbo:                       0
  Discard:                  0,  Total Error:                 0
  
# 执行测试
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.231.31
  PING 10.5.231.31: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.231.31 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
# 测试之后AR31的g0/0/2接口情况
&amp;lt;AR31&amp;gt;display interface GigabitEthernet 0/0/2
GigabitEthernet0/0/2 current state : UP
Line protocol current state : UP
Last line protocol up time : 2021-01-02 17:18:42 UTC-08:00
Description:HUAWEI, AR Series, GigabitEthernet0/0/2 Interface
Route Port,The Maximum Transmit Unit is 1500
Internet Address is 10.5.231.31/24
IP Sending Frames&#39; Format is PKTFMT_ETHNT_2, Hardware address is 00e0-fcba-5c14
Last physical up time   : 2021-01-02 17:18:42 UTC-08:00
Last physical down time : 2021-01-02 17:18:34 UTC-08:00
Current system time: 2021-01-02 18:03:26-08:00
Port Mode: COMMON COPPER
Speed : 1000,  Loopback: NONE
Duplex: FULL,  Negotiation: ENABLE
Mdi   : AUTO
Last 300 seconds input rate 1224 bits/sec, 0 packets/sec
Last 300 seconds output rate 7504 bits/sec, 0 packets/sec
Input peak rate 7624 bits/sec,Record time: 2021-01-02 17:18:48
Output peak rate 12344 bits/sec,Record time: 2021-01-02 17:24:43

Input:  316 packets, 418557 bytes
  Unicast:                 16,  Multicast:                 297
  Broadcast:                3,  Jumbo:                       0
  Discard:                  0,  Total Error:                 0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR31的g0/0/2接口在测试前后input方向上的Unicast报文数量没变，表明AR31的g0/0/2接口没有收到单播测试报文，即流量过滤策略设置在了AR28的g0/0/2接口下。

2.7 查看是否存在反向流量过滤
在AR34上以loopback0接口地址为源地址，以AR32的loopback0接口地址为目的地址，查看是否存在反方向的流量过滤，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR34&amp;gt;ping -a 10.5.1.34 10.5.1.32
  PING 10.5.1.32: 56  data bytes, press CTRL_C to break
    Reply from 10.5.1.32: bytes=56 Sequence=1 ttl=253 time=40 ms
    Reply from 10.5.1.32: bytes=56 Sequence=2 ttl=253 time=30 ms
    Reply from 10.5.1.32: bytes=56 Sequence=3 ttl=253 time=40 ms
    Reply from 10.5.1.32: bytes=56 Sequence=4 ttl=253 time=30 ms
    Reply from 10.5.1.32: bytes=56 Sequence=5 ttl=253 time=30 ms

  --- 10.5.1.32 ping statistics ---
    5 packet(s) transmitted
    5 packet(s) received
    0.00% packet loss
    round-trip min/avg/max = 30/34/40 ms
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR34能够正常访问AR32的loopback0接口，即不存在反方向的流量过滤。

2.8 结论
通过以上分析，故障的根本原因为AR28的g0/0/2接口在出方向上配置了针对AR32的loopback0接口的流量过滤策略。

三、故障解决
3.1 AR28的g0/0/2接口在出方向上配置了针对AR32的loopback0接口的流量过滤策略，需要在AR28上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/2  //进入接口视图
display this  //查看当前配置
undo traffic-policy outbound  //删除流量过滤策略
undo traffic-filter outbound

执行完以上命令之后需要在AR32上执行以下命令进行检查：
ping -a 10.5.1.32 10.5.231.31 //检查故障是否排除
ping -a 10.5.1.32 10.5.1.31
ping -a 10.5.1.32 10.5.234.31
ping -a 10.5.1.32 10.5.234.34


3.2 如果执行以上命令未能排除故障，则存在以下高可能性：
3.2.1 AR31的g0/0/2、g0/0/1和AR34的g0/0/1接口下存在流量过滤
system-view //进入系统视图
interface xxx //进入接口视图
display this  //查看当前配置
undo traffic-policy outbound  //删除流量过滤策略
undo traffic-filter outbound
undo traffic-policy inbound
undo traffic-filter inbound

执行完以上命令之后需要在AR32上执行以下命令进行检查：
ping -a 10.5.1.32 10.5.231.31 //检查故障是否排除
ping -a 10.5.1.32 10.5.1.31
ping -a 10.5.1.32 10.5.234.31
ping -a 10.5.1.32 10.5.234.34


3.3 如果执行以上命令成功的排除故障，则需要在执行过命令的设备上继续执行以下命令：
return //返回用户视图
save //保存修改之后的配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助，谢谢！
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TAC-5</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-tac-4/"" data-c="
          &lt;h1 id=&#34;诊断四&#34;&gt;诊断四&lt;/h1&gt;
&lt;p&gt;AR32的loopback0无法访问ISIS区域内的任何设备&lt;/p&gt;
&lt;h2 id=&#34;tac4-1变种1&#34;&gt;TAC4-1:变种1&lt;/h2&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

1.1 AR28的ospf进程下没有引入isis或者引入错误的isis进程ID；
1.2 AR28的ospf进程下配置了外部路由汇总并加了关键字not-advertise，汇总后不通告；
1.3 AR28的ospf进程下使用filter-policy命令针对出方向的5类lsa进行了过滤；
1.4 AR28在GigabitEthernet0/0/0和GigabitEthernet2/0/0接口下配置了ospf filter-lsa-out ase。

二、故障分析
2.1 故障重现
AR32不能访问isis区域所有设备，为确定故障是否存在，需要在AR32上逐一进行测试，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.1.34
  PING 10.5.1.34: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.1.34 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
.....省略部分已经测试，但是无法ping通的结果
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32的loopback0接口确实无法访问isis区域的任何设备，故障确实存在。

2.2 检查路由表
AR32想要访问isis区域的设备，首先需要在路由表上存在ISIS区域设备的路由，查看AR32的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 11       Routes : 11       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.27/32  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.28/32  OSPF    10   1           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.32/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.128.0/24  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.232.0/24  Direct  0    0           D   10.5.232.32     GigabitEthernet
0/0/0
    10.5.232.32/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.232.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32上并不存在isis区域的任何路由，但是存在AR28的loopback0接口地址的路由，说明AR32与AR28之间的ospf邻居正常。

2.3 检查ospf的链路状态数据库
isis区域的路由数据ospf的外部路由，ospf传递外部路由使用5类lsa，查看AR32的ospf链路状态数据库中是否存在5类lsa，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ospf lsdb

	 OSPF Process 1 with Router ID 10.5.1.32
		 Link State Database 

		         Area: 0.0.0.1
 Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric
 Router    10.5.1.32       10.5.1.32          505  48    80000006       1
 Router    10.5.1.28       10.5.1.28          514  36    80000004       1
 Network   10.5.232.32     10.5.1.32          505  32    80000002       0
 Sum-Net   10.5.128.0      10.5.1.28          552  28    80000001       1
 Sum-Net   10.5.1.28       10.5.1.28          552  28    80000001       0
 Sum-Net   10.5.1.27       10.5.1.28          508  28    80000001       1
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32的链路状态数据库中不存在任何5类lsa。

2.4 查看AR27的ospf链路状态数据库
由于5类lsa是在整个区域内泛洪的，AR27和AR28之间同样运行ospf路由协议，查看AR27上是否存在5类lsa，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR27&amp;gt;display ospf lsdb 

	 OSPF Process 1 with Router ID 10.5.1.27
		 Link State Database 

		         Area: 0.0.0.0
 Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric
 Router    10.5.1.27       10.5.1.27          625  48    80000006       1
 Router    10.5.1.28       10.5.1.28          617  48    80000008       1
 Network   10.5.128.28     10.5.1.28          617  32    80000002       0
 Sum-Net   10.5.1.32       10.5.1.28          629  28    80000001       1
 Sum-Net   10.5.232.0      10.5.1.28          666  28    80000001       1
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR27上也不存在相应的5类lsa。目前推断是AR28上没有上将isis的路由引入ospf出现了问题。

2.5 查看AR34和AR31的路由表
通信是双向的，不仅需要AR32上存在isis区域设备的路由，同样需要isis区域设备上存在AR32的loopback0接口的路由，查看AR34和AR31的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# AR31的路由表
&amp;lt;AR31&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 20       Routes : 20       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.27/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.28/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.30/32  ISIS-L1 15   20          D   10.5.234.34     GigabitEthernet
0/0/1
      10.5.1.31/32  Direct  0    0           D   127.0.0.1       LoopBack0
      10.5.1.32/32  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
      10.5.1.34/32  ISIS-L1 15   10          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.128.0/24  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
     10.5.134.0/24  ISIS-L1 15   20          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.230.0/24  ISIS-L1 15   30          D   10.5.234.34     GigabitEthernet
0/0/1
     10.5.231.0/24  Direct  0    0           D   10.5.231.31     GigabitEthernet
0/0/2
    10.5.231.31/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/2
   10.5.231.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/2
     10.5.232.0/24  ISIS-L2 15   74          D   10.5.231.28     GigabitEthernet
0/0/2
     10.5.234.0/24  Direct  0    0           D   10.5.234.31     GigabitEthernet
0/0/1
    10.5.234.31/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

# AR34的路由表
&amp;lt;AR34&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 16       Routes : 17       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

        0.0.0.0/0   ISIS-L1 15   10          D   10.5.234.31     GigabitEthernet
0/0/1
                    ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.30/32  ISIS-L1 15   10          D   10.5.134.30     GigabitEthernet
0/0/0
      10.5.1.31/32  ISIS-L1 15   10          D   10.5.234.31     GigabitEthernet
0/0/1
      10.5.1.34/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.134.0/24  Direct  0    0           D   10.5.134.34     GigabitEthernet
0/0/0
    10.5.134.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.134.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.230.0/24  ISIS-L1 15   20          D   10.5.134.30     GigabitEthernet
0/0/0
     10.5.231.0/24  ISIS-L1 15   20          D   10.5.234.31     GigabitEthernet
0/0/1
     10.5.234.0/24  Direct  0    0           D   10.5.234.34     GigabitEthernet
0/0/1
    10.5.234.34/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.234.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR31的路由表中存在AR32的loopback0接口地址的路由，AR34上虽然不存在，但是存在两条指向AR31、AR30的等价默认路由，这说明AR34与AR30、AR31之间的level-1级别的isis邻居正常，AR28与AR30、AR31之间的level-2级别的isis邻居正常，AR28已经正确的将ospf区域的路由引入isis进程中。

2.6 结论
通过以上分析，说明AR28上的ospf没有将5类lsa发送给AR32，主要有以下4中原因：
2.6.1 AR28的ospf进程下没有引入isis或者引入错误的isis进程ID；
2.6.2 AR28的ospf进程下配置了外部路由汇总并加了关键字not-advertise，汇总后不通告；
2.6.3 AR28的ospf进程下使用filter-policy命令针对出方向的5类lsa进行了过滤；
2.6.4 AR28在GigabitEthernet0/0/0和GigabitEthernet2/0/0接口下配置了ospf filter-lsa-out ase。

三、故障解决
3.1 针对上述不同的问题，需要在AR28上执行不同的命令，详细情况如下：
3.1.1 AR28的ospf进程下没有引入isis或者引入错误的isis进程ID
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
display this //查看当前配置
import-route isis {正确的isis进程ID} //引入正确的isis进程

3.1.2 AR28的ospf进程下配置了外部路由汇总并加了关键字not-advertise，汇总后不通告
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
display this //查看当前配置
undo asbr-summary 10.5.0.0 255.255.0.0 //删除区域间路由汇总

3.1.3 AR28的ospf进程下使用filter-policy命令针对出方向的5类lsa进行了过滤
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
display this //查看当前配置
undo filte-policy export //删除路由过滤规则

3.1.4 AR28在GigabitEthernet0/0/0和GigabitEthernet2/0/0接口下配置了ospf filter-lsa-out ase
system-view //进入系统视图
interface xxx //进入接口视图
undo ospf filter-lsa-out ase //删除对5类lsa的过滤

执行完上述命令之后，需要在AR32上执行以下命令进行检查：
display ospf lsdb //查看是否存在5类lsa
display ip routing-table //查看是否存在isis区域设备的路由
ping -a 10.5.1.32 10.5.1.34 //查看故障是否排除
ping -a 10.5.1.32 10.5.1.31

3.2 如果执行上述命令未能排除故障，则存在以下高可能性故障：
3.2.1 AR28与AR32的ospf进程下存在路由过滤
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
undo filte-policy export //删除路由过滤规则
undo filte-policy import

3.2.2 AR28与AR27、AR32互联接口、以及isis区域设备接口下存在流量过滤
display traffic-policy applied-record //查看调用流量过滤规则的接口
display acl all
system-view //进入系统视图
interface {调用流量过滤策略的接口ID} //进入接口视图
undo traffic-policy inbound //删除流量过滤策略
undo traffic-policy outbound
undo traffic-filter inbound
undo traffic-filter outbound

执行完上述命令之后，需要在AR32上执行以下命令进行检查：
display ospf lsdb //查看是否存在5类lsa
display ip routing-table //查看是否存在isis区域设备的路由
ping -a 10.5.1.32 10.5.1.34 //查看故障是否排除
ping -a 10.5.1.32 10.5.1.31

3.3 如果执行上述命令成功测排除故障，则需要继续在执行过命令的设备上继续执行以下命令：
return //回到用户视图
save //保存当前配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助，谢谢！
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tac4-2变种2&#34;&gt;TAC4-2:变种2&lt;/h2&gt;
&lt;h2 id=&#34;解答-2&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# AR27上存在5类lsa，删除相关的可能性
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TAC-4</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-tac-3/"" data-c="
          &lt;h1 id=&#34;诊断三&#34;&gt;诊断三&lt;/h1&gt;
&lt;p&gt;AR32无法访问AR28的loopback0口&lt;/p&gt;
&lt;h2 id=&#34;tac3-1变种1&#34;&gt;TAC3-1:变种1&lt;/h2&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;AR32无法访问AR28
一、故障根因

1.1 AR28在ospf的区域0中配置了区域间路由汇总并加了关键字not-advertise，汇总后不通告；
1.2 AR28在ospf的区域中使用filter命令针对loopback0接口的3类lsa进行过滤，可以配置在区域0的出方向或者区域1的入方向；
1.3 AR28在GigabitEthernet2/0/0接口下配置ospf filter-lsa-out summary acl xxx，过去掉3类lsa。

二、故障分析
2.1 故障重现
在AR32上以loopback0接口地址为源地址，测试与AR28的loopback0接口的连通性，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.1.28
  PING 10.5.1.28: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.1.28 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32与AR28的loopback0接口之间的通信存在问题。

2.2 检查路由表
AR32要想访问AR28的loopback0接口，首先需要爱路由表中存在其路由，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 10       Routes : 10       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.27/32  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
      10.5.1.32/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.128.0/24  OSPF    10   2           D   10.5.232.28     GigabitEthernet
0/0/0
     10.5.232.0/24  Direct  0    0           D   10.5.232.32     GigabitEthernet
0/0/0
    10.5.232.32/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.232.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32的路由表中不存在AR28的loopback0接口地址的路由。

2.3 查看ospf邻居
由于AR28与AR32之间运行的是ospf路由协议，检查AR28与AR32之间的ospf邻居是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ospf peer brief 

	 OSPF Process 1 with Router ID 10.5.1.32
		  Peer Statistic Information
 ----------------------------------------------------------------------------
 Area Id          Interface                        Neighbor id      State    
 0.0.0.1          GigabitEthernet0/0/0             10.5.1.28        Full        
 ----------------------------------------------------------------------------
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32与AR28之间建立了正常的ospf邻居关系。

2.4 检查ospf链路状态数据库
ospf要想计算出相应的路由，首先需要收到相应的lsa，查看AR32的ospf链路状态数据库中是否存在相应的lsa，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ospf lsdb

	 OSPF Process 1 with Router ID 10.5.1.32
		 Link State Database 

		         Area: 0.0.0.1
 Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric
 Router    10.5.1.32       10.5.1.32           34  48    80000007       1
 Router    10.5.1.28       10.5.1.28           44  36    80000005       1
 Network   10.5.232.32     10.5.1.32           34  32    80000003       0
 Sum-Net   10.5.128.0      10.5.1.28           83  28    80000002       1
 Sum-Net   10.5.1.27       10.5.1.28           51  28    80000002       1
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32上只存在AR28发送的1类lsa。

2.5 查看1类lsa的详细信息
在AR34上查看接收到AR28发送的1类lsa的详细信息，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;display ospf lsdb router 10.5.1.28

	 OSPF Process 1 with Router ID 10.5.1.32
		         Area: 0.0.0.1
		 Link State Database 


  Type      : Router
  Ls id     : 10.5.1.28
  Adv rtr   : 10.5.1.28  
  Ls age    : 128 
  Len       : 36 
  Options   :  ASBR  ABR  E  
  seq#      : 80000005 
  chksum    : 0xa126
  Link count: 1
   * Link ID: 10.5.232.32  
     Data   : 10.5.232.28  
     Link Type: TransNet     
     Metric : 1
&amp;quot;&amp;quot;&amp;quot;
结果显示，这条lsa中只存在描述TransNet类型的AR28的GigabitEthernet2/0/0，并不存在AR28的loopback0接口的任何描述信息。

2.6 查看AR27的ospf链路状态数据库和相应的lsa信息
AR27与AR28之间也运行ospf路由协议，为确认AR28是否将loopback0接口宣告进ospf，需要查看AR27的链路状态数据库进行确认，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# AR27的ospf链路状态数据库
&amp;lt;AR27&amp;gt;display ospf lsdb 

	 OSPF Process 1 with Router ID 10.5.1.27
		 Link State Database 

		         Area: 0.0.0.0
 Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric
 Router    10.5.1.27       10.5.1.27          338  48    80000008       1
 Router    10.5.1.28       10.5.1.28          338  48    80000007       1
 Network   10.5.128.27     10.5.1.27          338  32    80000002       0
 Sum-Net   10.5.1.32       10.5.1.28          332  28    80000002       1
 Sum-Net   10.5.232.0      10.5.1.28          370  28    80000002       1
 

		 AS External Database
 Type      LinkState ID    AdvRouter          Age  Len   Sequence   Metric
 External  10.5.230.0      10.5.1.28          376  36    80000002       1
 External  10.5.231.0      10.5.1.28          376  36    80000002       1
 External  10.5.1.31       10.5.1.28          356  36    80000002       1
 External  10.5.1.30       10.5.1.28          356  36    80000002       1
 External  10.5.1.34       10.5.1.28          356  36    80000002       1
 External  10.5.134.0      10.5.1.28          356  36    80000002       1
 External  10.5.234.0      10.5.1.28          356  36    80000002       1

# AR27上收到的AR28发送的1类lsa详情
&amp;lt;AR27&amp;gt;display ospf lsdb router 10.5.1.28 

	 OSPF Process 1 with Router ID 10.5.1.27
		         Area: 0.0.0.0
		 Link State Database 


  Type      : Router
  Ls id     : 10.5.1.28
  Adv rtr   : 10.5.1.28  
  Ls age    : 436 
  Len       : 48 
  Options   :  ASBR  ABR  E  
  seq#      : 80000007 
  chksum    : 0x84da
  Link count: 2
   * Link ID: 10.5.128.27  
     Data   : 10.5.128.28  
     Link Type: TransNet     
     Metric : 1
   * Link ID: 10.5.1.28    
     Data   : 255.255.255.255 
     Link Type: StubNet      
     Metric : 0 
     Priority : Medium
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR27上不经存在AR28发送的1类lsa，并且该1类lsa除了存在描述TransNet类型的GigabitEthernet0/0/0接口信息，还存在描述StubNet类型的loopback0接口信息，这表明AR28上已经将loopback0接口宣告进区域0中。（AR28的GigabitEthernet0/0/0接口地址为10.5.128.28）

2.7 检查AR28的路由表中是否存在AR32的loopback0接口地址的路由
通信是双向的，在AR32上，以loopback0接口地址为源地址，测试与AR28的GigabitEthernet0/0/0接口的通信情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR32&amp;gt;ping -a 10.5.1.32 10.5.128.28
  PING 10.5.128.28: 56  data bytes, press CTRL_C to break
    Reply from 10.5.128.28: bytes=56 Sequence=1 ttl=255 time=30 ms
    Reply from 10.5.128.28: bytes=56 Sequence=2 ttl=255 time=10 ms
    Reply from 10.5.128.28: bytes=56 Sequence=3 ttl=255 time=20 ms
    Reply from 10.5.128.28: bytes=56 Sequence=4 ttl=255 time=20 ms
    Reply from 10.5.128.28: bytes=56 Sequence=5 ttl=255 time=20 ms

  --- 10.5.128.28 ping statistics ---
    5 packet(s) transmitted
    5 packet(s) received
    0.00% packet loss
    round-trip min/avg/max = 10/20/30 ms
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR32的loopback0接口能够正常访问AR28的GigabitEthernet0/0/0，这也表明AR32的路由表中存在AR28的loopback0接口地址的路由。

2.8 结论
通过以上分析，AR32和AR28处于不同的ospf区域，ospf不同区域间的路由传递使用3类lsa，而AR32上并不存在AR28发送的3类lsa，说明AR28过滤掉发往AR32的3类lsa，可以通过以下3种方式实现：
2.8.1 AR28在ospf的区域0中配置了区域间路由汇总并加了关键字not-advertise，汇总后不通告；
2.8.2 AR28在ospf的区域中使用filter命令针对loopback0接口的3类lsa进行过滤，可以配置在区域0的出方向或者区域1的入方向；
2.8.3 AR28在GigabitEthernet2/0/0接口下配置ospf filter-lsa-out summary acl xxx，过去掉3类lsa。

三、故障解决
3.1 针对不同的故障原因，需要在AR28上执行不同的命令，详情如下：
3.1.1 AR28在ospf的区域0中配置了区域间路由汇总并加了关键字not-advertise
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
area 0 //进入区域0
abr-summary 10.5.1.28 255.255.255.255 //删除not-advertise关键字

3.1.2 AR28在ospf的区域中使用filter命令针对loopback0接口的3类lsa进行过滤，可以配置在区域0的出方向或者区域1的入方向；
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
area 0 //进入区域0
undo filter export //删除出方向针对3类lsa的过滤
area 1 //进入区域1
undo filter import //删除入方向针对3类lsa的过滤

3.1.3 AR28在GigabitEthernet2/0/0接口下配置ospf filter-lsa-out summary acl xxx，过去掉3类lsa。
system-view //进入系统视图
interface GigabitEthernet 2/0/0 //进入接口视图
display this //查看当前配置
undo ospf filter-lsa-out //删除接口下对3类lsa的过滤

执行完以上命令之后，需要在AR32上执行以下命令进行检查：
display ip routing-table //查看路由表中是否存在AR28的loopback0接口的路由
ping -a 10.5.1.32 10.5.1.28 //查看故障是否解决

3.2 如果执行以上命令未能排除故障，则存在以下高可能性故障：
3.2.1 AR28或者AR32的ospf进程下存在路由过滤，需要在AR28或者AR32上执行以下命令：
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
display this //查看当前配置
undo filter-policy import //删除路由过滤策略
undo filter-policy export

3.2.2 AR28和AR32互联接口下存在流量过滤，需要在AR28或者AR32上执行以下命令：
system-view //进入系统视图
interface {AR28和AR32互联接口ID} //进入接口视图
undo traffic-policy outbound //删除流量过滤策略
undo traffic-policy inbound
undo traffic-filter outbound
undo traffic-filter inbound

执行完以上命令之后，需要在AR32上执行以下命令进行检查：
display ip routing-table //查看路由表中是否存在AR28的loopback0接口的路由
ping -a 10.5.1.32 10.5.1.28 //查看故障是否解决

3.3 如果通过执行以上命令成功排除故障，则需要在执行过命令的设备上继续执行以下命令：
return //返回用户视图
save //保存修改之后的配置

3.4 如果通过执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助，谢谢！
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tac3-2变种2&#34;&gt;TAC3-2:变种2&lt;/h2&gt;
&lt;h2 id=&#34;解答-2&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 排障方法见变种1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tac3-3变种3&#34;&gt;TAC3-3:变种3&lt;/h2&gt;
&lt;h2 id=&#34;解答-3&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 排障方法见变种1
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TAC-3</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-tac-2/"" data-c="
          &lt;h1 id=&#34;诊断二&#34;&gt;诊断二&lt;/h1&gt;
&lt;p&gt;AR29的loopback0口无法访问AR33的loopback0口&lt;/p&gt;
&lt;h2 id=&#34;tac2-1变种1&#34;&gt;TAC2-1:变种1&lt;/h2&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

AR29与AR33之间的ospf的hello时间不一致、ospf的区域类型不一致导致AR29与AR33之间无法建立ospf邻居，从而AR29与AR33之间的loopback0接口无法正常通信。

二、故障分析
2.1 故障重现
在AR29上，测试AR29和AR33的loopback0接口之间的通信情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;ping -a 10.5.1.29 10.5.1.33
  PING 10.5.1.33: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.1.33 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29无法访问AR33的loopback0接口，故障确实存在。

2.2 检查路由表
AR29想要访问AR33的loopback0接口，首先需要在路由表中存在对方的路由，查看AR29的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 11       Routes : 11       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.29/32  Direct  0    0           D   127.0.0.1       LoopBack0
     10.5.128.0/24  Direct  0    0           D   10.5.128.29     GigabitEthernet
0/0/0
    10.5.128.29/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.128.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.233.0/24  Direct  0    0           D   10.5.233.29     GigabitEthernet
0/0/1
    10.5.233.29/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.233.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29的路由表中并不存在AR33的loopback0接口地址的路由。

2.3 检查ospf邻居
由于AR33之间运行ospf路由协议，查看AR29与AR33的ospf邻居是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display ospf peer brief 

	 OSPF Process 1 with Router ID 10.5.1.29
		  Peer Statistic Information
 ----------------------------------------------------------------------------
 Area Id          Interface                        Neighbor id      State    
 ----------------------------------------------------------------------------
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29上并不存在AR33的ospf邻居。

2.4 检查接口宣告情况
查看AR29是否将相关接口宣告进ospf区域2中，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display ospf interface all

	 OSPF Process 1 with Router ID 10.5.1.29
		 Interfaces 

 Area: 0.0.0.0          (MPLS TE not enabled)

 Interface: 10.5.128.29 (GigabitEthernet0/0/0)
 Cost: 1       State: DR        Type: Broadcast    MTU: 1500  
 Priority: 1
 Designated Router: 10.5.128.29
 Backup Designated Router: 0.0.0.0
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 
 
 Area: 0.0.0.2          (MPLS TE not enabled)

 Interface: 10.5.233.29 (GigabitEthernet0/0/1)
 Cost: 1       State: DR        Type: Broadcast    MTU: 1500  
 Priority: 1
 Designated Router: 10.5.233.29
 Backup Designated Router: 0.0.0.0
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 

 Interface: 10.5.1.29 (LoopBack0)
 Cost: 0       State: P-2-P     Type: P2P       MTU: 1500  
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29已经将与AR33的互联接口GigabitEthernet0/0/1宣告进ospf区域2中，同时也将LoopBack0接口宣告进区域2中。

2.5 获取AR33三层地址
ospf邻居的建立依赖三层的正常通信，检查AR33与AR29之间的三层通信是否正常，检查三层的连通性首先需要回去对方的三层地址，查看ARP列表中是否存在或者查看lldp邻居，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display arp
IP ADDRESS      MAC ADDRESS     EXPIRE(M) TYPE        INTERFACE   VPN-INSTANCE 
                                          VLAN/CEVLAN PVC                      
------------------------------------------------------------------------------
10.5.128.29     00e0-fcc1-1b22            I -         GE0/0/0
10.5.233.29     00e0-fcc1-1b23            I -         GE0/0/1
------------------------------------------------------------------------------
Total:3         Dynamic:1       Static:0     Interface:2   

&amp;lt;AR29&amp;gt;display lldp neighbor 
Error: Global LLDP is not enabled.
&amp;quot;&amp;quot;&amp;quot;
结果显示，ARP列表中并不存在AR33的三层地址，AR29上也并未开启LLDP。

2.6 检查ospf错误情况
在AR29上查看AR29与AR33互联接口下的ospf报错情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display ospf error interface GigabitEthernet 0/0/1

	 OSPF Process 1 with Router ID 10.5.1.29
		 OSPF error statistics 

 Interface: GigabitEthernet0/0/1 (10.5.233.29)
General packet errors:
 0     : Bad version                    0     : Bad checksum
 0     : Bad area id                    0     : Bad authentication type
 0     : Bad authentication key         0     : Unknown neighbor
 0     : Bad net segment                0     : Extern option mismatch
 0     : Router id confusion

HELLO packet errors:
 0     : Netmask mismatch               56    : Hello timer mismatch
 0     : Dead timer mismatch            0     : Invalid Source Address

DD packet errors:
 0     : MTU option mismatch

LS REQ packet errors:
 0     : Bad request

LS UPD packet errors:
 0     : LSA checksum bad

Receive Grace LSA errors:
 0     : Number of invalid LSAs         0     : Number of policy failed LSAs
 0     : Number of wrong period LSAs

&amp;quot;&amp;quot;&amp;quot;
结果显示，“56    : Hello timer mismatch”表明AR29与AR33的ospf的hello时间不一致。

2.7 查看调试信息
由于AR33无法登陆，只能在AR29上查看调试信息来确认AR33与AR29之间的ospf的hello时间是否一致，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# 开启调试模式
&amp;lt;AR29&amp;gt;terminal monitor 
Info: Current terminal monitor is on.
&amp;lt;AR29&amp;gt;terminal debugging 
Info: Current terminal debugging is on.

# 查看调试信息
&amp;lt;AR29&amp;gt;debugging ospf packet hello interface GigabitEthernet 0/0/1

# AR29给发送的hello报文
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.1-08:00 AR29 RM/6/RMDEBUG:
 FileID: 0xd0178025 Line: 559 Level: 0x20
 OSPF 1: SEND Packet. Interface: GigabitEthernet0/0/1
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.2-08:00 AR29 RM/6/RMDEBUG:  Source Address: 10.5.233.29

&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.3-08:00 AR29 RM/6/RMDEBUG:  Destination Address: 224.0.
0.5
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.4-08:00 AR29 RM/6/RMDEBUG:  Ver# 2, Type: 1 (Hello)
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.5-08:00 AR29 RM/6/RMDEBUG:  Length: 44, Router: 10.5.1.
29
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.6-08:00 AR29 RM/6/RMDEBUG:  Area: 0.0.0.2, Chksum: 0
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.7-08:00 AR29 RM/6/RMDEBUG:  AuType: 02
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.8-08:00 AR29 RM/6/RMDEBUG:  Key(ascii): * * * * * * * *

&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.9-08:00 AR29 RM/6/RMDEBUG:  Net Mask: 255.255.255.0
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.10-08:00 AR29 RM/6/RMDEBUG:  Hello Int: 10, Option: _E_

&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.11-08:00 AR29 RM/6/RMDEBUG:  Rtr Priority: 1, Dead Int:
 40
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.12-08:00 AR29 RM/6/RMDEBUG:  DR: 10.5.233.29
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.13-08:00 AR29 RM/6/RMDEBUG:  BDR: 0.0.0.0
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:04:51.856.14-08:00 AR29 RM/6/RMDEBUG:  # Attached Neighbors: 0

# AR33给发送的hello报文  
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.1-08:00 AR29 RM/6/RMDEBUG:
 FileID: 0xd0178024 Line: 2236 Level: 0x20
 OSPF 1: RECV Packet. Interface: GigabitEthernet0/0/1
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.2-08:00 AR29 RM/6/RMDEBUG:  Source Address: 10.5.233.33

&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.3-08:00 AR29 RM/6/RMDEBUG:  Destination Address: 224.0.
0.5
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.4-08:00 AR29 RM/6/RMDEBUG:  Ver# 2, Type: 1 (Hello)
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.5-08:00 AR29 RM/6/RMDEBUG:  Length: 44, Router: 10.5.1.
33
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.6-08:00 AR29 RM/6/RMDEBUG:  Area: 0.0.0.2, Chksum: 0
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.7-08:00 AR29 RM/6/RMDEBUG:  AuType: 02
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.8-08:00 AR29 RM/6/RMDEBUG:  Key(ascii): * * * * * * * *

&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.9-08:00 AR29 RM/6/RMDEBUG:  Net Mask: 255.255.255.0
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.10-08:00 AR29 RM/6/RMDEBUG:  Hello Int: 15, Option: _N_

&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.11-08:00 AR29 RM/6/RMDEBUG:  Rtr Priority: 1, Dead Int:
 60
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.12-08:00 AR29 RM/6/RMDEBUG:  DR: 10.5.233.33
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.13-08:00 AR29 RM/6/RMDEBUG:  BDR: 0.0.0.0
&amp;lt;AR29&amp;gt;
Jan  2 2021 12:05:00.626.14-08:00 AR29 RM/6/RMDEBUG:  # Attached Neighbors: 0

#关闭调试信息输出
&amp;lt;AR29&amp;gt;undo terminal debugging 
Info: Current terminal debugging is off.
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29的hello时间为10秒（ Hello Int: 10），AR33的hello时间为15秒（Hello Int: 15）；AR29的ospf区域类型为普通区域（Option: _E_），AR33的ospf区域为nssa区域（Option: _N_）。AR33与AR29的RouterID不冲突、均为ospf区域2、认证通过、网段一致。即AR29与AR33之间无法建立ospf邻居的因素有两个，一是hello时间不一致，二是ospf区域类型以一致。同时获取到AR33的三层地址为10.5.233.33。

2.8 测试三层的连通性
ospf邻居建立的前提为三层通信正常，测试AR29与AR33的三层通信是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;ping 10.5.233.33
  PING 10.5.233.33: 56  data bytes, press CTRL_C to break
    Reply from 10.5.233.33: bytes=56 Sequence=1 ttl=255 time=20 ms
    Reply from 10.5.233.33: bytes=56 Sequence=2 ttl=255 time=30 ms
    Reply from 10.5.233.33: bytes=56 Sequence=3 ttl=255 time=10 ms
    Reply from 10.5.233.33: bytes=56 Sequence=4 ttl=255 time=20 ms
    Reply from 10.5.233.33: bytes=56 Sequence=5 ttl=255 time=30 ms

  --- 10.5.233.33 ping statistics ---
    5 packet(s) transmitted
    5 packet(s) received
    0.00% packet loss
    round-trip min/avg/max = 10/22/30 ms
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29与AR33的三层通信正常。

2.9 结论
通过上述分析，故障的根本原因为AR29与AR33之间的ospf的hello时间不一致、ospf的区域类型不一致导致AR29与AR33之间无法建立ospf邻居，从而AR29与AR33之间的loopback0接口无法正常通信。


三、故障解决
3.1 AR29与AR33之间的ospf的hello时间不一致、ospf的区域类型不一致，需要在AR33上执行以下命令：
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
area 2 //进入区域2
undo nssa //删除nssa无语配置
interface GigabitEthernet 0/0/1 //进入接口视图
undo ospf timer hello //删除ospf的hello时间配置

执行完以上命令之后需要在AR29上执行以下命令进行检查：
display ospf peer brief //检查AR33与AR29之间的ospf邻居是否正常
display ip routing-table //检查A29的路由表中是否存在AR33的loopback0接口地址的路由
ping -a 10.5.1.29 10.5.1.33 //查看故障是否解决

3.2 如果执行以上命令未能排除故障，则存在以下高可能性故障：
3.2.1 AR33的loopback0接口没有宣告进区域2，需要在AR33上执行以下命令：
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
area 2 //进入区域2
network 10.5.1.33 0.0.0.0 //将loopback0接口地址宣告进区域2

3.2.2 AR29与AR33的ospf区域认证不一致，需要在AR29上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/1 //进入接口视图
undo ospf authentication-mode //接口认证优先于区域认证，删除接口认证
ospf {ospf进程ID} //进入ospf进程下
area 2 //进入区域2
authentication-mode MD5 1 cipher {与AR33相同的密码} //修改区域认证密码

3.2.3 AR29与AR33互联接口的mtu不一致，需要在AR33上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/1 //进入接口视图
mtu 1500 //修改mtu值

3.2.4 AR29与AR33的ospf进程下表存在路由过滤策略，需要在AR33和AR29上执行以下命令：
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
display this //查看当前配置
undo filter-policy import //删除路由过滤策略
undo filter-policy export

3.2.5 AR29与AR33的互联接口下存在流量过滤策略，需要在AR33和AR29上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/1 //进入接口视图
display this //查看当前配置
undo traffic-policy inbound //删除流量过滤策略
undo traffic-policy outbound 
undo traffic-filter inbound 
undo traffic-filter outbound 

执行完以上命令之后需要在AR29上执行以下命令进行检查：
display ospf peer brief //检查AR33与AR29之间的ospf邻居是否正常
display ip routing-table //检查A29的路由表中是否存在AR33的loopback0接口地址的路由
ping -a 10.5.1.29 10.5.1.33 //查看故障是否解决

3.3 如果执行以上命令成功排除故障，则需要在执行过命令的设备上继续执行以下命令：
return //返回用户视图
save //保存修改之后的配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助，谢谢！
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;tac2-2变种2&#34;&gt;TAC2-2:变种2&lt;/h2&gt;
&lt;h2 id=&#34;解答-2&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 排障步骤和变种3相同，都是通过最后的调试信息找到错点
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;tac2-3变种3&#34;&gt;TAC2-3:变种3&lt;/h2&gt;
&lt;h2 id=&#34;解答-3&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 排障步骤和变种3相同，都是通过最后的调试信息找到错点
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TAC-2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-tac/"" data-c="
          &lt;h1 id=&#34;诊断一&#34;&gt;诊断一&lt;/h1&gt;
&lt;p&gt;AR29的loopback0口无法访问AR28的loopback0口&lt;/p&gt;
&lt;h2 id=&#34;解答&#34;&gt;解答&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;一、故障根因

LSW6上vlan配置错误，导致AR29与AR28处于不同的广播域中，无法建立正常的ospf邻居关系。

二、故障分析
2.1 故障重现
在AR29上，以AR29的loopback0地址为源，测试与AR28的loopback0接口的连通性，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;ping -a 10.5.1.29 10.5.1.28
  PING 10.5.1.28: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.1.28 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29与AR28的loopback0接口之间确实无法通信，故障存在。

2.2 检查路由表
AR29要想访问AR28的loopback0接口，首先需要在路由表中存在到达对方接口的路由，查看AR29的路由表，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display ip routing-table 
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 12       Routes : 12       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

      10.5.1.29/32  Direct  0    0           D   127.0.0.1       LoopBack0
      10.5.1.33/32  OSPF    10   1           D   10.5.233.33     GigabitEthernet
0/0/1
     10.5.128.0/24  Direct  0    0           D   10.5.128.29     GigabitEthernet
0/0/0
    10.5.128.29/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.128.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.233.0/24  Direct  0    0           D   10.5.233.29     GigabitEthernet
0/0/1
    10.5.233.29/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
   10.5.233.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/1
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29上并不存在到达AR28的loopback0接口的路由。

2.3 检查ospf邻居
AR28与AR29之间运行ospf路由协议，检查AR28与AR29之间的ospf邻居是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display ospf peer brief 

	 OSPF Process 1 with Router ID 10.5.1.29
		  Peer Statistic Information
 ----------------------------------------------------------------------------
 Area Id          Interface                        Neighbor id      State    
 0.0.0.2          GigabitEthernet0/0/1             10.5.1.33        Full        
 ----------------------------------------------------------------------------
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29上不存在与AR28的邻居关系。

2.4 检查AR27的ospf邻居与路由
AR27和AR28、AR29处于ospf同一区域中，查看AR27的ospf邻居和路由是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# AR27的ospf邻居
&amp;lt;AR27&amp;gt;display ospf peer brief 

	 OSPF Process 1 with Router ID 10.5.1.27
		  Peer Statistic Information
 ----------------------------------------------------------------------------
 Area Id          Interface                        Neighbor id      State    
 0.0.0.0          GigabitEthernet0/0/0             10.5.1.28        Full        
 ----------------------------------------------------------------------------

# AR27的路由表
&amp;lt;AR27&amp;gt;display ip routing-table
Route Flags: R - relay, D - download to fib
------------------------------------------------------------------------------
Routing Tables: Public
         Destinations : 19       Routes : 19       

Destination/Mask    Proto   Pre  Cost      Flags NextHop         Interface

        0.0.0.0/0   Static  60   0           D   10.5.128.27     GigabitEthernet
0/0/0
      10.5.1.27/32  Direct  0    0           D   127.0.0.1       LoopBack0
      10.5.1.28/32  OSPF    10   1           D   10.5.128.28     GigabitEthernet
0/0/0
      10.5.1.30/32  O_ASE   150  1           D   10.5.128.28     GigabitEthernet
0/0/0
      10.5.1.31/32  O_ASE   150  1           D   10.5.128.28     GigabitEthernet
0/0/0
      10.5.1.32/32  OSPF    10   2           D   10.5.128.28     GigabitEthernet
0/0/0
      10.5.1.34/32  O_ASE   150  1           D   10.5.128.28     GigabitEthernet
0/0/0
     10.5.128.0/24  Direct  0    0           D   10.5.128.27     GigabitEthernet
0/0/0
    10.5.128.27/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
   10.5.128.255/32  Direct  0    0           D   127.0.0.1       GigabitEthernet
0/0/0
     10.5.134.0/24  O_ASE   150  1           D   10.5.128.28     GigabitEthernet
0/0/0
     10.5.230.0/24  O_ASE   150  1           D   10.5.128.28     GigabitEthernet
0/0/0
     10.5.231.0/24  O_ASE   150  1           D   10.5.128.28     GigabitEthernet
0/0/0
     10.5.232.0/24  OSPF    10   2           D   10.5.128.28     GigabitEthernet
0/0/0
     10.5.234.0/24  O_ASE   150  1           D   10.5.128.28     GigabitEthernet
0/0/0
      127.0.0.0/8   Direct  0    0           D   127.0.0.1       InLoopBack0
      127.0.0.1/32  Direct  0    0           D   127.0.0.1       InLoopBack0
127.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
255.255.255.255/32  Direct  0    0           D   127.0.0.1       InLoopBack0
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR27与AR28建立了正常的ospf邻居关系，并且AR27的路由表中存在AR28的loopback0接口地址的路由，这说明AR28与AR27之间的ospf配置是正确的。

2.5 对比查看AR27与AR29的ospf配置
AR27的ospf配置为正确的，通过与其对比，查看AR29的ospf是否正确，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# AR27的ospf配置
&amp;lt;AR27&amp;gt;display ospf brief

	 OSPF Process 1 with Router ID 10.5.1.27
		 OSPF Protocol Information

 RouterID: 10.5.1.27        Border Router: 
 Multi-VPN-Instance is not enabled
 Global DS-TE Mode: Non-Standard IETF Mode
 Graceful-restart capability: disabled
 Helper support capability  : not configured
 Applications Supported: MPLS Traffic-Engineering 
 Spf-schedule-interval: max 10000ms, start 500ms, hold 1000ms
 Default ASE parameters: Metric: 1 Tag: 1 Type: 2
 Route Preference: 10 
 ASE Route Preference: 150 
 SPF Computation Count: 7     
 RFC 1583 Compatible
 Retransmission limitation is disabled
 Area Count: 1   Nssa Area Count: 0 
 ExChange/Loading Neighbors: 0
 Process total up interface count: 2
 Process valid up interface count: 1
 
 Area: 0.0.0.0          (MPLS TE not enabled)
 Authtype: MD5   Area flag: Normal
 SPF scheduled Count: 7     
 ExChange/Loading Neighbors: 0
 Router ID conflict state: Normal
 Area interface up count: 2

 Interface: 10.5.128.27 (GigabitEthernet0/0/0)
 Cost: 1       State: DR        Type: Broadcast    MTU: 1500  
 Priority: 1
 Designated Router: 10.5.128.27
 Backup Designated Router: 10.5.128.28
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 

 Interface: 10.5.1.27 (LoopBack0)
 Cost: 0       State: P-2-P     Type: P2P       MTU: 1500  
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 

# AR29的ospf配置
&amp;lt;AR29&amp;gt;display ospf brief 

	 OSPF Process 1 with Router ID 10.5.1.29
		 OSPF Protocol Information

 RouterID: 10.5.1.29        Border Router:  AREA 
 Multi-VPN-Instance is not enabled
 Global DS-TE Mode: Non-Standard IETF Mode
 Graceful-restart capability: disabled
 Helper support capability  : not configured
 Applications Supported: MPLS Traffic-Engineering 
 Spf-schedule-interval: max 10000ms, start 500ms, hold 1000ms
 Default ASE parameters: Metric: 1 Tag: 1 Type: 2
 Route Preference: 10 
 ASE Route Preference: 150 
 SPF Computation Count: 7     
 RFC 1583 Compatible
 Retransmission limitation is disabled
 Area Count: 2   Nssa Area Count: 0 
 ExChange/Loading Neighbors: 0
 Process total up interface count: 3
 Process valid up interface count: 2
 
 Area: 0.0.0.0          (MPLS TE not enabled)
 Authtype: MD5   Area flag: Normal
 SPF scheduled Count: 7     
 ExChange/Loading Neighbors: 0
 Router ID conflict state: Normal
 Area interface up count: 2

 Interface: 10.5.128.29 (GigabitEthernet0/0/0)
 Cost: 1       State: DR        Type: Broadcast    MTU: 1500  
 Priority: 1
 Designated Router: 10.5.128.29
 Backup Designated Router: 0.0.0.0
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 

 Interface: 10.5.1.29 (LoopBack0)
 Cost: 0       State: P-2-P     Type: P2P       MTU: 1500  
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 
 
 Area: 0.0.0.2          (MPLS TE not enabled)
 Authtype: MD5   Area flag: Normal
 SPF scheduled Count: 6     
 ExChange/Loading Neighbors: 0
 Router ID conflict state: Normal
 Area interface up count: 1

 Interface: 10.5.233.29 (GigabitEthernet0/0/1)
 Cost: 1       State: BDR       Type: Broadcast    MTU: 1500  
 Priority: 1
 Designated Router: 10.5.233.33
 Backup Designated Router: 10.5.233.29
 Timers: Hello 10 , Dead 40 , Poll  120 , Retransmit 5 , Transmit Delay 1 

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR27和AR29的GigabitEthernet0/0/0接口均宣告进ospf区域0中，cost值均为1，链路类型均为Broadcast，mtu均为1500，hello时间均为10秒；LoopBack0也均宣告进区域0中，cost均为0，链路类型均为P2P，mtu均为1500，hello时间均为10秒。这说明AR29的ospf配置正确。

2.6 检查ospf错误情况
检查AR29与LSW6相连的接口下ospf错误情况，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display ospf error interface GigabitEthernet 0/0/0

	 OSPF Process 1 with Router ID 10.5.1.29
		 OSPF error statistics 

 Interface: GigabitEthernet0/0/0 (10.5.128.29)
General packet errors:
 0     : Bad version                    0     : Bad checksum
 0     : Bad area id                    0     : Bad authentication type
 0     : Bad authentication key         0     : Unknown neighbor
 0     : Bad net segment                0     : Extern option mismatch
 0     : Router id confusion

HELLO packet errors:
 0     : Netmask mismatch               0     : Hello timer mismatch
 0     : Dead timer mismatch            0     : Invalid Source Address

DD packet errors:
 0     : MTU option mismatch

LS REQ packet errors:
 0     : Bad request

LS UPD packet errors:
 0     : LSA checksum bad

Receive Grace LSA errors:
 0     : Number of invalid LSAs         0     : Number of policy failed LSAs
 0     : Number of wrong period LSAs

&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29上没有出现任何错误，出现这种情况只有两种情况，一是邻居正常建立，二是AR29没有收到任何报文，显然目前情况是AR29没有收到任何报文。

2.7 检查三层的连通性
ospf邻居的建立依赖三层的连通性，测试AR29与AR28之间三层是否正常通信，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# 通过查看AR27的ARP列表获取到AR28的GigabitEthernet0/0/0接口信息
&amp;lt;AR27&amp;gt;display arp
IP ADDRESS      MAC ADDRESS     EXPIRE(M) TYPE        INTERFACE   VPN-INSTANCE 
                                          VLAN/CEVLAN PVC                      
------------------------------------------------------------------------------
10.5.128.27     00e0-fc0e-3f2e            I -         GE0/0/0
10.5.128.28     00e0-fc61-5aef  1         D-0         GE0/0/0
------------------------------------------------------------------------------
Total:2         Dynamic:1       Static:0     Interface:1   

# 测试三层连通性
&amp;lt;AR29&amp;gt; ping 10.5.128.28
  PING 10.5.128.28: 56  data bytes, press CTRL_C to break
    Request time out
    Request time out
    Request time out
    Request time out
    Request time out

  --- 10.5.128.28 ping statistics ---
    5 packet(s) transmitted
    0 packet(s) received
    100.00% packet loss
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR28与AR29之间的三层无法正常通信。

2.8 检查ARP列表并进行单播测试
三层正常通信的前提是获取到对方接口的Mac地址，检查AR29的ARP列表中是否存在相应的表项，同时进行单播测试，结果如下：
&amp;quot;&amp;quot;&amp;quot;
# ARP列表
&amp;lt;AR29&amp;gt;display arp
IP ADDRESS      MAC ADDRESS     EXPIRE(M) TYPE        INTERFACE   VPN-INSTANCE 
                                          VLAN/CEVLAN PVC                      
------------------------------------------------------------------------------
10.5.128.29     00e0-fcc1-1b22            I -         GE0/0/0
10.5.233.29     00e0-fcc1-1b23            I -         GE0/0/1
10.5.233.33     00e0-fc64-44f6  18        D-0         GE0/0/1
------------------------------------------------------------------------------
Total:3         Dynamic:1       Static:0     Interface:2   

# 单播测试
&amp;lt;AR29&amp;gt;arp-ping mac 00e0-fc61-5aef interface GigabitEthernet 0/0/0
  OutInterface: GigabitEthernet0/0/0 MAC[00-E0-FC-61-5A-EF], press CTRL_C to bre
ak
Error: Request timed out.
Error: Request timed out.
Error: Request timed out.

    ----- ARP-Ping MAC statistics -----
    3 packet(s) transmitted
    0 packet(s) received
    MAC[00-E0-FC-61-5A-EF]  not be used
&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29的ARP列表中并不存在AR28的GigabitEthernet0/0/0接口的Mac地址表项，同时单播测试也失败，这表明AR28与AR29的二层也无法正常通信。

2.9 检查接口状态
查看AR29的GigabitEthernet0/0/0的接口状态是否正常，结果如下：
&amp;quot;&amp;quot;&amp;quot;
&amp;lt;AR29&amp;gt;display interface GigabitEthernet 0/0/0
GigabitEthernet0/0/0 current state : UP
Line protocol current state : UP
Last line protocol up time : 2021-01-02 10:23:01 UTC-08:00
Description:HUAWEI, AR Series, GigabitEthernet0/0/0 Interface
Route Port,The Maximum Transmit Unit is 1500
Internet Address is 10.5.128.29/24
IP Sending Frames&#39; Format is PKTFMT_ETHNT_2, Hardware address is 00e0-fcc1-1b22
Last physical up time   : 2021-01-02 10:23:01 UTC-08:00
Last physical down time : 2021-01-02 10:22:53 UTC-08:00
Current system time: 2021-01-02 10:50:04-08:00
Port Mode: FORCE COPPER
Speed : 1000,  Loopback: NONE
Duplex: FULL,  Negotiation: ENABLE
Mdi   : AUTO
Last 300 seconds input rate 424 bits/sec, 0 packets/sec
Last 300 seconds output rate 72 bits/sec, 0 packets/sec
Input peak rate 568 bits/sec,Record time: 2021-01-02 10:23:28
Output peak rate 432 bits/sec,Record time: 2021-01-02 10:44:09

Input:  734 packets, 87346 bytes
  Unicast:                  0,  Multicast:                 734
  Broadcast:                0,  Jumbo:                       0
  Discard:                  0,  Total Error:                 0

  CRC:                      0,  Giants:                      0
  Jabbers:                  0,  Throttles:                   0
  Runts:                    0,  Symbols:                     0
  Ignoreds:                 0,  Frames:                      0

Output:  159 packets, 14754 bytes
  Unicast:                  3,  Multicast:                 150
  Broadcast:                6,  Jumbo:                       0
  Discard:                  0,  Total Error:                 0

  Collisions:               0,  ExcessiveCollisions:         0
  Late Collisions:          0,  Deferreds:                   0

    Input bandwidth utilization threshold : 100.00%
    Output bandwidth utilization threshold: 100.00%
    Input bandwidth utilization  :    0%
    Output bandwidth utilization :    0%


&amp;quot;&amp;quot;&amp;quot;
结果显示，AR29的GigabitEthernet0/0/0接口在物理上和协议上均是up状态，说明AR29的物理层正常。

2.10 结论
通过以上分析，故障的根本原因为LSW6上vlan配置错误，导致AR29与AR28处于不同的广播域中，无法建立正常的ospf邻居关系。


三、故障解决
3.1 LSW6上vlan配置错误，需要在LSW6上执行以下命令：
system-view //进入系统视图
display port vlan active //查看接口Ethernet 0/0/2的vlanID
interface Ethernet 0/0/3 //进入接口视图
port link-type access //设置接口模式为access
port default vlan {Ethernet 0/0/2接口的vlanID} //配置正确的vlanID

执行完上述命令之后需要在AR29上执行以下命令进行检查：
ping 10.5.128.28 //检查三层的连通性
display ospf peer brief //查看ospf邻居是否正常
display ip routing-table //查看路由表中是否存在AR28的loopback0接口的路由
ping -a 10.5.1.29 10.5.1.28 //检查故障是否排除

3.2 如果执行以上命令未能排除故障，则存在以下高可能性故障：
3.2.1 LSW6上配置了mux-vlan，需要在LSW6上执行以下命令：
system-view //进入系统视图
display mux-vlan //查看配置了mux-vlan的接口
interface {配置了mux-vlan的接口} //进入接口视图
undo port mux-vlan enable //删除mux-vlan配置

3.2.2 AR29的ospf区域认证错误，需要在AR29上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/0 //进入接口视图
undo ospf authentication-mode //接口认证由于区域认证，需要先删除接口认证
ospf {ospf进程ID} //进入ospf进程下
area 0 //进入区域0
authentication-mode md5 1 cipher {AR28的区域0认证密码} //修改接口认证

3.2.3 AR29与AR28的ospf进程下存在路由过滤，需要在AR28和AR29上执行以下命令：
system-view //进入系统视图
ospf {ospf进程ID} //进入ospf进程下
display this // 查看当前配置
undo filter-policy import //删除路由过滤策略
undo filter-policy export

3.2.4 AR29与AR28的GigabitEthernet 0/0/0接口下配置流量过滤策略，需要在AR28和AR29上执行以下命令：
system-view //进入系统视图
interface GigabitEthernet 0/0/0 //进入接口视图
display this // 查看当前配置
undo traffic-policy inbound //删除流量过滤策略
undo traffic-policy outbound
undo traffic-filter inbound
undo traffic-filter outbound

执行完上述命令之后需要在AR29上执行以下命令进行检查：
ping 10.5.128.28 //检查三层的连通性
display ospf peer brief //查看ospf邻居是否正常
display ip routing-table //查看路由表中是否存在AR28的loopback0接口的路由
ping -a 10.5.1.29 10.5.1.28 //检查故障是否排除

3.3 如果执行以上命令成功排除故障，则需要在执行过命令的设备上继续执行以下命令：
return //回到用户视图
save //保存修改之后的配置

3.4 如果执行以上命令未能排除故障，则需要用户提供完整的设备配置信息或者派遣一线工程师到达用户现场进行现场排障，同时拨打华为400服务热线请求华为专家的协助，谢谢！
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TAC-1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-labv2-bu-zou-fen-jie/"" data-c="
          &lt;h1 id=&#34;lab-v2&#34;&gt;Lab V2&lt;/h1&gt;
&lt;h2 id=&#34;1-l2vrrp&#34;&gt;1. L2+VRRP&lt;/h2&gt;
&lt;h3 id=&#34;11-链路聚合&#34;&gt;1.1 链路聚合&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;假设S1不支持LACP，S1和S2互联的接口需要合成一个二层逻辑接口，逻辑接口的成员链路根据源-目的MAC进行负载分担&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1
int eth-trunk 12
    load-balance src-dst-mac
    trunkport g0/0/23 0/0/24
    dis eth 12
# SW2
int eth-trunk 12
    load-balance src-dst-mac
    trunkport g0/0/23 0/0/24
    dis eth 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-link-type&#34;&gt;1.2 Link-type&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4互联接口的链路类型为trunk，允许除VLAN1外的所有vlan通过&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1
port-group group-member g0/0/1 g0/0/12 eth-trunk 12
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1
# SW2
port-group group-member g0/0/1 g0/0/12 eth-trunk 12
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1
# SW3
port-group group-member g0/0/1 g0/0/2
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1
# SW4
port-group group-member g0/0/1 g0/0/2
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.1.254，为PC1的网关，CE1会周期性发送Sender IP为10.3.1.254，源MAC为00-00-5E-00-01-01&lt;code&gt;vrid为1&lt;/code&gt;的免费ARP。PC1与网关之间的数据包封装在VLAN10中（PC1收发untag的帧）&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.2.254，为Server1的网关，CE2会周期性发送Sender IP为10.3.2.254，源MAC为00-00-5E-00-01-02&lt;code&gt;vrid为2&lt;/code&gt;的免费ARP。Server1与网关之间的数据包封装在VLAN20中（Server1收发untag的帧）&lt;/li&gt;
&lt;li&gt;VRRP的master设备重启时，在g0/0/2变为up 1分钟后，才能重新成为master&lt;br&gt;
【注意】此处做完不通是对的，需要将SW1/SW2面对CE1/CE2的接口配置为trunk，并允许Vlan10/20通过&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 2/3/4-----------------------------------
# CE1
dis ip int bri
int g0/0/2.10
    dis th
    vrrp vrid 1 virtual-ip 10.3.1.254
    vrrp vrid 1 priority 120
    vrrp vrid 1 preempt-mode timer delay 60
    arp broadcast enable
int g0/0/2.20
    dis th
    vrrp vrid 2 virtual-ip 10.3.2.254
    arp broadcast enable

# CE2
dis ip int bri
int g0/0/2.10
    dis th
    vrrp vrid 1 virtual-ip 10.3.1.254
    arp broadcast enable
int g0/0/2.20
    dis th
    vrrp vrid 2 virtual-ip 10.3.2.254
    vrrp vrid 2 priority 120
    vrrp vrid 2 preempt-mode timer delay 60
    arp broadcast enable

# SW1
vlan batch 10 20
dis port vlan active
int g0/0/2
    port link-type trunk
    port trunk allow-pass vlan 10 20

# SW2
vlan batch 10 20
dis port vlan active
int g0/0/2
    port link-type trunk
    port trunk allow-pass vlan 10 20

# SW3
vlan batch 10 20
dis port vlan active
int e0/0/1  
    port link access
    port default vlan 10

# SW4
vlan batch 10 20
dis port vlan active
int e0/0/1
    port link access
    port default vlan 20

# 测试------------------
# CE1/2
dis vrrp bri
# PC1/2
ping 10.3.2.254
ping 10.3.1.254
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-mstp&#34;&gt;1.3 MSTP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4都运行MSTP。Vlan 10在instance 10，S1作为primary root，S2作为secondary root。Vlan 20在instance 20，S2作为primary root，S1作为secondary root。MSTP的region name是HUAWEI，Revision-level 12。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q
stp instance 10 root primary
stp instance 20 secondary primary

# SW2
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q
stp instance 10 root secondary 
stp instance 20 root primary

# SW3
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q

# SW4
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;除了交换机的互联端口，其他端口要确保不参与MSTP计算，由disabled会直接转到Forwarding状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1
stp edged-port default
port-group group-member eth 12 g0/0/1 g0/0/12
    stp edged-port disable

# SW2
stp edged-port default
port-group group-member eth 12 g0/0/1 g0/0/12
    stp edged-port disable

# SW3
stp edged-port default
port-group group-member g0/0/1 g0/0/2
    stp edged-port disable

# SW4
stp edged-port default
port-group group-member g0/0/1 g0/0/2
    stp edged-port disable

# 检查
# SW1/2/3/4
dis stp bri 
# sw1端口均是forwarding，eth12为vlan20和vlan10的root
# sw2端口均是forwarding，eth12为vlan10的root
# sw3端口g0/0/1是vlan10的root，g0/0/2是vlan20的root
# sw4端口g0/0/1是vlan20的root，g0/0/2是vlan10的root
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-wan&#34;&gt;1.4 WAN&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PE1-RR1的互联Serial接口，绑定为一个逻辑接口，成员链路采用HDLC，逻辑接口的IPv4地址、IPv6地址请按照图1、图5配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#PE1
ipv6 
int ip-trunk 1
    ipv6 enable 
    ip addr 10.1.13.1 30
    ipv6 addr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1300 127
    q
int s0/0/1
    link-protocol hdlc
    ip-trunk 1
int s0/0/2
    link-protocol hdlc
    ip-trunk 1
    q

# RR1
ipv6
int ip-trunk 1
    ipv6 enable 
    ip addr 10.1.13.2 30
    ipv6 addr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1301 127
    q
int s0/0/1
    link-protocol hdlc
    ip-trunk 1
int s0/0/2
    link-protocol hdlc
    ip-trunk 1
    q

# 测试-----------------------
# RR1
ping 10.1.13.1
ping ipv6 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1300
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;PE3-CE3的互联POS接口，绑定为一个逻辑接口，成员链路采用PPP，逻辑接口的IPv4地址，请按照图1配置&lt;br&gt;
&lt;code&gt;注意PE3的mp接口需要先绑定VPN1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3
int mp-group 0/0/1
    dis cu conf vpn
    ip binding vpn-instance VPN1
    ip add 10.2.33.1 30
    q
int p4/0/0
    ppp mp mp-group 0/0/1
int p6/0/0
    ppp mp mp-group 0/0/1

# CE3
int mp-group 0/0/1
    ip add 10.2.33.2 30
    q
int p4/0/0
    ppp mp mp-group 0/0/1
int p6/0/0
    ppp mp mp-group 0/0/1

# 测试
# CE3
ping 10.2.33.1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-ipv4-igp&#34;&gt;2. IPv4 IGP&lt;/h2&gt;
&lt;h3 id=&#34;21-基本配置&#34;&gt;2.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有设备的接口IPv4地址按照图1配置（除PE1-RR1的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;Route-id与loopback0的IPv4地址相同。MPLS域各设备的loopback0为172.16.0.0/16的32位主机地址（已预配置），未来扩容的MPLS域各设备的loopback0，从172.16.0.0/16去可用的主机地址，比如172.16.1.21/32可能分布在AS100，也可能分布在AS200。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 2---------------------------
# CE1
dis ip int br
router id 172.17.1.1
# CE2
dis ip int br
router id 172.17.1.2

# PE1
dis ip int br
router id 172.16.1.1
# PE2
dis ip int br
router id 172.16.1.20
# RR1
dis ip int br
router id 172.16.1.3
# P1
dis ip int br
router id 172.16.1.4
# ASBR1
dis ip int br
router id 172.16.1.5
# ASBR2
dis ip int br
router id 172.16.1.6

# ASBR3
dis ip int br
router id 172.16.1.7
# ASBR4
dis ip int br
router id 172.16.1.8
# RR2
dis ip int br
router id 172.16.1.9
# P2
dis ip int br
router id 172.16.1.10
# PE3
dis ip int br
router id 172.16.1.11
# PE4
dis ip int br
router id 172.16.1.2

# CE3
dis ip int br
router id 172.17.1.3
# CE4
dis ip int br
router id 172.17.1.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-ospf&#34;&gt;2.2 OSPF&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1和CE2之间的链路，及该两台设备的loopback0通告入OSPF区域0（已预配置）&lt;/li&gt;
&lt;li&gt;CE1的g0/0/2.10和g0/0/2.20、CE2的g0/0/2.10和g0/0/2.20，直连网段通告入OSPF区域0，这些接口不能收发OSPF报文&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1
dis ip int bri
ospf 1 router-id 172.17.1.1
    a 0
        network 172.17.1.1 0.0.0.0 # lo0
        network 10.2.12.1 0.0.0.0 # g0/0/0
        network 10.3.1.1 0.0.0.0 # g0/0/2的子接口10 
        network 10.3.2.1 0.0.0.0 # g0/0/2的子接口20
        q
    silent-int g0/0/2.10
    silent-int g0/0/2.20

# CE2
dis ip int bri
ospf 1 router-id 172.17.1.2
    a 0
        network 172.17.1.2 0.0.0.0 # lo0
        network 10.2.12.2 0.0.0.0 # g0/0/0
        network 10.3.1.2 0.0.0.0 # g0/0/2的子接口10 
        network 10.3.2.2 0.0.0.0 # g0/0/2的子接口20
        q
    silent-int g0/0/2.10
    silent-int g0/0/2.20

# 检查-------------------
# CE1/2
dis ospf peer bri
dis ospf int 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;RR2、P2、PE3、PE4在OSPF区域0中，cost如图2配置（已预配置）&lt;br&gt;
&lt;code&gt;PE4不能宣告lo0，原因为次优路径，涉及考点5&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RR2
dis ip int bri
ospf 1 router-id  172.16.1.9
    a 0
        network 172.16.1.9 0.0.0.0  # lo 0
        network 10.1.91.1 0.0.0.0 #g0/0/0
        network 10.1.119.1 0.0.0.0 #g0/0/2

# P2
dis ip int bri
ospf 1 router-id  172.16.1.10
    a 0
        network 172.16.1.10 0.0.0.0  # lo 0
        network 10.1.91.2 0.0.0.0 #g0/0/0
        network 10.1.102.1 0.0.0.0 #g0/0/2

# PE3
dis ip int bri
ospf 1 router-id  172.16.1.11
    a 0
        network 172.16.1.11 0.0.0.0  # lo 0
        network 10.1.112.1 0.0.0.0 #g0/0/0
        network 10.1.119.2 0.0.0.0 #g0/0/2

# PE4
dis ip int bri
ospf 1 router-id  172.16.1.2
    a 0    # 不能宣告lo0，原因为次优路径，涉及考点5
        network 10.1.112.2 0.0.0.0 #g0/0/0
        network 10.1.102.2 0.0.0.0 #g0/0/2

# 检查-----------------
# 所有设备
dis ospf int 
dis ospf peer bri
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;PE3-PE4的OSPF链路类型为P2P&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3
int g0/0/0
    ospf network-type p2p
# PE4
int g0/0/0
    ospf network-type p2p
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;PE4上将loopback0地址引入OSPF。AS200中，各OSPF网元到PE4 loopback0的路由，要累加内部cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE4
ip ip-prefix L0 permit 172.16.1.2 32
route-policy L0 permit node 10
    if-match ip-prefix L0
    apply tag 2  # 用于后面双向路由引入防止次优路径
ospf 1
    import-route direct type 1 route-policy L0   

# 检查-----------------
# P2
dis ip rou 172.16.1.2 verbose  # 172.16.1.2的cost变为1501，tag为2
# RR2
dis ip rou 172.16.1.2 verbose  # 172.16.1.2的cost变为1511，tag为2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-isis&#34;&gt;2.3 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;AS100内loopback0和互联网接口全部开启ISIS协议，其中PE1、PE2的路由类型为L1，区域号为49.0001，RR1、P1路由类型为L12，区域号为49.0001，ASBR1、ASBR2路由类型为L2，区域号为49.0002。各网元system-id唯一，cost-style为wide，cost值如图2配置（除PE1-RR1之外的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;AS200内，RR2、P2、ASBR3、ASBR4的loopback0和互联接口全部开启isis协议，IS类型为L2，区域号为49.0003。各网元system-id唯一，cost-style为wide，cost值如图2配置（已预配置）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1/2----------------------
# PE1
dis cu conf isis # is-level level-1 # 如果有此配置，则不再进行配置
dis isis int
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
int ip-trunk 1
    dis th
    isis  enable 
    isis cost 1500
dis isis int
dis isis peer # 2个

# PE2
dis cu conf isis # is-level level-1 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# RR1
dis cu conf isis # is-level level-1-2 # 如果有此配置，则不再进行配置
dis isis int
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
int ip-trunk 1
    dis th
    isis  enable 
    isis cost 1500
dis isis int
dis isis peer # 4个

# P1
dis cu conf isis # is-level level-1-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 4个

# ASBR1
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# ASBR2
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# ASBR3
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# ASBR4
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# RR2
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# P2
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个


# 检查-----------------
# RR1
dis ip rou pro isis # 有1/20/4/5/6的路由
# ASBR3
dis ip rou pro isis # 有8/9/10的路由
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;RR2-P2的ISIS链路类型为P2P&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RR2
int g0/0/0
    isis circuit-type p2p
# P2
int g0/0/0
    isis circuit-type p2p
dis isis peer
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;P1的ISIS进程，产生LSP的最大延迟时间是1S，初始延迟为50ms，递增时间为50ms。使能LSP的快速扩散特性。SPF计算间隔为1s，初始延迟为100ms，递增时间为100ms。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# P1
isis 1
    timer lsp-generation 1 50 50
    flash-flood
    timer spf 1 100 100
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-mpls-vpn&#34;&gt;3. MPLS VPN&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CE1、CE2为VPN1的Hub-CE，PE1、PE2为Hub-CE，CE3、CE4为VPN1的spoke站点，PE3、PE4为SpokePE&lt;/li&gt;
&lt;li&gt;CE4位Multi-VPN-instance CE，CE4的VPN实例VPN1，通过g0/0/1连接PE4&lt;code&gt;CE4的OSPF需要做vrf-lite&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dis cu conf vpn
ospf 1 router-id  172.17.1.4 vpn-instance VPN1
	vpn-instance-capability simple
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;合理设置VPN1参数，使得Spoke站点互访的数据必须经过Hub-CE设备，当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由（PE3上VPN1的RD为100:13，ExportRT为100:1，ImportRT为200:1）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#PE1
dis cu conf vpn
ip vpn-instance HUB
    vpn-target 200:1 export
    q
ip vpn-instance VPN1
    vpn-target 100:1 200:1 import # 200:1的作用：当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由
dis cu int# 查看intg0/0/1.1和g0/0/1.2分别绑定VPN1和HUB，并且都已经配置arp broadcast enable

#PE2
dis cu conf vpn
ip vpn-instance HUB 
    vpn-target 200:1 export
    q
ip vpn-instance VPN1
    vpn-target 100:1 200:1 import 
dis cu int# 查看intg0/0/1.1和g0/0/1.2分别绑定VPN1和HUB，并且都已经配置arp broadcast enable

# PE3
ip vpn-instance VPN1
    vpn-target 100:1 export
    vpn-target 200:1 import

# PE4
ip vpn-instance VPN1
    vpn-target 100:1 export
    vpn-target 200:1 import
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如图4，CE1通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE1，CE1通过g0/0/1.2向PE1通告的BGP update中，某些路由的as path中有200。在CE1上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;如图4，CE2通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE2，CE2通过g0/0/1.2向PE2通告的BGP update中，某些路由的as path中有200。在CE2上，将OSPF路由导入BGP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#CE1
dis ip int bri
bgp  65000
    router-id 172.17.1.1
    peer 10.2.11.2 as 100
    peer 10.2.11.6 as 100
    import ospf 1

#PE1
bgp 100
    dis ip int bri
    router-id 172.16.1.1
    ipv4-family vpn-instance VPN1
        peer 10.2.11.1 as 65000
    ipv4-family vpn-instance HUB
        peer 10.2.11.5 as 65000
        peer 10.2.11.5 allow-as-loop

#CE2
dis ip int bri
bgp  65000
    router-id 172.17.1.2
    peer 10.2.22.2 as 100
    peer 10.2.22.6 as 100
    import ospf 1

#PE2
bgp 100
    dis ip int bri
    router-id 172.16.1.20
    ipv4-family vpn-instance VPN1
        peer 10.2.22.1 as 65000
    ipv4-family vpn-instance HUB
        peer 10.2.22.5 as 65000
        peer 10.2.22.5 allow-as-loop

# 检查-----------------
# 所有设备
dis bgp vpnv4 all peer
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;CE3通过OSPF区域1接入PE3通过PE3-CE3的逻辑接口互通，通告CE3的各环回口；CE4通过OSPF区域0接入PE4，通过PE4-CE4的g0/0/1.1接口互通，通告CE4的各环回口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3
ospf 2 vpn-instance VPN1
    a 1
        dis ip int bri # 查看MP口
        network 10.2.33.1 0.0.0.0
# CE3
dis ip int bri 
ospf 1 router-id 172.17.1.3
    area 1 # 同时需要宣告所有环回口
        net 10.2.33.2 0.0.0.0
        net 172.17.1.3 0.0.0.0
        net 10.3.3.3 0.0.0.0
dis ospf peer bri

# PE4
ospf 2 vpn-instance VPN1
    a 0
        dis ip int bri # 查看g0/0/1口
        net 10.2.44.1 0.0.0.0
# CE4
dis cu int  # 配置地址的3个接口都需要绑定VPN1
dis ip int bri 
ospf 1 vpn-instance VPN1
    area 0 # 同时需要宣告所有环回口
        net 10.2.44.2 0.0.0.0
        net 172.17.1.4 0.0.0.0
        net 10.4.4.4 0.0.0.0
# 检查
# PE3/PE4/CE3/CE4
dis ospf peer bri
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;如图3，AS100、AS200内各网元配置MPLS LSR ID，全局使能MPLS，MPLS LDP（已预配置）。AS100、AS200内各直连链路建立LDP邻居。（除PE1-RR1之外的逻辑链路外，已预配置）&lt;br&gt;
如图4，在AS100、AS200内建立IBGP IPv4邻居关系，RR1是PE1、PE2、P1、ASBR1、ASBR2的反射器，RR2是PE3、PE4、P2、ASBR3、ASBR4的反射器。ASBR1-ASBR3、ASBR2-ASBR4建立EBGP IPv4邻居关系（已预配置）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# MPLS--------------------
# AS100和AS200内所有设备
mpls lsr-id 172.16.1.1/20/3/4/5/6/7/8/9/10/11/2
mpls
mpls ldp
# AS100和AS200内所有设备的互联接口全部开启mpls ldp，将需要开启mpls接口的配置写入记事本，然后在相应设备上粘贴配置
# PE1
int ip 1
    mpls 
    mpls ldp
int g0/0/0
    mpls 
    mpls ldp
# PE2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
# RR1
int ip 1
    mpls 
    mpls ldp
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# P1
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
# ASBR1：注意这是option C方案，AS之间的接口不能配置
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# ASBR2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# ASBR3
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# ASBR4
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
#RR2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
#P2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
#PE3
int g0/0/0
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
#PE4
int g0/0/0
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp

# 检查-----------------
# AS100/200内所有设备
dis mpls ldp peer


# BGP
# PE1/PE2/P1/ASBR1/ASBR2
bgp 100
    router-id 172.16.1.1/20/4/5/6
    peer 172.16.1.3 as 100
    peer 172.16.1.3 connect lo 0
# RR1
bgp 100
    router-id 172.16.1.3
    peer 172.16.1.1 as 100 # 配置邻居
    peer 172.16.1.20 as 100
    peer 172.16.1.4 as 100
    peer 172.16.1.5 as 100
    peer 172.16.1.6 as 100
    dis th
    peer 172.16.1.1 co lo 0 # 配置更新源
    peer 172.16.1.20 co lo 0
    peer 172.16.1.4 co lo 0
    peer 172.16.1.5 co lo 0
    peer 172.16.1.6 co lo 0
    peer 172.16.1.1 re # 配置反射器
    peer 172.16.1.20 re
    peer 172.16.1.4 re
    peer 172.16.1.5 re
    peer 172.16.1.6 re

# ASBR1
bgp 100
    dis th
    peer 172.16.1.3 next-hop-local
    peer 10.1.57.2  as 200

# ASBR2
bgp 100
    dis th
    peer 172.16.1.3 next-hop-local
    peer 10.1.68.2 as 200

# ASBR3
bgp 200
    router-id 172.16.1.7
    peer 10.1.57.1  as 100
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0
    peer 172.16.1.9 next-hop-local

# ASBR4
bgp 200
    router-id 172.16.1.8
    peer 10.1.68.1 as 100
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0
    peer 172.16.1.9 next-hop-local

# P2/PE3/PE4
bgp 200
    router-id 172.16.1.10/11/2
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0

# RR2
bgp 200
    router-id 172.16.1.9
    peer 172.16.1.7 as 200 # 配置邻居
    peer 172.16.1.8 as 200
    peer 172.16.1.10 as 200
    peer 172.16.1.11 as 200
    peer 172.16.1.2 as 200
	peer 172.16.1.7 co lo 0 # 更新源
    peer 172.16.1.8 co lo 0 
    peer 172.16.1.10 co lo 0 
    peer 172.16.1.11 co lo 0 
    peer 172.16.1.2 co lo 0 
	peer 172.16.1.7 re # 反射器
    peer 172.16.1.8 re 
    peer 172.16.1.10 re 
    peer 172.16.1.11 re
    peer 172.16.1.2 re

# 检查-----------------
# RR1/2
dis bgp peer  # 5个邻居建立
# ASBR1/2/3/4
dis bgp peer # 2个邻居

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;ASBR1-ASBR3，ASBR2-ASBR4之间通过直连接口建立BGP邻居关系。在ASBR上，将ISIS的loopback0路由引入BGP。假设AS100和AS200中的loopback0地址为172.16.1.Y/32。当Y为奇数时，对端设备访问本AS设备的loopback0，优选ASBR1-ASBR3；当Y为偶数时，对端设备访问本AS设备的loopback0，优选ASBR2-ASBR4.保证配有有最好的扩展性&lt;br&gt;
&lt;code&gt;做本题之前先做第9题&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ASBR1
acl 2000   # 4台ASBR的ACL都是相同的，建议复制，不同的是route-policy
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 200
route-policy AB permit node 20
    if-match acl 2001
    apply cost 100
bgp 100
    import-route isis 1 route-policy AB
# ASBR3
acl 2000
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 200
route-policy AB permit node 20
    if-match acl 2001
    apply cost 100
bgp 200
    import-route isis 1 route-policy AB


# ASBR2
acl 2000
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 100
route-policy AB permit node 20
    if-match acl 2001
    apply cost 200
bgp 100
    import-route isis 1 route-policy AB
# ASBR4
acl 2000
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 100
route-policy AB permit node 20
    if-match acl 2001
    apply cost 200
bgp 200
    import-route isis 1 route-policy AB

# 检查-----------------
# 4台ASBR
dis bgp rou # 奇数路由走1/3，反之亦然。例如ASBR1上172.16.1.1的下一跳0.0.0.0（默认为ASBR3）,172.16.1.2的下一跳就是172.16.1.6

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;在RR2、P2上，ISIS和OSPF双向引入前缀为172.16.0.0/16的主机路由。被引入的协议的cost要继承到引入后的协议中，P2和PE4的loopback0互访走最优路径。配置要求有最好的扩展性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;## RR2
ip ip-prefix 172 permit 172.16.0.0 16 greater-equal 32  # 匹配172的主机路由

route-policy O2I deny node 10
    if-match tag 100
route-policy O2I permit node 20
    if-match ip-prefix 172
    apply tag 200
route-policy I2O deny node 10
    if-match tag 101
route-policy I2O permit node 20
    if-match ip-prefix 172
    apply cost-type type-1
    apply tag 201

route-policy OASE permit node 10
    if-match tag 2 # 与PE4引入时指定的tag一致
    apply preference 14 #针对PE4引入的ospf外部路由设置优先级为14
    
ospf 1
    import-route isis 1 type 1 route-policy I2O 
    preference ase route-policy OASE
isis 1
    import-route ospf 1 inherit-cost route-policy O2I

dis route-policy # 此时查看匹配到的路由是不是有0，有则需要把deny重新配置一下
dis cu conf routr-policy
undo route-policy O2I node 10
route-policy O2I deny node 10
    if-match tag 300
undo route-policy I2O node 10
route-policy I2O deny node 10
    if-match tag 201


# P2
ip ip-prefix 172 permit 172.16.0.0 16 greater-equal 32

route-policy I2O permit node 20
    if-match ip-prefix 172
    apply tag 100
route-policy I2O deny node 10
    if-match tag 200
route-policy O2I permit node 20
    if-match ip-prefix 172
    apply tag 101
route-policy O2I deny node 10
    if-match tag 201
    
route-policy OASE permit node 10
    if-match tag 2 # 与PE4引入时指定的tag一致
    apply preference 14   # 针对PE4引入的ospf外部路由设置优先级为14（ospf为10，isis为15）
    
ospf 1
    import-route isis 1 type 1 route-policy I2O 
    preference ase route-policy OASE
isis 1
    import-route ospf 1 inherit-cost route-policy O2I

dis route-policy  # 此时查看匹配到的路由是不是有0，因为路由之前已经过去了，需要把deny重新配置一下
dis cu conf routr-policy
undo route-policy O2I node 10
route-policy O2I deny node 10
    if-match tag 301
undo route-policy I2O node 10
route-policy I2O deny node 10
    if-match tag 200

# 检查-----------------
# RR2/P2
dis route-policy  # 此时匹配的路由条数不应该有0
# P2
dis ip rou # 到达PE4(172.16.1.2)的路由应该为O_ASE，接口为g0/0/2，即OSPF的外部路由而不是ISIS的路由
# PE4
dis ip rou pro ospf # 到达P2(172.16.1.10)为g0/0/2接口
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;如图4，各站点通过MPLS BGP VPN 跨域 Option C 方案二，能够相互学习路由。PE1-RR1、PE2-RR1、PE3-RR2、PE4-RR2之间建立MP-IBGP连接的源接口为loopback0。RR1-RR2之间建立MP-EBGP邻居的源接口为loopback0。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RR1/P1：配置isis的路由泄露
ip ip-prefix 172 permit 172.16.0.0 16 gr 32
isis 1
    import isis level-2 into level-1 filter-policy ip-prefix 172

# PE3、PE4：路由的相互引入
# PE3/4
bgp 200
	#边缘设备路由的双向引入，使CE3/4学到相应的路由
    ipv4-family vpn-instance VPN1
        import ospf 2
ospf 2
    import bgp type 1

# ASBR1/2/3/4：开启路由带标签能力，将bgp路由导入IGP同时优选IGP
int g0/0/2  # ASBR互联接口开启mpls
    mpls
    q
ip ip-prefix 172 permit 172.16.0.0 16 great 32 #将对端172的主机路由引入本AS内部IGP
route-policy 172 permit node 10
    if-match ip-prefix 172
    apply tag 1234
route-policy AB deny node 5  # 防止将BGP引入IGP时出环
    if-match tag 1234
isis   # IGP引入BGP的路由
    import-route bgp inherit-cost route-policy 172
bgp 100/200
    preference 12 255 255  # 修改bgp优先级，保证IGP优选。ebgp的优先级12小于ISIS的优先级15，优选bgp；ibgp的优先级255大于ISIS的优先级，优选ISIS；本地优先级为255
IGP标签
route-policy MPLS permit no 10 # 向ebgp邻居通告路由时带标签
    apply mpls-label  
    
# ASBR1
mpls
    lsp-trigger bgp-label-route ip-prefix 172  # 让LDP为来自BGP的带标签的路由分配
bgp 100
    peer 10.1.57.2 route-policy MPLS export
    peer 10.1.57.2 label-route-capability  # 针对邻居开启公网路由带标签能力
# ASBR3
mpls
    lsp-trigger bgp-label-route ip-prefix 172  # 让LDP为来自BGP的带标签的路由分配
bgp 200
    peer 10.1.57.1 route-policy MPLS export
    peer 10.1.57.1 label-route-capability
# ASBR2
mpls
    lsp-trigger bgp-label-route ip-prefix 172  # 让LDP为来自BGP的带标签的路由分配
bgp 100
    peer 10.1.68.2 route-policy MPLS export
    peer 10.1.68.2 label-route-capability
# ASBR4
mpls
    lsp-trigger bgp-label-route ip-prefix 172  # 让LDP为来自BGP的带标签的路由分配
bgp 200
    peer 10.1.68.1 route-policy MPLS export
    peer 10.1.68.1  label-route-capability

# PE1/2
bgp 100
    ipv4-family vpnv4
        peer 172.16.1.3 enable
# RR1
bgp 100
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0
    peer 172.16.1.9 ebgp-max-hop
    ipv4-family unicast
        undo peer 172.16.1.9 enable  # 关闭RR之间的ipv4邻居，防止路由选路错误
    ipv4-family vpnv4
        undo policy vpn-target 
        peer 172.16.1.9 enable
        peer 172.16.1.9 next-hop-invariable
        peer 172.16.1.9 allow-as-loop
        peer 172.16.1.1 enable
        peer 172.16.1.1 re
        peer 172.16.1.1 next-hop-invariable # 不修改下一跳
        peer 172.16.1.20 enable
        peer 172.16.1.20 re
        peer 172.16.1.20 next-hop-in
# PE3/4
bgp 200
    ipv4-family vpnv4
        peer 172.16.1.9 enable


# RR2
bgp 200
    peer 172.16.1.3 as 100
    peer 172.16.1.3 co lo 0
    peer 172.16.1.3 ebgp-max-hop
    ipv4-family unicast
        undo peer 172.16.1.9 enable 
    ipv4-family vpnv4
        undo policy vpn-target 
        peer 172.16.1.3 enable
        peer 172.16.1.3 next-hop-in
        peer 172.16.1.3 allow-as-loop
        peer 172.16.1.11 enable
        peer 172.16.1.11 re
        peer 172.16.1.11 next-hop-in
        peer 172.16.1.2 enable
        peer 172.16.1.2 re
        peer 172.16.1.2 next-hop-in

# 检查-----------------
# RR1/2
dis bgp vpnv4 all peer #各有3个邻居
dis bgp peer # 查看两个RR之间的邻居
# RR2/PE3/PE4
dis bgp vpnv4 all rou  # 是否学到CE1/2/3/4上的路由10.3.1.0、10.3.2.0、10.3.3.3、10.4.4.4
# RR1/PE1/PE2
dis bgp vpnv4 all rou  # 是否学到CE1/2/3/4上的路由10.3.1.0、10.3.2.0、10.3.3.3、10.4.4.4
# RR1/P1
dis ip rou pro isis  # 查看时候学习到isis level2的路由，主要是192.168.1.11/2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;在CE1、CE2上配置EBGP的协议优先级为120&lt;/li&gt;
&lt;li&gt;在CE1、CE2上面，将BGP导入OSPF。保证配置有最好的扩展性（和4、5要求重合）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1/2：修改eBGP的优先级
bgp 65000
    preference 120 255 255
    
ospf 1
    import bgp type 1  # 引入之前先做PE1/2上面的soo
# PE1：为了防环，需要配置soo属性
bgp 100
    ipv4-family vpn-instance HUB
        peer 10.2.11.5 soo 100:12
    ipv4-family vpn-instance VPN1
        peer 10.2.11.1 soo 100:12
# PE2：为了防环，需要配置Soo属性
bgp 100
    ipv4-family vpn-instance HUB
        peer 10.2.22.5 soo 100:12
    ipv4-family vpn-instance VPN1
        peer 10.2.22.1 soo 100:12
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;在PE3、PE4上修改BGP local preference属性。实现CE3、CE4访问直连的10.3.x.0/24网段时，若x为奇数，PE3、PE4优选下一跳为PE1，若x为偶数，PE3、PE4优选下一跳为PE2，不用考虑来回路径是否一致&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE3/4
acl 2000
    rule permit source 10.3.0.0 0.0.254.255
acl 2001
    rule permit source 10.3.1.0 0.0.254.255
ip ip-prefix NH-PE1 permit 172.16.1.1 32
ip ip-prefix NH-PE2 permit 172.16.1.20 32
route-policy AB permit node 10
    if-match acl 2000
    if-match ip next-hop ip-prefix NH-PE2
    apply local-preference 200   # 本地优先级越大越优，cost越小越优
route-policy AB permit node 20
    if-match acl 2001
    if-match ip next-hop ip-prefix NH-PE1
    apply local-preference 200
route-policy AB permit node 30  # 放行其他路由
bgp 200
    ipv4-family vpnv4
    peer 172.16.1.9 route-policy AB import  # 从反射器来的路由应用上面的条件

# 检查-----------------
# PE3/4
dis bgp vpnv4 all rou #10.3.1.0下一跳为172.16.1.1，本地优先级为200；10.3.2.0下一条为172.16.1.20，本地优先级为200

# 整个大题最后的测试
# CE3/4
tracert -a 10.3.3.3 10.4.4.4 # CE4：9hop
tracert -a 10.3.3.3 10.3.1.10 # PC1：8hop
tracert -a 10.3.3.3 10.3.2.20 # PC2：8hop

# CE4
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.3.3  # CE3：9hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.1.10 # PC1：8hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.2.20 # PC2：8hop

# PC1/2
tracert 10.3.3.3 # 3hop
tracert 10.4.4.4

# PC1
tracert 10.3.2.20 # 2hop
# PC2
tracert 10.3.1.10 # 2hop
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-feature&#34;&gt;4. Feature&lt;/h2&gt;
&lt;h3 id=&#34;41-ha&#34;&gt;4.1 HA&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1配置静态的默认路由访问ISP，下一跳IP为100.0.1.2.该默认路由要与CE1-ISP链路的BFD状态绑定（CE1的对端设备不支持BFD），感知故障的时间要小于150ms&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE1
bfd # 开启全局bfd
    q
bfd huawei bind peer-ip 100.0.1.2 int g2/0/1 one-arm-echo 
    discriminator local 1  # 配置本地设备标示为1
    min-echo-rx-interval 40 # 40的3倍小于150
    commit
    q
ip route-static 0.0.0.0 0.0.0.0 100.0.1.2 track bfd-session huawei
# 检测---------
dis bfd session all
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CE2配置静态的默认路由访问ISP，下一跳IP为200.0.2.2.该默认路由要与CE2-ISP链路的NQA ICMP测试绑定，间隔5S测试执行1次&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE2
nqa test-instance huawei huawei
    test-type icmp
    destination-address ipv4 200.0.2.2
    frequency 5
    start now
    q
ip route-static 0.0.0.0 0.0.0.0 200.0.2.2 track nqa huawei huawei
# 检测---------
dis nqa history
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;CE3、CE4能够通过默认路由访问ISP。CE1-ISP的链路断开时，CE1仍能访问ISP；CE2-ISP的链路断开时，CE2仍能访问ISP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 使用ospf结合bgp下发默认
# CE1:2
ospf 1
    default-route-advertise
bgp 65000
    network 0.0.0.0
int g0/0/2.10:20  # 分别在自己的master VRRP上针对去往ISP和对方的链路开启track
    vrrp vrid 1:2 track int g0/0/0 reduced 15
    vrrp vrid 1:2 track int g2/0/1:2 reduced 15
# PE3/4
ospf 2 
    default-route-advertise
# 检测--------
# CE3
dis ip rou   # 查看是否有默认路由
# CE4
dis ip rou vpn-instance VPN1 # 查看是否有默认路由
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-nat&#34;&gt;4.2 NAT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/1访问ISP。&lt;br&gt;
在CE2上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/2访问ISP。&lt;br&gt;
Server1拥有单独的公网地址102.0.1.1，对ISP提供FTP和HTTP服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#  CE1
acl 2999
    rule deny source 10.3.2.10 0
    rule permit source 10.3.0.0 0.0.255.255
nat address-group 1 102.0.1.2 102.0.1.6
int g2/0/1
    nat outbound 2999 address-group 1
    nat server protocol tcp global 102.0.1.1 www inside 10.3.2.10 www
    nat server protocol tcp global 102.0.1.1 ftp inside 10.3.2.10 ftp
#  CE2
acl 2999
    rule deny source 10.3.2.10 0
    rule permit source 10.3.0.0 0.0.255.255
nat address-group 1 102.0.1.2 102.0.1.6
int g2/0/2
    nat outbound 2999 address-group 1
    nat server protocol tcp global 102.0.1.1 www inside 10.3.2.10 www
    nat server protocol tcp global 102.0.1.1 ftp inside 10.3.2.10 ftp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;43-qos&#34;&gt;4.3 Qos&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1的g2/0/1、CE2的g2/0/2的出方向，周一至周五的8:00-18:00，对TCP目的端口号为6881-6999的流量，承诺的平均速率为1Mbps&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1/2/3--------------
# CE1
time-range WORKING 8:00 to 18:00 working-day
acl 3000
    rule permit tcp desination-port range 6881 6999 timer-range WORKING
traffic classifiter HUAWEI
    if-match acl 3000
traffic behavior HUAWEI
    car cir 1000
traffic policy HUAWEI
    classifier HUAWEI behavior HUAWEI
interface g2/0/1
    traffic-policy HUAWEI outbound
# CE2
time-range WORKING 8:00 to 18:00 working-day
acl 3000
    rule permit tcp desination-port range 6881 6999 timer-range WORKING
traffic classifiter HUAWEI 
    if-match acl 3000
traffic behavior HUAWEI
    car cir 1000
traffic policy HUAWEI
    classifier HUAWEI behavior HUAWEI
interface g2/0/2
    traffic-policy HUAWEI outbound

# 检查-----
dis traffic policy user-defied
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-ipv6&#34;&gt;5. IPv6&lt;/h2&gt;
&lt;h3 id=&#34;51-基本配置&#34;&gt;5.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有相关设备接口的IPv6地址，按照图6配置（除PE1-RR1的逻辑接口外，已预配置）&lt;br&gt;
&lt;code&gt;在WAN那道题中已经配置&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-ipv6-isis&#34;&gt;5.2 IPv6 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图6，PE1、PE2、RR1、P1、ASBR1、ASBR2运行isis协议，各直连网段通告入isis，配置各链路cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int ip 1
    isis ipv6 enable 
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 20 

# PE2
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 20
int g0/0/2
    isis ipv6 enable 
    isis ipv6 cost 1500

# RR1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int ip 1
    isis ipv6 enable 
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 860

# P1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/2
    isis ipv6 enable 
    isis ipv6 cost 1500
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 1000

# ASBR1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 860
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 100

# ASBR2
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 1000
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 100
    
# RR1/P1
isis 1
    ipv6 import-route isis level-2 into level-1    # 路由渗透，保证AS内环回口互通，可以做与v1相同的策略进行防环，此处不做了

# 检查---------
dis ipv6 rou pro isis # 可以查看到AS100内所有其他设备环回口路由，建议在PE2上查看
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-ipv6-multicast&#34;&gt;5.3 IPv6 Multicast&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图7，AS100中，相邻设备建立PIM IPv6 SM的邻居关系。PE1的E0/0/0静态加入组FF1E::AA&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
multicast ipv6 routing-enabel
int E0/0/0   
	ipv6 enable
	ipv6 addr 3000:E85A:8CA2:BF40:C45A:89EE:CBDF:ADD1/112
    pim ipv6 sm  # 先开启
    pim ipv6 silent  # 保障安全
    mld enable   # 后开启
    mld static-group FF1E::AA  # 静态加组
int loo 0
    pim ipv6 sm
int ip 1
	ipv6 enable
    pim ipv6 sm
int g0/0/0
	ipv6 enable
	pim ipv6 sm

# PE2
multicast ipv6 routing-enabel
int loo 0
	ipv6 enable
    pim ipv6 sm
int g0/0/0
	ipv6 enable
    pim ipv6 sm
int g0/0/2
	ipv6 enable
    pim ipv6 sm

# RR1
multicast ipv6 routing-enabel
int loo 0
	ipv6 enable
    pim ipv6 sm
int ip 1
	ipv6 enable
    pim ipv6 sm
int g0/0/0
	ipv6 enable
    pim ipv6 sm
int g0/0/1
	ipv6 enable
    pim ipv6 sm

# P1
multicast ipv6 routing-enabel
int loo 0
	ipv6 enable
    pim ipv6 sm
int g0/0/0
	ipv6 enable
    pim ipv6 sm
int g0/0/1
	ipv6 enable
    pim ipv6 sm
int g0/0/2
	ipv6 enable
    pim ipv6 sm

# ASBR1
multicast ipv6 routing-enabel
int loo 0
	ipv6 enable
    pim ipv6 sm
int g0/0/0
	ipv6 enable
    pim ipv6 sm
int g0/0/1
	ipv6 enable
    pim ipv6 sm

# ASBR2
multicast ipv6 routing-enabel
int loo 0
	ipv6 enable
    pim ipv6 sm
int g0/0/0
	ipv6 enable
    pim ipv6 sm
int g0/0/2
	ipv6 enable
    pim ipv6 sm

#--------检查
# 所有配置设备
dis pim ipv6 neighbor 

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ASBR1的loopback0、ASBR2的loopback0为C-BSR且都为FF1E::/112的C-RP。ASBR1的loopback0成为BSR，ASBR2的loopback0成为FF1E::/112的RP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ASBR1/ASBR2
acl ipv6 2000
    rule permit source FF1E::AA/112  # 定义RP的服务组范围
acl ipv6 3100
    rule permit ipv6 source 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5/128 destination FF1E::AA/112
    rule permit ipv6 source 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6 128 destination FF1E::AA/112

# ASBR1 :bsr优先级是越大越优  rp优先级是越小越优
pim-ipv6
    c-bsr priority 200
    c-bsr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5
    c-rp 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5 group-po 2000 pri 200
    crp-policy 3100
# ASBR2
pim-ipv6
    c-bsr priority 100
    c-bsr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6
    c-rp 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6 group-po 2000 pri 100
    crp-policy 3100
# 检查--------------
# PE1
dis pim ipv6 bsr-info  # BSR地址为xxxxxxDCA5，优先级为200，C-RP数量2个
dis pim ipv6 rp-info  # RP地址为xxxxxxDCA5，优先级为200；下一个RP地址为xxxxxxDCA6，优先级为100
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;无论哪个C-RP成为RP，都要确保PIM IPv6域生成（*，G）表项无次优路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
pim-ipv6
    spt-switch-threshold infinity
# 检查--------------
#ASBR1/2
dis pim ipv6 rou  # 只有（*，FF1E::AA）
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验LABv2步骤分解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-labv1/"" data-c="
          &lt;p&gt;二层、WAN、生成树、IPv4 IGP、BGP和V2相同，区别是isis和ospf双向引入v1放在isis题中，v2放在mpls vpn题中(第9题，已经将其提前到isis中)&lt;code&gt;主要区别是跨域部分，BGP没区别&lt;/code&gt;，下面主要是区别点&lt;/p&gt;
&lt;h1 id=&#34;v1&#34;&gt;V1&lt;/h1&gt;
&lt;h2 id=&#34;mpls-vpnv1-mpls&#34;&gt;MPLS VPN&lt;sub&gt;V1-MPLS&lt;/sub&gt;&lt;/h2&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;在ASBR上，将isis的loopback0的路由引入BGP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# V2是打tag，V1是明细（允许本区域内的）
# ASBR1/2
ip ip-prefix 172 permit 172.16.1.1/20/3/4/5/6 32
route-policy 172 permit no 10
    if-match ip-prefix 172
bgp 100
    import isis 1 route-policy 172
# ASBR3/4
ip ip-prefix 172 permit 172.16.1.7/8/9/10/11/2 32
route-policy 172 permit no 10
    if-match ip-prefix 172
bgp 200
    import isis 1 route-policy 172
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;如图3，AS100、AS200内各网元配置MPLS LSR ID，全局使能MPLS，MPLS LDP（已预配置）。AS100、AS200内各直连链路建立LDP邻居。（除PE1-RR1之外的逻辑链路外，已预配置）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 9--------------------要求相同，ASBR之间还是只能开启mpls
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;如图4，各站点，&lt;strong&gt;通过MPLS BGP VPN跨域OptionC方案一&lt;/strong&gt;，能够相互学习路由。MPLS域不能出现次优路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#  -----------路由处理
# RR1/P1：isis路由渗透
# 路由渗透V2是全部，V1只渗透ASBR1/2的
ip ip-prefix ASBR12 permit 172.16.1.5 32
ip ip-prefix ASBR12 permit 172.16.1.6 32
isis 1
    import isis level-2 into level-1 filter-policy ip-prefix ASBR12

# PE3/PE4:vpn路由的相互引入(与v2相同)
bgp 200
    ipv4-family vpn-instance VPN1
    import-route ospf 2
ospf 2
    import-route bgp type 1

# 不需要：将bgp路由导入IGP同时优选IGP，修改bgp优先级


# ---------vpnv4邻居：比V2多开启了label能力
# PE1/2：PE3/4
bgp 100
	# 比v2多label
    peer 172.16.1.3:9 label-route-capability 
    ipv4-family vpnv4
        peer 172.16.1.3:9 enable
        
# RR1：RR2
bgp 100:200
	# 比v2多label
    peer 172.16.1.1/20:11/2 label-route-capability 
    ipv4-family vpnv4
        peer 172.16.1.1/20:11/2 enable
        peer 172.16.1.1/20:11/2 re
        peer 172.16.1.1/20:11/2 next-hop-invariable

#  -----------标签能力
# 与V2相比：
# 1. 不需要：开启mpls进程下的标签携带能力
# 2. ASBR需要开启针对RR的label
# 3. ASBR的EBGP邻居之间变成 label+policy
# 4. ASBR与RR之间 label+双层标签
# ASBR1/2：ASBR3/4
route-policy mpls1 permit node 10  # ASBR的EBGP邻居之间
    apply mpls-label
route-policy mpls2 permit node 10  #ASBR与RR之间
    if-match mpls-label
    apply mpls-label  # 如果有标签，再给个标签
bgp 100:200
	# 对ebgp邻居加标签
    peer 10.1.57/68.2 label-route-capability
    peer 10.1.57/68.2 route-policy mpls1 export  
	# 对RR有标签再加一层
    peer 172.16.1.3:9 label-route-capability 
    peer 172.16.1.3:9 route-policy mpls2 export  
    
# RR1：RR2
bgp 100:200
    peer 172.16.1.5/6:7/8 label-route-capability

# 检查------
# RR1/RR2/PE1/PE2/PE3/PE4
dis bgp vpnv4 all peer
# RR/PE/CE
dis bgp vpnv4 all rou  # 需要有10.3.1.0、10.3.2.0、10.3.3.3、10.4.4.4
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;在CE1、CE2上配置EBGP的协议优先级为120&lt;/li&gt;
&lt;li&gt;在CE1、CE2上面，将BGP导入OSPF。保证配置有最好的扩展性（和4、5要求重合）&lt;/li&gt;
&lt;li&gt;在PE3、PE4上修改BGP local preference属性。实现CE3、CE4访问直连的10.3.x.0/24网段时，若x为奇数，PE3、PE4优选下一跳为PE1，若x为偶数，PE3、PE4优选下一跳为PE2，不用考虑来回路径是否一致&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 整个大题最后的测试
# CE3/4
tracert -a 10.3.3.3 10.4.4.4 # CE4：9hop
tracert -a 10.3.3.3 10.3.1.10 # PC1：8hop
tracert -a 10.3.3.3 10.3.2.20 # PC2：8hop
# CE4
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.3.3  # CE3：9hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.1.10 # PC1：8hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.2.20 # PC2：8hop
# PC1/2
tracert 10.3.3.3 # 3hop
tracert 10.4.4.4
# PC1
tracert 10.3.2.20 # 2hop
# PC2
tracert 10.3.1.10 # 2hop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-featurev1-hav1-nat&#34;&gt;4. Feature&lt;sub&gt;V1-HA+V1-NAT&lt;/sub&gt;&lt;/h2&gt;
&lt;h3 id=&#34;41-ha&#34;&gt;4.1 HA&lt;/h3&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CE2配置静态的默认路由访问ISP，下一跳IP为200.0.2.2.该默认路由要与CE2-ISP链路的NQA ICMP测试绑定，间隔3S测试执行1次&lt;code&gt;只有一点区别，就是将&amp;quot;间隔5秒&amp;quot;改为&amp;quot;间隔3秒&amp;quot;，配置方法相同&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-qos&#34;&gt;4.3 Qos&lt;/h3&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CE4-PE4的Qos规则如下表所示：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1607328085867.png&#34; alt=&#34;Qos&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在CE4的g0/0/1出方向对流量进行802.1p标记。在PE4的g0/0/1的入方向，继承CE4的802.1p值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# CE4
acl 3001
    rule permit ip destination 10.3.1.0 0.0.0.255
traffic classifier re
    if-match acl 3001  
traffic behavior re
    remark 8021p 5

acl 3002
    rule permit  ip destination  10.3.2.0 0.0.0.255
traffic classifier si
    if-match acl 3002
traffic behavior si
    remark 8021p 4

acl 3003
    rule permit  ip destination  10.3.3.0 0.0.0.255
traffic classifier mo
    if-match acl 3003
traffic behavior mo
    remark 8021p 3

acl 3004
    rule permit  ip destination  10.3.4.0 0.0.0.255
traffic classifier of
    if-match acl 3004 
traffic behavior of
    remark 8021p 2

traffic behavior BE  # 其他
    remark 8021p 0

traffic policy Qos
    classifier re behavior re
    classifier si behavior si
    classifier mo behavior mo
    classifier of behavior of
    classifier default-class behavior BE

int g0/0/1
    traffic-policy Qos outbound

# PE4
qos map-table dot1p-dscp  # 在PE4的g0/0/1的入方向上，继承CE4的802.1p值，并将802.1p映射为DSCP。dis th之后只显示5，其他为默认，可以只配置5
    input 5 output 46
    # input 4 output 32
    # input 3 output 24
    # input 2 output 16
    # input 0 output 0
int g0/0/1
    trust 8021p
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;PE4的g0/0/0和g0/0/2匹配DSCP值，根据表1，配置拥塞管理和拥塞避免&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE4
drop-profile cs4
    wred dscp
    dscp cs4 low-limit 70 high-limit 100 discard-percentage 50
drop-profile cs3
    wred dscp
    dscp cs3 low-limit 50 high-limit 90 discard-percentage 50
drop-profile cs2
    wred dscp
    dscp cs2 low-limit 50 high-limit 80 discard-percentage 50
drop-profile default
    wred dscp
    dscp default low-limit 50 high-limit 80 discard-percentage 50
qos queue-profile QP
    schedule wfq 0 to 4 pq 5  # 必须先做
    queue 4 weight 63
    queue 4 drop-profile cs4
    queue 3 weight 21
    queue 3 drop-profile cs3
    queue 2 weight 9
    queue 2 drop-profile cs2
    queue 0 weight 1
    queue 0 drop-profile default
int g0/0/0
    qos queue-profile QP
int g0/0/2
    qos queue-profile QP   

# 检查------
dis qos queue-profile QP
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-ipv6&#34;&gt;5. IPv6&lt;/h2&gt;
&lt;h3 id=&#34;52-ipv6-isis&#34;&gt;5.2 IPv6 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图6，PE1、PE2、RR1、P1、ASBR1、ASBR2运行isis协议，各直连网段通告入isis，配置各链路cost&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-ipv6-bgp&#34;&gt;5.3 IPv6 BGP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图7，ASBR1-ASBR3通过直连链路建立eBGP4+邻居，PE1、PE2、P1是RR1的BGP4+客户端（已预配置）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# --------ASBR1/3之间的EBGP
# ASBR1/ASBR3
ipv6 #开启IPv6，需要在ASBR3上做
bgp 100
    peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:5700/1 as 200/100
    ipv6-family unicast
        peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:5700/1 enable  # ipv6需要手动en

#-----------------IBGP+反射 
# ASBR1/ASBR2/P1/PE1/PE2
bgp 100
    peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA3 as 100
    peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA3 co lo 0
    ipv6-family unicast
        peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA3 enable

# ASBR1/ASBR2 ：设置下一跳自我
bgp 100
    ipv6-family unicast
        peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA3 next-hop-local

# RR1
bgp 100
    peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA1/2/4/5/6 as 100
     peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA1/2/4/5/6 co lo 0
    ipv6-family unicast
        peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA1/2/3/4/6 enable
        # 注意ASBR不需要设置反射客户端
        peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA1/2/4 reflect-client

# 检查-----------
# ASBR1/3
dis bgp ipv6 peer 
# RR1
dis bgp ipv6 peer
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在ASBR1将ISIS IPv6的路由导入BGP4+，只向ASBR3通告前缀为xxxxxxxxxx（loo0）的路由，不能使用route-policy，将ASBR3的loopback0通告入BGP4+&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ASBR1：所有lo 接口地址
ip ipv6-prefix 66 permit 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA0 124 gr 128 
bgp 100
    ipv6-family unicast
        import isis 1   # 需要引入isis路由
        peer 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:5700 ipv6-prefix 66 export

# ASBR3：BGP中宣告lo 0
bgp 200
    ipv6-family unicast
        network  2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA7 128

# 检查--------
# ASBR1/3
dis bgp ipv6 rou # 有DCA1-7的地址
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;PE1、PE2学习到ASBR3 loopback0的BGP4+明细路由&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RR1/P1 ： IPv6的路由渗透
ip ip-prefix 66 permit 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA0 124 gr 128 
isis 1
    ipv6 import-route isis level-2 into level-1 filter-policy ipv6-prefix 66

# 检查---------
dis bgp ipv6 rou #有DCA7的明细路由
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;请在PE1使能某特性，以确保PE1在启动过程（从物理接口up，到协议xx建立）中，PE2-ASBR3的IPv6 ping不丢包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
switchover mode nonstop-routing
isis
    graceful-restart
    set-overload on-startup wait-for-bgp
bgp 100
    ipv6-family unicast
        auto-frr   
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验LABv1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-zhi-zhi-xing-ming-ling-subprocess/"" data-c="
          &lt;p&gt;subprocess用来生成子进程，并可以通过管道连接他们的&lt;strong&gt;输入/输出/错误&lt;/strong&gt;，以及获得他们的返回值。&lt;br&gt;
subprocess用来替换多个旧模块和函数：&lt;code&gt;os.system、os.spawn*、os.popen*、popen2.*、commands.*&lt;/code&gt;。在python中，通过标准库中的subprocess包来fork一个子进程，并且运行一个外部的程序。subprocess包中定义有数个创建子进程的函数，这些函数分别以不同的方式创建子进程，可以根据需要来从中选取一个使用。另外subprocess还提供了一些管理标准流(standard stream)和管道(pipe)的工具，从而&lt;code&gt;在进程间使用文本通信&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;旧模块的使用&#34;&gt;旧模块的使用&lt;/h1&gt;
&lt;h2 id=&#34;ossystem&#34;&gt;os.system()&lt;/h2&gt;
&lt;p&gt;执行操作系统的命令，将结果输出到屏幕，只返回命令执行状态&lt;code&gt;0成功，非0失败&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
&amp;gt;&amp;gt;&amp;gt; a = os.system(&amp;quot;df -Th&amp;quot;)
Filesystem   Type  Size Used Avail Use% Mounted on
/dev/sda3   ext4  1.8T 436G 1.3T 26% /
tmpfs     tmpfs  16G   0  16G  0% /dev/shm
/dev/sda1   ext4  190M 118M  63M 66% /boot
&amp;gt;&amp;gt;&amp;gt; a
0     
# 0 表示执行成功

# 执行错误的命令
&amp;gt;&amp;gt;&amp;gt; res = os.system(&amp;quot;list&amp;quot;)
sh: list: command not found
&amp;gt;&amp;gt;&amp;gt; res
32512    # 返回非 0 表示执行错误
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ospopen&#34;&gt;os.popen()&lt;/h2&gt;
&lt;p&gt;执行操作系统的命令，会将结果保存在内存当中，可以用&lt;code&gt;read()&lt;/code&gt;方法读取出来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;import os
&amp;gt;&amp;gt;&amp;gt; res = os.popen(&amp;quot;ls -l&amp;quot;)
# 将结果保存到内存中
&amp;gt;&amp;gt;&amp;gt; print res
&amp;lt;open file &#39;ls -l&#39;, mode &#39;r&#39; at 0x7f02d249c390&amp;gt;
# 用read()读取内容
&amp;gt;&amp;gt;&amp;gt; print res.read()
total 267508
-rw-r--r-- 1 root root  260968 Jan 27 2016 AliIM.exe
-rw-------. 1 root root   1047 May 23 2016 anaconda-ks.cfg
-rw-r--r-- 1 root root  9130958 Nov 18 2015 apache-tomcat-8.0.28.tar.gz
-rw-r--r-- 1 root root     0 Oct 31 2016 badblocks.log
drwxr-xr-x 5 root root   4096 Jul 27 2016 certs-build
drwxr-xr-x 2 root root   4096 Jul 5 16:54 Desktop
-rw-r--r-- 1 root root   2462 Apr 20 11:50 Face_24px.ico
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;subprocess的使用&#34;&gt;subprocess的使用&lt;/h1&gt;
&lt;h2 id=&#34;subprocess模块中的常用函数&#34;&gt;subprocess模块中的常用函数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;subprocess.run()&lt;br&gt;
执行指定的命令，等待命令执行完成后返回一个包含执行结果的CompletedProcess类的实例。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, timeout=None, check=False, universal_newlines=False)

# 应用举例：
&amp;gt;&amp;gt;&amp;gt; import subprocess
# python 解析则传入命令的每个参数的列表
&amp;gt;&amp;gt;&amp;gt; subprocess.run([&amp;quot;df&amp;quot;,&amp;quot;-h&amp;quot;])
Filesystem      Size Used Avail Use% Mounted on
/dev/mapper/VolGroup-LogVol00
           289G  70G 204G 26% /
tmpfs         64G   0  64G  0% /dev/shm
/dev/sda1       283M  27M 241M 11% /boot
CompletedProcess(args=[&#39;df&#39;, &#39;-h&#39;], returncode=0)
# 需要交给Linux shell自己解析，则:传入命令字符串，shell=True
&amp;gt;&amp;gt;&amp;gt; subprocess.run(&amp;quot;df -h|grep /dev/sda1&amp;quot;,shell=True)
/dev/sda1       283M  27M 241M 11% /boot
CompletedProcess(args=&#39;df -h|grep /dev/sda1&#39;, returncode=0)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;类介绍&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;需要说明的是，&lt;code&gt;subprocess.run()&lt;/code&gt;函数是Python3.5中新增的一个高级函数，其返回值是一个&lt;code&gt;subprocess.CompletedPorcess&lt;/code&gt;类的实例，因此，&lt;code&gt;subprocess.completedPorcess&lt;/code&gt;类也是Python 3.5中才存在的。它表示的是一个已结束进程的状态信息，它所包含的属性如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1. args&lt;/strong&gt;： 用于加载该进程的参数，这可能是一个列表或一个字符串&lt;br&gt;
&lt;strong&gt;2. returncode&lt;/strong&gt;： 子进程的退出状态码。通常情况下，退出状态码为0则表示进程成功运行了；一个负值-N表示这个子进程被信号N终止了&lt;br&gt;
&lt;strong&gt;3. stdout&lt;/strong&gt;： 从子进程捕获的stdout。这通常是一个字节序列，如果run()函数被调用时指定&lt;code&gt;universal_newlines=True&lt;/code&gt;，则该属性值是一个字符串。如果run()函数被调用时指定&lt;code&gt;stderr=subprocess.STDOUT&lt;/code&gt;，那么stdout和stderr将会被整合到这一个属性中，且stderr将会为None&lt;br&gt;
&lt;strong&gt;4. stderr&lt;/strong&gt;： 从子进程捕获的stderr。它的值与stdout一样，是一个字节序列或一个字符串。如果stderr没有被捕获的话，它的值就为None&lt;br&gt;
&lt;strong&gt;5. check_returncode()&lt;/strong&gt;： 如果returncode是一个非0值，则该方法会抛出一个&lt;code&gt;CalledProcessError&lt;/code&gt;异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;subprocess.call()&lt;br&gt;
执行指定的命令，返回命令执行结果和状态，其功能类似于&lt;code&gt;os.system(cmd)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;subprocess.call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None)

# 应用举例：
&amp;gt;&amp;gt;&amp;gt; res = subprocess.call([&amp;quot;ls&amp;quot;,&amp;quot;-l&amp;quot;])
总用量 28
-rw-r--r-- 1 root root   0 6月 16 10:28 1
drwxr-xr-x 2 root root 4096 6月 22 17:48 _1748
-rw-------. 1 root root 1264 4月 28 20:51 anaconda-ks.cfg
drwxr-xr-x 2 root root 4096 5月 25 14:45 monitor
-rw-r--r-- 1 root root 13160 5月  9 13:36 npm-debug.log
# 命令执行状态
&amp;gt;&amp;gt;&amp;gt; res
0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;subprocess.check_call()&lt;br&gt;
执行指定的命令，如果执行成功则返回结果和状态码，否则抛出异常。其功能等价于&lt;code&gt;subprocess.run(..., check=True)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;subprocess.check_call(args, *, stdin=None, stdout=None, stderr=None, shell=False, timeout=None)

# 应用举例：
&amp;gt;&amp;gt;&amp;gt; subprocess.check_call([&amp;quot;ls&amp;quot;,&amp;quot;-l&amp;quot;])
总用量 28
-rw-r--r-- 1 root root   0 6月 16 10:28 1
drwxr-xr-x 2 root root 4096 6月 22 17:48 _1748
-rw-------. 1 root root 1264 4月 28 20:51 anaconda-ks.cfg
drwxr-xr-x 2 root root 4096 5月 25 14:45 monitor
-rw-r--r-- 1 root root 13160 5月  9 13:36 npm-debug.log
0
&amp;gt;&amp;gt;&amp;gt; subprocess.check_call([&amp;quot;lm&amp;quot;,&amp;quot;-l&amp;quot;])
Traceback (most recent call last):
 File &amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;, line 1, in &amp;lt;module&amp;gt;
 File &amp;quot;/usr/lib64/python2.7/subprocess.py&amp;quot;, line 537, in check_call
  retcode = call(*popenargs, **kwargs)
 File &amp;quot;/usr/lib64/python2.7/subprocess.py&amp;quot;, line 524, in call
  return Popen(*popenargs, **kwargs).wait()
 File &amp;quot;/usr/lib64/python2.7/subprocess.py&amp;quot;, line 711, in __init__
  errread, errwrite)
 File &amp;quot;/usr/lib64/python2.7/subprocess.py&amp;quot;, line 1327, in _execute_child
  raise child_exception
OSError: [Errno 2] No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;subprocess.check_output()&lt;br&gt;
执行指定的命令，如果执行状态码为0则返回命令执行结果，而不是打印，否则抛出异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;subprocess.check_output(args, *, stdin=None, stderr=None, shell=False, universal_newlines=False, timeout=None)

# 应用举例：
&amp;gt;&amp;gt;&amp;gt; res = subprocess.check_output(&amp;quot;pwd&amp;quot;)
&amp;gt;&amp;gt;&amp;gt; res
b&#39;/root\n&#39; # 结果以字节形式返回
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;subprocess.getoutput(cmd)&lt;br&gt;
接收字符串格式的命令，执行命令并返回执行结果，其功能类似于&lt;code&gt;os.popen(cmd).read()&lt;/code&gt;和&lt;code&gt;commands.getoutput(cmd)&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;subprocess.getstatusoutput(cmd)

# 应用举例：
&amp;gt;&amp;gt;&amp;gt; subprocess.getoutput(&#39;pwd&#39;)
&#39;/root&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;subprocess.getstatusoutput(cmd)	&lt;br&gt;
执行cmd命令，返回一个元组&lt;code&gt;(命令执行状态, 命令执行结果输出)&lt;/code&gt;，其功能类似于&lt;code&gt;commands.getstatusoutput()&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;subprocess.getoutput(cmd)

# 应用举例：
#执行正确
&amp;gt;&amp;gt;&amp;gt; subprocess.getstatusoutput(&#39;pwd&#39;)
(0, &#39;/root&#39;)
#执行错误
&amp;gt;&amp;gt;&amp;gt; subprocess.getstatusoutput(&#39;pd&#39;)
(127, &#39;/bin/sh: pd: command not found&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用函数中参数说明&#34;&gt;常用函数中参数说明&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;args&lt;br&gt;
要执行的shell命令，默认应该是一个字符串序列，序列的第一个元素通常都必须是一个可执行文件的路径，如&lt;code&gt;[&#39;df&#39;, &#39;-Th&#39;]&lt;/code&gt;或&lt;code&gt;(&#39;df&#39;, &#39;-Th&#39;)&lt;/code&gt;，当然也可以使用executeable参数来指定可执行文件的路径；也可以是一个字符串，如&lt;code&gt;&#39;df -Th&#39;&lt;/code&gt;，但是此时需要把shell参数的值置为True。&lt;/li&gt;
&lt;li&gt;shell&lt;br&gt;
如果shell为True，那么指定的命令将通过shell执行。如果需要访问某些shell的特性，如管道、文件名通配符、环境变量扩展功能，这将是非常有用的。当然，python本身也提供了许多类似shell的特性的实现，如glob、fnmatch、os.walk()、os.path.expandvars()、os.expanduser()和shutil等。&lt;/li&gt;
&lt;li&gt;check&lt;br&gt;
如果check参数的值是True，且执行命令的进程以非0状态码退出，则会抛出一个CalledProcessError的异常，且该异常对象会包含 参数、退出状态码以及stdout和stderr(如果它们有被捕获的话)。&lt;/li&gt;
&lt;li&gt;universal_newlines&lt;br&gt;
该参数影响的是输入与输出的数据格式，比如它的值默认为False，此时stdout和stderr的输出是字节序列；当该参数的值设置为True时，stdout和stderr的输出是字符串&lt;/li&gt;
&lt;li&gt;stdin,stdout,stderr&lt;br&gt;
分别表示程序的标准输入、标准输出、标准错误。有效的值可以是PIPE，存在的文件描述符，存在的文件对象或None，如果为None需从父进程继承过来，stdout可以是PIPE，表示对子进程创建一个管道，stderr可以是STDOUT，表示标准错误数据应该从应用程序中捕获并作为标准输出流stdout的文件句柄。&lt;/li&gt;
&lt;li&gt;input
&lt;ul&gt;
&lt;li&gt;run()函数&lt;br&gt;
默认不会捕获命令执行结果的正常输出和错误输出，如果我们向获取这些内容需要传递subprocess.PIPE，然后可以通过返回的CompletedProcess类实例的stdout和stderr属性或捕获相应的内容&lt;/li&gt;
&lt;li&gt;call()和check_call()函数&lt;br&gt;
返回的是命令执行的状态码，而不是CompletedProcess类实例，所以对于它们而言，stdout和stderr不适合赋值为subprocess.PIPE&lt;/li&gt;
&lt;li&gt;check_output()函数&lt;br&gt;
默认就会返回命令执行结果，所以不用设置stdout的值，如果希望在结果中捕获错误信息，可以执行stderr=subprocess.STDOUT&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;subprocess.run()、subprocess.call()、subprocess.check_call()和subprocess.check_output()都是通过对subprocess.Popen的封装来实现的高级函数，因此如果我们需要更复杂功能时，可以通过subprocess.Popen来完成。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;subprocesspopen的构造函数&#34;&gt;subprocess.Popen的构造函数&lt;/h2&gt;
&lt;p&gt;该类用于在一个新的进程中执行一个子程序。上面介绍的这些函数都是基于subprocess.Popen类实现的，通过使用这些被封装后的高级函数可以很方面的完成一些常见的需求。由于subprocess模块底层的进程创建和管理是由Popen类来处理的，因此，当无法通过上面哪些高级函数来实现一些不太常见的功能时就可以通过subprocess.Popen类提供的灵活的api来完成。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 构造函数
class subprocess.Popen(
    args, 
    bufsize=-1, 
    executable=None, 
    stdin=None, 
    stdout=None, 
    stderr=None,     
    preexec_fn=None, 
    close_fds=True, 
    shell=False, 
    cwd=None, 
    env=None, 
    universal_newlines=False,
    startup_info=None, 
    creationflags=0, 
    restore_signals=True, 
    start_new_session=False, 
    pass_fds=()
    )
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;args&lt;br&gt;
要执行的shell命令，可以是字符串，也可以是命令各个参数组成的序列。当该参数的值是一个字符串时，该命令的解释过程是与平台相关的，因此通常建议将args参数作为一个序列传递。&lt;/li&gt;
&lt;li&gt;bufsize&lt;br&gt;
指定缓存策略，0表示不缓冲，1表示行缓冲，其他大于1的数字表示缓冲区大小，负数表示使用系统默认缓冲策略。&lt;/li&gt;
&lt;li&gt;stdin, stdout, stderr&lt;br&gt;
分别表示程序标准输入、输出、错误句柄。&lt;/li&gt;
&lt;li&gt;preexec_fn&lt;br&gt;
用于指定一个将在子进程运行之前被调用的可执行对象，只在Unix平台下有效。&lt;/li&gt;
&lt;li&gt;close_fds&lt;br&gt;
如果该参数的值为True，则除了0,1和2之外的所有文件描述符都将会在子进程执行之前被关闭。&lt;/li&gt;
&lt;li&gt;shell&lt;br&gt;
该参数用于标识是否使用shell作为要执行的程序，如果shell值为True，则建议将args参数作为一个字符串传递而不要作为一个序列传递。&lt;/li&gt;
&lt;li&gt;cwd&lt;br&gt;
如果该参数值不是None，则该函数将会在执行这个子进程之前改变当前工作目录。&lt;/li&gt;
&lt;li&gt;env&lt;br&gt;
用于指定子进程的环境变量，如果env=None，那么子进程的环境变量将从父进程中继承。如果&lt;code&gt;env!=None&lt;/code&gt;，它的值必须是一个映射对象。&lt;/li&gt;
&lt;li&gt;universal_newlines&lt;br&gt;
如果该参数值为True，则该文件对象的stdin，stdout和stderr将会作为文本流被打开，否则他们将会被作为二进制流被打开。&lt;/li&gt;
&lt;li&gt;startupinfo和creationflags&lt;br&gt;
这两个参数只在Windows下有效，它们将被传递给底层的CreateProcess()函数，用于设置子进程的一些属性，如主窗口的外观，进程优先级等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;subprocesspopen类的实例可调用的方法&#34;&gt;subprocess.Popen类的实例可调用的方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Popen.poll()	&lt;br&gt;
用于检查子进程（命令）是否已经执行结束，没结束返回None，结束后返回状态码。&lt;/li&gt;
&lt;li&gt;Popen.wait(timeout=None)	&lt;br&gt;
等待子进程结束，并返回状态码；如果在timeout指定的秒数之后进程还没有结束，将会抛出一个&lt;code&gt;TimeoutExpired&lt;/code&gt;异常。&lt;/li&gt;
&lt;li&gt;Popen.communicate(input=None, timeout=None)	&lt;br&gt;
该方法可用来与进程进行交互，比如发送数据到stdin，从stdout和stderr读取数据，直到到达文件末尾。
&lt;ul&gt;
&lt;li&gt;该方法中的可选参数input应该是将被发送给子进程的数据，如果没有数据发送给子进程，该参数应该是None。input参数的数据类型必须是&lt;strong&gt;字节串&lt;/strong&gt;，如果universal_newlines参数值为True，则input参数的数据类型必须是字符串。&lt;/li&gt;
&lt;li&gt;该方法返回一个元组(stdout_data, stderr_data)，这些数据将会是字节串或字符串（如果universal_newlines的值为True）。&lt;/li&gt;
&lt;li&gt;如果在timeout指定的秒数后该进程还没有结束，将会抛出一个TimeoutExpired异常。捕获这个异常，然后重新尝试通信不会丢失任何输出的数据。但是超时之后子进程并没有被杀死，为了合理的清除相应的内容，一个好的应用应该手动杀死这个子进程来结束通信。&lt;/li&gt;
&lt;li&gt;需要注意的是，这里读取的数据是缓冲在内存中的，所以，如果数据大小非常大或者是无限的，就不应该使用这个方法。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Popen.send_signal(signal)	&lt;br&gt;
发送指定的信号给这个子进程。&lt;/li&gt;
&lt;li&gt;Popen.terminate()	&lt;br&gt;
停止该子进程。&lt;/li&gt;
&lt;li&gt;Popen.kill()	&lt;br&gt;
杀死该子进程。&lt;/li&gt;
&lt;li&gt;Popen.pid&lt;br&gt;
获取子进程的进程ID。&lt;/li&gt;
&lt;li&gt;Popen.returncode&lt;br&gt;
获取进程的返回码。如果进程未结束，将返回None。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;举例&#34;&gt;举例&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;stdout&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; import subprocess
&amp;gt;&amp;gt;&amp;gt; res = subprocess.Popen(&amp;quot;ls /tmp/yum.log&amp;quot;, shell=True, stdout=subprocess.PIPE) # 使用管道
&amp;gt;&amp;gt;&amp;gt; res.stdout.read()  # 标准输出
b&#39;/tmp/yum.log\n&#39;
res.stdout.close()  # 关闭
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;stderr&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; res = subprocess.Popen(&amp;quot;lm -l&amp;quot;,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
# 标准输出为空
&amp;gt;&amp;gt;&amp;gt; res.stdout.read()
b&#39;&#39;
#标准错误中有错误信息
&amp;gt;&amp;gt;&amp;gt; res.stderr.read()
b&#39;/bin/sh: lm: command not found\n&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;poll()&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; res = subprocess.Popen(&amp;quot;sleep 10;echo &#39;hello&#39;&amp;quot;,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; print(res.poll())
None
&amp;gt;&amp;gt;&amp;gt; print(res.poll())
None
&amp;gt;&amp;gt;&amp;gt; print(res.poll())
0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;wait()&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt;&amp;gt;&amp;gt; obj = subprocess.Popen(&amp;quot;sleep 10;echo &#39;hello&#39;&amp;quot;,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; obj.wait()
# 中间会一直等待
0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;terminate()&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;gt;&amp;gt;&amp;gt; res = subprocess.Popen(&amp;quot;sleep 20;echo &#39;hello&#39;&amp;quot;,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; res.terminate() # 结束进程
&amp;gt;&amp;gt;&amp;gt; res.stdout.read()
b&#39;&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;pid&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import subprocess
&amp;gt;&amp;gt;&amp;gt; res = subprocess.Popen(&amp;quot;sleep 5;echo &#39;hello&#39;&amp;quot;,shell=True,stdout=subprocess.PIPE,stderr=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; res.pid # 获取这个linux shell 的 进程号
3668
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;communicate进程交互&lt;br&gt;
多次交互一次输出：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; obj = subprocess.Popen([&amp;quot;python&amp;quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; obj.stdin.write(&#39;print(1) \n&#39;)
&amp;gt;&amp;gt;&amp;gt; obj.stdin.write(&#39;print(2) \n&#39;)
&amp;gt;&amp;gt;&amp;gt; obj.stdin.write(&#39;print(3) \n&#39;)
&amp;gt;&amp;gt;&amp;gt; out,err = obj.communicate()
&amp;gt;&amp;gt;&amp;gt; print(out)
1
2
3

&amp;gt;&amp;gt;&amp;gt; print(err)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一次交互并输出：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; obj = subprocess.Popen([&amp;quot;python&amp;quot;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; out,err = obj.communicate(input=&#39;print(1) \n&#39;)
&amp;gt;&amp;gt;&amp;gt; print(out)
1

&amp;gt;&amp;gt;&amp;gt; print(err)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;管道&lt;br&gt;
实现类似&lt;code&gt;df -Th | grep data&lt;/code&gt;命令的功能，实际上就是实现shell中管道的共功能&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# p1的输出=p2的输入，利用的是子进程之间的交互功能
&amp;gt;&amp;gt;&amp;gt; p1 = subprocess.Popen([&#39;df&#39;, &#39;-Th&#39;], stdout=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; p2 = subprocess.Popen([&#39;grep&#39;, &#39;data&#39;], stdin=p1.stdout, stdout=subprocess.PIPE)
&amp;gt;&amp;gt;&amp;gt; out,err = p2.communicate()
&amp;gt;&amp;gt;&amp;gt; print(out)
/dev/vdb1      ext4      493G  4.8G  463G   2% /data
/dev/vdd1      ext4     1008G  420G  537G  44% /data1
/dev/vde1      ext4      985G  503G  432G  54% /data2

&amp;gt;&amp;gt;&amp;gt; print(err)
None
&lt;/code&gt;&lt;/pre&gt;
">Python之执行命令（subprocess）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/linux-xi-tong-bei-fen-yu-hui-fu/"" data-c="
          &lt;h1 id=&#34;tar命令&#34;&gt;tar命令&lt;/h1&gt;
&lt;p&gt;副本模式，本机备份整个系统，以后还原还是还原到本机&lt;code&gt;注意存放备份的目录下要有充足的可用空间用于备份，可以直接挂在其他云存储用于备份&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&#34;同机备份与恢复&#34;&gt;同机备份与恢复&lt;/h2&gt;
&lt;p&gt;可以使用tar.gz格式或者tar.bz2格式（这里是以备注到根目录下为例），注意，要排除备份文件，不然会陷入无限循环直至撑满所有的可用空间，如果有挂在网络存储，也需要排除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#-------------------备份系统
tar cvpzf /system_backup.tar.gz / --exclude=/system_backup.tar.gz --exclude=/proc --exclude=/lost+found  --exclude=/mnt --exclude=/sys
# 或
tar cvpjf /system_backup.tar.bz2 / --exclude=/system_backup.tar.bz2 --exclude=/proc --exclude=/lost+found  --exclude=/mnt --exclude=/sys

#-------------------恢复系统
tar xvpfz /system_backup.tar.gz -C /
# 或
tar xvpfj /system_backup.tar.bz2 -C /
#创建备份时排除的目录（所有群组和所有者均为root，权限777）
mkdir proc
mkdir lost+found
mkdir mnt
mkdir sys
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;异机恢复与备份&#34;&gt;异机恢复与备份&lt;/h2&gt;
&lt;p&gt;/tmp目录如果没有重要配置文件也是可以排除的，/dev目录则存放驱动文件，两台机器不同，必须排除。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1. 生成备份主机A
tar cvpzf /mnt/system_backup.tar.gz / --exclude=/mnt/system_backup.tar.gz --exclude=/proc --exclude=/lost+found --exclude=/mnt --exclude=/sys --exclude=/dev --exclude=/tmp --exclude=/media

# 2. 将备份上传到目标主机B(需要恢复的主机)
scp /mnt/system_backup.tar.gz root@192.168.0.166:/mnt

# 3. 在目标机B上用ISO、LiveCD等启动（类似windows PE），挂载磁盘（这里以挂载到/media文件夹为例）
sudo -s  
cd /media/&amp;lt;对应的uuid号&amp;gt;
# 备份重要配置文件/boot/gurb/gurb.cfg /etc/fstab，记录里面的UUID

# 删除重复文件
# 除了上面备份系统时排除的一些文件夹外，比如说dev mnt media sys这些文件夹，其他全部删除。
rm -rf root home usr lib lib64 etc var bin sbin opt boot run selinux vmlinuz initrd.img

# 还原备份
mount /dev/vda1 /mnt/1
# 这里注意千万不要写/目录，会把现有的系统搞挂！！！应该是挂载的目录
tar xvpfz system_backup.tar.gz -C /mnt/1
cd /mnt/1       #此时你可以看到根目录的结构，但是编辑fstab文件发现是现有系统的fstab
chroot ./       #执行chroot后会以./目录为根目录，这时编辑的文件就是真正的目标源文件了。


# 还原后修改/etc/fstab里的UUID为刚刚备份的文件里面的信息，注意分区格式也要对应。
# 修改/boot/gurb/gurb.cfg里的UUID为刚刚备份的文件里面的信息。
# 修改网卡、IP配置文件，以防无法分配IP。（如果是虚拟机记得添加网卡，配置中等性能的显卡）
# 如果有依赖于原有平台的服务，如内建NTP，Agent等监控程序，关闭服务，关闭开机自启；
# 查看/etc/rc2.d目录中的S开头的服务都是会开机自动运行的；里面是软链接，想添加的话自己建一个链接文件就可以，S代表start，后面数字是启动顺序，删除软链接。
# 同时删除/etc/init.d/下对应的脚本。
vim /etc/init.d/rc.local
exit      #退出chroot
cd ~
umount /mnt/1

# 一切完成后就可以重启了，不出意外就正常启动系统了（启动后原来安装系统时设置的账户等全部消失；账户和源主机一致）。
# 若开机Grub提示“boot error 15 :Error 15 file not found”
#       解决方法：请检查GRUB相关文件的内核文件所在位置。通常与/boot分区有关。
# 若开机Grub提示“dracut:dono&#39;t how to hand root=f078”
#       解决方法：将root=UUID改成root=/dev/sdaX这种格式。
# 若开机系统提示/usr/libexec/gconf-sanity-check-2退出状态256的解决
#       解决方法：chmod 777 /tmp
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;rsync命令&#34;&gt;rsync命令&lt;/h1&gt;
&lt;p&gt;注意目标分区的格式最好是NTFS、FAT、EXT之类的格式，避免遇到大于4G的文件无法备份的问题&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#最好有其他分区或外接存储设备，挂载好，df -lh看挂载点。
#备份
rsync -Pa / /media/usb/backup_20201206 --exclude=/media/* --exclude=/sys/* --exclude=/proc/* --exclude=/mnt/* --exclude=/tmp/*

#恢复
rsync -Pa /media/usb/backup_20170410 /
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;dd命令&#34;&gt;dd命令&lt;/h1&gt;
&lt;p&gt;扇区克隆，目标分区要比备份分区要大，即使没有使用的空间也会被原样克隆下来，会&lt;strong&gt;比较慢&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#备份
df -h   #查看系统所在分区
dd if=/dev/sda1 of=/dev/sdb3     #备份sda1到sdb3中

#恢复
dd if=/dev/sdb3 of=/dev/sda1     #恢复sdb3到sdb1中
&lt;/code&gt;&lt;/pre&gt;
">Linux系统备份与恢复</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-lab-yao-qiu-yu-zhu-yi-dian/"" data-c="
          &lt;h1 id=&#34;v2&#34;&gt;V2&lt;/h1&gt;
&lt;h2 id=&#34;1-l2vrrp&#34;&gt;1. L2+VRRP&lt;/h2&gt;
&lt;h3 id=&#34;11-链路聚合&#34;&gt;1.1 链路聚合&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;假设S1不支持LACP，S1和S2互联的接口需要合成一个二层逻辑接口，逻辑接口的成员链路根据源-目的MAC进行负载分担&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;12-link-type&#34;&gt;1.2 Link-type&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4互联接口的链路类型为trunk，允许除VLAN1外的所有vlan通过&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.1.254，为PC1的网关，CE1会周期性发送Sender IP为10.3.1.254，源MAC为00-00-5E-00-01-01&lt;code&gt;vrid为1&lt;/code&gt;的免费ARP。PC1与网关之间的数据包封装在VLAN10中（PC1收发untag的帧）&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.2.254，为Server1的网关，CE2会周期性发送Sender IP为10.3.2.254，源MAC为00-00-5E-00-01-02&lt;code&gt;vrid为2&lt;/code&gt;的免费ARP。Server1与网关之间的数据包封装在VLAN20中（Server1收发untag的帧）&lt;/li&gt;
&lt;li&gt;VRRP的master设备重启时，在g0/0/2变为up 1分钟后，才能重新成为master&lt;br&gt;
【注意】此处做完不通是对的，需要将SW1/SW2面对CE1/CE2的接口配置为trunk，并允许Vlan10/20通过&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;13-mstp&#34;&gt;1.3 MSTP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4都运行MSTP。Vlan 10在instance 10，S1作为primary root，S2作为secondary root。Vlan 20在instance 20，S2作为primary root，S1作为secondary root。MSTP的region name是HUAWEI，Revision-level 12。&lt;/li&gt;
&lt;li&gt;除了交换机的互联端口，其他端口要确保不参与MSTP计算，由disabled会直接转到Forwarding状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;14-wan&#34;&gt;1.4 WAN&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PE1-RR1的互联Serial接口，绑定为一个逻辑接口，成员链路采用HDLC，逻辑接口的IPv4地址、IPv6地址请按照图1、图5配置&lt;/li&gt;
&lt;li&gt;PE3-CE3的互联POS接口，绑定为一个逻辑接口，成员链路采用PPP，逻辑接口的IPv4地址，请按照图1配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-ipv4-igp&#34;&gt;2. IPv4 IGP&lt;/h2&gt;
&lt;h3 id=&#34;21-基本配置&#34;&gt;2.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有设备的接口IPv4地址按照图1配置（除PE1-RR1的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;Route-id与loopback0的IPv4地址相同。MPLS域各设备的loopback0为172.16.0.0/16的32位主机地址（已预配置），未来扩容的MPLS域各设备的loopback0，从172.16.0.0/16去可用的主机地址，比如172.16.1.21/32可能分布在AS100，也可能分布在AS200。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;22-ospf&#34;&gt;2.2 OSPF&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1和CE2之间的链路，及该两台设备的loopback0通告入OSPF区域0（已预配置）&lt;/li&gt;
&lt;li&gt;CE1的g0/0/2.10和g0/0/2.20、CE2的g0/0/2.10和g0/0/2.20，直连网段通告入OSPF区域0，这些接口不能收发OSPF报文&lt;/li&gt;
&lt;li&gt;RR2、P2、PE3、PE4在OSPF区域0中，cost如图2配置（已预配置）&lt;/li&gt;
&lt;li&gt;PE3-PE4的OSPF链路类型为P2P&lt;/li&gt;
&lt;li&gt;PE4上将loopback0地址引入OSPF。AS200中，各OSPF网元到PE4 loopback0的路由，要累加内部cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. PE4的lo0口不能宣告进ospf区域0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-isis&#34;&gt;2.3 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;AS100内loopback0和互联网接口全部开启ISIS协议，其中PE1、PE2的路由类型为L1，区域号为49.0001，RR1、P1路由类型为L12，区域号为49.0001，ASBR1、ASBR2路由类型为L2，区域号为49.0002。各网元system-id唯一，cost-style为wide，cost值如图2配置（除PE1-RR1之外的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;AS200内，RR2、P2、ASBR3、ASBR4的loopback0和互联接口全部开启isis协议，IS类型为L2，区域号为49.0003。各网元system-id唯一，cost-style为wide，cost值如图2配置（已预配置）&lt;/li&gt;
&lt;li&gt;RR2-P2的ISIS链路类型为P2P&lt;/li&gt;
&lt;li&gt;P1的ISIS进程，产生LSP的最大延迟时间是1S，初始延迟为50ms，递增时间为50ms。使能LSP的快速扩散特性。SPF计算间隔为1s，初始延迟为100ms，递增时间为100ms。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. PE1的lo不能进入环回口，需要使用loo才能进入
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-mpls-vpn~v0-bgp-v2-mpls部分-1-v2-mpls部分-2~&#34;&gt;3. MPLS VPN~v0-BGP + V2-MPLS部分-1 + V2-MPLS部分-2~&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CE1、CE2为VPN1的Hub-CE，PE1、PE2为Hub-CE，CE3、CE4为VPN1的spoke站点，PE3、PE4为SpokePE&lt;/li&gt;
&lt;li&gt;CE4位Multi-VPN-instance CE，CE4的VPN实例VPN1，通过g0/0/1连接PE4&lt;code&gt;CE4的OSPF需要做vrf-lite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;合理设置VPN1参数，使得Spoke站点互访的数据必须经过Hub-CE设备，当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由（PE3上VPN1的RD为100:13，ExportRT为100:1，ImportRT为200:1）&lt;/li&gt;
&lt;li&gt;如图4，CE1通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE1，CE1通过g0/0/1.2向PE1通告的BGP update中，某些路由的as path中有200。在CE1上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;如图4，CE2通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE2，CE2通过g0/0/1.2向PE2通告的BGP update中，某些路由的as path中有200。在CE2上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;CE3通过OSPF区域1接入PE3通过PE3-CE3的逻辑接口互通，通告CE3的各环回口；CE4通过OSPF区域0接入PE4，通过PE4-CE4的g0/0/1.1接口互通，通告CE4的各环回口&lt;/li&gt;
&lt;li&gt;如图3，AS100、AS200内各网元配置MPLS LSR ID，全局使能MPLS，MPLS LDP（已预配置）。AS100、AS200内各直连链路建立LDP邻居。（除PE1-RR1之外的逻辑链路外，已预配置）&lt;br&gt;
如图4，在AS100、AS200内建立IBGP IPv4邻居关系，RR1是PE1、PE2、P1、ASBR1、ASBR2的反射器，RR2是PE3、PE4、P2、ASBR3、ASBR4的反射器。ASBR1-ASBR3、ASBR2-ASBR4建立EBGP IPv4邻居关系（已预配置）。&lt;/li&gt;
&lt;li&gt;ASBR1-ASBR3，ASBR2-ASBR4之间通过直连接口建立BGP邻居关系。在ASBR上，在ASBR上，将ISIS的loopback0路由引入BGP。假设AS100和AS200中的loopback0地址为172.16.A.Y/32。当Y为奇数时，对端设备访问本AS设备的loopback0，优选ASBR1-ASBR3；当Y为偶数时，对端设备访问本AS设备的loopback0，优选ASBR2-ASBR4.保证配有有最好的扩展性&lt;/li&gt;
&lt;li&gt;在RR2、P2上，ISIS和OSPF双向引入前缀为172.16.0.0/16的主机路由。被引入的协议的cost要继承到引入后的协议中，P2和PE4的loopback0互访走最优路径。配置要求有最好的扩展性&lt;/li&gt;
&lt;li&gt;如图4，&lt;strong&gt;各站点通过MPLS BGP VPN 跨域 Option C 方案二&lt;/strong&gt;，能够相互学习路由。PE1-RR1、PE2-RR1、PE3-RR2、PE4-RR2之间建立MP-IBGP连接的源接口为loopback0。RR1-RR2之间建立MP-EBGP邻居的源接口为loopback0。&lt;/li&gt;
&lt;li&gt;在CE1、CE2上配置EBGP的协议优先级为120&lt;/li&gt;
&lt;li&gt;在CE1、CE2上面，将BGP导入OSPF。保证配置有最好的扩展性（和4、5要求重合）&lt;/li&gt;
&lt;li&gt;在PE3、PE4上修改BGP local preference属性。实现CE3、CE4访问直连的10.3.x.0/24网段时，若x为奇数，PE3、PE4优选下一跳为PE1，若x为偶数，PE3、PE4优选下一跳为PE2，不用考虑来回路径是否一致&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-feature&#34;&gt;4. Feature&lt;/h2&gt;
&lt;h3 id=&#34;41-ha&#34;&gt;4.1 HA&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1配置静态的默认路由访问ISP，下一跳IP为100.0.1.2.该默认路由要与CE1-ISP链路的BFD状态绑定（CE1的对端设备不支持BFD），感知故障的时间要小于150ms&lt;/li&gt;
&lt;li&gt;CE2配置静态的默认路由访问ISP，下一跳IP为200.0.2.2.该默认路由要与CE2-ISP链路的NQA ICMP测试绑定，间隔3S测试执行1次&lt;/li&gt;
&lt;li&gt;CE3、CE4能够通过默认路由访问ISP。CE1-ISP的链路断开时，CE1仍能访问ISP；CE2-ISP的链路断开时，CE2仍能访问ISP&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;42-nat&#34;&gt;4.2 NAT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/1访问ISP。在CE2上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/2访问ISP。Server1拥有单独的公网地址102.0.1.1，对ISP提供FTP和HTTP服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;43-qos&#34;&gt;4.3 Qos&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1的g2/0/1、CE2的g2/0/2的出方向，周一至周五的8:00-18:00，对TCP目的端口号为6881-6999的流量，承诺的平均速率为1Mbps&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-ipv6&#34;&gt;5. IPv6&lt;/h2&gt;
&lt;h3 id=&#34;51-基本配置&#34;&gt;5.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有相关设备接口的IPv6地址，按照图6配置（除PE1-RR1的逻辑接口外，已预配置）&lt;br&gt;
&lt;code&gt;在WAN那道题中已经配置&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-ipv6-isis&#34;&gt;5.2 IPv6 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图6，PE1、PE2、RR1、P1、ASBR1、ASBR2运行isis协议，各直连网段通告入isis，配置各链路cost&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;53-ipv6-multicast&#34;&gt;5.3 IPv6 Multicast&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图7，AS100中，相邻设备建立PIM IPv6 SM的邻居关系。PE1的e0/0/0静态加入组FF1E::AA&lt;/li&gt;
&lt;/ol&gt;
">HCIE 实验LAB要求与注意点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-lab/"" data-c="
          &lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1607225084557.png&#34; alt=&#34;实验LAB&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;v2&#34;&gt;V2&lt;/h1&gt;
&lt;h2 id=&#34;1-l2vrrpv0-二层&#34;&gt;1. L2+VRRP&lt;sub&gt;v0-二层&lt;/sub&gt;&lt;/h2&gt;
&lt;h3 id=&#34;11-链路聚合&#34;&gt;1.1 链路聚合&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;假设S1不支持LACP，S1和S2互联的接口需要合成一个二层逻辑接口，逻辑接口的成员链路根据源-目的MAC进行负载分担&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1
int eth-trunk 12
    load-balance src-dst-mac
    trunkport g0/0/23 0/0/24
    dis eth 12

# SW2
int eth-trunk 12
    load-balance src-dst-mac
    trunkport g0/0/23 0/0/24
    dis eth 12
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;12-link-type&#34;&gt;1.2 Link-type&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4互联接口的链路类型为trunk，允许除VLAN1外的所有vlan通过&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.1.254，为PC1的网关，CE1会周期性发送Sender IP为10.3.1.254，源MAC为00-00-5E-00-01-01&lt;code&gt;vrid为1&lt;/code&gt;的免费ARP。PC1与网关之间的数据包封装在VLAN10中（PC1收发untag的帧）&lt;/li&gt;
&lt;li&gt;CE1、CE2的VRRP虚拟IP地址10.3.2.254，为Server1的网关，CE2会周期性发送Sender IP为10.3.2.254，源MAC为00-00-5E-00-01-02&lt;code&gt;vrid为2&lt;/code&gt;的免费ARP。Server1与网关之间的数据包封装在VLAN20中（Server1收发untag的帧）&lt;/li&gt;
&lt;li&gt;VRRP的master设备重启时，在g0/0/2变为up 1分钟后，才能重新成为master&lt;br&gt;
【注意】此处做完不通是对的，需要将SW1/SW2面对CE1/CE2的接口配置为trunk，并允许Vlan10/20通过&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1--------------------------------
# SW1
port-group group-member g0/0/1 g0/0/12 eth-trunk 12
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1

# SW2
port-group group-member g0/0/1 g0/0/12 eth-trunk 12
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1

# SW3
port-group group-member g0/0/1 g0/0/2
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1


# SW4
port-group group-member g0/0/1 g0/0/2
    port link-type trunk
    port trunk allow-pass vlan all
    undo port trunk allow-pass vlan 1

# 2/3/4-----------------------------------
# CE1
dis ip int bri
int g0/0/2.10
    dis th
    vrrp vrid 1 virtual-ip 10.3.1.254
    vrrp vrid 1 priority 120
    vrrp vrid 1 preempt-mode timer delay 60
    arp broadcast enable
int g0/0/2.20
    dis th
    vrrp vrid 2 virtual-ip 10.3.2.254
    arp broadcast enable

# CE2
dis ip int bri
int g0/0/2.10
    dis th
    vrrp vrid 1 virtual-ip 10.3.1.254
    arp broadcast enable
int g0/0/2.20
    dis th
    vrrp vrid 2 virtual-ip 10.3.2.254
    vrrp vrid 2 priority 120
    vrrp vrid 2 preempt-mode timer delay 60
    arp broadcast enable

# SW1
vlan batch 10 20
dis port vlan active
int g0/0/2
    port link-type trunk
    port trunk allow-pass vlan 10 20

# SW2
vlan batch 10 20
dis port vlan active
int g0/0/2
    port link-type trunk
    port trunk allow-pass vlan 10 20

# SW3
vlan batch 10 20
dis port vlan active
int e0/0/1   # 此处配置下联接口，主要是PC1收发untag的帧
    port link access
    port default vlan 10

# SW4
vlan batch 10 20
dis port vlan active
int e0/0/1
    port link access
    port default vlan 20

# 测试------------------
# CE1/2
dis vrrp bri
# PC1/2
ping 10.3.2.254
ping 10.3.1.254
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;13-mstp&#34;&gt;1.3 MSTP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;S1、S2、S3、S4都运行MSTP。Vlan 10在instance 10，S1作为primary root，S2作为secondary root。Vlan 20在instance 20，S2作为primary root，S1作为secondary root。MSTP的region name是HUAWEI，Revision-level 12。&lt;/li&gt;
&lt;li&gt;除了交换机的互联端口，其他端口要确保不参与MSTP计算，由disabled会直接转到Forwarding状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1-----------------------------------------------------
# SW1
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q
stp instance 10 root primary
stp instance 20 secondary primary

# SW2
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q
stp instance 10 root secondary 
stp instance 20 root primary

# SW3
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q

# SW4
stp mode mstp
stp region-configuration
    instance 10 vlan 10
    instance 20 vlan 20
    region-name HUAWEI
    revision-level 12
    active region-configuration
    q

# 2---------------------------------------------
# SW1
stp edged-port default
port-group group-member eth 12 g0/0/1 g0/0/12
    stp edged-port disable

# SW2
stp edged-port default
port-group group-member eth 12 g0/0/1 g0/0/12
    stp edged-port disable

# SW3
stp edged-port default
port-group group-member g0/0/1 g0/0/2
    stp edged-port disable

# SW4
stp edged-port default
port-group group-member g0/0/1 g0/0/2
    stp edged-port disable

# 检查
# SW1/2/3/4
dis stp bri 
# sw1端口均是forwarding，eth12为vlan20的root
# sw2端口均是forwarding，eth12为vlan10的root
# sw3端口g0/0/1是vlan10的root，g0/0/2是vlan20的root
# sw4端口g0/0/1是vlan20的root，g0/0/2是vlan10的root
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14-wan&#34;&gt;1.4 WAN&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PE1-RR1的互联Serial接口，绑定为一个逻辑接口，成员链路采用HDLC，逻辑接口的IPv4地址、IPv6地址请按照图1、图5配置&lt;/li&gt;
&lt;li&gt;PE3-CE3的互联POS接口，绑定为一个逻辑接口，成员链路采用PPP，逻辑接口的IPv4地址，请按照图1配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1-----------------------------------------
#PE1
ipv6 
int ip-trunk 1
    ipv6 enable 
    ip addr 10.1.13.1 30
    ipv6 addr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1300 127
    q
int s0/0/1
    link-protocol hdlc
    ip-trunk 1
int s0/0/2
    link-protocol hdlc
    ip-trunk 1
    q

# RR1
ipv6
int ip-trunk 1
    ipv6 enable 
    ip addr 10.1.13.2 30
    ipv6 addr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1301 127
    q
int s0/0/1
    link-protocol hdlc
    ip-trunk 1
int s0/0/2
    link-protocol hdlc
    ip-trunk 1
    q

# 测试-----------------------
# RR1
ping 10.1.13.1
ping ipv6 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:1300

# 2--------------------------------------------
# PE3
int mp-group 0/0/1
    dis cu conf vpn
    ip binding vpn-instance VPN1
    ip add 10.2.33.1 30
    q
int p4/0/0
    ppp mp mp-group 0/0/1
int p6/0/0
    ppp mp mp-group 0/0/1

# CE3
int mp-group 0/0/1
    ip add 10.2.33.2 30
    q
int p4/0/0
    ppp mp mp-group 0/0/1
int p6/0/0
    ppp mp mp-group 0/0/1

# 测试
# CE3
ping 10.2.33.1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-ipv4-igp~v0-igp-v0-双点双向引入23-5~&#34;&gt;2. IPv4 IGP~v0-IGP + v0-双点双向引入(2.3-5)~&lt;/h2&gt;
&lt;h3 id=&#34;21-基本配置&#34;&gt;2.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有设备的接口IPv4地址按照图1配置（除PE1-RR1的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;Route-id与loopback0的IPv4地址相同。MPLS域各设备的loopback0为172.16.0.0/16的32位主机地址（已预配置），未来扩容的MPLS域各设备的loopback0，从172.16.0.0/16去可用的主机地址，比如172.16.1.21/32可能分布在AS100，也可能分布在AS200。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 2---------------------------
# CE1
dis ip int br
router id 172.17.1.1
# CE2
dis ip int br
router id 172.17.1.2

# PE1
dis ip int br
router id 172.16.1.1
# PE2
dis ip int br
router id 172.16.1.20
# RR1
dis ip int br
router id 172.16.1.3
# P1
dis ip int br
router id 172.16.1.4
# ASBR1
dis ip int br
router id 172.16.1.5
# ASBR2
dis ip int br
router id 172.16.1.6

# ASBR3
dis ip int br
router id 172.16.1.7
# ASBR4
dis ip int br
router id 172.16.1.8
# RR2
dis ip int br
router id 172.16.1.9
# P2
dis ip int br
router id 172.16.1.10
# PE3
dis ip int br
router id 172.16.1.11
# PE4
dis ip int br
router id 172.16.1.2

# CE3
dis ip int br
router id 172.17.1.3
# CE4
dis ip int br
router id 172.17.1.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;22-ospf&#34;&gt;2.2 OSPF&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1和CE2之间的链路，及该两台设备的loopback0通告入OSPF区域0（已预配置）&lt;/li&gt;
&lt;li&gt;CE1的g0/0/2.10和g0/0/2.20、CE2的g0/0/2.10和g0/0/2.20，直连网段通告入OSPF区域0，这些接口不能收发OSPF报文&lt;/li&gt;
&lt;li&gt;RR2、P2、PE3、PE4在OSPF区域0中，cost如图2配置（已预配置）&lt;/li&gt;
&lt;li&gt;PE3-PE4的OSPF链路类型为P2P&lt;/li&gt;
&lt;li&gt;PE4上将loopback0地址引入OSPF。AS200中，各OSPF网元到PE4 loopback0的路由，要累加内部cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1/2--------------------------------------
# CE1
int g0/0/2.10
    ospf enable 1 a 0
int g0/0/2.20
    ospf enable 1 a 0
dis ip int bri
ospf 1 router-id 172.17.1.1
    a 0
        network 172.17.1.1 0.0.0.0 # lo0
        network 10.2.12.1 0.0.0.0 # g0/0/0
        network 10.3.1.1 0.0.0.0 # g0/0/2的子接口10 
        network 10.3.2.1 0.0.0.0 # g0/0/2的子接口20
        q
    silent-int g0/0/2.10
    silent-int g0/0/2.20

# CE2
int g0/0/2.10
    ospf enable 1 a 0
int g0/0/2.20
    ospf enable 1 a 0
dis ip int bri
ospf 1 router-id 172.17.1.2
    a 0
        network 172.17.1.2 0.0.0.0 # lo0
        network 10.2.12.2 0.0.0.0 # g0/0/0
        network 10.3.1.2 0.0.0.0 # g0/0/2的子接口10 
        network 10.3.2.2 0.0.0.0 # g0/0/2的子接口20
        q
    silent-int g0/0/2.10
    silent-int g0/0/2.20

# 检查-------------------
# CE1/2
dis ospf peer bri
dis ospf int 

# 3/4---------------------------
# RR2
dis ip int bri
ospf 1 router-id  172.16.1.9
    a 0
        network 172.16.1.9 0.0.0.0  # lo 0
        network 10.1.91.1 0.0.0.0 #g0/0/0
        network 10.1.119.1 0.0.0.0 #g0/0/2

# P2
dis ip int bri
ospf 1 router-id  172.16.1.10
    a 0
        network 172.16.1.10 0.0.0.0  # lo 0
        network 10.1.91.2 0.0.0.0 #g0/0/0
        network 10.1.102.1 0.0.0.0 #g0/0/2

# PE3
dis ip int bri
ospf 1 router-id  172.16.1.11
    a 0
        network 172.16.1.11 0.0.0.0  # lo 0
        network 10.1.112.1 0.0.0.0 #g0/0/0
        network 10.1.119.2 0.0.0.0 #g0/0/2

# PE4
dis ip int bri
ospf 1 router-id  172.16.1.2
    a 0    # 不能宣告lo0，原因为次优路径，涉及考点5
        network 10.1.112.2 0.0.0.0 #g0/0/0
        network 10.1.102.2 0.0.0.0 #g0/0/2

# 检查-----------------
# 所有设备
dis ospf int 
dis ospf peer bri

# 4--------------------------------
# PE3
int g0/0/0
    ospf network-type p2p
# PE4
int g0/0/0
    ospf network-type p2p

# 检查-----------------
# 所有设备
dis ospf int 
dis ospf peer bri

# 5-------------------------
# PE4
ip ip-prefix L0 permit 172.16.1.2 32
route-policy L0 permit node 10
    if-match ip-prefix L0
    apply tag 2  # 用于后面双向路由引入防止次优路径
ospf 1
    import-route direct type 1 route-policy L0   

# 检查-----------------
# P2
dis ip rou 172.16.1.2 verbose  # 172.16.1.2的cost变为1501，tag为2
# RR2
dis ip rou 172.16.1.2 verbose  # 172.16.1.2的cost变为1511，tag为2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-isis&#34;&gt;2.3 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;AS100内loopback0和互联网接口全部开启ISIS协议，其中PE1、PE2的路由类型为L1，区域号为49.0001，RR1、P1路由类型为L12，区域号为49.0001，ASBR1、ASBR2路由类型为L2，区域号为49.0002。各网元system-id唯一，cost-style为wide，cost值如图2配置（除PE1-RR1之外的逻辑接口外，已预配置）&lt;/li&gt;
&lt;li&gt;AS200内，RR2、P2、ASBR3、ASBR4的loopback0和互联接口全部开启isis协议，IS类型为L2，区域号为49.0003。各网元system-id唯一，cost-style为wide，cost值如图2配置（已预配置）&lt;/li&gt;
&lt;li&gt;RR2-P2的ISIS链路类型为P2P&lt;/li&gt;
&lt;li&gt;P1的ISIS进程，产生LSP的最大延迟时间是1S，初始延迟为50ms，递增时间为50ms。使能LSP的快速扩散特性。SPF计算间隔为1s，初始延迟为100ms，递增时间为100ms。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1/2----------------------
# PE1
dis cu conf isis # is-level level-1 # 如果有此配置，则不再进行配置
dis isis int
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
int ip-trunk 1
    dis th
    isis  enable 
    isis cost 1500
dis isis int
dis isis peer # 2个

# PE2
dis cu conf isis # is-level level-1 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# RR1
dis cu conf isis # is-level level-1-2 # 如果有此配置，则不再进行配置
dis isis int
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
int ip-trunk 1
    dis th
    isis  enable 
    isis cost 1500
dis isis int
dis isis peer # 4个

# P1
dis cu conf isis # is-level level-1-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 4个

# ASBR1
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# ASBR2
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# ASBR3
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# ASBR4
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# RR2
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个

# P2
dis cu conf isis # is-level level-2 # 如果有此配置，则不再进行配置
int loo 0  # 此处lo不能进入环回口，需要使用loo
    isis  enable 
dis isis int
dis isis peer # 2个


# 检查-----------------
# RR1
dis ip rou pro isis # 有1/20/4/5/6的路由
# ASBR3
dis ip rou pro isis # 有8/9/10的路由

# 3-----------------
# RR2
int g0/0/0
    isis circuit-type p2p
# P2
int g0/0/0
    isis circuit-type p2p
dis isis peer

# 4----------------------------
产生LSP的最大延迟时间是1S，初始延迟为50ms，递增时间为50ms。使能LSP的快速扩散特性。SPF计算间隔为1s，初始延迟为100ms，递增时间为100ms。
# P1
isis 1
    timer lsp-generation 1 50 50
    flash-flood
    timer spf 1 100 100
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-mpls-vpn~v0-bgp-v2-mpls部分-1-v2-mpls部分-2~&#34;&gt;3. MPLS VPN~v0-BGP + V2-MPLS部分-1 + V2-MPLS部分-2~&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;CE1、CE2为VPN1的Hub-CE，PE1、PE2为Hub-CE，CE3、CE4为VPN1的spoke站点，PE3、PE4为SpokePE&lt;/li&gt;
&lt;li&gt;CE4位Multi-VPN-instance CE，CE4的VPN实例VPN1，通过g0/0/1连接PE4&lt;code&gt;CE4的OSPF需要做vrf-lite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;合理设置VPN1参数，使得Spoke站点互访的数据必须经过Hub-CE设备，当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由（PE3上VPN1的RD为100:13，ExportRT为100:1，ImportRT为200:1）&lt;/li&gt;
&lt;li&gt;如图4，CE1通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE1，CE1通过g0/0/1.2向PE1通告的BGP update中，某些路由的as path中有200。在CE1上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;如图4，CE2通过g0/0/1.1和g0/0/1.2建立直连EBGP邻居接入PE2，CE2通过g0/0/1.2向PE2通告的BGP update中，某些路由的as path中有200。在CE2上，将OSPF路由导入BGP&lt;/li&gt;
&lt;li&gt;CE3通过OSPF区域1接入PE3通过PE3-CE3的逻辑接口互通，通告CE3的各环回口；CE4通过OSPF区域0接入PE4，通过PE4-CE4的g0/0/1.1接口互通，通告CE4的各环回口&lt;/li&gt;
&lt;li&gt;如图3，AS100、AS200内各网元配置MPLS LSR ID，全局使能MPLS，MPLS LDP（已预配置）。AS100、AS200内各直连链路建立LDP邻居。（除PE1-RR1之外的逻辑链路外，已预配置）&lt;br&gt;
如图4，在AS100、AS200内建立IBGP IPv4邻居关系，RR1是PE1、PE2、P1、ASBR1、ASBR2的反射器，RR2是PE3、PE4、P2、ASBR3、ASBR4的反射器。ASBR1-ASBR3、ASBR2-ASBR4建立EBGP IPv4邻居关系（已预配置）。&lt;/li&gt;
&lt;li&gt;ASBR1-ASBR3，ASBR2-ASBR4之间通过直连接口建立BGP邻居关系。在ASBR上，在ASBR上，将ISIS的loopback0路由引入BGP。假设AS100和AS200中的loopback0地址为172.16.A.Y/32。当Y为奇数时，对端设备访问本AS设备的loopback0，优选ASBR1-ASBR3；当Y为偶数时，对端设备访问本AS设备的loopback0，优选ASBR2-ASBR4.保证配有有最好的扩展性&lt;/li&gt;
&lt;li&gt;在RR2、P2上，ISIS和OSPF双向引入前缀为172.16.0.0/16的主机路由。被引入的协议的cost要继承到引入后的协议中，P2和PE4的loopback0互访走最优路径。配置要求有最好的扩展性&lt;/li&gt;
&lt;li&gt;如图4，各站点通过MPLS BGP VPN 跨域 Option C 方案二，能够相互学习路由。PE1-RR1、PE2-RR1、PE3-RR2、PE4-RR2之间建立MP-IBGP连接的源接口为loopback0。RR1-RR2之间建立MP-EBGP邻居的源接口为loopback0。&lt;/li&gt;
&lt;li&gt;在CE1、CE2上配置EBGP的协议优先级为120&lt;/li&gt;
&lt;li&gt;在CE1、CE2上面，将BGP导入OSPF。保证配置有最好的扩展性（和4、5要求重合）&lt;/li&gt;
&lt;li&gt;在PE3、PE4上修改BGP local preference属性。实现CE3、CE4访问直连的10.3.x.0/24网段时，若x为奇数，PE3、PE4优选下一跳为PE1，若x为偶数，PE3、PE4优选下一跳为PE2，不用考虑来回路径是否一致&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 3--------------------------
#PE1
dis cu conf vpn
ip vpn-instance HUB
    vpn-target 200:1 export
    q
ip vpn-instance VPN1
    vpn-target 100:1 200:1 import # 200:1的作用：当CE1-PE1链路断开的情况下，PE1仍然可以学习到CE1的业务路由
dis cu int# 查看intg0/0/1.1和g0/0/1.2分别绑定VPN1和HUB，并且都已经配置arp broadcast enable

#PE2
dis cu conf vpn
ip vpn-instance HUB 
    vpn-target 200:1 export
    q
ip vpn-instance VPN1
    vpn-target 100:1 200:1 import 
dis cu int# 查看intg0/0/1.1和g0/0/1.2分别绑定VPN1和HUB，并且都已经配置arp broadcast enable

# PE3
ip vpn-instance VPN1
    vpn-target 100:1 export
    vpn-target 200:1 import

# PE4
ip vpn-instance VPN1
    vpn-target 100:1 export
    vpn-target 200:1 import

# 4/5----------------------
#CE1
dis ip int bri
bgp  65000
    router-id 172.17.1.1
    peer 10.2.11.2 as 100
    peer 10.2.11.6 as 100
    import ospf 1

#PE1
bgp 100
    dis ip int bri
    router-id 172.16.1.1
    ipv4-family vpn-instance VPN1
        peer 10.2.11.1 as 65000
    ipv4-family vpn-instance HUB
        peer 10.2.11.5 as 65000
        peer 10.2.11.5 allow-as-loop

#CE2
dis ip int bri
bgp  65000
    router-id 172.17.1.2
    peer 10.2.22.2 as 100
    peer 10.2.22.6 as 100
    import ospf 1

#PE2
bgp 100
    dis ip int bri
    router-id 172.16.1.20
    ipv4-family vpn-instance VPN1
        peer 10.2.22.1 as 65000
    ipv4-family vpn-instance HUB
        peer 10.2.22.5 as 65000
        peer 10.2.22.5 allow-as-loop

# 检查-----------------
# 所有设备
dis bgp vpnv4 all peer


# 6/2--------------------------
# PE3
ospf 2 vpn-instance VPN1
    a 1
        dis ip int bri # 查看MP口
        network 10.2.33.1 0.0.0.0
# CE3
dis ip int bri 
ospf 1 router-id 172.17.1.3
    area 1 # 同时需要宣告所有环回口
        net 10.2.33.2 0.0.0.0
        net 172.17.1.3 0.0.0.0
        net 10.3.3.3 0.0.0.0
dis ospf peer bri

# PE4
ospf 2 vpn-instance VPN1
    a 0
        dis ip int bri # 查看g0/0/1口
        net 10.2.44.1 0.0.0.0
# CE4
dis cu int  # 配置地址的3个接口都需要绑定VPN1
dis ip int bri 
ospf 1 vpn-instance VPN1
    area 0 # 同时需要宣告所有环回口
        net 10.2.44.2 0.0.0.0
        net 172.17.1.4 0.0.0.0
        net 10.4.4.4 0.0.0.0
        q
    vpn-instance-capability simple
dis ospf peer bri

# 7.2 BGP------------------此部分最好在记事本中写好配置
# PE1/PE2/P1/ASBR1/ASBR2
bgp 100
    router-id 172.16.1.1/20/4/5/6
    peer 172.16.1.3 as 100
    peer 172.16.1.3 connect lo 0
# RR1
bgp 100
    router-id 172.16.1.3
    peer 172.16.1.1 as 100 # 配置邻居
    peer 172.16.1.20 as 100
    peer 172.16.1.4 as 100
    peer 172.16.1.5 as 100
    peer 172.16.1.6 as 100
    dis th
    peer 172.16.1.1 co lo 0 # 配置更新源
    peer 172.16.1.20 co lo 0
    peer 172.16.1.4 co lo 0
    peer 172.16.1.5 co lo 0
    peer 172.16.1.6 co lo 0
    peer 172.16.1.1 re # 配置反射器
    peer 172.16.1.20 re
    peer 172.16.1.4 re
    peer 172.16.1.5 re
    peer 172.16.1.6 re

# ASBR1
bgp 100
    dis th
    peer 172.16.1.3 next-hop-local
    peer 10.1.57.2  as 200

# ASBR2
bgp 100
    dis th
    peer 172.16.1.3 next-hop-local
    peer 10.1.68.2 as 200

# ASBR3
bgp 200
    router-id 172.16.1.7
    peer 10.1.57.1  as 100
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0
    peer 172.16.1.9 next-hop-local

# ASBR4
bgp 200
    router-id 172.16.1.8
    peer 10.1.68.1 as 100
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0
    peer 172.16.1.9 next-hop-local

# P2/PE3/PE4
bgp 200
    router-id 172.16.1.10/11/2
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0

# RR2
bgp 200
    router-id 172.16.1.9
    peer 172.16.1.7 as 200 # 配置邻居
    peer 172.16.1.8 as 200
    peer 172.16.1.10 as 200
    peer 172.16.1.11 as 200
    peer 172.16.1.2 as 200
	peer 172.16.1.7 co lo 0 # 更新源
    peer 172.16.1.8 co lo 0 
    peer 172.16.1.10 co lo 0 
    peer 172.16.1.11 co lo 0 
    peer 172.16.1.2 co lo 0 
	peer 172.16.1.7 re # 反射器
    peer 172.16.1.8 re 
    peer 172.16.1.10 re 
    peer 172.16.1.11 re
    peer 172.16.1.2 re

# 检查-----------------
# RR1/2
dis bgp peer  # 5个邻居建立
# ASBR1/2/3/4
dis bgp peer # 2个邻居

# 7.1 MPLS--------------------
# AS100和AS200内所有设备
mpls lsr-id 172.16.1.1/20/3/4/5/6/7/8/9/10/11/2
mpls
mpls ldp
# AS100和AS200内所有设备的互联接口全部开启mpls ldp，将需要开启mpls接口的配置写入记事本，然后在相应设备上粘贴配置
# PE1
int ip 1
    mpls 
    mpls ldp
int g0/0/0
    mpls 
    mpls ldp
# PE2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
# RR1
int ip 1
    mpls 
    mpls ldp
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# P1
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
# ASBR1：注意这是option C方案，AS之间的接口不能配置
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# ASBR2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# ASBR3
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
# ASBR4
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
#RR2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
#P2
int g0/0/0
    mpls 
    mpls ldp
int g0/0/1
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
#PE3
int g0/0/0
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp
#PE4
int g0/0/0
    mpls 
    mpls ldp
int g0/0/2
    mpls 
    mpls ldp

# 检查-----------------
# AS100/200内所有设备
dis mpls ldp peer

# 8-----------------------
# ASBR1
acl 2000   # 4台ASBR的ACL都是相同的，建议复制，不同的是route-policy
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 200
route-policy AB permit node 20
    if-match acl 2001
    apply cost 100
bgp 100
    import-route isis 1 route-policy AB
# ASBR3
acl 2000
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 200
route-policy AB permit node 20
    if-match acl 2001
    apply cost 100
bgp 200
    import-route isis 1 route-policy AB


# ASBR2
acl 2000
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 100
route-policy AB permit node 20
    if-match acl 2001
    apply cost 200
bgp 100
    import-route isis 1 route-policy AB
# ASBR4
acl 2000
    rule permit source 172.16.1.0 0.0.0.254
acl 2001
    rule permit source 172.16.1.1 0.0.0.254
route-policy AB permit node 10
    if-match acl 2000
    apply cost 100
route-policy AB permit node 20
    if-match acl 2001
    apply cost 200
bgp 200
    import-route isis 1 route-policy AB

# 检查-----------------
# 4台ASBR
dis bgp rou # 奇数路由走1/3，反之亦然。例如ASBR1上172.16.1.1的下一跳0.0.0.0（默认为ASBR3）,172.16.1.2的下一跳就是172.16.1.6


# 9--------------------
## RR2
ip ip-prefix 172 permit 172.16.0.0 16 greater-equal 32  # 匹配172的主机路由

route-policy O2I deny node 10
    if-match tag 100
route-policy O2I permit node 20
    if-match ip-prefix 172
    apply tag 200
route-policy I2O deny node 10
    if-match tag 101
route-policy I2O permit node 20
    if-match ip-prefix 172
    apply tag 201

route-policy OASE permit node 10
    if-match tag 2 # 与PE4引入时指定的tag一致
    apply preference 14   # 针对PE4引入的ospf外部路由设置优先级为14（ospf为10，isis为15）
ospf 1
    import-route isis 1 type 1 route-policy I2O 
    preference ase route-policy OASE
isis 1
    import-route ospf 1 inherit-cost route-policy O2I

dis route-policy  # 此时查看匹配到的路由是不是有0，因为路由之前已经过去了，需要把deny重新配置一下
dis cu conf routr-policy
undo route-policy O2I node 10
route-policy O2I deny node 10
    if-match tag 300
undo route-policy I2O node 10
route-policy I2O deny node 10
    if-match tag 201


# P2
ip ip-prefix 172 permit 172.16.0.0 16 greater-equal 32

route-policy I2O permit node 20
    if-match ip-prefix 172
    apply tag 100
route-policy I2O deny node 10
    if-match tag 200
route-policy O2I permit node 20
    if-match ip-prefix 172
    apply tag 101
route-policy O2I deny node 10
    if-match tag 201
route-policy OASE permit node 10
    if-match tag 2 # 与PE4引入时指定的tag一致
    apply preference 14   # 针对PE4引入的ospf外部路由设置优先级为14（ospf为10，isis为15）
ospf 1
    import-route isis 1 type 1 route-policy I2O 
    preference ase route-policy OASE
isis 1
    import-route ospf 1 inherit-cost route-policy O2I

dis route-policy  # 此时查看匹配到的路由是不是有0，因为路由之前已经过去了，需要把deny重新配置一下
dis cu conf routr-policy
undo route-policy O2I node 10
route-policy O2I deny node 10
    if-match tag 301
undo route-policy I2O node 10
route-policy I2O deny node 10
    if-match tag 200

# 检查-----------------
# RR2/P2
dis route-policy  # 此时匹配的路由条数不应该有0
# P2
dis ip rou # 到达PE4(172.16.1.2)的路由应该为O_ASE，接口为g0/0/2，即OSPF的外部路由而不是ISIS的路由
# PE4
dis ip rou pro ospf # 到达P2(172.16.1.10)为g0/0/2接口


# 10-------------------------
# ASBR1/2/3/4
int g0/0/2  # ASBR互联接口开启mpls
    mpls
    q
route-policy MPLS permit no 10 # 向ebgp邻居通告路由时带标签
    apply mpls-label  
ip ip-prefix 172 permit 172.16.0.0 16 great 32 #将对端172的主机路由引入本AS内部IGP
route-policy 172 permit node 10
    if-match ip-prefix 172
    apply tag 1234
route-policy AB deny node 5  # 防止将BGP引入IGP时出环
    if-match tag 1234
isis   # IGP引入BGP的路由
    import-route bgp inherit-cost route-policy 172
mpls
    lsp-trigger bgp-label-route ip-prefix 172  # 让LDP为来自BGP的带标签的路由分配IGP标签

# ASBR1
bgp 100
    peer 10.1.57.2 route-policy MPLS export
    peer 10.1.57.2 label-route-capability  # 针对邻居开启公网路由带标签能力
    preference 12 255 255  # 修改bgp优先级，保证IGP优选。ebgp的优先级12小于ISIS的优先级15，优选bgp；ibgp的优先级255大于ISIS的优先级，优选ISIS；本地优先级为255
# ASBR3
bgp 200
    peer 10.1.57.1 route-policy MPLS export
    peer 10.1.57.1 label-route-capability
    preference 12 255 255
# ASBR2
bgp 100
    peer 10.1.68.2 route-policy MPLS export
    peer 10.1.68.2 label-route-capability
    preference 12 255 255
# ASBR4
bgp 200
    peer 10.1.68.1 route-policy MPLS export
    peer 10.1.68.1  label-route-capability
    preference 12 255 255

# PE1/2
bgp 100
    ipv4-family vpnv4
        peer 172.16.1.3 enable
# RR1
bgp 100
    peer 172.16.1.9 as 200
    peer 172.16.1.9 co lo 0
    peer 172.16.1.9 ebgp-max-hop
    ipv4-family unicast
        undo peer 172.16.1.9 enable  # 关闭RR之间的ipv4邻居，防止路由选路错误
    ipv4-family vpnv4
        undo policy vpn-target 
        peer 172.16.1.9 enable
        peer 172.16.1.9 next-hop-invariable
        peer 172.16.1.9 allow-as-loop
        peer 172.16.1.1 enable
        peer 172.16.1.1 re
        peer 172.16.1.1 next-hop-invariable # 不修改下一跳
        peer 172.16.1.20 enable
        peer 172.16.1.20 re
        peer 172.16.1.20 next-hop-in
# PE3/4
bgp 200
    ipv4-family vpnv4
        peer 172.16.1.9 enable
    ipv4-family vpn-instance VPN1   # 边缘设备路由的双向引入，使CE3/4学到相应的路由
        import ospf 2
ospf 2
    import bgp type 1

# RR1/P1：配置isis的路由泄露
ip ip-prefix 172 permit 172.16.0.0 16 gr 32
isis 1
    import isis level-2 into level-1 filter-policy ip-prefix 172

# RR2
bgp 200
    peer 172.16.1.3 as 100
    peer 172.16.1.3 co lo 0
    peer 172.16.1.3 ebgp-max-hop
    ipv4-family unicast
        undo peer 172.16.1.9 enable 
    ipv4-family vpnv4
        undo policy vpn-target 
        peer 172.16.1.3 enable
        peer 172.16.1.3 next-hop-in
        peer 172.16.1.3 allow-as-loop
        peer 172.16.1.11 enable
        peer 172.16.1.11 re
        peer 172.16.1.11 next-hop-in
        peer 172.16.1.2 enable
        peer 172.16.1.2 re
        peer 172.16.1.2 next-hop-in

# 检查-----------------
# RR1/2
dis bgp vpnv4 all peer #各有3个邻居
dis bgp peer # 查看两个RR之间的邻居
# RR2/PE3/PE4
dis bgp vpnv4 all rou  # 是否学到CE1/2/3/4上的路由10.3.1.0、10.3.2.0、10.3.3.3、10.4.4.4
# RR1/PE1/PE2
dis bgp vpnv4 all rou  # 是否学到CE1/2/3/4上的路由10.3.1.0、10.3.2.0、10.3.3.3、10.4.4.4
# RR1/P1
dis ip rou pro isis  # 查看时候学习到isis level2的路由，主要是192.168.1.11/2

# 11/12--------------------------
# CE1/2：修改eBGP的优先级
bgp 65000
    preference 120 255 255
ospf 1
    import bgp type 1  # 引入之前先做PE1/2上面的soo
# PE1：为了防环，需要配置soo属性
bgp 100
    ipv4-family vpn-instance HUB
        peer 10.2.11.5 soo 100:12
    ipv4-family vpn-instance VPN1
        peer 10.2.11.1 soo 100:12
# PE2：为了防环，需要配置Soo属性
bgp 100
    ipv4-family vpn-instance HUB
        peer 10.2.22.5 soo 100:12
    ipv4-family vpn-instance VPN1
        peer 10.2.22.1 soo 100:12

# 13------------------
# PE3/4
acl 2000
    rule permit source 10.3.0.0 0.0.254.0
acl 2001
    rule permit source 10.3.1.0 0.0.254.0
ip ip-prefix NH-PE1 permit 172.16.1.1 32
ip ip-prefix NH-PE2 permit 172.16.1.20 32
route-policy AB permit node 10
    if-match acl 2000
    if-match ip next-hop ip-prefix NH-PE2
    apply local-preference 200   # 本地优先级越大越优，cost越小越优
route-policy AB permit node 20
    if-match acl 2001
    if-match ip next-hop ip-prefix NH-PE1
    apply local-preference 200
route-policy AB permit node 30  # 放行其他路由
bgp 200
    ipv4-family vpnv4
    peer 172.16.1.9 route-policy AB import  # 从反射器来的路由应用上面的条件

# 检查-----------------
# PE3/4
dis bgp vpnv4 all rou #10.3.1.0下一跳为172.16.1.1，本地优先级为200；10.3.2.0下一条为172.16.1.20，本地优先级为200

# 整个大题最后的测试
# CE3/4
tracert -a 10.3.3.3 10.4.4.4 # CE4：9hop
tracert -a 10.3.3.3 10.3.1.10 # PC1：8hop
tracert -a 10.3.3.3 10.3.2.20 # PC2：8hop

# CE4
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.3.3  # CE3：9hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.1.10 # PC1：8hop
tracert -vpn-instance VPN1 -a 10.4.4.4 10.3.2.20 # PC2：8hop

# PC1/2
tracert 10.3.3.3 # 3hop
tracert 10.4.4.4

# PC1
tracert 10.3.2.20 # 2hop
# PC2
tracert 10.3.1.10 # 2hop
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-featurev0-feature&#34;&gt;4. Feature&lt;sub&gt;V0-feature&lt;/sub&gt;&lt;/h2&gt;
&lt;h3 id=&#34;41-ha&#34;&gt;4.1 HA&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CE1配置静态的默认路由访问ISP，下一跳IP为100.0.1.2.该默认路由要与CE1-ISP链路的BFD状态绑定（CE1的对端设备不支持BFD），感知故障的时间要小于150ms&lt;/li&gt;
&lt;li&gt;CE2配置静态的默认路由访问ISP，下一跳IP为200.0.2.2.该默认路由要与CE2-ISP链路的NQA ICMP测试绑定，间隔5S测试执行1次&lt;/li&gt;
&lt;li&gt;CE3、CE4能够通过默认路由访问ISP。CE1-ISP的链路断开时，CE1仍能访问ISP；CE2-ISP的链路断开时，CE2仍能访问ISP&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1---------------------------
# ISP
int g2/0/1
    ip addr 100.0.1.2 30

# CE1
int g2/0/1
    ip addr 100.0.1.1 30
bfd # 开启全局bfd
    q
bfd huawei bind peer-ip 100.0.1.2 int g2/0/1 one-arm-echo 
    discriminator local 1  # 配置本地设备标示为1
    min-echo-rx-interval 40 # 40的3倍小于150
    commit
    q
ip route-static 0.0.0.0 0.0.0.0 100.0.1.2 track bfd-session huawei
# 检测---------
dis bfd session all

# 2---------------------------
# ISP
int g2/0/2
    ip addr 200.0.2.2 30

# CE2
int g2/0/2
    ip addr 200.0.2.1 30
    q
nqa test-instance huawei huawei
    test-type icmp
    destination-address ipv4 200.0.2.2
    frequency 5
    start now
    q
ip route-static 0.0.0.0 0.0.0.0 200.0.2.2 track nqa huawei huawei
# 检测---------
dis nqa history

# 3--------------
# 使用ospf结合bgp下发默认
# CE1/2
ospf 1
    default-route-advertise
bgp 65000
    network 0.0.0.0
# PE3/4
ospf 2 
    default-route-advertise
# 检测--------
# CE3
dis ip rou   # 查看是否有默认路由
# CE4
dis ip rou vpn-instance VPN1 # 查看是否有默认路由
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;42-nat&#34;&gt;4.2 NAT&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/1访问ISP。&lt;br&gt;
在CE2上，10.3.0.0/16（不含10.3.2.10）的内网地址转换为102.0.1.2-102.0.1.6，通过g2/0/2访问ISP。&lt;br&gt;
Server1拥有单独的公网地址102.0.1.1，对ISP提供FTP和HTTP服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#  CE1
acl 2999
    rule deny source 10.3.2.10 0
    rule permit source 10.3.0.0 0.0.255.255
nat address-group 1 102.0.1.2 102.0.1.6
int g2/0/1
    nat outbound 2999 address-group 1
    nat server protocol tcp global 102.0.1.1 www inside 10.3.2.10 www
    nat server protocol tcp global 102.0.1.1 ftp inside 10.3.2.10 ftp
#  CE2
acl 2999
    rule deny source 10.3.2.10 0
    rule permit source 10.3.0.0 0.0.255.255
nat address-group 1 102.0.1.2 102.0.1.6
int g2/0/2
    nat outbound 2999 address-group 1
    nat server protocol tcp global 102.0.1.1 www inside 10.3.2.10 www
    nat server protocol tcp global 102.0.1.1 ftp inside 10.3.2.10 ftp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;43-qos&#34;&gt;4.3 Qos&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在CE1的g2/0/1、CE2的g2/0/2的出方向，周一至周五的8:00-18:00，对TCP目的端口号为6881-6999的流量，承诺的平均速率为1Mbps&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1/2/3--------------
# CE1
time-range WORKING 8:00 to 18:00 working-day
acl 3000
    rule permit tcp desination-port range 6881 6999 timer-range WORKING
traffic classifiter HUAWEI operator or
    if-match acl 3000
traffic behavior HUAWEI
    car cir 1000
traffic policy HUAWEI
    classifier HUAWEI behavior HUAWEI
interface g2/0/1
    traffic-policy HUAWEI outbound
# CE2
time-range WORKING 8:00 to 18:00 working-day
acl 3000
    rule permit tcp desination-port range 6881 6999 timer-range WORKING
traffic classifiter HUAWEI 
    if-match acl 3000
traffic behavior HUAWEI
    car cir 1000
traffic policy HUAWEI
    classifier HUAWEI behavior HUAWEI
interface g2/0/2
    traffic-policy HUAWEI outbound

# 检查-----
dis traffic policy user-defied
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-ipv6&#34;&gt;5. IPv6&lt;/h2&gt;
&lt;h3 id=&#34;51-基本配置&#34;&gt;5.1 基本配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;所有相关设备接口的IPv6地址，按照图6配置（除PE1-RR1的逻辑接口外，已预配置）&lt;br&gt;
&lt;code&gt;在WAN那道题中已经配置&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;52-ipv6-isis&#34;&gt;5.2 IPv6 ISIS&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图6，PE1、PE2、RR1、P1、ASBR1、ASBR2运行isis协议，各直连网段通告入isis，配置各链路cost&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# PE1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int ip 1
    isis ipv6 enable 
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 20 

# PE2
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 20
int g0/0/2
    isis ipv6 enable 
    isis ipv6 cost 1500

# RR1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int ip 1
    isis ipv6 enable 
    isis ipv6 cost 1550
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 860

# P1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/2
    isis ipv6 enable 
    isis ipv6 cost 1500
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 80
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 1000

# ASBR1
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 860
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 100

# ASBR2
ipv6
isis 
    ipv6 enable topology ipv6 
int loo 0
    isis ipv6 enable
int g0/0/1
    isis ipv6 enable 
    isis ipv6 cost 1000
int g0/0/0
    isis ipv6 enable 
    isis ipv6 cost 100

# 检查---------
dis ipv6 rou pro isis # 可以查看到AS100内所有其他设备环回口路由，建议在PE2上查看
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;53-ipv6-multicast&#34;&gt;5.3 IPv6 Multicast&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如图7，AS100中，相邻设备建立PIM IPv6 SM的邻居关系。PE1的e0/0/0静态加入组FF1E::AA&lt;/li&gt;
&lt;li&gt;ASBR1的loopback0、ASBR2的loopback0为C-BSR且都为FF1E::/112的C-RP。ASBR1的loopback0成为BSR，ASBR2的loopback0成为FF1E::/112的RP&lt;/li&gt;
&lt;li&gt;无论哪个C-RP成为RP，都要确保PIM IPv6域生成（*，G）表项无次优路径&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1------------------------
# RR1/P1
isis 1
    ipv6 import-route isis level-2 into level-1    # 路由渗透，保证AS内环回口互通，可以做与v1相同的策略进行防环，此处不做了

# PE1
multicast ipv6 routing-enabel
int g0/0/0
    pim ipv6 sm  # 先开启
    pim ipv6 silent  # 保障安全
    mld enable   # 后开启
    mld static-group FF1E::AA  # 静态加组
int loo 0
    pim ipv6 sm
int ip 1
    pim ipv6 sm

# PE2
int loo 0
    pim ipv6 sm
int g0/0/0
    pim ipv6 sm
int g0/0/2
    pim ipv6 sm

# RR1
int ip 1
    pim ipv6 sm
int g0/0/0
    pim ipv6 sm
int g0/0/1
    pim ipv6 sm

# P1
int g0/0/0
    pim ipv6 sm
int g0/0/1
    pim ipv6 sm
int g0/0/2
    pim ipv6 sm

# ASBR1
int g0/0/0
    pim ipv6 sm
int g0/0/1
    pim ipv6 sm

# ASBR2
int g0/0/0
    pim ipv6 sm
int g0/0/2
    pim ipv6 sm

# 2--------------------
# ASBR1/ASBR2
acl ipv6 2000
    rule permit source FF1E::AA/112  # 定义RP的服务组范围
acl ipv6 3100
    rule permit ipv6 source 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5/128 destination FF1E::AA/112
    rule permit ipv6 source 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6 128 destination FF1E::AA/112

# ASBR1
pim-ipv6
    c-bsr priority 200
    c-bsr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5
    c-rp 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA5 group-po 2000 pri 200
    crp-policy 3100
# ASBR2
pim-ipv6
    c-bsr priority 100
    c-bsr 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6
    c-rp 2000:EAD8:99EF:CC3E:B2AD:9EFF:A2DD:DCA6 group-po 2000 pri 100
    crp-policy 3100
# 检查--------------
# PE1
dis pim ipv6 bsr-info  # BSR地址为xxxxxxDCA5，优先级为200，C-RP数量2个
dis pim ipv6 rp-info  # RP地址为xxxxxxDCA5，优先级为200；下一个RP地址为xxxxxxDCA6，优先级为100

# 3------------------
# PE1
pim-ipv6
    spt-switch-threshold infinity
# 检查--------------
#ASBR1/2
dis pim ipv6 rou  # 只有（*，FF1E::AA）
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验LABv2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-ts_plana-yao-qiu-zheng-li/"" data-c="
          &lt;h1 id=&#34;1-eth-trunk&#34;&gt;1. eth-trunk&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3881281&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3881281&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site1中，LSW1-LSW2之间的所有链路要求做eth-trunk的捆绑，并且此eth-trunk要求做src-dst-ip负载；&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;2-mstp&#34;&gt;2. MSTP&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4698686&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4698686&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;site1中，CLIENT1属于VLAN12，CLIENT2属于VLAN34；MSTP中的VLAN12属于instance1，vlan34属于instance2；两个instance的主备根桥分别在SW1和SW2上，并且要求CLIENT1访问R1时经过的路径是SW3-SW1-R1；同时要求CLIENT2访问R1时经过的路径是SW3-SW2-R1;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;3-bgp-adv&#34;&gt;3. BGP ADV&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2721642&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2721642&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;R1访问VLAN12时经过的路径是R1-LSW1-LSW3;访问VLAN34时经过的路径是R1-LSW2-LSW3；只允许在AS300中实现，并且确保你的解决方案不要影响AS100 AS300以外的其他AS;&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;4-ospf&#34;&gt;4. OSPF&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2453629&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2453629&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AS100中所有设备都运行了OSPF，但是部分设备的邻居关系有问题，解决此问题&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;5-mux-vlan&#34;&gt;5. mux-vlan&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1907309&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1907309&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site4中，AR24、AR25、AR26在一个网段中，同时都运行了ISIS协议，要求AR26能和AR24、AR25都能形成邻居关系，但是AR24与AR25不能形成邻居关系；通过LSW8的二层VLAN技术以及其他设备排除错误点来实现此要求： 注意；配置过程中不能在LSW8上删除和增加新的VLAN；&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;6-mpls-vpn&#34;&gt;6. MPLS-VPN&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2818630&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2818630&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site1与Site4为同一个VPN客户的两个站点，现在site1里的CLIENTS无法和site4里的CLIENT通信，请解决此问题；注意：不要删除现有配置，可修改解决&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;7-vrrp&#34;&gt;7. VRRP&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8760119&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8760119&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2中AR10与AR11要为LSW4的PC4提供第一跳网关冗余服务，虚拟网关地址为10.2.129.254和10.2.129.253；在配置正确的情况下，VRRP配置后的状态信息如下；  为了加速VRRP的收敛，使用BFD跟踪上行链路状态以及VRRP的邻居关系；(最终结果要和下面的信息一致)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;lt;AR10&amp;gt;display vrrp
  GigabitEthernet0/0/0 | Virtual Router 1
    State : Master
    Virtual IP : 10.2.129.254
    Master IP : 10.2.129.10
    PriorityRun : 200
    PriorityConfig : 200
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$z&amp;lt;@sHH2C5Kh[\s6#]}C2I`kl%$%$
    Virtual MAC : 0000-5e00-0101
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 1 Prioritu reduced:120
    BFD-session static : UP
    Create time : 2014-07-17 20:59:30 UTC-05:13
    Last change time : 2014-07-17 20:59:41 UTC-05:13

  GigabitEthernet0/0/0 | Virtual Router 2
    State : Backup
    Virtual IP : 10.2.129.253
    Master IP : 10.2.129.11
    PriorityRun : 100
    PriorityConfig : 100
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$$&amp;gt;13KX6vBGrR0d~&amp;amp;FZ;QI`m`%$%$
    Virtual MAC : 0000-5e00-0102
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 2 Prioritu increased:120
    BFD-session static : UP
    Create time : 2014-07-17 20:59:30 UTC-05:13
    Last change time : 2014-07-17 21:00:38 UTC-05:13

&amp;lt;AR11&amp;gt;display vrrp
  GigabitEthernet0/0/0 | Virtual Router 1
    State : Backup
    Virtual IP : 10.2.129.254
    Master IP : 10.2.129.10
    PriorityRun : 100
    PriorityConfig : 100
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s 
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$}/TEU.6A&amp;quot;ML/\e!^KvqEId;F%$%$
    Virtual MAC : 0000-5e00-0101
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 2 Prioritu increased:120
    BFD-session static : UP
    Create time : 2014-07-17 21:19:52 UTC-05:13
    Last change time : 2014-07-17 21:21:05 UTC-05:13

  GigabitEthernet0/0/0 | Virtual Router 2
    State : Master
    Virtual IP : 10.2.129.253
    Master IP : 10.2.129.11
    PriorityRun : 200
    PriorityConfig : 200
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$#tW6O)PNIKiC7uP:)c^7IdYN%$%$
    Virtual MAC : 0000-5e00-0102
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 1 Prioritu reduced:120
    BFD-session static : UP
    Create time : 2014-07-17 21:19:52 UTC-05:13
    Last change time : 2014-07-17 21:20:00 UTC-05:13
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;8-dhcp&#34;&gt;8. DHCP&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2973631&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2973631&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2中，AR10 AR11是DHCP服务器并且相互备份，要求CLIENT7能通过DHCP服务器获取到地址10.2.129.100；要求CLIENT8只能获取指定地址为10.2.129.101；现在CLIENT8有时无法获取地址，请解决；&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;9-sham-link&#34;&gt;9. sham-link&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4935800&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4935800&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2与Site3为同一个VPN客户的两个站点，现在AR10与AR20上面的客户（loopback0模拟）都能互通；请解决此问题；并且要求当AS100连接正常的时候，两个客户的数据包通信必须经过AS100；但是AS100出现问题的时候，两个站点可以通过备份链路进行通信&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;10-ipv6&#34;&gt;10. IPv6&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9641415&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9641415&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2与Site3配置了IPV6，并且运行OSPFV3协议；参与的设备有AR10、AR11、AR18、AR20；AR18与AR20之间通过tunnel相通；现在环境中的IPV6 CLIENT 13、IPV6 CLIENT 9 、IPV6 CLIENT10无法实现互相通信，请解决&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;11-telnet&#34;&gt;11. Telnet&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3966888&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3966888&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site3中，AR16 AR17 AR18帧中继网络中运行ospf，使用默认的网络类型；要求AR18能通过telnet远程管理AR16、AR17；现在AR18无法远程管理；解决此问题已满足以下表项；要求AR16的telnet认证方式为AAA，AR16上存在两个用户，admin用户级别为15级，guest用户级别为1级要求两个用户都能认证telnet登录；要求AR17的认证方法为password；所有telnet到AR17的用户级别无需求，但是能支持命令要求截图一致&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;12-qos&#34;&gt;12. Qos&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3111298&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3111298&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site3中AR20上一个用户（ loopback0模拟）和AR18的一个用户（loopback0模拟）要进行语音通信，使用的音频编码G.711，每路语音需要64Kbps的带宽，目前从AR20到AR18的语音质量不够好，需要在AR19上部署QOS；以保证语音流量的服务质量（反向流量不要求）&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;13-nat&#34;&gt;13. NAT&lt;/h1&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-1459468&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-1459468&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site5中通过安全接入AS,client11现在无法通过网关AR27访问到公网AS100、AS200；解决此问题已满足以下表项&lt;/p&gt;
">HCIE 实验TS_PlanA要求整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-ts_-yu-planb-zhi-jian-de-chong-yao-qu-bie/"" data-c="
          &lt;h1 id=&#34;拓扑的区别&#34;&gt;拓扑的区别&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;不考BGP、IPv6 BGP、msdp、ospf&lt;/li&gt;
&lt;li&gt;site2多了AR116&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;考题的具体区别&#34;&gt;考题的具体区别&lt;/h1&gt;
&lt;p&gt;只记录在planB排错步骤下&lt;code&gt;不容易发现&lt;/code&gt;的问题或者&lt;code&gt;容易漏掉&lt;/code&gt;的问题&lt;/p&gt;
&lt;h2 id=&#34;eth-trunkmstpbgp-adv&#34;&gt;eth-trunk+MSTP+BGP ADV&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;SW2的所有上联接口的stp cost配置删除，否则ALTE接口不能DISCARDING&lt;/li&gt;
&lt;li&gt;AR1需要bgp 100需要创建vpn-instance 1（引入直连、建立邻居(sw1的vlan100和sw2的vlan200)）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mux-vlan&#34;&gt;mux-vlan&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR26修改is-level level-2&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mpls-vpn&#34;&gt;MPLS-VPN&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;这个用的是OptionA，与PlanB的排错方式不同，需要查看所有的ASBR（AR23/4/5/2/1）的VPN配置&lt;code&gt;dis cu conf vpn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;除了AR23，其余几个AR均需要添加RT200:100&lt;/li&gt;
&lt;li&gt;AR2在vpn-instance 1中没有配置AR4/5的邻居&lt;/li&gt;
&lt;li&gt;ASBR设备只需要配置域内的mpls和mpls ldp&lt;/li&gt;
&lt;li&gt;AR4/5的bgp中的vpnv4需要&lt;code&gt;policy vpn-target&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AR9的mpls lsr-id错误&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;AR23的&lt;code&gt;acl 2001&lt;/code&gt;需要添加&lt;code&gt;rule permit&lt;/code&gt;来允许所有通过&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;vrrp&#34;&gt;VRRP&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置复制到记事本中修改。配置完之后vrrp在AR10中vrid1有5行配置，vrid2有4行，AR11相反&lt;/li&gt;
&lt;li&gt;vrrpv6的地址的最后一位为254，然后修改AR10的优先级&lt;code&gt;vrrp6 vrid 1 priority 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;AR116的bfd配置是正确的，然后AR10/11的bfd1是配置与AR116之间的bfd，bfd2是这两者之间&lt;/li&gt;
&lt;li&gt;接口g0/0/0配置bfd命令参考&lt;code&gt;vrrp vrid 1 track bfd-session session-name 1 reduced 120&lt;/code&gt;，根据要求进行配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dhcp&#34;&gt;DHCP&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置复制到记事本中修改。AR10参考AR11进行配置（第二个mac配置错误）&lt;/li&gt;
&lt;li&gt;sw4需要配置接口1/3&lt;code&gt;dhcp snooping trusted&lt;/code&gt;且删除端口5的配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sham-link&#34;&gt;sham-link&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;首先解决ospf 100的邻居问题，ospf100的AR6/7/8，AR8的router-id错误和认证配置&lt;/li&gt;
&lt;li&gt;AR7的bgp100中ipv4-family vpnv4的反射（不要忘了lo 1绑定vpn2）&lt;/li&gt;
&lt;li&gt;AR6的g2/0/0的ip为10.2.128.9，所以需要修改ospf110中的a 1宣告&lt;/li&gt;
&lt;li&gt;AR10/11需要将上联接口的IP宣告进ospf110&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ipv6&#34;&gt;IPv6&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR11不需要添加路由汇总&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;telnet&#34;&gt;Telnet&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AR16的acl2001&lt;/li&gt;
&lt;li&gt;在接口下配置ospf的dr优先级，确保AR18为DR&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;qos&#34;&gt;Qos&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;规则中的tcp改为udp&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;nat&#34;&gt;NAT&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;此版本无静态路由需要手动添加，且指向AR9的IP&lt;/li&gt;
&lt;li&gt;测试时只测试AS200，无法测试AS100中的地址&lt;/li&gt;
&lt;/ol&gt;
">HCIE-TS_PlanA与PlanB之间的重要区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-ts_plana/"" data-c="
          &lt;p&gt;&lt;code&gt;不考BGP、IPv6 BGP、msdp&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;ts排错plana&#34;&gt;TS排错&lt;sup&gt;PlanA&lt;/sup&gt;&lt;/h1&gt;
&lt;h2 id=&#34;eth-trunksite1的sw12&#34;&gt;eth-trunk&lt;sub&gt;site1的sw1/2&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site1中，LSW1-LSW2之间的所有链路要求做eth-trunk的捆绑，并且此eth-trunk要求做src-dst-ip负载；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1
dis eth-trunk
int eth 12
dis th
undo trunkport e0/0/18
mode lacp-static
load-balance src-dst-ip
trunkport eth 0/0/18 to 0/0/20

# sw2
dis eth-trunk
int eth 12
dis  th
load-balance src-dst-ip
trunkport eth 0/0/20
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mstpbgp-advsite1的sw123bgp100的ar1&#34;&gt;MSTP+BGP ADV&lt;sub&gt;site1的sw1/2/3,bgp100的AR1&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site1中，CLIENT1属于VLAN12，CLIENT2属于VLAN34；MSTP中的VLAN12属于instance1，vlan34属于instance2；两个instance的主备根桥分别在SW1和SW2上，并且要求CLIENT1访问R1时经过的路径是SW3-SW1-R1；同时要求CLIENT2访问R1时经过的路径是SW3-SW2-R1;&lt;/li&gt;
&lt;li&gt;R1访问VLAN12时经过的路径是R1-LSW1-LSW3;访问VLAN34时经过的路径是R1-LSW2-LSW3；只允许在AS300中实现，并且确保你的解决方案不要影响AS100 AS300以外的其他AS;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1
dis th
int e0/0/21
dis th
port trunk all vlan all
dis cu conf mst
bgp 300
dis th
undo network 10.1.12.0 255.255.255.0
network 10.1.12.0 255.255.255.0

# sw2
dis th
stp instance 2 root primary
int e0/0/22
dis th
port trunk all vlan all
q
dis cu conf mst
    stp region-configuration # 使用sw1的配置
    region-name HCIE
    instance 1 vlan 12
    instance 2 vlan 34
    active region-configuration
bgp 300
dis th
network 10.1.12.0 255.255.255.0 route-policy MED
undo network 10.1.34.0 255.255.255.0
network 10.1.34.0 255.255.255.0


# sw3
dis th
stp mode mstp
int e0/0/21
dis th
port trunk all vlan all
int e0/0/22
dis th
port trunk all vlan all
dis cu conf mst
int e0/0/1
dis th
undo stp cost 
port link-type access
port default vlan 12
int e0/0/2
dis th
port link-type access
port default vlan 12
int e0/0/3
dis th
port link-type access
port default vlan 34
int e0/0/4
dis th
port link-type access
port default vlan 34

# AR1
int g2/0/2
dis th
int g2/0/1
dis th
ip binding vpn-instance 1
bgp 100
dis th
ipv4-family vpn-instance 1
peer 10.1.100.100 as 300  # sw1
peer 10.1.200.200 as 300  # sw2
import-route direct
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mux-vlansite4的ar242526和sw8&#34;&gt;mux-vlan&lt;sub&gt;site4的AR24/25/26和sw8&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site4中，AR24、AR25、AR26在一个网段中，同时都运行了ISIS协议，要求AR26能和AR24、AR25都能形成邻居关系，但是AR24与AR25不能形成邻居关系；通过LSW8的二层VLAN技术以及其他设备排除错误点来实现此要求： 注意；配置过程中不能在LSW8上删除和增加新的VLAN；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw8
dis mux-vlan
vlan 100
undo subordinate group 30  50
subordinate separate 50
port-group group-member g0/0/1 g0/0/2
port link-type access
port default vlan 50
port mux-vlan enable
q
int g0/0/3
dis th
port default vlan 100
port mux-vlan enable

# AR24
isis 100
dis th
int g0/0/0
dis th
isis authen md5 cipher hcie

# AR25
isis 100
dis th
int g0/0/0
dis th
isis authen md5 cipher hcie

# AR26
isis 100
dis th
is-level level-2
int g0/0/0
dis th
isis authen md5 cipher hcie
isis dis-pri 127
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mpls-vpnas100和as200的所有设备&#34;&gt;MPLS-VPN&lt;sub&gt;AS100和AS200的所有设备&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site1与Site4为同一个VPN客户的两个站点，现在site1里的CLIENTS无法和site4里的CLIENT通信，请解决此问题；注意：不要删除现有配置，可修改解决&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1
dis cu conf vpn # 主要查看RD和RT值
ip vpn-instance 1
vpn-target 200:100
dis bgp vpnv4 all rou

# AR2
dis cu conf vpn # 主要查看RD和RT值
ip vpn-instance 1
vpn-target 200:100
bgp 100
dis th
ipv4-family vpnv4
policy vpn-target
ipv4-family vpn-instance 1
peer 200.100.24.4 as 200
peer 200.100.25.5 as 200
q
q
dis bgp vpnv4 all rou

# AR4
dis cu conf vpn # 主要查看RD和RT值
ip vpn-instance 1
vpn-target 200:100
bgp 200
dis th
ipv4-family vpnv4
policy vpn-target
int g0/0/1
mpls
mpls ldp
q
dis bgp vpnv4 all rou

# AR5
dis cu conf vpn # 主要查看RD和RT值
ip vpn-instance 1
vpn-target 200:100
bgp 200
dis th
ipv4-family vpnv4
policy vpn-target

#AR9
dis cu | i mpls
undo mpls
y
mpls lsr-id 200.1.1.9
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
int g0/0/2
mpls
mpls ldp

# AR23
dis cu conf vpn # 主要查看RD和RT值
tracert lsp -a 200.1.1.23 ip 200.1.1.4 32
tracert lsp -a 200.1.1.23 ip 200.1.1.5 32
dis bgp vpnv4 all rou
isis 100
import bgp
bgp 200
dis th
dis cu conf route
acl 2000
dis th
rule permit source 10.1.34.0 0
rule permit source 10.1.1.1 0
acl 2001
dis th
rule permit
dis bgp vpnv4 all rou

# AR26
dis ip rou pro isis
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;vrrpsite2的ar1011&#34;&gt;VRRP&lt;sub&gt;site2的AR10/11&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2中AR10与AR11要为LSW4的PC4提供第一跳网关冗余服务，虚拟网关地址为10.2.129.254和10.2.129.253；在配置正确的情况下，VRRP配置后的状态信息如下；  为了加速VRRP的收敛，使用BFD跟踪上行链路状态以及VRRP的邻居关系；(最终结果要和下面的信息一致)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR10
int g0/0/0
dis th
vrrp vrid 1 authentication-mode md5 hcie
vrrp vrid 2 authentication-mode md5 hcie
vrrp vrid 2 virtual-ip 10.2.129.253
undo vrrp vrid 2 virtual-ip 10.2.129.251
vrrp vrid 1 preempt-mode timer delay 1
vrrp vrid 2 preempt-mode timer delay 1
vrrp6 vrid 1 virtual-ip FE80::1 link-local
vrrp6 vrid 1 virtual-ip 2002:10:2:129::254
vrrp6 vrid 1 priority 200
q
dis cu | i bfd
undo bfd 2
bfd 2 bind peer-ip 10.2.129.11 source-ip 10.2.129.10 auto
undo bfd 1
bfd 1 bind peer-ip 10.2.128.2 source-ip 10.2.128.1 auto
int g0/0/0
vrrp vrid 1 track bfd-session session-name 1 reduced 120
vrrp vrid 2 track bfd-session session-name 2 increased 120

# AR11
int g0/0/0
dis th
vrrp vrid 1 authentication-mode md5 hcie
vrrp vrid 2 authentication-mode md5 hcie
vrrp vrid 2 priority 200
vrrp vrid 2 preempt-mode timer delay 1
undo vrrp6 vrid 1
vrrp6 vrid 1 virtual-ip FE80::2 link-local
vrrp6 vrid 1 virtual-ip 2002:10:2:129::254
dis cu | i bfd
undo bfd 1
bfd 1 bind peer-ip 10.2.128.6 source-ip 10.2.128.5 auto
int g0/0/0
vrrp vrid 1 track bfd-session session-name 1 increased 120
vrrp vrid 2 track bfd-session session-name 2 reduced 120

# AR116
dis cu | i bfd
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dhcpsite2的ar1011和sw4&#34;&gt;DHCP&lt;sub&gt;site2的AR10/11和SW4&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2中，AR10 AR11是DHCP服务器并且相互备份，要求CLIENT7能通过DHCP服务器获取到地址10.2.129.100；要求CLIENT8只能获取指定地址为10.2.129.101；现在CLIENT8有时无法获取地址，请解决；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR10
dis cu conf ip-pool # 将配置复制到记事本进行修改
    1. 网关错误，修改为254
    2. 网络错误，修改为10.2.129.0/24
    3. 缺少排除地址
    2. 两个mac错误
undo ip pool hcie
    刷入配置
dhcp enable
int g0/0/0
dhcp select global

# AR11
dis cu conf ip-pool # 将配置复制到记事本进行修改
    1. 第二个mac错误
undo ip pool hcie
    刷入配置
dhcp enable
int g0/0/0
dhcp select global

# sw4
int e0/0/1
dhcp snooping trusted
int e0/0/3
dhcp snooping trusted
int e0/0/5
undo dhcp snooping trusted
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;sham-linkas100的ar61378site3的ar20&#34;&gt;sham-link&lt;sub&gt;AS100的AR6/13/7/8，site3的AR20&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2与Site3为同一个VPN客户的两个站点，现在AR10与AR20上面的客户（loopback0模拟）都能互通；请解决此问题；并且要求当AS100连接正常的时候，两个客户的数据包通信必须经过AS100；但是AS100出现问题的时候，两个站点可以通过备份链路进行通信；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR8
ospf 100
dis th
ospf 100 router-id 100.1.1.8
return
reset ospf proccess
ospf 100
a 0
network 100.1.78.8 0.0.0.0
authentication-mode md5 1 cipher hcie
osfp 110
dis th
a 0
undo sham-link 100.1.136.13 100.1.136.6
a 1
undo network 100.1.136.13 0.0.0.0
sham-link 100.1.136.6 100.1.136.13



# AR7
ospf 100
dis th
a 0
undo authentication-mode  
int g0/0/1
dis th
undo ospf timer hello 
bgp 100
dis th
ipv4-famliy vpnv4
peer 100.1.1.6 reflect-client
peer 100.1.1.13 reflect-client

# AR6
ospf 110
dis th
a 1
undo network 10.2.128.6 0.0.0.0
network 10.2.128.9 0.0.0.0
int lo 1
dis th
ip binding vpn-instance 2
ip address 100.1.136.6 255.255.255.255
bgp 100
dis th

# AR13
osfp 110
dis th
a 1
undo sham-link 100.1.136.6 100.1.136.13
sham-link 100.1.136.13 100.1.136.6
int lo 1
dis th
bgp 100
dis th
ipv4-famliy vpn-instance 2
network 100.1.136.13 255.255.255.255

# AR116
ospf 110
dis th

# AR10
ospf 110
dis th
a 1
network 10.2.128.1 0.0.0.0
q
tracert -a 10.2.1.10 10.3.1.20

# AR11
int s3/0/1
dis th
ospf cost 100
ospf 110
dis th
a 1
network 10.2.128.5 0.0.0.0

# AR20
int s3/0/0
dis th
ospf cost 100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ipv6as100的ar1011site3的ar2018&#34;&gt;IPv6&lt;sub&gt;AS100的AR10/11，site3的AR20/18&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2与Site3配置了IPV6，并且运行OSPFV3协议；参与的设备有AR10、AR11、AR18、AR20；AR18与AR20之间通过tunnel相通；现在环境中的IPV6 CLIENT 13、IPV6 CLIENT 9 、IPV6 CLIENT10无法实现互相通信，请解决；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR18
int t 0/0/100
dis th
undo ospfv3 1 area 0.0.0.1
ospfv3 1 area 0.0.0.0
ospfv3
dis th
undo silent-interface t 0/0/100

# AR20
int t 0/0/100
dis th
gre key 123
ospfv3
dis th
a 0
abr-summary 2002:10:3:209:: 64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;telnetsite3的ar161718&#34;&gt;Telnet&lt;sub&gt;site3的AR16/17/18&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site3中，AR16 AR17 AR18帧中继网络中运行ospf，使用默认的网络类型；要求AR18能通过telnet远程管理AR16、AR17；现在AR18无法远程管理；解决此问题已满足以下表项；要求AR16的telnet认证方式为AAA，AR16上存在两个用户，admin用户级别为15级，guest用户级别为1级要求两个用户都能认证telnet登录；要求AR17的认证方法为password；所有telnet到AR17的用户级别无需求，但是能支持命令要求截图一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR16
aaa
dis th
local-user admin privilege level 15
local-user admin password cipher hcie
local-user guest password cipher hcie
local-user admin service-type telnet
user-interface vty 0 4
dis th
authentication-mode aaa
acl 2001
rule 5 permit source 10.3.1.18 0
int s3/0/0
dis th
ospf dr-priority 0

# AR17
user-interface vty 0 4
dis th
# user privilege level 0 # 这是默认级别，如果没有就对了
set authentication password cipher hcie
int s3/0/0
dis th
ospf dr-priority 0

# AR18
int s3/0/0
dis th
ospf dr-priority 255
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;qossite3的ar19&#34;&gt;Qos&lt;sub&gt;site3的AR19&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site3中AR20上一个用户（ loopback0模拟）和AR18的一个用户（loopback0模拟）要进行语音通信，使用的音频编码G.711，每路语音需要64Kbps的带宽，目前从AR20到AR18的语音质量不够好，需要在AR19上部署QOS；以保证语音流量的服务质量（反向流量不要求）；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR19
dis cu  # 复制到记事本进行修改

acl name UDP 3999  
dis th
rule 1 permit udp source 10.3.1.20 0 destination 10.3.1.18 0 destination-port range 16384 32767  # 由tcp改为udp

traffic behavior cbq
dis th
undo queue llq 
queue llq bandwidth 64

traffic behavior remark
dis th
undo remark dscp
remark dscp ef

int g0/0/0  # AR20到AR18，反向流量无需求，则g0/0/0为入方向，s3/0/0为出方向
dis th
undo traffic-policy outbound
traffic-policy remark-ef inbound 

int s3/0/0
dis th
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;natar279&#34;&gt;NAT&lt;sub&gt;AR27/9&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site5中通过安全接入AS,client11现在无法通过网关AR27访问到公网AS100、AS200；解决此问题已满足以下表项；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR27
dis cu | i  route
ip route-static 0.0.0.0 0.0.0.0 s3/0/0 # 或者指向200.1.209.9
dis cu conf acl # 规则号为2000
dis cu conf nat  # 在接口下调用地址组，组号为1
int s3/0/0
dis th
ppp chap password cipher hcie
nat outbound 2000 address-group 1
q
dis nat out # 有一条s3/0/0

# AR9
int s3/0/0
dis th
isis enable 200
ppp authentication-mode chap
aaa
dis th
local-user hcie password cipher hcie
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TS_PlanA</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-ts_planb-yao-qiu-zheng-li/"" data-c="
          &lt;h1 id=&#34;整体要求&#34;&gt;整体要求&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;所有设备登录密码为hcie&lt;/li&gt;
&lt;li&gt;所有FR环境中要使用静态的MAP映射&lt;/li&gt;
&lt;li&gt;所有FR设备不允许做任何修改&lt;/li&gt;
&lt;li&gt;所有的策略是不能删除的，但是可以新增或者修改&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;题目要求&#34;&gt;题目要求&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1605853424451.PNG&#34; alt=&#34;TS_PlanB&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;1-mstp&#34;&gt;1. MSTP&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-2437454&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-2437454&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;site1中，CLIENT1属于VLAN12，CLIENT2属于VLAN34；&lt;br&gt;
MSTP中的VLAN12属于instance1，vlan34属于instance2；&lt;br&gt;
两个instance的主备根桥分别在SW1和SW2上，并且要求CLIENT1访问R1时经过的路径是SW3-SW1-R1；同时要求CLIENT2访问R1时经过的路径是SW3-SW2-R1;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;SW1/2/3上的mstp配置：dis cu conf mst
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;2-eth-trunk&#34;&gt;2. eth-trunk&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-5029760&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-5029760&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site1中，LSW1-LSW2之间的所有链路要求做eth-trunk的捆绑，并且此eth-trunk要求做src-dst-ip负载；&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;3-bgp-adv&#34;&gt;3. BGP ADV&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8897931&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8897931&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;R1访问VLAN12时经过的路径是R1-LSW1-LSW3;&lt;br&gt;
访问VLAN34时经过的路径是R1-LSW2-LSW3；&lt;br&gt;
只允许在AS300中实现，并且确保你的解决方案不要影响AS100 AS300以外的其他AS;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;4-mux-vlan&#34;&gt;4. mux-vlan&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9522342&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9522342&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site4中，AR24、AR25、AR26在一个网段中，同时都运行了ISIS协议，要求AR26能和AR24、AR25都能形成邻居关系，但是AR24与AR25不能形成邻居关系；&lt;br&gt;
通过LSW8的二层VLAN技术以及其他设备排除错误点来实现此要求：&lt;br&gt;
注意：配置过程中不能在LSW8上删除和增加新的VLAN；&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;5-mpls-vpn&#34;&gt;5. MPLS-VPN&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8947312&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8947312&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site1与Site4为同一个VPN客户的两个站点，现在site1里的CLIENTS无法和site4里的CLIENT通信，请解决此问题；&lt;br&gt;
注意：不要删除现有配置，可修改解决；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. AS100中的AR7 和 AS200中的AR9 的mpls lsr-id错误
2. AR23中isis 100和bgp 200中的vpn-instance 1的路由相互引入，同时注意acl 2000
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;6-sham-link&#34;&gt;6. sham-link&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6763279&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6763279&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2与Site3为同一个VPN客户的两个站点，现在AR10与AR20上面的客户（loopback0模拟）都能互通；请解决此问题；&lt;br&gt;
并且要求当AS100连接正常的时候，两个客户的数据包通信必须经过AS100；但是AS100出现问题的时候，两个站点可以通过备份链路进行通信；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. AR6和AR13的lo 2绑定bgp100中vpn-instance 2，且bgp 100中的宣告lo 2地址，同时引入ospf 110，ospf 110的area 1中宣告的lo 2地址删除，并引入bgp
2. 注意【不影响此题】：AR11和AR20相连的串口在IPv6中，宣告进ospfv3的区域0，而不是区域1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;7-vrrp&#34;&gt;7. vrrp&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9562357&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9562357&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2中AR10与AR11要为LSW4的PC4提供第一跳网关冗余服务，虚拟网关地址为10.2.129.254和10.2.129.253；  为了加速VRRP的收敛，使用BFD跟踪上行链路状态以及VRRP的邻居关系；(最终结果要和下面的信息一致)&lt;br&gt;
在配置正确的情况下，VRRP配置后的状态信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;lt;AR10&amp;gt;display vrrp
  GigabitEthernet0/0/0 | Virtual Router 1
    State : Master
    Virtual IP : 10.2.129.254
    Master IP : 10.2.129.10
    PriorityRun : 200
    PriorityConfig : 200
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$z&amp;lt;@sHH2C5Kh[\s6#]}C2I`kl%$%$
    Virtual MAC : 0000-5e00-0101
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 1 Prioritu reduced:120
    BFD-session static : UP
    Create time : 2014-07-17 20:59:30 UTC-05:13
    Last change time : 2014-07-17 20:59:41 UTC-05:13

  GigabitEthernet0/0/0 | Virtual Router 2
    State : Backup
    Virtual IP : 10.2.129.253
    Master IP : 10.2.129.11
    PriorityRun : 100
    PriorityConfig : 100
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$$&amp;gt;13KX6vBGrR0d~&amp;amp;FZ;QI`m`%$%$
    Virtual MAC : 0000-5e00-0102
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 2 Prioritu increased:120
    BFD-session static : UP
    Create time : 2014-07-17 20:59:30 UTC-05:13
    Last change time : 2014-07-17 21:00:38 UTC-05:13

&amp;lt;AR11&amp;gt;display vrrp
  GigabitEthernet0/0/0 | Virtual Router 1
    State : Backup
    Virtual IP : 10.2.129.254
    Master IP : 10.2.129.10
    PriorityRun : 100
    PriorityConfig : 100
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s 
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$}/TEU.6A&amp;quot;ML/\e!^KvqEId;F%$%$
    Virtual MAC : 0000-5e00-0101
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 2 Prioritu increased:120
    BFD-session static : UP
    Create time : 2014-07-17 21:19:52 UTC-05:13
    Last change time : 2014-07-17 21:21:05 UTC-05:13

  GigabitEthernet0/0/0 | Virtual Router 2
    State : Master
    Virtual IP : 10.2.129.253
    Master IP : 10.2.129.11
    PriorityRun : 200
    PriorityConfig : 200
    MasterPriority : 200
    Preempt : YES   Delay Time : 1 s
    TimerRun : 1 s
    TimerConfig : 1 s
    Auth type : MD5   Auth key : %$%$#tW6O)PNIKiC7uP:)c^7IdYN%$%$
    Virtual MAC : 0000-5e00-0102
    Check TTL : YES
    Config type : normal-vrrp
    Backup-forward : disabled
    Track BFD : 1 Prioritu reduced:120
    BFD-session static : UP
    Create time : 2014-07-17 21:19:52 UTC-05:13
    Last change time : 2014-07-17 21:20:00 UTC-05:13
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;8-telnet&#34;&gt;8. Telnet&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8355444&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8355444&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site3中，AR16 AR17 AR18帧中继网络中运行ospf，使用默认的网络类型；&lt;br&gt;
要求AR18能通过telnet远程管理AR16、AR17；现在AR18无法远程管理；解决此问题已满足以下表项；&lt;br&gt;
要求AR16的telnet认证方式为AAA，AR16上存在两个用户，admin用户级别为15级，guest用户级别为1级要求两个用户都能认证telnet登录；&lt;br&gt;
要求AR17的认证方法为password；所有telnet到AR17的用户级别无需求，但是能支持命令要求截图一致。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;9-ipv6&#34;&gt;9. IPv6&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-6745291&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-6745291&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2与Site3配置了IPV6，并且运行OSPFV3协议；&lt;br&gt;
参与的设备有AR10、AR11、AR18、AR20；AR18与AR20之间通过tunnel相通；&lt;br&gt;
现在环境中的IPV6 CLIENT 13、IPV6 CLIENT 9 、IPV6 CLIENT16无法实现互相通信，请解决；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. site3--两个邻居和T0/0/100是在ospfv3的区域0中【AR18与AR20相连的串口宣告在区域0】
2. site2--两个邻居是在ospfv3的区域1中【AR11与AR20相连的串口宣告在区域1】
3. AR18的ipv6地址配置错误
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;10-bgp&#34;&gt;10. BGP&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3890178&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3890178&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要求AS100中AR12的loopback0口能够访问AS200中的AR9的loopback0口；但是现在两个loopback口地址无法访问；请解决该问题；&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;11-nat&#34;&gt;11. NAT&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9396326&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9396326&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site5中通过安全接入AS，client11现在无法通过网关AR27访问到公网AS100、AS200；解决此问题已满足以下表项；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. AR9的s3/0/0接口宣告进ISIS 200
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;12-dhcp&#34;&gt;12. DHCP&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-4501195&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-4501195&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site2中，AR10 AR11是DHCP服务器并且相互备份，要求CLIENT7能通过DHCP服务器获取到地址10.2.129.100；&lt;br&gt;
要求CLIENT8只能获取指定地址为10.2.129.101；&lt;br&gt;
现在CLIENT8有时无法获取地址，请解决；&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;13-ospf&#34;&gt;13. OSPF&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8269628&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8269628&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AS100中所有设备都运行了OSPF，但是部分设备的邻居关系有问题，解决此问题；&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;14-msdp&#34;&gt;14. msdp&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-3661904&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-3661904&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AS100与AS200要部署域间组播；&lt;br&gt;
AR7是AS100中的RP，AR9是AS200中的RP；&lt;br&gt;
AS100中AR22上有一台视频服务器，AS200中AR23上有一个组播接收者要加入组239.1.1.1，现在客户无法收到组播数据，无法观看相应的视频；请解决该问题；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. AS200中的AR9和AS100中的AR7的msdp
2. AR22下联接口删除igmp，AR23下联接口先开启pim sm，再开启igmp，但不加组
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;15-qos&#34;&gt;15. QoS&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-8707934&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-8707934&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Site3中AR20上一个用户（ loopback0模拟）和AR18的一个用户（loopback0模拟）要进行语音通信，使用的音频编码G.711，每路语音需要64Kbps的带宽，目前从AR20到AR18的语音质量不够好，需要在AR19上部署QOS；&lt;br&gt;
以保证语音流量的服务质量（反向流量不要求）；&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;16-ipv6-bgp&#34;&gt;16. IPv6 BGP&lt;/h2&gt;
&lt;ul class=&#34;contains-task-list&#34;&gt;
&lt;li class=&#34;task-list-item&#34;&gt;&lt;input class=&#34;task-list-item-checkbox&#34; checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34; id=&#34;task-item-9493376&#34;&gt;&lt;label class=&#34;task-list-item-label&#34; for=&#34;task-item-9493376&#34;&gt; 已完成&lt;/label&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AS200中AR9 AR4 AR5上面各有一个IPV6客户站点（loopback1模拟），AS100中有AR2 AR7上各有一个IPV6客户站点（loopback1模拟），要求这几个站点都能互通，并且要求双向路径要优选AR2-AR4之间的链路，一旦主用链路出现问题在使用备用链路AR2-AR5；&lt;br&gt;
现在这几个站点之间的互通存在部分问题，请解决；&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. AS100--AR7的bgp100中宣告lo1的IPv6地址
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TS_PlanB要求整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-lab-ts_planb-cuo-dian-zheng-li/"" data-c="
          &lt;p&gt;解题的步骤总结如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;查看全局配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 局部显示配置命令
dis th # 在全局模式下执行
# 查看当前设备所有配置
display  current-configuration
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;查看协议配置（有过滤规则需要查看相应的过滤规则）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dis cu conf stp/ospf/bgp/msdp...
dis stp instance 1 bri # stp实例
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;查看协议运行状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dis mux-vlan
dis eth-trunk 12
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;查看接口配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dis cu int g0/0/0...
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mstpeth-trunkbgp-adv&#34;&gt;MSTP+Eth-Trunk+BGP ADV&lt;/h1&gt;
&lt;h2 id=&#34;要求&#34;&gt;要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site1中，CLIENT1属于VLAN12，CLIENT2属于VLAN34；MSTP中的VLAN12属于instance1，vlan34属于instance2；两个instance的主备根桥分别在SW1和SW2上，并且要求CLIENT1访问R1时经过的路径是SW3-SW1-R1，CLIENT2访问R1时经过的路径是SW3-SW2-R1&lt;/li&gt;
&lt;li&gt;site1中，LSW1-LSW2之间的所有链路要求做eth-trunk的捆绑，并且此eth-trunk要求做src-dst-ip负载&lt;/li&gt;
&lt;li&gt;R1访问VLAN12时经过的路径是R1-LSW1-LSW3，访问VLAN34时经过的路径是R1-LSW2-LSW3；只允许在AS300中实现，并且确保你的解决方案不要影响AS100、AS300以外的其他AS&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设备&#34;&gt;设备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site1：SW1/2/3&lt;/li&gt;
&lt;li&gt;AS100：AR1&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;建议&#34;&gt;建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;先查看sw3上的部分全局配置、stp配置，再查看4个接口的配置&lt;/li&gt;
&lt;li&gt;sw1与sw2同时操作，先查看部分全局配置，再查看stp配置、查看接口配置、eth-trunk配置，最后查看bgp配置&lt;/li&gt;
&lt;li&gt;AR1上先查看bgp配置，再查看接口配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 全局配置
# sw1
dis th
stp en
stp ins 1 root pri

dis cu conf mst

dis eth-trunk 12
int Eth-Trunk 12
dis th
load-balance src-dst-ip 
dis cu int eth-t 12

dis cu conf bgp
bgp 300
dis th # MED策略配置给备份路由，即10.1.34.0
undo network 10.1.23.0 255.255.255.0
undo network 10.1.12.0 255.255.255.0
network 10.1.12.0 255.255.255.0   

int e0/0/21
dis th
port trunk allow vlan all  # mstp关键现象步骤

# sw2
dis th

dis cu conf mst

dis eth-trunk 12
int Eth-Trunk 12
dis th
undo trunkport e0/0/18
undo trunkport e0/0/20
undo trunkport e0/0/21
mode lacp-static
load-balance src-dst-ip 
trunkport e0/0/18
trunkport e0/0/20 # 因为int e0/0/19有配置，所以需要删除其配置才能添加
int e0/0/19
dis th
port hybrid vlan 1
eth-trunk 12
dis cu int eth-t 12

dis cu conf bgp
bgp 300
dis th # MED策略配置给备份路由，即10.1.12.0
network 10.1.12.0 255.255.255.0 route-policy MED 
undo network 10.1.34.0 255.255.255.0
network 10.1.34.0 255.255.255.0

int e0/0/22
dis th
port trunk allow vlan all   # mstp关键现象步骤

# sw3
dis th
stp mode mstp

dis cu conf mst
    stp region-configuration # 使用sw1的配置
    region-name HCIE
    instance 1 vlan 12
    instance 2 vlan 34
    active region-configuration

int e0/0/2
dis th
port default vlan 34
undo stp ins 2 cost
int eth 0/0/21
dis th
undo stp instance 1 cost
stp instance 2 cost 3000000
port trunk allow vlan all
int eth 0/0/22
dis th
undo stp instance 2 cost
stp instance 1 cost 8000000

# AR1
dis cu conf bgp
bgp 100
dis th
ipv4-family vpn-instance 1
undo peer 10.1.100.100   # 10.1.100.100，10.1.200.200的as号均为300
peer 10.1.100.100 as-number 300

int g2/0/1
dis th
ip binding vpn-instance 1
ip address 10.1.100.1 255.255.255.0 
int g2/0/2
dis th
ip binding vpn-instance 1
ip address 10.1.200.1 255.255.255.0 

#-----------------------------------------------------
# 检查
# Eth-Trunk
# SW1/2
dis eth-t 12 # WorkingMode: STATIC；Hash arithmetic: According to SIP-XOR-DIP；e0/0/18.19.20的状态均为Select

# BGP ADV
# AR1
dis bgp vpnv4 vpn-ins 1 peer # 两个邻居都Established
dis bgp vpnv4 vpn-ins 1 rou # 10.1.12.0（10.1.100.100的MED为0）和10.1.34.0（10.1.200.200的MED为0）均出现两条路由的负载
tracert -vpn-instance 1 10.1.12.11 # 10.1.100.100--10.1.12.11
tracert -vpn-instance 1 10.1.34.22 # 10.1.200.200--10.1.34.22

# MSTP
# client1/2
tracert 10.1.1.1 #client1:10.1.12.1--10.1.1.1；client2:10.1.34.1--10.1.1.1
# SW3
dis stp bri
dis stp instance 1 bri
dis stp instance 2 bri
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;mux-vlanmpls-vpnospfbgpipv6-bgp&#34;&gt;Mux-Vlan+MPLS-VPN+OSPF+BGP+IPv6 BGP&lt;/h1&gt;
&lt;h2 id=&#34;要求-2&#34;&gt;要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site4中，AR24、AR25、AR26在一个网段中，同时都运行了ISIS协议，要求AR26能和AR24、AR25都能形成邻居关系，但是AR24与AR25不能形成邻居关系在AR24和AR25上虽然能看到彼此的邻居关系，但是不是在R26-SW8-R24-R25这一网段上成为邻居关系，而是在R24-R25-SW7这一网段上成为邻居，符合题目要求。通过LSW8的二层VLAN技术以及其他设备排除错误点来实现此要求，【注意】配置过程中不能在LSW8上删除和增加新的VLAN&lt;/li&gt;
&lt;li&gt;site1与Site4为同一个VPN客户的两个站点，现在site1里的CLIENT无法和site4里的CLIENT通信，解决此问题，【注意】不要删除现有配置，可修改解决&lt;/li&gt;
&lt;li&gt;AS100中所有设备都运行了OSPF，但是部分设备的邻居关系有问题，解决此问题&lt;/li&gt;
&lt;li&gt;要求AS100中AR12的loopback0口能够访问AS200中的AR9的loopback0口，但是现在两个loopback口地址无法访问，请解决该问题&lt;/li&gt;
&lt;li&gt;AS200中AR9 AR4 AR5上面各有一个IPV6客户站点（loopback1模拟），AS100中有AR2 AR7上各有一个IPV6客户站点（loopback1模拟），要求这几个站点都能互通，并且要求双向路径要优选AR2-AR4之间的链路，一旦主用链路出现问题在使用备用链路AR2-AR5；现在这几个站点之间的互通存在部分问题，请解决；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设备-2&#34;&gt;设备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site4的SW8、AR26/25/24&lt;/li&gt;
&lt;li&gt;AS100的AR1/2/3/6/7/8/13/12&lt;/li&gt;
&lt;li&gt;AS200的AR9&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;建议-2&#34;&gt;建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;做通site4中的mux-vlan&lt;/li&gt;
&lt;li&gt;AS100中的OSPF&lt;/li&gt;
&lt;li&gt;AS100中的BGP、MPLS&lt;/li&gt;
&lt;li&gt;AS200中的ISIS、BGP、MPLS&lt;/li&gt;
&lt;li&gt;AR1和AR23之间的VPN&lt;/li&gt;
&lt;li&gt;AR12和AR9之间的通信（主要涉及route-policy）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作-2&#34;&gt;操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#-----------------------------Mux-Vlan------------------------
# 协议运行状态
# sw8
dis mux-vlan
int e0/0/1
dis th
undo port mux-vlan enable
port default vlan 1
int e0/0/2
dis th
undo port mux-vlan enable
port default vlan 1
vlan 100
dis th
undo subordinate separate
undo subordinate group 50
subordinate separate 50
q
port-group group-member e0/0/1 e0/0/2
port link access
port default vlan 50
port mux-vlan enable
q

# AR24
dis cu conf isis
int g0/0/0
dis th
isis authentication-mode md5 cipher hcie
undo mtu


# AR25
dis cu conf isis
isis 100
dis th
undo domain-authentication-mode
int g0/0/0
dis th
isis authentication-mode md5 cipher hcie

# AR26
dis cu conf isis
int g0/0/0
dis th
isis authentication-mode md5 cipher hcie
isis dis-pri  127

#-----------------------------------------------------
# 检查
# sw8
dis mux-vlan # 100（e0/0/3）为principal，50为隔离型从且有两个接口（e/0/0/1和e/0/0/2）
# AR24/25/26
dis isis peer  #AR24/25/26相互建立邻居
# AR26
dis ip rou pro isis # 去往10.4.128.23/24的两条路由负载


#-----------------------------OSPF------------------------
# AR1
dis cu conf ospf
dis cu | in ip-pre
undo ip ip-prefix 2
ip ip-prefix 2 permit 100.1.1.2 32
ip ip-prefix 2 permit 0.0.0.0 0 less-equal 32
dis cu | in ip-pre
ospf 100
dis th
a 1
undo network 100.1.16.1 0.0.0.0
a 0 
network 100.1.16.1 0.0.0.0
dis ospf peer bri # 此时AR1和AR6、AR2均建立邻居

# AR2（无问题，问题发生在邻居身上）
dis cu conf ospf
dis ospf peer bri 
int g0/0/0
dis th
int g0/0/1
dis th
int g0/0/2
dis th

# AR3
dis cu conf ospf
dis ospf peer bri 
int g0/0/0
dis th
undo ospf timer dead
int g0/0/1
dis th
undo ospf timer dead
dis ospf peer bri

# AR13（只看100，无问题）
dis cu conf ospf
dis ospf peer bri

# AR8
dis cu conf ospf
ospf 100
a 0
network 100.1.78.8 0.0.0.0
dis ospf peer bri
int g0/0/1
dis th

# AR7
dis cu conf ospf
ospf 100 router-id 100.1.1.7
return
reset ospf process
y
sys
ospf 100
dis th
a 0
undo authentication-mode
dis ospf peer bri
int g0/0/1
dis th
ospf timer hello 10
dis ospf peer bri

# AR6（无问题）
dis cu conf ospf
dis ospf peer bri

#-----------------------------------------------------
# 检查
# AR1/2/3/13/8/7/6
dis ospf peer bri  # 直连的路由器均为ospf邻居


#-----------------------------BGP100------------------------
# 由于以AR7为反射中心，所以先看AR7
# AR7
dis cu conf bgp
bgp 100
dis th
undo peer 100.1.1.12
peer 100.1.1.12 as-number 100
peer 100.1.1.12 connect-interface LoopBack0
ipv4-family unicast
dis th
peer 100.1.1.6 reflect-client
peer 100.1.1.12 reflect-client
peer 100.1.1.13 reflect-client
q
ipv6-family unicast 
network 2002:100:7:1::1 128
q
dis th
ipv4-family vpnv4
peer 100.1.1.2 reflect-client
peer 100.1.1.13 reflect-client
q
dis th
dis bgp peer # AR8/12出问题
int g0/0/1
dis th
mpls
mpls ldp
int g2/0/0
dis th
mpls
mpls ldp
q
dis bgp peer
dis ip rou # 可以看到100.1.1.8是直连路由，下一跳为lo 1，此现象不对
undo mpls
y
mpls lsr-id 100.1.1.7
mpls
mpls ldp
int lo 1
undo ip addr
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
int g0/0/2
mpls
mpls ldp
int g2/0/0
mpls
mpls ldp
q
dis bgp peer # AR12还不行


# AR12
dis cu conf bgp
bgp 100
dis th
undo peer 100.1.1.7 connect-interface 
peer 100.1.1.7 connect-interface lo 0
ipv4-family unicast
undo reflector cluster-id 
q
dis bgp peer

#-----------------------------------------------------
# 检查
# 此部分通过做完bgp200一起检查

#-----------------------------BGP200（和ISIS）------------------------
# AR23测试
tracert lsp -a 200.1.1.23 ip 200.1.1.4 32
tracert lsp -a 200.1.1.23 ip 200.1.1.5 32 #此时不通，说明AR9上存在问题

# AR9
dis cu | in mpls
dis ip int bri # 200.200.200.9是lo 1的地址
undo mpls
mpls lsr-id 200.1.1.9
mpls
mpls ldp
q
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
int g0/0/2
mpls
mpls ldp
dis cu conf bgp  
bgp 200
dis th
undo network 200.1.1.9 255.255.255.255
ipv6-family unicast 
dis th
peer 2002:200:1:1::4 reflect-client 
peer 2002:200:1:1::5 reflect-client 

# AR4
dis cu conf isis
dis cu conf acl-basic
acl 2000
dis th
undo rule 5
rule 5 permit source 200.1.1.9 0
q
dis cu conf bgp
bgp 200
dis th
ipv4-family unicast
dis th
undo import-route isis 2000
import-route isis 200
undo network 200.1.1.4 255.255.255.255

# AR5
dis cu conf isis
dis cu conf bgp
bgp 200
dis th
ipv4-family unicast
undo network 200.1.1.5 255.255.255.255
peer 200.1.1.9 next-hop-local
q
dis th

# AR23
dis cu conf isis
isis 100
dis th
import-route bgp
dis cu conf bgp
bgp 200
dis th
ipv4-family vpn-instance 1
undo import-route isis 200
import-route isis 100
dis cu conf route-policy 
acl 2000
dis th
rule permit source 10.1.34.0 0
rule permit source 10.1.1.1 0
q
dis bgp vpnv4 all rou  # 只能查看到10.4的路由，没有10.1的路由，此时回查AR2上有没有
dis cu | in vpn

# AR1
dis cu | in vpn
ip vpn-instance 1
# 如果可以删除现有配置，加入后面这一行：undo vpn-target 200:10
vpn-target 200:100 
dis th
q
dis bgp vpnv4 all rou

# AR4
dis mpls interface
int p 5/0/0
dis th

# AR2
dis mpls interface
int p 5/0/0
dis th
mpls
# 如果没说不能删除现有配置，还需要如下操作
# int g2/0/0
# dis th
# undo mpls ldp

# AR23测试
tracert lsp -a 200.1.1.23 ip 200.1.1.4 32
tracert lsp -a 200.1.1.23 ip 200.1.1.5 32 


#-----------------------------BGP------------------------ 
# AR2
dis cu conf bgp
dis cu cong route-policy
route-policy AS-PATH permit node 1 
apply as-path 100 100 additive   # 原题中为100 200，那么这些路由就无法传递到as200中
acl 200
dis th
rule 25 permit source 100.1.1.7 0
rule 30 permit source 100.1.225.0 0.0.0.255 # 把其中的deny全部改为permit
bgp 100
dis th  # LP是将引入的路由的本地优先级设置为200，AS-PATH是将发布出去的路由添加路径属性
ipv4-family unicast
dis th
undo  peer 200.100.24.4 route-policy LP export
peer 200.100.24.4 route-policy LP import
undo peer 200.100.25.5 route-policy AS-PATH import
peer 200.100.25.5 route-policy AS-PATH export
ipv6-family unicast
dis th
undo peer 2002:200:100:24::4 route-policy LP export
peer 2002:200:100:24::4 route-policy LP import
undo peer 2002:200:100:25::5 route-policy AS-PATH import
peer 2002:200:100:25::5 route-policy AS-PATH export

#-----------------------------------------------------
# 检查
# AR24/25
dis ip rou pro isis  # 已经有10.1.12和10.1.34的路由
# AR26
dis ip rou pro isis # 已经有10.1.12、10.1.34、10.1.1.1的路由，并且全部为两条路由
# client12
tracert 10.1.12.11 # 通
tracert 10.1.34.22 # 通
# client 1
tracert 10.4.126.12 # 通
# client 2
tracert 10.4.126.12 # 通
# AR12
ping -a 100.1.1.12 200.1.1.9 # 通
#AR9
ping -a 200.1.1.9 100.1.1.12 # 通
# IPv6 BGP
# AR9/2
dis bgp ipv6 peer # 均有到达AR4/5的邻居
# AR7
tracert ipv6 -a 2002:100:7:1::1 2002:200:9:1::1 # (lo 1地址)第2跳为AR4
# AR9
tracert ipv6 -a 2002:200:9:1::1 2002:100:7:1::1 # 第1跳为AR4
# AR4
int p 5/0/0
shutdown
# AR7
tracert ipv6 -a 2002:100:7:1::1 2002:200:9:1::1 # 第2跳为AR5
# AR9
tracert ipv6 -a 2002:200:9:1::1 2002:100:7:1::1 # 第1跳为AR5
# AR4
int p 5/0/0
undo shutdown

&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;sham-linkvrrpdhcp&#34;&gt;Sham-Link+VRRP+DHCP&lt;/h1&gt;
&lt;h2 id=&#34;要求-3&#34;&gt;要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2与Site3为同一个VPN客户的两个站点，现在AR10与AR20上面的客户（loopback0模拟）都能互通，请解决此问题；并且要求当AS100连接正常的时候，两个客户的数据包通信必须经过AS100；但是AS100出现问题的时候，两个站点可以通过备份链路进行通信&lt;/li&gt;
&lt;li&gt;Site2中AR10与AR11要为LSW4的PC4提供第一跳网关冗余服务，虚拟网关地址为10.2.129.254和10.2.129.253；在配置正确的情况下，VRRP配置后的状态信息如下： 为了加速VRRP的收敛，使用BFD跟踪上行链路状态以及VRRP的邻居关系&lt;/li&gt;
&lt;li&gt;Site2中，AR10 AR11是DHCP服务器并且相互备份。要求CLIENT7能通过DHCP服务器获取到地址10.2.129.100；要求CLIENT8只能获取指定地址为10.2.129.101；现在CLIENT8有时无法获取地址，请解决；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设备-3&#34;&gt;设备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2的AR10/11&lt;/li&gt;
&lt;li&gt;AS100的AR6/13&lt;/li&gt;
&lt;li&gt;Site3的AR20&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;建议-3&#34;&gt;建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;VRRP&lt;/li&gt;
&lt;li&gt;DHCP&lt;/li&gt;
&lt;li&gt;Sham-Link&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作-3&#34;&gt;操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#-----------------------------VRRP------------------------
# AR10
dis vrrp bri
int g0/0/0 
dis th
vrrp vrid 1 authentication-mode md5 hcie
vrrp vrid 2 authentication-mode md5 hcie
vrrp vrid 2 virtual-ip 10.2.129.253
undo vrrp vrid 2 virtual-ip 10.2.129.251
vrrp vrid 1 preempt-mode timer delay 1
q
dis bfd session all
dis cu |  in bfd  # 缺少&amp;quot;session-name 2 increased 120&amp;quot;需要在接口下配置
undo bfd 2
bfd 2 bind peer-ip 10.2.129.11 source-ip 10.2.129.10 auto
int g0/0/0
vrrp vrid 2 track bfd-session session-name 2 increased 120
dis bfd session all

# AR11
dis vrrp bri
int g0/0/0 
dis th
vrrp vrid 1 authentication-mode md5 hcie
vrrp vrid 2 authentication-mode md5 hcie
vrrp vrid 2 preempt-mode timer delay 1
vrrp vrid 2 priority 200
dis bfd session all
dis cu |  in bfd
dis bfd session all

# AR6
dis bfd session all
dis cu |  in bfd
bfd 1 bind peer-ip 10.2.128.11 vpn-instance 2 source-ip 10.2.128.6 auto
dis bfd session all

#-----------------------------------------------------
# 检查
# AR6/10/11
dis bfd session all # 两个相邻会话均建立
# AR10/11
dis vrrp # 对照配置要求进行纠错

#-----------------------------DHCP------------------------
# AR10
dis cu | i pool
ip pool HCIE
dis th  # 复制到记事本进行修改
q
undo ip pool HCIE
y
ip pool HCIE
 gateway-list 10.2.129.254 
 network 10.2.129.0 mask 255.255.255.0 
 excluded-ip-address 10.2.129.102 10.2.129.200
 static-bind ip-address 10.2.129.101 mac-address 5489-98cf-3513
 static-bind ip-address 10.2.129.100 mac-address 5489-98cf-0549 
 dns-list 8.8.8.8 
 domain-name huawei.com
q
dhcp enable
int g0/0/0
dhcp select global

# AR11
dis cu | i pool
ip pool HCIE
dis th
q
undo ip pool HCIE
y
ip pool HCIE
 gateway-list 10.2.129.253
 network 10.2.129.0 mask 255.255.255.0 
 excluded-ip-address 10.2.129.1 10.2.129.99
 static-bind ip-address 10.2.129.101 mac-address 5489-98cf-3513
 static-bind ip-address 10.2.129.100 mac-address 5489-98cf-0549 
 dns-list 8.8.8.8 
 domain-name huawei.com
q
dhcp enable
int g0/0/0
dhcp select global

# sw4
int e0/0/1
dis th  # 需要有dhcp snooping trusted
int e0/0/3
dis th # 需要有dhcp snooping trusted
int e0/0/4
dis th
port hybrid untagged vlan 1
int e0/0/5
dis th
port hybrid untagged vlan 1

#-----------------------------------------------------
# 检查
# Client7/8
基础配置--IPv4--DHCP--应用
命令行--ipconfig  # 7的地址为10.2.129.100，8的地址为10.2.129.101


#-----------------------------Sham-Link------------------------
# Sham-Link配置在AS100中的AR6/13(ASBR)
# AR6
int lo 2
dis th
ip binding vpn-instance 2
ip address 100.1.136.6 255.255.255.255
dis cu conf ospf
ospf 110
dis th
a 0
undo sham-link 100.1.136.6 100.1.136.13
a 1
sham-link 100.1.136.6 100.1.136.13
q
q
dis cu conf bgp 
bgp 100
ipv4-family vpn-instance 2 
network 100.1.136.6 255.255.255.255
dis mpls ldp int

int s3/0/0
dis th
dis ospf peer bri #110上g口2个邻居


# AR13
int lo 2
dis th
dis cu conf ospf
ospf 110
dis th
import bgp
a 1
undo network 100.1.136.13 0.0.0.0
undo sham-link 100.1.136.13 100.1.136.100
sham-link 100.1.136.13 100.1.136.6
q
q
dis cu conf bgp 
bgp 100
ipv4-family vpn-instance 2 
undo network 100.1.136.0 255.255.255.0
network 100.1.136.13 255.255.255.255
import-route ospf 110
dis mpls ldp int # g2/0/1未开启ldp
int g2/0/1
mpls ldp

# AR10
int s3/0/0
dis th
ospf network-type broadcast
dis ospf peer bri #110上s口两个邻居，g口1个

# AR11
int s3/0/0
dis th
fr map ip 10.2.128.10 110 broadcast
undo ip addr
ip address 10.2.128.11 255.255.255.0
dis ospf peer bri  # 110上s口两个邻居，g口1个
int s3/0/1
dis th
aaa
dis th
local-user hcie password cipher hcie
int s3/0/1
dis th
dis ip int bri #  s3/0/1UP

# AR20
int s3/0/0
dis th
ppp chap password cipher hcie
ospf cost 100
dis ip int bri #  s3/0/0UP

#-----------------------------------------------------
# 检查
# 测试lo 0是否通
# AR10
tracert -a 10.2.1.10 10.3.1.20 #7跳，通
# AR20
tracert -a 10.3.1.20 10.2.1.10 #7跳，通
# 测试备份链路
# AR6
int s3/0/0
shutdown
# AR10
tracert -a 10.2.1.10 10.3.1.20 #2跳，通
# AR20
tracert -a 10.3.1.20 10.2.1.10 # 2跳，通
# 恢复后链路
# AR6
int s3/0/0
un shutdown
# AR10
tracert -a 10.2.1.10 10.3.1.20 #7跳，通
# AR20
tracert -a 10.3.1.20 10.2.1.10 # 7跳，通
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;telnetipv6qos&#34;&gt;Telnet+IPv6+QoS&lt;/h1&gt;
&lt;h2 id=&#34;要求-4&#34;&gt;要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site3中，AR16 AR17 AR18帧中继网络中运行ospf，使用默认的网络类型；要求AR18能通过telnet远程管理AR16、AR17；现在AR18无法远程管理；解决此问题已满足以下表项；要求AR16的telnet认证方式为AAA，AR16上存在两个用户，admin用户级别为15级，guest用户级别为1级，要求两个用户都能认证telnet登录；要求AR17的认证方法为password；所有telnet到AR17的用户级别无需求，但是能支持命令要求截图一致。&lt;/li&gt;
&lt;li&gt;Site2与Site3配置了IPV6，并且运行OSPFV3协议；参与的设备有AR10、AR11、AR18、AR20；AR18与AR20之间通过tunnel相通；现在环境中的IPV6 CLIENT 13、IPV6 CLIENT 9 、IPV6 CLIENT16无法实现互相通信，请解决&lt;/li&gt;
&lt;li&gt;Site3中AR20上一个用户（ loopback0模拟）和AR18的一个用户（loopback0模拟）要进行语音通信，使用的音频编码G.711，每路语音需要64Kbps的带宽，目前从AR20到AR18的语音质量不够好，需要在AR19上部署QOS；以保证语音流量的服务质量（反向流量不要求）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设备-4&#34;&gt;设备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site2的AR10/11&lt;/li&gt;
&lt;li&gt;site3的AR16/17/18/19/20&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;建议-4&#34;&gt;建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Telnet&lt;/li&gt;
&lt;li&gt;IPv6&lt;/li&gt;
&lt;li&gt;Qos&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作-4&#34;&gt;操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#-----------------------------Telnet------------------------
# AR16（SPOKE）
int s3/0/0
dis th
ospf dr-priority 0
undo ospf timer hello
ospf network-type broadcast
fr map ip 10.3.129.17 608 broadcast
ping 10.3.129.17
ping 10.3.129.18
aaa 
dis th
local-user admin password cipher hcie
local-user admin privilege level 15
local-user admin service-type telnet
local-user guest password cipher hcie
q
user-interface vty 0 4
dis th
authentication-mode aaa

# AR17（SPOKE）
int s3/0/0
dis th
ospf dr-priority 0
ping 10.3.129.16
ping 10.3.129.18
user-interface vty 0 4
dis th
user privilege level 0
set authentication password cipher hcie

# AR18（HUB）
int s3/0/0
dis th
undo fr inarp
ospf dr-priority 100
ospf network-type broadcast
fr map ip 10.3.129.17 807 broadcast
ping 10.3.129.16
ping 10.3.129.17

#-----------------------------------------------------
# 检查
# AR18（输入密码后的界面，不需要sys）
telnet 10.3.1.16
admin
hcie
sys
q
q
telnet 10.3.1.16
guest
hcie
sys  # 报错才对
dis local-user
q
telnet 10.3.1.17
hcie
sys   # 报错才对
q

#-----------------------------IPv6------------------------
# AR10
dis cu conf ospfv3

# AR11
dis cu conf ospfv3
a 1
undo abr-summary 2002:10:2:131::13 128
abr-summary 2002:10:2:131::13 128

# AR18
dis cu conf ospfv3
ospfv3 1
dis th
undo silent-interface Tunnel0/0/100
int tun 0/0/100
dis th
undo ipv6 address 2002:100:101::18/64
ipv6 address 2002:100:100::18/64
undo ospfv3 1 area 0.0.0.1
ospfv3 1 area 0.0.0.0
tunnel-protocol gre # 下面4行配置直接复制AR20的最后4行，然后修改一下目的地址为20
source LoopBack0
destination 10.3.1.20
gre key 123

# AR20
dis cu conf ospfv3
ospfv3 1
dis th
undo silent-interface Tunnel0/0/100
a 1
undo abr-summary 2002:10:3:18::18 128
abr-summary 2002:10:3:18::18 128
int tun 0/0/100
dis th
undo ipv6 address FE80::18 link-local
ipv6 address FE80::20 link-local
undo ospfv3 1 area 0.0.0.1
ospfv3 1 area 0.0.0.0

#-----------------------------------------------------
# 检查
# AR18/20/10/11
dis ospfv3 peer # AR18/20在a0中为邻居；AR20\11\10在a1中为邻居
# client13，将其网关改成AR10的g0/0/1的地址
ping 2002:10:3:18::16
ping 2002:10:3:209::9  # 全通
# client 9，将其网关改成AR20的g0/0/1的地址
ping 2002:10:3:18::16
ping 2002:10:2:131::13 # 全通
# client 16，将其网关改成AR18的g0/0/0的地址，同时将IPv6地址最后一位改为16
ping 2002:10:3:209::9
ping 2002:10:2:131::13 # 全通


#-----------------------------Qos------------------------
# AR19
dis cu  # 然后将配置复制到记事本进行查看修改
acl name UDP 3999  
undo rule 5
rule 1 permit udp source 10.3.1.20 0 destination 10.3.1.18 0 destination-port range 16384 32767

traffic behavior cbq
dis th
undo queue llq 
queue llq bandwidth 64

traffic behavior remark
dis th
undo remark dscp
remark dscp ef

traffic policy cbq
dis th
undo classifier match-ef
classifier match-udp behavior cbq

traffic policy remark-ef
dis th
undo classifier match-udp
classifier match-ef behavior remark

int g0/0/0  # AR20到AR18，反向流量无需求，则g0/0/0为入方向，s3/0/0为出方向
dis th
undo traffic-policy outbound
traffic-policy remark-ef inbound 

int s3/0/0
dis th
undo traffic-policy inbound  
traffic-policy cbq outbound

#-----------------------------------------------------
# 检查
# 此题只能检查配置，即流量方向、规则等
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;natmsdp&#34;&gt;NAT+msdp&lt;/h1&gt;
&lt;h2 id=&#34;要求-5&#34;&gt;要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site5中通过安全接入AS，client11现在无法通过网关AR27访问到公网AS100、AS200&lt;/li&gt;
&lt;li&gt;AS100与AS200要部署域间组播；AR7是AS100中的RP，AR9是AS200中的RP；AS100中AR22上有一台视频服务器，AS200中AR23上有一个组播接收者要加入组239.1.1.1，现在客户无法收到组播数据，无法观看相应的视频；请解决该问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设备-5&#34;&gt;设备&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AS100的AR22/7&lt;/li&gt;
&lt;li&gt;AS200的AR9&lt;/li&gt;
&lt;li&gt;site5的AR27&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;建议-5&#34;&gt;建议&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;NAT&lt;/li&gt;
&lt;li&gt;msdp&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;操作-5&#34;&gt;操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#-----------------------------NAT------------------------
# AR27
int s3/0/0
dis th
ppp chap password cipher hcie
q
dis cu | i  route
undo ip route-static 0.0.0.0 0.0.0.0 GigabitEthernet0/0/0
ip route-static 0.0.0.0 0.0.0.0 s3/0/0
dis cu conf acl # 规则号为2000
dis cu conf nat  # 在接口下调用地址组，组号为1
nat outbound 2000 address-group 1
q
dis nat out # 有一条s3/0/0

# AR9
int s3/0/0
dis th
isis enable 200
ppp authentication-mode chap
aaa
dis th
local-user hcie password cipher hcie
local-user hcie service-type ppp

#-----------------------------------------------------
# 检查
ping 200.1.1.23/9/4/5
ping 100.1.1.1/2/3/6/7/8/13/21/22/12  # 1/3/6/13不通，与AR2上的acl 2000规则有关

#-----------------------------msdp------------------------
# AR22
int g0/0/1
dis th
undo igmp enable
undo igmp static-group 239.1.1.1
pim sm
int g0/0/0
dis th
dis ospf int  #已经宣告进，且为DR

# AR7
dis cu conf pim
pim 
dis th
c-bsr lo 0
dis pim neighbor # 缺少邻居AR2
int g0/0/2
dis th
pim sm
q
dis pim neighbor # 4个邻居齐了
dis pim rp # RP为100.1.1.7
dis cu conf msdp
msdp
peer 200.1.1.9 password cipher hcie
dis msdp bri  # 200.1.1.9已经UP

# AR9（AS200采用静态的方式指定RP）
dis cu conf pim
pim 
dis th
static-rp 200.1.1.9
dis cu conf msdp
msdp
dis th
peer 100.1.1.7 connect-interface LoopBack0
peer 100.1.1.7 password cipher hcie
dis msdp bri  # 100.1.1.7已经UP

# AR4
dis cu conf pim
pim 
dis th
static-rp 200.1.1.9
dis pim nei # 缺少AR2
int p 5/0/0
dis th
pim sm
dis pim nei # AR2的pos口配置pim sm之后邻居齐全

# AR5
dis cu conf pim

# AR23
dis cu conf pim
pim 
dis th
static-rp 200.1.1.9
dis pim nei
int g0/0/1
dis th
undo igmp static-group 239.1.1.1
pim sm
igmp enable

# AR2
int p 5/0/0
dis th
pim sm
dis pim nei # AR4的pos口配置pim sm之后邻居齐全
dis cu conf acl-basic 
acl 2000
dis th
rule 30 permit source 100.1.225.0 0.0.0.255


#-----------------------------------------------------
# 检查
# Client6：组播---加入
# AR22：ping multicast 239.1.1.1
# AR9
dis msdp sa-cache 出现 (100.1.225.254, 239.1.1.1)
# AR23/9/4/2/7/21/22
dis pim routing-table #都出现 (100.1.225.254, 239.1.1.1)
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TS_PlanB错点整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-shi-yan-fu-xi-ji-hua-2-ge-yue/"" data-c="
          &lt;h1 id=&#34;ts排错planb&#34;&gt;TS排错&lt;sup&gt;PlanB&lt;/sup&gt;&lt;/h1&gt;
&lt;h2 id=&#34;mstpsite1的sw123&#34;&gt;MSTP&lt;sub&gt;site1的sw1/2/3&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site1中，CLIENT1属于VLAN12，CLIENT2属于VLAN34&lt;/li&gt;
&lt;li&gt;MSTP中的VLAN12属于instance1，vlan34属于instance2&lt;/li&gt;
&lt;li&gt;两个instance的主备根桥分别在SW1和SW2上&lt;/li&gt;
&lt;li&gt;并且要求CLIENT1访问R1时经过的路径是SW3-SW1-R1，CLIENT2访问R1时经过的路径是SW3-SW2-R1&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 全局配置
sys
dis th
# sw1的stp是关闭的，需要将其打开
stp en
# sw1的stp是实例1/2的备份根，需要将其修改为实例1的主根
stp ins 1 root pri
# sw3的生成树模式为stp，需要将其修改为mstp
stp mode mstp

# stp配置详情
dis current-configuration configuration mst-region
# sw3的实例与vlan对应错误，可以使用sw1的配置重新刷一遍
stp region-configuration
region-name HCIE
instance 1 vlan 12
instance 2 vlan 34
active region-configuration

# sw3上stp实例查看
dis stp instance 1 brief
dis stp instance 2 brief

# 此时结果不对，需要去做Eth-Trunk

# 在sw3上查看stp实例的配置
dis stp instance 1 brief
dis stp instance 2 brief  # st根桥等仍然不对，需要查看接口配置
dis cu int eth 0/0/21
dis cu int eth 0/0/22 # 在sw3上由于不能删除配置，则需要将cost值改为相反的值
int eth 0/0/21
undo stp instance 1 cost
stp instance 2 cost 3000000
int eth 0/0/22
undo stp instance 2 cost
stp instance 1 cost 8000000
# 或者
# int eth 0/0/21
# stp instance 1 cost 8000000
# int eth 0/0/22
# stp instance 2 cost 3000000

# 在sw3查看下联接口属于相应的vlan
dis cu int e0/0/1  # 属于vlan12，没有问题
dis cu int e0/0/2  # 此接口vlan错误，并且需要删除配置的stp的cost值
int e0/0/2
port default vlan 34
undo stp ins 2 cost
# 再次查看stp实例配置
dis stp instance 1 brief
dis stp instance 2 brief 

# 在client1和client上查看路由情况
tracert 10.1.1.1  # 只能发现第一条对了，但是无法到达目的地址

# 此时结果不对，需要去做BGP ADV

# 在client1和client2上查看路由情况
tracert 10.1.1.1 # client1（10.1.12.1--10.1.1.1）；client2（10.1.34.1--10.1.1.1）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;eth-trunksite1的sw12&#34;&gt;Eth-Trunk&lt;sub&gt;site1的sw1/2&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site1中，LSW1-LSW2之间的所有链路要求做eth-trunk的捆绑，并且此eth-trunk要求做src-dst-ip负载&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看eth-trunk的配置详情
dis eth-trunk 12
# sw1的负载均衡模式不对，需要修改为src-dst-ip负载
int Eth-Trunk 12
load-balance src-dst-ip 
# sw2的工作模式和物理端口均不对，需要工作模式修改为lacp-static、负载模式为src-dst-ip、端口修改为e0/0/18~20
int Eth-Trunk 12
undo trunkport e0/0/18
undo trunkport e0/0/20
undo trunkport e0/0/21
mode lacp-static
load-balance src-dst-ip 
trunkport e0/0/18
trunkport e0/0/20
int e0/0/19 # 在加入e0/0/19的时候无法加入，是因为这个端口有配置
port hybrid vlan 1    # 或者在配置视图下执行clear conf int Ethernet0/0/19，然后把该接口undo shutdown
eth-trunk 12  # 或者在Eth-Trunk 12配置视图下进行添加

# 查看eth-trunk当前配置【无错误】
dis current-configuration int eth-t 12 

# 查看sw1上与sw3相连的接口配置
dis current-configuration interface Ethernet0/0/21  # 不允许vlan12通过
# 需要放行所有
int e0/0/21
port trunk allow vlan all

# 查看sw2上与sw3相连的接口配置
dis current-configuration interface Ethernet0/0/22 # 不允许vlan34通过
# 需要放行所有
int e0/0/22
port trunk allow vlan all

# 返回实验MSTP ，然后在sw3上查看stp实例
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;bgp-advas100的ar1负载均衡涉及site1的sw12&#34;&gt;BGP ADV&lt;sub&gt;AS100的AR1，负载均衡涉及site1的sw1/2&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;R1访问VLAN12时经过的路径是R1-LSW1-LSW3，访问VLAN34时经过的路径是R1-LSW2-LSW3&lt;/li&gt;
&lt;li&gt;只允许在AS300中实现，并且确保你的解决方案不要影响AS100、AS300以外的其他AS&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看当前bgp配置
dis cu conf bgp

# AR1上的vpn实例1中的邻居10.1.100.100的as号为300
bgp 100
ipv4-family vpn-instance 1
undo peer 10.1.100.100
peer 10.1.100.100 as-number 300

# 查看下联接口配置
dis cu int g2/0/1
dis cu int g2/0/2
# g2/0/1绑定的是vpn实例2，g2/0/2绑定的是vpn实例3，均需要修改为实例1
int g2/0/1
ip binding vpn-instance 1
ip address 10.1.100.1 255.255.255.0 
int g2/0/2
ip binding vpn-instance 1
ip address 10.1.200.1 255.255.255.0 

# 查看vpn实例1的邻居状况
dis bgp vpnv4 vpn-ins 1 peer # 两个邻居都Established

# 查看路由情况
dis bgp vpnv4 vpn-ins 1 rou
# 此时能够查看到10.1.12.0/24的路由只有1条路径，10.1.34.0/24的路由有2条路径。需要对10.1.12.0/24进行负载均衡，即此条路由也需要有两条路径

# sw1
dis cu con bgp
bgp 300
dis th  
# network 10.1.23.0 255.255.255.0这条配置多余，需要删除
ipv4-family unicast
undo network 10.1.23.0 255.255.255.0
# 路由10.1.12.0宣告时添加了策略，如果要进行负载，则需要删除这些路由策略
undo network 10.1.12.0 255.255.255.0
network 10.1.12.0 255.255.255.0
# 此时在AR1上查看路由
# 如果还是原来的模样，可能是路由未收敛完毕，不用管，继续去查看sw2的配置
# sw2
dis cu con bgp
bgp 300
dis th  
# 此进程下少宣告了10.1.12.0，同时需要去掉关于MED值的策略
ipv4-family unicast
network 10.1.12.0 255.255.255.0 route-policy MED
undo network 10.1.34.0 255.255.255.0
network 10.1.34.0 255.255.255.0
# 此时在AR1上查看路由
# 10.1.12.0（10.1.100.100的MED为0）和10.1.34.0（10.1.200.200的MED为0）均出现两条路由的负载

# 返回实验MSTP，在client1/2上执行tracert 10.1.1.1
# 此时从Client到AR的路由没有问题了，需要查看AR到Client的路由
# AR1
tracert -vpn-instance 1 10.1.12.11  # （10.1.100.100--10.1.12.11）
tracert -vpn-instance 1 10.1.34.22  # （10.1.200.200--10.1.34.22）

# 此时路由正确，MSTP、Eth-Trunk、BGP ADV这3题已经做完
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mux-vlansite4的sw8ar262524&#34;&gt;Mux-Vlan&lt;sub&gt;site4的sw8，AR26/25/24&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site4中，AR24、AR25、AR26在一个网段中，同时都运行了ISIS协议，要求AR26能和AR24、AR25都能形成邻居关系，但是AR24与AR25不能形成邻居关系&lt;code&gt;在AR24和AR25上虽然能看到彼此的邻居关系，但是不是在R26-SW8-R24-R25这一网段上成为邻居关系，而是在R24-R25-SW7这一网段上成为邻居，符合题目要求&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过LSW8的二层VLAN技术以及其他设备排除错误点来实现此要求。 【注意】配置过程中不能在LSW8上删除和增加新的VLAN&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在sw8上查看mux-vlan情况
dis mux-vlan
# 在sw8上，需要在e0/0/3上配置主vlan（vlan 100，principal），e/0/0/1和e/0/0/2配置隔离型从vlan（vlan 50，separate）
# 目前，只有e0/0/2是隔离型mux-vlan，不符合要求
# 继续查看上联接口e/0/0/1和e/0/0/2的配置
dis cu int e0/0/1
dis cu int e0/0/2
dis cu int e0/0/3
# 恢复上述接口原始状态
int e0/0/1
undo port mux-vlan enable
port default vlan 1
int e0/0/2
undo port mux-vlan enable
port default vlan 1
# 配置主vlan
vlan 100
dis th
undo subordinate separate
undo subordinate group 50
subordinate separate 50
# 配置端口
q
port-group group-member e0/0/1 e0/0/2
port link access
port default vlan 50
port mux-vlan enable
q
# 查看sw8上的mux-vlan配置
dis mux-vlan # 此时已经符合要求

# 在AR26上进行测试
dis cu int g0/0/0
ping 10.4.129.25
ping 10.4.129.24  # ping AR24和AR25均能通
# 在AR24上进行测试
ping 10.4.129.26  # 通
ping 10.4.129.25  # 不通
# 在AR25上进行测试
ping 10.4.129.26  # 通
ping 10.4.129.24  # 不通
# 出现以上现象，说明mux-vlan实验已经完成
# 但是ISIS还是有问题，下面进行ISIS排错

# AR26/25/24
dis cu conf isis
# 可以查看到AR25配置了域认证，其他两台均没有配置，删除AR25的认证
# 在AR25上执行
isis 100
undo domain-authentication-mode
dis isis peer # 此时并未查看到g0/0/0接口上的邻居
# 查看3台路由器的g0/0/0的接口配置
dis cu int g0/0/0 # 这3台接口配置的接口认证均不一样，需要进行统一，刷一下配置
int g0/0/0
isis authentication-mode md5 cipher hcie
# 查看邻居状态
dis isis peer  #AR24和AR26未建立邻居
# AR26
int g0/0/0
dis th  # 此接口下配置了mtu，需要删除
undo mtu 
# 查看邻居状态和路由情况
dis isis peer  #AR24/25/26相互建立邻居
dis ip rou pro isis  # 但是在AR26上去往AR23（10.4.128.0/24）的两条路由并不是负载的
# 因为AR26是hub，AR25/26为两个spoke，则需要修改AR26的优先级，保证其为DIS
# （如果已经选择AR26为DIS，可能看到已经负载，但是下面这一步必须做，以防万一）
# AR26
int g0/0/0
isis dis-pri  127  # 这一步是为下一个实验MPLS-VPN做准备
# 查看路由情况
dis ip rou pro isis # 已经实现去往10.4.128.23/24的两条路由的负载
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;mpls-vpn和ospfas100的ar12367813-as200的ar23945-site4的ar262425&#34;&gt;MPLS-VPN（和OSPF）&lt;sub&gt;AS100的AR1/2/3/6/7/8/13、AS200的AR23/9/4/5、site4的AR26/24/25&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site1与Site4为同一个VPN客户的两个站点，现在site1里的CLIENT无法和site4里的CLIENT通信，解决此问题。【注意】不要删除现有配置，可修改解决&lt;/li&gt;
&lt;li&gt;【OSPF】AS100中所有设备都运行了OSPF，但是部分设备的邻居关系有问题，解决此问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看ospf配置情况
dis cu conf ospf
# AR1上的策略查看
dis cu | in ip-pre  # 不应该deny掉100.1.1.2 32
undo ip ip-prefix 2
ip ip-prefix 2 permit 100.1.1.2 32  # 允许来自AR2的路由
ip ip-prefix 2 permit 0.0.0.0 0 less-equal 32  # 允许所有
dis cu | in ip-pre
dis ospf peer bri  # 查看邻居情况，只有AR2一个邻居，继续排查ospf
dis cu conf ospf # 100.1.16.1应该宣告在区域0中
ospf 100
dis th
a 1
undo network 100.1.16.1 0.0.0.0
a 0 
network 100.1.16.1 0.0.0.0
q
dis th
dis ospf peer bri # 此时AR1和AR6、AR2均建立邻居
# AR2
dis cu conf ospf  # 正常
# AR3
dis cu conf ospf  # 正常
# AR6
dis cu conf ospf # 正常
# AR7
dis cu conf ospf # router-id错误，应该为100.1.1.7；区域0有认证，需要去掉
ospf 100 router-id 100.1.1.7
return
reset ospf pr
y
ospf 100
a 0
undo authentication-mode  
dis ospf peer bri # 此时AR7和AR2\6\21均建立邻居，但是和AR8还没有建立邻居，接下来查看对应接口
dis cu int g0/0/1  # 此接口下配置了ospf的hello和dead时间，查看AR8下面是否配置
# AR8
dis cu int g0/0/1  # 此接口下没有配置ospf的hello和dead时间，需要删除AR7相应配置
# AR7
int g0/0/1
ospf timer hello 10  # 修改hello时间为默认，则dead时间也会相应的修改，也可以undo掉
# 查看接口是否宣告
dis ospf int  # 可以看到100.1.78.7已经宣告，再去AR8上查看
# AR8
dis ospf int # 100.1.78.8没有宣告，需要进行宣告
ospf 100
a 0
network 100.1.78.8 0.0.0.0
dis ospf peer bri   # 此时AR8和AR3\7\13均建立邻居，去AR7上确认
# AR7
dis ospf peer bri  # 此时AR7和AR2\8\6\21均建立邻居
# AR3
dis ospf peer bri # 和AR8\13建立邻居，但是缺少AR2
dis cu int g0/0/1 # 此接口下配置了dead时间，去AR2相应接口下查看
# AR2
dis cu int g0/0/1  # 此接口下未配置dead时间，需要去掉AR3上的dead时间
# AR3
int g0/0/0
undo ospf timer dead  # 此步误操作
int g0/0/1
undo ospf timer dead
dis ospf peer bri # 正常和AR2\8\13建立邻居
# 此时AR1\2\3\13\6\7\8之间均已建立ospf邻居关系，AR7是中心，也是路由反射器

# 查看AR7上的bgp邻居情况
dis bgp peer  # 可以查看到R8（Idle）未能Established
ping -a 100.1.1.7 100.1.1.8  # 通
# AR8
ping -a 100.1.1.8 100.1.1.7 # 不通
# AR7/8 
dis ospf int  # 邻居正常
# AR7上查看路由表
dis ip rou # 可以看到100.1.1.8是直连路由，下一跳为lo 1，此现象不对
int lo 1
dis th
undo ip address 100.1.1.8 255.255.255.255 # 此地址开启LSR，无法去掉，需要关掉mpls
q
dis cu | in mpls
undo mpls
y
mpls lsr-id 100.1.1.7
mpls
mpls ldp
int lo 1
undo ip addr
dis bgp peer # 查看100.1.1.8邻居情况
# 接下来配置mpls
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
int g0/0/2
mpls
mpls ldp
q
dis bgp vpnv4 all peer # 此时有AR1/2/6/13的邻居
bgp 100
dis th # 可以查看到只有AR1\6配置了反射客户端，AR2\13需要相应的配置
ipv4-family vpnv4
peer 100.1.1.2 reflect-client
peer 100.1.1.13 reflect-client

# AR23
tracert lsp -a 200.1.1.23 ip 200.1.1.4 32
tracert lsp -a 200.1.1.23 ip 200.1.1.5 32 #此时不通，说明AR9上存在问题
# AR9
dis cu | in mpls  # mpls的lsr-id为200.200.200.9
dis ip int bri # 是lo 1的地址
undo mpls
mpls lsr-id 200.1.1.9
mpls
mpls ldp
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
int g0/0/2
mpls
mpls ldp # 再去AR23上tracert
# AR23
tracert lsp -a 200.1.1.23 ip 200.1.1.4 32 # 不通
tracert lsp -a 200.1.1.23 ip 200.1.1.5 32 # 通
# 排查AR4
dis cu con isis # 正常，但是可以看到引用了一条过滤器
dis cu conf acl-basic  #  可以看到将来自200.1.1.9的数据deny了，需要去掉这条规则
acl 2000
undo rule 5
rule 5 permit source 200.1.1.9 0
dis th # 再去AR23测试
# AR23
tracert lsp -a 200.1.1.23 ip 200.1.1.4 32 # 通

# AR4/5/9
dis cu con bgp
# AR4上bgp引入isis的路由是，进程号写的2000，应该为200
bgp 200
ipv4-fa uni
undo import-route isis 2000
import-route isis 200  # 因为引入isis路由了，宣告200.1.1.4则是多余的
undo network 200.1.1.4 255.255.255.255
# AR5
bgp 200
ipv4-fa uni
undo network 200.1.1.5 255.255.255.255
ipv4-fa vpnv4
peer 200.1.1.9 next-hop-local  # AR4和AR5均为边界设备，所有到达AR9均需要设置下一跳自我
# AR9
bgp 200
ipv4-fa uni
undo network 200.1.1.9 255.255.255.255
dis bgp rou # 此时可以看到去往100.1.1.2/8/4/5/23等（所有的路由）的路由均有两条
# AR23作为边界，需要查看是否路由双向重发布
dis cu conf isis # isis100没有引入bgp
isis 100
import-route bgp
dis cu conf bgp
bgp 200
ipv4-f vpn-i 1
undo import-route isis 200
import-route isis 100
dis cu conf route-policy  # 查看规则索引
dis cu conf acl  # 可以看到只通过10.1.12.0，还需要允许10.1.34.0
acl 2000
rule permit source 10.1.34.0 0
rule permit source 10.1.1.1 0  # AR1上的lo1，这个也绑定了vpn实例1
dis bgp vpnv4 all rou  # 只能查看到10.4的路由，没有10.1的路由，此时回查AR2上有没有
# AR2
dis bgp vpnv4 all rou # AR2上路由是全的，查看AR9
# AR9
dis bgp vpnv4 all rou  # AR9上路由是全的，最后确认问题还是在AR23上
# AR23
dis cu | in vpn  # 可以查看到vpn实例1中的vpn-target均为200:100【dis cu conf vpn-instance】
# 然后查看AR1
ip vpn 1
dis th  # 导出为200:10，导入为200:10，所以需要添加200:100的配置
vpn-target 200:100 
# AR1
dis bgp vpnv4 all rou # AR1上已经有10.1.12和10.1.34的路由
# AR23
dis bgp vpnv4 all rou # AR23上已经有10.1.12和10.1.34的路由
# AR26
dis ip rou pro isis # AR26上仍然没有10.1.12和10.1.34的路由，主要原因是AR2上的pos口没有宣告mpls，但是AR4上已经宣告了
# AR4
dis mpls int
dis cu p 5/0/0
# AR2
dis mpls interface
dis cu p 5/0/0
int p 5/0/0/
mpls
# AR24
dis ip rou pro isis  # 已经有10.1.12和10.1.34的路由
# AR26
dis ip rou pro isis  # 已经有10.1.12、10.1.34、10.1.1.1的路由，并且全部为负载（两条路由）【如果此处不对，需要在AR23上执行isis 100；isis dis-pri 127】
# client12
tracert 10.1.12.11 # 通
tracert 10.1.34.22 # 通
# client 1
tracert 10.4.126.12 # 通
# client 2
tracert 10.4.126.12 # 通
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;sham-linksite2的ar1011as100的ar613site3的ar20&#34;&gt;Sham-link&lt;sub&gt;Site2的AR10/11，AS100的AR6/13，Site3的AR20&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2与Site3为同一个VPN客户的两个站点，现在AR10与AR20上面的客户（loopback0模拟）都能互通，请解决此问题；&lt;/li&gt;
&lt;li&gt;并且要求当AS100连接正常的时候，两个客户的数据包通信必须经过AS100；&lt;/li&gt;
&lt;li&gt;但是AS100出现问题的时候，两个站点可以通过备份链路进行通信&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看AR13/6的lo2地址
# AR6
dis cu int lo 2  # 地址配置错
int lo 2
ip binding vpn-instance 2
ip address 100.1.136.6 255.255.255.255
# AR13
dis cu int lo 2  # 正常
# AR13/6
dis cu conf ospf  # 可以AR13看到sham-link在进程110下的区域1中，但是AR6却宣告在区域0中，需要修改；AR13的区域1中宣告了100.1.136.13且sham-link的目的地址为100.1.136.6，这个需要删除（引起网络震荡）
# AR6
ospf 110
a 0
undo sham-link 100.1.136.6 100.1.136.13
a 1
sham-link 100.1.136.6 100.1.136.13 # lo 2的地址
dis ospf sham-link  # 状态仍然为Down
# AR13
ospf 110
a 1
undo network 100.1.136.13 0.0.0.0
undo sham-link 100.1.136.13 100.1.136.100
sham-link 100.1.136.13 100.1.136.6
dis ospf sham-link  # 状态仍然为Down

# AR6的bgp配置
dis cu conf bgp  # 没错，已经将100.1.136.6/32宣告，如果配置中没有宣告则需要宣告
bgp 100
ipv4-family vpn 2
network 100.1.136.6 255.255.255.255
# AR13
dis cu conf bgp  # 地址没错，掩码错了
bgp 100
ipv4-family vpn 2
undo network 100.1.136.0 255.255.255.0
network 100.1.136.13 255.255.255.255
dis cu int g2/0/1 # 此接口的ldp没有开启
int g2/0/1
mpls ldp   
dis mpls ldp int  # 可以查看到开启ldp的有2/0/0和2/0/1
dis ospf sham-link  # 已经成功up，获取到NeighborID
# AR6
dis ospf sham-link  # 已经成功up，获取到NeighborID

# 下面需要在AR6/13上做路由双向引入
# AR6
dis cu conf bgp # 实例2已经引入ospf110的路由
dis cu conf ospf # ospf110已经引入BGP路由
# AR13 
dis cu conf bgp  #  实例2没有引入ospf路由
bgp 100
ipv4-family vpn-instance 2 
import-route ospf 110
dis cu conf ospf  # ospf110没有引入路由
ospf 110
import-route bgp

# 查看AR6/10/11的串口配置
dis cu int s3/0/0 # AR10缺少ospf network-type broadcast；AR11的地址掩码为16位，其他为24为，fr map没有加broadcast
# AR10
int s3/0/0
ospf network-type broadcast
# AR11
int s3/0/0
undo ip address 10.2.128.11 255.255.0.0
ip address 10.2.128.11 255.255.255.0
fr map ip 10.2.128.10 110 broadcast

# 查看AR6/10/11的ospf邻居
dis ospf peer bri # 3个路由器在S3/0/0上均有其他两个ospf邻居（AR10有3个邻居，其中一个为g0/0/0的）

# 在AR10和AR20上查看邻居情况
dis ip rou pro ospf #AR10上已经有10.3的路由，下一跳为AR6的10.2.128.6；AR20上已经有10.2的路由，下一跳为AR19上10.3.192.19

# 查看AR11/20备份链路
dis ip int bri # AR11的s3/0/1和AR20的s3/0/0接口协议上是down状态
# AR11
dis cu int s3/0/1
#AR20
dis cu int s3/0/0 # 可以看到这两个接口ppp的chap认证方式不一样，且此接口没有配置cost值
# AR11
aaa
dis th
local-user hcie password cipher hcie
dis ip int bri # s3/0/1接口UP
dis ospf peer bri  #有4个邻居
# AR20
int s3/0/0
ppp chap password cipher hcie
ospf cost 100
dis ip int bri # s3/0/0接口UP

# 测试lo 0是否通
# AR10
tracert -a 10.2.1.10 10.3.1.20 #7跳，通
# AR20
tracert -a 10.3.1.20 10.2.1.10 # 7跳，通
# 测试备份链路
# AR6
int s3/0/0
shutdown
# AR10
tracert -a 10.2.1.10 10.3.1.20 #2跳，通
# AR20
tracert -a 10.3.1.20 10.2.1.10 # 2跳，通
# AR6
int s3/0/0
un shutdown
# AR10
tracert -a 10.2.1.10 10.3.1.20 #7跳，通
# AR20
tracert -a 10.3.1.20 10.2.1.10 # 7跳，通
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;vrrpsite2的ar1011&#34;&gt;VRRP&lt;sub&gt;Site2的AR10/11&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2中AR10与AR11要为LSW4的PC4提供第一跳网关冗余服务，虚拟网关地址为10.2.129.254和10.2.129.253；&lt;/li&gt;
&lt;li&gt;在配置正确的情况下，VRRP配置后的状态信息如下：  为了加速VRRP的收敛，使用BFD跟踪上行链路状态以及VRRP的邻居关系&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看AR10/11接口g0/0/0的配置
int g0/0/0
dis th  
# AR11上没有配置vrrp1的验证，同时也把vrrp2的验证改一下
# AR11/10
vrrp vrid 1 authentication-mode md5 hcie  
vrrp vrid 2 authentication-mode md5 hcie  
# AR10的vrrp2虚拟IP不对
vrrp vrid 2 virtual-ip 10.2.129.253
undo vrrp vrid 2 virtual-ip 10.2.129.251
# 继续查看配置
dis vrrp
# AR10的delay time需要配置，vrrp2缺少increased 120
vrrp vrid 1 preempt-mode timer delay 1
vrrp vrid 2 track bfd-session session-name 2 increased 120
# AR11的delay time需要配置，AR11的优先级不对
vrrp vrid 2 preempt-mode timer delay 1
vrrp vrid 2 priority 200
# 此时，AR10上的vrrp1和AR11上的vrrp2有5行配置；AR10上的vrrp2和AR11上的vrrp1有4行配置

# 查看AR10/11/6上的BFD
dis bfd se al # AR10/6上1个up,AR11上两个down
dis cu | i bfd
# AR10和AR6之间没问题；AR10和AR11之间，AR10的bfd中peer-ip配置错误；AR6与AR11之间，AR6缺少邻居AR11的配置
# AR10
undo bfd 2
bfd 2 bind peer-ip 10.2.129.11 source-ip 10.2.129.10 auto
commit
# AR6
bfd 1 bind peer-ip 10.2.128.11 vpn-instance 2 source-ip 10.2.128.6 auto
commit
# 查看AR10/11/6上的BFD
dis bfd se all #每台上面的两个会话都up
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;dhcpsite2的ar1011&#34;&gt;DHCP&lt;sub&gt;Site2的AR10/11&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2中，AR10 AR11是DHCP服务器并且相互备份&lt;/li&gt;
&lt;li&gt;要求CLIENT7能通过DHCP服务器获取到地址10.2.129.100；&lt;/li&gt;
&lt;li&gt;要求CLIENT8只能获取指定地址为10.2.129.101；现在CLIENT8有时无法获取地址，请解决；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR10/11上查看地址池
dis cu | i pool
ip pool HCIE
dis th
# AR10的网关地址、网段不对，client18的地址不对【刷配置修改】
undo ip pool HCIE
y
    ip pool HCIE
    gateway-list 10.2.129.254 
    network 10.2.129.0 mask 255.255.255.0 
    excluded-ip-address 10.2.129.102 10.2.129.200
    static-bind ip-address 10.2.129.100 mac-address 5489-98cf-0549 
    static-bind ip-address 10.2.129.101 mac-address 5489-98cf-3513 
    dns-list 8.8.8.8 
    domain-name huawei.com
q
dhcp enable
int g0/0/0
dhcp select global
# AR11
undo ip pool HCIE
y
    ip pool HCIE
    gateway-list 10.2.129.253 
    network 10.2.129.0 mask 255.255.255.0 
    excluded-ip-address 10.2.129.1 10.2.129.99 
    static-bind ip-address 10.2.129.100 mac-address 5489-98cf-0549 
    static-bind ip-address 10.2.129.101 mac-address 5489-98cf-3513 
    dns-list 8.8.8.8 
    domain-name huawei.com
q
dhcp enable
int g0/0/0
dhcp select global
# SW4
int e0/0/1
dis th
int e0/0/3
dis th
int e0/0/4
dis th 
port hybrid untagged vlan 1  # tagged不能undo，只能使用untagged
int e0/0/5
dis th
port hybrid untagged vlan 1

# 测试
# client7/8基础配置--DHCP--应用--命令行--ipconfig  可以获得正确的地址【选择DHCP之后别忘了应用】
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;telnetsite3的ar161718&#34;&gt;Telnet&lt;sub&gt;Site3的AR16/17/18&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site3中，AR16 AR17 AR18帧中继网络中运行ospf，使用默认的网络类型；&lt;/li&gt;
&lt;li&gt;要求AR18能通过telnet远程管理AR16、AR17；现在AR18无法远程管理；解决此问题已满足以下表项；&lt;/li&gt;
&lt;li&gt;要求AR16的telnet认证方式为AAA，AR16上存在两个用户，admin用户级别为15级，guest用户级别为1级，要求两个用户都能认证telnet登录；&lt;/li&gt;
&lt;li&gt;要求AR17的认证方法为password；所有telnet到AR17的用户级别无需求，但是能支持命令要求截图一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR16/17/18查看s3/0/0的配置
int s3/0/0
dis th
# AR16(spoke)
ospf dr-priority 0
fr map ip 10.3.129.17 608 broadcast
undo ospf timer hello
ospf network-type broadcast

# AR17(spoke)
ospf dr-priority 0

# AR18（HuB）
ospf dr-priority 100
undo fr inarp
fr map ip 10.3.129.17 807 broadcast
ospf network-type broadcast

# 测试FR
# AR16
ping 10.3.129.18 # 通
ping 10.3.129.17 # 通
# AR17
ping 10.3.129.16 # 通
ping 10.3.129.18 # 通
# AR18
ping 10.3.129.16 # 通
ping 10.3.129.17 # 通

# 继续完成telnet配置
# AR16
aaa
dis th
local-user admin privilege level 15
local-user admin password cipher hcie
local-user guest password cipher hcie
local-user admin service-type telnet
user-interface vty 0 4
dis th
authentication-mode aaa
# 测试AR18
telnet 10.3.1.16
admin
hcie
q
telnet 10.3.1.16
guest
hcie
dis local-user
sys  # 因为等级不够而报错
q
# AR17
user-interface vty 0 4
user privilege level 0
set authentication password cipher hcie
# 测试AR18
telnet 10.3.1.17
hcie
sys   # 因为等级不够而报错
q
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ipv6site2的ar1011site3的ar1820&#34;&gt;IPv6&lt;sub&gt;site2的AR10/11，site3的AR18/20&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site2与Site3配置了IPV6，并且运行OSPFV3协议；&lt;/li&gt;
&lt;li&gt;参与的设备有AR10、AR11、AR18、AR20；&lt;/li&gt;
&lt;li&gt;AR18与AR20之间通过tunnel相通；&lt;/li&gt;
&lt;li&gt;现在环境中的IPV6 CLIENT 13、IPV6 CLIENT 9 、IPV6 CLIENT16无法实现互相通信，请解决&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR18/20/10/11
dis cu conf ospfv3
# AR18
ospfv3 1
undo silent-interface Tunnel0/0/100
int tun 0/0/100
dis th
undo ipv6 address 2002:100:101::18/64
ipv6 address 2002:100:100::18/64
undo ospfv3 1 area 0.0.0.1
ospfv3 1 area 0.0.0.0
tunnel-protocol gre
source LoopBack0
destination 10.3.1.20
gre key 123
# AR20
ospfv3 1
undo silent-interface Tunnel0/0/100
a 1
undo abr-summary 2002:10:3:18::18 128
abr-summary 2002:10:3:18::18 128
int tun 0/0/100
dis th
undo ipv6 address FE80::18 link-local
ipv6 address FE80::20 link-local
undo ospfv3 1 area 0.0.0.1
ospfv3 1 area 0.0.0.0
# AR11
ospfv3 1
a 1
undo abr-summary 2002:10:2:131::13 128
abr-summary 2002:10:2:131::13 128
# AR18/20/10/11
dis ospfv3 peer # AR18/20在a0中为邻居；AR20\11\10在a1中为邻居
# 测试
client13，将其网关改成AR10的g0/0/1的地址
client9，将其网关改成AR20的g0/0/1的地址
client16，将其网关改成AR18的g0/0/0的地址，同时将IPv6地址最后一位改为16
# client13
ping 2002:10:3:18::16
ping 2002:10:3:209::9  # 全通
# client 9
ping 2002:10:3:18::16
ping 2002:10:2:131::13 # 全通
# client 16
ping 2002:10:3:209::9
ping 2002:10:2:131::13 # 全通
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;bgpas100的ar1272-as200的ar9&#34;&gt;BGP&lt;sub&gt;AS100的AR12/7/2、AS200的AR9&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;要求AS100中AR12的loopback0口能够访问AS200中的AR9的loopback0口；但是现在两个loopback口地址无法访问；请解决该问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看AR12的bgp情况
dis bgp peer # 与AR7的邻居为idle
dis cu conf bgp # 发现peer100.1.1.7通过lo1建立，在查看接口情况；同时需要去掉反射地址簇
dis ip int bri # 应该是lo 0
bgp 100
undo peer 100.1.1.7 connect-interface
peer 100.1.1.7 connect-interface lo 0
undo reflector cluster-id
# 查看R7
bgp 100
dis th  # 100.1.1.12的as号为100
undo peer 100.1.1.12
peer 100.1.1.12 as-number 100 
peer 100.1.1.12 connect-interface LoopBack0
peer 100.1.1.12 reflect-client
dis bgp peer # AR12的邻居establish
ping -a 100.1.1.7 100.1.1.12
# AR7
dis bgp peer # AR7已经establish
ping -a 100.1.1.12 100.1.1.7
# 查看边界设备AR2有没有针对AR7做下一跳自我；AR4/5有没有针对AR9做下一跳自我
# AR2/4/5
dis cu conf bgp  # AR2上有AR7的下一跳自我；AR4/5上有AR9的下一跳自我
# AR9上有没有配置R4/R5的反射客户端
dis cu conf bgp # 已经配置
# AR2 
dis cu conf bgp  # 发现针对200.100.24.4（LP）和200.100.25.5（AS-PATH）的两条route-policy【这个错点也涉及IPv6】
dis cu conf route-policy
route-policy AS-PATH permit node 1 
apply as-path 100 100 additive
dis th
acl 200
dis th
rule 25 permit source 100.1.1.7 0
rule 30 permit source 100.1.225.0 0.0.0.255 # 这个是影响组播的
dis th 
bgp 100
ipv4-family unicast
undo peer 200.100.24.4 route-policy LP export
peer 200.100.24.4 route-policy LP import
undo peer 200.100.25.5 route-policy AS-PATH import
peer 200.100.25.5 route-policy AS-PATH export
ipv6-family unicast
undo peer 2002:200:100:24::4 route-policy LP export
peer 2002:200:100:24::4 route-policy LP import
undo peer 2002:200:100:25::5 route-policy AS-PATH import
peer 2002:200:100:25::5 route-policy AS-PATH export
# 测试
# AR12
ping -a 100.1.1.12 200.1.1.9 # 通
#AR9
ping -a 200.1.1.9 100.1.1.12 # 通
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;natsite5的ar27-as200的ar9&#34;&gt;NAT&lt;sub&gt;site5的AR27、AS200的AR9&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;site5中通过安全接入AS，client11现在无法通过网关AR27访问到公网AS100、AS200&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR27/AR9
int s3/0/0
dis th # 两台路由器的认证方式不一样
# AR9
ppp authentication-mode chap
isis enable 200
aaa
dis th
local-user hcie service-type ppp
local-user hcie password cipher hcie
q

# AR27
ppp chap password cipher hcie
dis cu | i route  # 可以查看到配置默认路由，接口为g0/0/0
undo ip route-static 0.0.0.0 0.0.0.0 GigabitEthernet0/0/0
ip route-static 0.0.0.0 0.0.0.0 s3/0/0
dis cu conf acl # acl2000为全通规则
dis cu | in nat
int s3/0/0
nat outbound 2000 address-group 1
dis nat out

# 测试
# client11
ping 200.1.1.9 #通
ping 200.1.1.23 #通
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;qossite3的ar19&#34;&gt;QoS&lt;sub&gt;site3的AR19&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Site3中AR20上一个用户（ loopback0模拟）和AR18的一个用户（loopback0模拟）要进行语音通信，使用的音频编码G.711，每路语音需要64Kbps的带宽，目前从AR20到AR18的语音质量不够好，需要在AR19上部署QOS；以保证语音流量的服务质量（反向流量不要求）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR19
dis cu  # 复制到记事本中查看

acl name UDP 3999  
rule 1 permit udp source 10.3.1.20 0 destination 10.3.1.18 0 destination-port range 16384 32767
undo rule 5

traffic behavior remark
dis th
undo remark dscp
remark dscp ef

traffic behavior cbq
undo queue llq 
queue llq bandwidth 64

interface Serial3/0/0
dis th
undo traffic-policy inbound  # 删除配置的时候不能加规则名称，只能加流量方向
traffic-policy cbq outbound
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;msdpas100的ar227&#34;&gt;msdp&lt;sub&gt;AS100的AR22/7&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AS100与AS200要部署域间组播；&lt;/li&gt;
&lt;li&gt;AR7是AS100中的RP，AR9是AS200中的RP；&lt;/li&gt;
&lt;li&gt;AS100中AR22上有一台视频服务器，AS200中AR23上有一个组播接收者要加入组239.1.1.1，现在客户无法收到组播数据，无法观看相应的视频；请解决该问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR22
int g0/0/1
dis th
undo igmp enable
undo igmp static-group 239.1.1.1
pim sm
# 查看g0/0/0有没有宣告进ospf的a1
dis cu int g0/0/0 # 地址为100.1.212.22
dis ospf int  #已经宣告进，且为DR

# AR7
pim
dis th
c-bsr lo 0
dis pim neighbor # 缺少AR2的邻居
int g0/0/2
dis th
pim sm
q
dis pim neighbor # 4个邻居齐全
dis pim rp # RP为100.1.1.7
dis pim routing-table # 没有
# AR22
ping multicast 239.1.1.1
# AR7
dis pim routing-table #出现
msdp
dis th
peer 200.1.1.9 password cipher hcie
# AR9
msdp
dis th
peer 100.1.1.7 connect-interface LoopBack0
peer 100.1.1.7 password cipher hcie
dis msdp bri  # 100.1.1.7已经UP
# AR7
dis msdp bri  # 200.1.1.9已经UP
# AR5
pim 
dis th # static-rp 200.1.1.9正确
# AR4
pim 
dis th # static-rp 100.1.1.7错误
static-rp 200.1.1.9
#AR9
pim 
dis th # static-rp 200.200.200.9错误
static-rp 200.1.1.9
# AR23
pim
static-rp 200.1.1.9
# AR4
dis pim neighbor #缺少AR2的邻居
int p 5/0/0
dis th
pim sm
# AR2
int p 5/0/0
dis th
pim sm
dis pim neighbor # 5个邻居
# AR4
dis pim neighbor # 3个邻居齐了
# AR23
dis pim neighbor # 1个邻居齐了
int g0/0/1
dis th
undo igmp static-group 239.1.1.1
pim sm
igmp enable
# client6
组播--加入
# AR22
ping multicast 239.1.1.1
# AR7/9/23
dis pim routing-table #都出现 (100.1.225.254, 239.1.1.1)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;ipv6-bgpas200的ar9-as100的ar7&#34;&gt;IPv6 BGP&lt;sub&gt;AS200的AR9、AS100的AR7&lt;/sub&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;AS200中AR9 AR4 AR5上面各有一个IPV6客户站点（loopback1模拟），AS100中有AR2 AR7上各有一个IPV6客户站点（loopback1模拟），要求这几个站点都能互通，并且要求双向路径要优选AR2-AR4之间的链路，一旦主用链路出现问题在使用备用链路AR2-AR5；现在这几个站点之间的互通存在部分问题，请解决；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR9
bgp 200
dis th
ipv6-family unicast 
peer 2002:200:1:1::4 reflect-client 
peer 2002:200:1:1::5 reflect-client 

# AR7
bgp 100
dis th
ipv6-family unicast 
network 2002:100:7:1::1 128

# AR2上的错误前面已经排除，即关于两条route-policy的配置

# 查看
# AR9/2
dis bgp ipv6 peer # 均有到达AR4/5的邻居
# AR7
tracert ipv6 -a 2002:100:7:1::1 2002:200:9:1::1 # 第2跳为AR4
# AR9
tracert ipv6 -a 2002:200:9:1::1 2002:100:7:1::1 # 第1跳为AR4
# AR4
int p 5/0/0
shutdown
# AR7
tracert ipv6 -a 2002:100:7:1::1 2002:200:9:1::1 # 第2跳为AR5
# AR9
tracert ipv6 -a 2002:200:9:1::1 2002:100:7:1::1 # 第1跳为AR5
# AR4
int p 5/0/0
undo shutdown
&lt;/code&gt;&lt;/pre&gt;
">HCIE 实验TS_PlanB</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-zhi-wen-jian-jian-kong-watchdog-he-pyinotify/"" data-c="
          &lt;p&gt;在python中文件监控主要有两个库：pyinotify&lt;code&gt;依赖于Linux平台的inotify，Linux平台推荐使用此模块，功能比watchdog强大且全面&lt;/code&gt;、watchdog。&lt;/p&gt;
&lt;h1 id=&#34;watchdog模块&#34;&gt;watchdog模块&lt;/h1&gt;
&lt;p&gt;主要有3个角色：observer、event_handler、被监控的文件夹。三者原本是独立的，主要通过&lt;code&gt;observer.schedule&lt;/code&gt;函数将三者串起来，observer不断检测调用平台依赖代码对监控文件夹进行变动检测，当发现改变时，通知event_handler处理。&lt;/p&gt;
&lt;h2 id=&#34;watchdog的3个角色&#34;&gt;watchdog的3个角色&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Observer&lt;br&gt;
主要作用是当作启动和关闭监控程序，给予文件夹路径后，Observer会监控文件夹的变化并且反馈变化。&lt;br&gt;
使用&lt;code&gt;from watchdog.observers import Observer&lt;/code&gt;命令导入。&lt;/li&gt;
&lt;li&gt;events&lt;br&gt;
watchdog的动作模块，具体作用是根据Observer模块反馈的事件分配不一样的操作动作方法，然后程序再继承这个方法开始执行所需的代码。&lt;br&gt;
使用&lt;code&gt;from watchdog.events import *&lt;/code&gt;命令导入。&lt;/li&gt;
&lt;li&gt;监控文件夹路径&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;代码实例&#34;&gt;代码实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 本模块的功能:&amp;lt;检测文件或目录变化&amp;gt;

# 导入watchdog对应模块
from watchdog.observers import Observer
from watchdog.events import *
# 导入时间模块
import time

class FileEventHandler(FileSystemEventHandler):
    # 初始化
    def __init__(self):
        FileSystemEventHandler.__init__(self)

    # 移动目录或文件
    def on_moved(self, event):
        now=time.strftime(&amp;quot;%Y-%m-%d %H:%M;%S&amp;quot;,time.localtime())
        if event.is_directory:
            print(f&amp;quot;{now} 移动目录从{event.src_path}到{event.dest_path}&amp;quot;)
        else:
            print(f&amp;quot;{now} 移动文件从{event.src_path}到{event.dest_path}&amp;quot;)

    # 创建目录或文件
    def on_created(self, event):
        now=time.strftime(&amp;quot;%Y-%m-%d %H:%M;%S&amp;quot;,time.localtime())
        if event.is_directory:
            print(f&amp;quot;{now} 创建目录{event.src_path}&amp;quot;)
        else:
            print(f&amp;quot;{now} 创建文件{event.src_path}&amp;quot;)

    # 删除目录或文件
    def on_deleted(self, event):
        now=time.strftime(&amp;quot;%Y-%m-%d %H:%M;%S&amp;quot;,time.localtime())
        if event.is_directory:
            print(&amp;quot;{now} 删除目录{0}&amp;quot;.format(event.src_path))
        else:
            print(&amp;quot;{now} 删除文件{0}&amp;quot;.format(event.src_path))

    # 修改目录或文件
    def on_modified(self, event):
        now=time.strftime(&amp;quot;%Y-%m-%d %H:%M;%S&amp;quot;,time.localtime())
        if event.is_directory:
            print(&amp;quot;{now} 修改目录{0}&amp;quot;.format(event.src_path))
        else:
            print(&amp;quot;{now} 修改文件{0}&amp;quot;.format(event.src_path))

if __name__ == &amp;quot;__main__&amp;quot;:
    # 实例化Observer对象
    observer = Observer()
    event_handler = FileEventHandler()
    # 设置监听目录
    dis_dir = &amp;quot;F:\迅雷下载&amp;quot;
    observer.schedule(event_handler,dis_dir,recursive=True) # recursive=True，可以直接写True，表示递归子目录
    print(f&amp;quot;监控目录 {dis_dir}&amp;quot;)
    observer.start()
    # try:
    #     while True:
    #         # 设置监听频率(间隔周期时间)
    #         time.sleep(1)
    # except KeyboardInterrupt:
    #     observer.stop()
    observer.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;pyinotify模块&#34;&gt;pyinotify模块&lt;/h1&gt;
&lt;p&gt;依赖于Linux内核的inotify功能，inotify是一个事件驱动的通知器，其通知接口从内核空间到用户空间通过三个系统调用。&lt;br&gt;
Notifier是pyinotify模块最重要的类，用来读取通知和处理事件，默认情况下，Notifier处理事件的方式是打印事件。&lt;br&gt;
Notifier类在初始化时接受多个参数，但是只有WatchManager对象是必须传递的参数，WatchManager对象保存了需要监视的文件和目录，以及监视文件和目录的哪些事件，Notifier类根据WatchManager对象中的配置来决定如何处理事件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/usr/bin/env python3
 
import pyinotify

# 创建WatchManager对象 
wm = pyinotify.WatchManager()
# 添加要监控的目录，以及要监控的事件，这里ALL_EVENT表示所有事件         
wm.add_watch(&#39;/tmp&#39;,pyinotify.ALL_EVENTS)  
# 交给Notifier进行处理
notifier = pyinotify.Notifier(wm)
# 循环处理事件      
notifier.loop()                            
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;事件标志&#34;&gt;事件标志&lt;/h2&gt;
&lt;p&gt;下面列举的是事件标志位，可以用&#39;与&#39;来关联监控多个事件，例如&lt;code&gt;multi_event = pyinotify.IN_OPEN | pyinotify.IN_CLOSE_NOWRITE&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IN_ACCESS&lt;br&gt;
被监控项目或者被监控目录中的文件被&lt;strong&gt;访问&lt;/strong&gt;，比如一个文件被读取&lt;/li&gt;
&lt;li&gt;IN_MODIFY	&lt;br&gt;
被监控项目或者被监控目录中的文件被&lt;strong&gt;修改&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_ATTRIB	&lt;br&gt;
被监控项目或者被监控目录中的文件的&lt;strong&gt;属性被修改&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_CLOSE_WRITE	&lt;br&gt;
一个&lt;strong&gt;可写&lt;/strong&gt;的文件或者目录&lt;strong&gt;被关闭&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_CLOSE_NOWRITE	&lt;br&gt;
一个&lt;strong&gt;只读&lt;/strong&gt;的文件或者目录&lt;strong&gt;被关闭&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_OPEN	&lt;br&gt;
文件或者目录&lt;strong&gt;被打开&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_MOVED_FROM	&lt;br&gt;
被监控项目或者目录中的文件&lt;strong&gt;被移除监控区域&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_MOVED_TO	&lt;br&gt;
文件或目录&lt;strong&gt;被移入监控区域&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_MOVE_SELF&lt;br&gt;
&lt;strong&gt;自移动&lt;/strong&gt;，即一个可执行文件在执行时移动自己&lt;/li&gt;
&lt;li&gt;IN_CREATE	&lt;br&gt;
在所监控的目录中&lt;strong&gt;创建子目录或文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_DELETE	&lt;br&gt;
在所监控的目录中&lt;strong&gt;删除目录或文件&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IN_DELETE_SELF&lt;br&gt;
自删除，即一个可执行文件在执行时删除自己&lt;/li&gt;
&lt;li&gt;IN_CLOSE&lt;br&gt;
文件&lt;strong&gt;被关闭&lt;/strong&gt;，等同于&lt;code&gt;(IN_CLOSE_WRITE | IN_CLOSE_NOWRITE)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IN_MOVE	&lt;br&gt;
文件&lt;strong&gt;被移动&lt;/strong&gt;，等同于&lt;code&gt;(IN_MOVED_FROM | IN_MOVED_TO)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IN_UNMOUNT&lt;br&gt;
宿主文件系统&lt;strong&gt;被umount&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;事件处理&#34;&gt;事件处理&lt;/h2&gt;
&lt;p&gt;前面的例子，我们使用的都是默认的事件处理方式：打印在屏幕上，而很多情况下我们需要定制事件的处理方式，来实现特殊的功能。定制事件需要继承ProcessEvent类，针对需要处理的事件编写&lt;code&gt;process_事件名(self,event)&lt;/code&gt;函数即可&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import pyinotify
 
 # 监控多个事件：文件被打开或者只读文件被关闭
multi_event = pyinotify.IN_OPEN | pyinotify.IN_CLOSE_NOWRITE
# 创建WatchManager对象
wm = pyinotify.WatchManager()                                   
 
 # 定制化事件处理类，注意继承
class MyEventHandler(pyinotify.ProcessEvent): 
    # 必须为process_事件名称，event表示事件对象                  
    def process_IN_OPEN(self,event): 
        # event.pathname 表示触发事件的文件路径                         
        print(&#39;OPEN&#39;,event.pathname)                            
    def process_IN_CLOSE_NOWRITE(self,event):
        print(&#39;CLOSE_NOWRITE&#39;,event.pathname)
# 实例化我们定制化后的事件处理类
handler = MyEventHandler() 
# 在notifier实例化时传入，notifier会自动执行                                     
notifier = pyinotify.Notifier(wm,handler)                       
# 添加监控的目录及事件
wm.add_watch(&#39;/tmp&#39;,multi_event)                                
notifier.loop()
&lt;/code&gt;&lt;/pre&gt;
">Python之文件监控（watchdog和pyinotify）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/centos7-gua-zai-wang-luo-cun-chu/"" data-c="
          &lt;p&gt;除了使用mount命令挂载Samba、NFS、iSCSI等常规存储协议分享的存储空间外，通常需要将例如FTP、sFTP以及各种网盘资源挂载在本地使用，不仅是为了方便操作，也有可能是为了备份数据。&lt;br&gt;
下面介绍这些非存储共享协议的挂载方式&lt;/p&gt;
&lt;h1 id=&#34;ftp&#34;&gt;FTP&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装curlftpfs
yum -y install curlftpfs
# 挂载
mkdir /mnt/ftp
curlftpfs -o codepage=utf8 ftp://root:123456@192.168.3.12 /mnt/ftp
# 卸载
fusermount -u /mnt/ftp
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;sftp&#34;&gt;sFTP&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装SSHFS
yum install sshfs
# 挂载
mkdir /mnt/sftp
sshfs root@192.168.3.19:/testsFTP /mnt/sftp  # 然后输入密码
# 如果想要开机后就挂载，可在/etc/local.rc文件中添加下面一行：
# sshfs -o IdentityFile=秘钥文件位置 root@192.168.3.19:/testsFTP /mnt/sftp
# 卸载
umount /mnt/sftp
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;webdav&#34;&gt;WebDav&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装davfs2
yum install -y davfs2
# 挂载
mkdir /mnt/webdav
mount -t davfs https://cainiao.net/ /mnt/webdav
# 卸载
unmount /mnt/webdav
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;网盘等资源&#34;&gt;网盘等资源&lt;/h1&gt;
&lt;p&gt;只能借助rclone等工具，当然rclone也可以挂载以上网络存储&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 官网下载rpm安装包上传到需要挂载网络存储的服务器
2. 安装：yum -y localinstall rclone.......
3. 生成rclone配置文件：rclone config，选择自己需要挂在的存储类型，然后按照要求填写参数
4. 创建挂载文件夹
5. 挂载：rclone mount sFTP:/testsFTP /mnt/123 &amp;amp;
6. 卸载：fusermount -u /mnt/123
&lt;/code&gt;&lt;/pre&gt;
">Centos7挂载网络存储</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/centos7-xiu-gai-mac-di-zhi/"" data-c="
          &lt;ul&gt;
&lt;li&gt;网卡名称：ens32&lt;/li&gt;
&lt;li&gt;原MAC地址：00:0c:29:3e:6e:74&lt;/li&gt;
&lt;li&gt;修改后MAC地址：00:01:23:0a:0b:cd&lt;/li&gt;
&lt;li&gt;原IP地址：192.168.3.8/24&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@source ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: ens32: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:3e:6e:74 brd ff:ff:ff:ff:ff:ff
    inet 192.168.3.8/24 brd 192.168.3.255 scope global dynamic ens32
       valid_lft 604648sec preferred_lft 604648sec
[root@source ~]# 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;临时修改&#34;&gt;临时修改&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ifconfig ens32 down
ifconfig ens32 hw ether 00:01:23:0a:0b:cd
ifconfig ens32 up
# 重启网络不失效，但是重启系统失效
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@source ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: ens32: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:01:23:0a:0b:cd brd ff:ff:ff:ff:ff:ff
    inet 192.168.3.8/24 brd 192.168.3.255 scope global dynamic ens32
       valid_lft 604181sec preferred_lft 604181sec
[root@source ~]# 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;永久修改&#34;&gt;永久修改&lt;/h1&gt;
&lt;h2 id=&#34;方式一开机执行命令&#34;&gt;方式一：开机执行命令&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;&amp;gt;/etc/rc.d/rc.local &amp;lt;&amp;lt;EOF
ifconfig ens32 down
ifconfig ens32 hw ether 00:01:23:0a:0b:cd
ifconfig ens32 up
EOF
chmod +x  /etc/rc.d/rc.local
reboot -h now
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@source ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: ens32: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:01:23:0a:0b:cd brd ff:ff:ff:ff:ff:ff
    inet 192.168.3.8/24 brd 192.168.3.255 scope global dynamic ens32
       valid_lft 604734sec preferred_lft 604734sec
[root@source ~]# 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;方拾二修改配置文件&#34;&gt;方拾二：修改配置文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/sysconfig/network-scripts/ifcfg-ens32
    # 如果有HWADDR这一行则注释掉，追加如下一行
    MACADDR=00:01:23:0a:0b:cd
    完整配置如下：
    # TYPE=Ethernet
    # BOOTPROTO=dhcp
    # NAME=ens32
    # DEVICE=ens32
    # ONBOOT=yes
    # MACADDR=00:01:23:0a:0b:cd
systemctl restart network
# 或者
# ifconfig ens32 down &amp;amp;&amp;amp; ifconfig ens32 up
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@source ~]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
2: ens32: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:01:23:0a:0b:cd brd ff:ff:ff:ff:ff:ff
    inet 192.168.3.15/24 brd 192.168.3.255 scope global dynamic ens32
       valid_lft 604668sec preferred_lft 604668sec
[root@source ~]# 
&lt;/code&gt;&lt;/pre&gt;
">Centos7修改mac地址</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-zhi-da-wen-jian-du-qu/"" data-c="
          &lt;p&gt;大文件一次性全部读入内存，导致代码运行缓慢，可以尝试按行或者分片读取，使用文件的可迭代方式将文件的内容按行或者按块读入内存，再逐行或者逐块写入新文件，最后用新文件覆盖源文件。&lt;/p&gt;
&lt;h1 id=&#34;按行读取&#34;&gt;按行读取&lt;/h1&gt;
&lt;p&gt;主要针对类似txt、csv等有换行的文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 方法一：
import os
with open(&amp;quot;123.csv&amp;quot;) as rf,open(&amp;quot;.123.csv&amp;quot;,&amp;quot;w&amp;quot;) as wf:
    # 对可迭代对象f逐行操作，防止内存溢出
    for line in rf:
        # 逐行读取
        line=line.replace(&#39;str1&#39;,&#39;str2&#39;)
        # 对读入的数据进行操作
        linex=line.replace(&amp;quot;1&amp;quot;,&amp;quot;A&amp;quot;)# 将1替换成A
        print(linex)
        # 写入缓存文件
        wf.write(linex)
# 替换原文件
os.remove(&amp;quot;123.csv&amp;quot;)
os.rename(&amp;quot;.123.csv&amp;quot;,&amp;quot;123.csv&amp;quot;)

# 方法二：
import os
with open(&amp;quot;123.csv&amp;quot;) as rf,open(&amp;quot;.123.csv&amp;quot;,&amp;quot;w&amp;quot;) as wf:
    while True:
        # 逐行读取
        line=rf.readline()
        # 对读入的数据进行操作
        linex = line.replace(&amp;quot;A&amp;quot;, &amp;quot;1&amp;quot;)  # 将A替换成1
        print(linex)
        # 写入缓存文件
        wf.write(linex)
        # 到文件结尾则跳出循环
        if not line:
            break
# 替换原文件
os.remove(&amp;quot;123.csv&amp;quot;)
os.rename(&amp;quot;.123.csv&amp;quot;,&amp;quot;123.csv&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;逐块读取&#34;&gt;逐块读取&lt;/h1&gt;
&lt;p&gt;主要针对类似pcap、bin等不换行的二进制文件等，当然也可以读取csv、txt等文本文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;import os
with open(&amp;quot;123.iso&amp;quot;,&amp;quot;rb&amp;quot;) as rf,open(&amp;quot;.123.iso&amp;quot;,&amp;quot;wb&amp;quot;) as wf:
    while True:
        # 逐块读取
        block=rf.read(1024)
        # 对读入的数据进行操作
        blockx = block.replace(b&amp;quot;\x00\x00&amp;quot;, b&amp;quot;\xab\xcd&amp;quot;)  # 将00:00替换成ab:cd
        print(blockx)
        # 写入缓存文件
        wf.write(blockx)
        # 到文件结尾则跳出循环
        if not block:
            break
# 替换原文件
os.remove(&amp;quot;123.iso&amp;quot;)
os.rename(&amp;quot;.123.iso&amp;quot;,&amp;quot;123.iso&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
">Python之大文件读取</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/linux-gao-bing-fa-diao-you-zong-jie/"" data-c="
          &lt;p&gt;高并发调优主要涉及3方面，单进程最大打开文件数限制、内核TCP参数方面和IO事件分配机制，下面从这3方面进行调优：&lt;br&gt;
&lt;code&gt;如非必须，关掉或卸载iptables防火墙，并阻止kernel加载iptables模块。这些模块会影响并发性能&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;单进程最大打开文件数限制&#34;&gt;单进程最大打开文件数限制&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ulimit -n 65535
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将root启动的单一进程的最大可以打开的文件数设置为65535个。如果系统回显类似于&lt;code&gt;Operationnotpermitted&lt;/code&gt;之类的话，说明上述限制修改失败，实际上是因为在中指定的数值超过了Linux系统对该用户打开文件数的&lt;strong&gt;软限制或硬限制&lt;/strong&gt;。因此，就需要修改Linux系统对用户的关于&lt;code&gt;打开文件数的软限制和硬限制&lt;/code&gt;，步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改limits.conf文件，并添加：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/security/limits.conf
    * soft nofile 65535
    * hard nofile 65535
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;*&lt;/code&gt;号表示修改所有用户的限制；&lt;code&gt;soft或hard&lt;/code&gt;指定要修改软限制还是硬限制；&lt;code&gt;65536&lt;/code&gt;则指定了想要修改的新的限制值，即最大打开文件数(请注意软限制值要小于或等于硬限制)。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改/etc/pam.d/login文件，在文件中添加如下行：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/pam.d/login
    session required /lib64/security/pam_limits.so
    # session required /lib/security/pam_limits.so # 32位系统
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在用户完成系统登录后，应该调用&lt;code&gt;pam_limits.so&lt;/code&gt;模块来设置系统对该用户可使用的各种资源数量的最大限制(包括用户可打开的最大文件数限制)，而&lt;code&gt;pam_limits.so&lt;/code&gt;模块就会从&lt;code&gt;/etc/security/limits.conf&lt;/code&gt;文件中读取配置来设置这些限制值。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;查看Linux系统级的最大打开文件数限制，使用如下命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat /proc/sys/fs/file-max
    395312
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这表明这台Linux系统最多允许同时打开&lt;code&gt;395312&lt;/code&gt;个文件(即包含所有用户打开文件数总和)，&lt;strong&gt;是Linux系统级硬限制&lt;/strong&gt;，所有用户级的打开文件数限制都不应超过这个数值。通常这个系统级硬限制是Linux系统在启动时根据系统硬件资源状况计算出来的最佳的最大同时打开文件数限制，&lt;strong&gt;如果没有特殊需要，不应该修改此限制&lt;/strong&gt;，除非想为用户级打开文件数限制设置超过此限制的值。&lt;br&gt;
修改此硬限制的方法是修改&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;文件内&lt;code&gt;fs.file-max = 650000&lt;/code&gt;，这是让Linux在启动完成后强行将系统级打开文件数硬限制设置为&lt;code&gt;650000&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;内核tcp参数方面&#34;&gt;内核TCP参数方面&lt;/h1&gt;
&lt;p&gt;Linux系统下，TCP连接断开后，会以&lt;code&gt;TIME_WAIT&lt;/code&gt;状态保留一定的时间，然后才会释放端口。当并发请求过多的时候，就会产生大量的&lt;code&gt;TIME_WAIT&lt;/code&gt;状态的连接，无法及时断开的话，会&lt;code&gt;占用大量的端口资源和服务器资源&lt;/code&gt;。这个时候我们可以优化TCP的内核参数，来及时将&lt;code&gt;TIME_WAIT&lt;/code&gt;状态的端口清理掉。&lt;br&gt;
下面的方法&lt;strong&gt;只对拥有大量TIME_WAIT状态的连接导致系统资源消耗有效&lt;/strong&gt;，如果不是这种情况下，效果可能不明显。可以使用netstat命令去查TIME_WAIT状态的连接状态，输入下面的组合命令，查看当前TCP连接的状态和对应的连接数量：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for (a in S) print a, S[a]}&#39;
    # 输出类似下面的结果：
    # LAST_ACK16
    # SYN_RECV348
    # ESTABLISHED70
    # FIN_WAIT1229
    # FIN_WAIT230
    # CLOSING33
    # TIME_WAIT18098
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只用关心&lt;code&gt;TIME_WAIT&lt;/code&gt;的个数，在这里可以看到，有18000多个&lt;code&gt;TIME_WAIT&lt;/code&gt;，这样就占用了18000多个端口。要知道端口的数量只有65535个，占用一个少一个，会严重的影响到后继的新连接。这种情况下，我们就有必要调整下Linux的TCP内核参数，让系统更快的释放TIME_WAIT连接。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/sysctl.conf
    net.ipv4.tcp_syncookies= 1
    net.ipv4.tcp_tw_reuse= 1
    net.ipv4.tcp_tw_recycle= 1
    net.ipv4.tcp_fin_timeout= 30
    # ----------------------------
    net.ipv4.tcp_keepalive_time= 1200
    net.ipv4.ip_local_port_range= 1024 65535
    net.ipv4.tcp_max_syn_backlog= 8192
    net.ipv4.tcp_max_tw_buckets= 5000
sysctl -p
# net.ipv4.tcp_syncookies= 1：表示开启SYNCookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭。
# net.ipv4.tcp_tw_reuse= 1：表示开启重用。允许将TIME-WAITsockets重新用于新的TCP连接，默认为0，表示关闭。
# net.ipv4.tcp_tw_recycle= 1：表示开启TCP连接中TIME-WAITsockets的快速回收。默认为0，表示关闭。
# net.ipv4.tcp_fin_timeout：修改系統默认的TIMEOUT时间。
# net.ipv4.tcp_keepalive_time= 1200：表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
# ip_local_port_range= 1024 65535：表示用于向外连接的端口范围。缺省情况下很小，改为1024到65535。
# net.ipv4.tcp_max_syn_backlog= 8192：表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
# net.ipv4.tcp_max_tw_buckets= 5000：表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。默认为180000，改为5000。此项参数可以控制TIME_WAIT的最大数量，只要超出就清除。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;前4行&lt;/strong&gt;调整之后，除了会进一步提升服务器的负载能力之外，还能够防御小流量程度的DoS、CC和SYN攻击。此外，如果连接数本身就很多，我们可以再优化一下TCP的可使用端口范围，进一步提升服务器的并发能力，加入&lt;strong&gt;后4行&lt;/strong&gt;参数，建议只在流量非常大的服务器上开启，会有显著的效果。一般的流量小的服务器上，没有必要去设置&lt;strong&gt;后4行&lt;/strong&gt;参数。&lt;br&gt;
&lt;strong&gt;内核其他TCP参数说明：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;net.ipv4.tcp_max_syn_backlog= 65535
# 记录的那些尚未收到客户端确认信息的连接请求的最大值。对于有128M内存的系统而言，缺省值是1024，小内存的系统则是128。

 net.core.netdev_max_backlog= 32768
# 每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目。

net.core.somaxconn= 32768
# 例如web应用中listen函数的backlog默认会给我们内核参数的net.core.somaxconn限制到128，而nginx定义的NGX_LISTEN_BACKLOG默认为511，所以有必要调整这个值。

net.core.wmem_default= 8388608
net.core.wmem_max= 16777216 
# 最大socket写buffer,可参考的优化值873200

net.core.rmem_default= 8388608
net.core.rmem_max= 16777216 
#最大socket读buffer,可参考的优化值873200

net.ipv4.tcp_wmem= 8192 436600 873200
# TCP写buffer,可参考的优化值:8192 436600 873200

net.ipv4.tcp_rmem = 32768 436600 873200
# TCP读buffer,可参考的优化值:32768 436600 873200

net.ipv4.tcp_timestsmps= 0
# 时间戳可以避免序列号的卷绕。一个1Gbps的链路肯定会遇到以前用过的序列号。时间戳能够让内核接受这种“异常”的数据包。这里需要将其关掉。

net.ipv4.tcp_synack_retries= 2
# 为了打开对端的连接，内核需要发送一个SYN并附带一个回应前面一个SYN的ACK。也就是所谓三次握手中的第二次握手。这个设置决定了内核放弃连接之前发送SYN+ACK包的数量。

net.ipv4.tcp_syn_retries= 2
# 在内核放弃建立连接之前发送SYN包的数量。

net.ipv4.tcp_tw_reuse= 1
# 开启重用。允许将TIME-WAITsockets重新用于新的TCP连接。

net.ipv4.tcp_mem= 94500000 91500000 92700000
# 有3个值，意思分别是是:
#   net.ipv4.tcp_mem[0]:低于此值，TCP没有内存压力。
#   net.ipv4.tcp_mem[1]:在此值下，进入内存压力阶段。
#   net.ipv4.tcp_mem[2]:高于此值，TCP拒绝分配socket。
# 上述内存单位是页，而不是字节。可参考的优化值是786432 1048576 1572864

net.ipv4.tcp_max_orphans= 3276800
# 系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。
# 如果超过这个数字，连接将即刻被复位并打印出警告信息。
# 这个限制仅仅是为了防止简单的DoS攻击，不能过分依靠它或者人为地减小这个值，更应该增加这个值(如果增加了内存之后)。

net.ipv4.tcp_fin_timeout= 30
# 如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间。
# 对端可以出错并永远不关闭连接，甚至意外当机。缺省值是60秒。2.2 内核的通常值是180秒，你可以按这个设置，但要记住的是，即使你的机器是一个轻载的WEB服务器，也有因为大量的死套接字而内存溢出的风险，FIN-WAIT-2的危险性比FIN-WAIT-1要小，因为它最多只能吃掉1.5K内存，但是它们的生存期长些。
# 同时还涉及到一个TCP 拥塞算法的问题，你可以用下面的命令查看本机提供的拥塞算法控制模块：sysctlnet.ipv4.tcp_available_congestion_control
# 对于几种算法的分析，详情可以参考下：TCP拥塞控制算法的优缺点、适用环境、性能分析，比如高延时可以试用hybla，中等延时可以试用htcp算法等。
# 如果想设置TCP拥塞算法为hybla：net.ipv4.tcp_congestion_control=hybla
# 额外的，对于内核版高于于3.7.1的，我们可以开启tcp_fastopen：net.ipv4.tcp_fastopen= 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;io事件分配机制&#34;&gt;IO事件分配机制&lt;/h1&gt;
&lt;p&gt;在开发支持高并发TCP连接的Linux应用程序时，应尽量使用&lt;code&gt;epoll或AIO技术&lt;/code&gt;来实现并发的TCP连接上的I/O控制，这将为提升程序对高并发TCP连接的支持提供有效的I/O保证。&lt;br&gt;
&lt;strong&gt;原因如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可用的I/O技术有同步I/O，非阻塞式同步I/O，以及异步I/O。&lt;br&gt;
在高TCP并发的情形下，如果使用同步I/O，这会严重阻塞程序的运转，除非为每个TCP连接的I/O创建一个线程。&lt;br&gt;
但是，过多的线程又会因系统对线程的调度造成巨大开销。&lt;br&gt;
因此，在高TCP并发的情形下使用同步I/O是不可取的，可以考虑使用非阻塞式同步I/O或异步I/O。&lt;br&gt;
非阻塞式同步I/O的技术包括使用select()、poll()、epoll等机制，异步I/O的技术就是使用AIO。&lt;/li&gt;
&lt;li&gt;从I/O事件分派机制来看，使用select()是不合适的，因为它所支持的并发连接数有限(通常在1024个以内)。&lt;br&gt;
如果考虑性能，poll()也是不合适的，尽管它可以支持的较高的TCP并发数，但是由于其采用“轮询”机制，当并发数较高时，其运行效率相当低，并可能存在I/O事件分派不均，导致部分TCP连接上的I/O出现“饥饿”现象。&lt;br&gt;
而如果使用epoll或AIO，则没有上述问题(早期Linux内核的AIO技术实现是通过在内核中为每个I/O请求创建一个线程来实现的，这种实现机制在高并发TCP连接的情形下使用其实也有严重的性能问题。但在最新的Linux内核中，AIO的实现已经得到改进)。&lt;/li&gt;
&lt;/ol&gt;
">Linux高并发调优总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/frp-shi-yong-zong-jie/"" data-c="
          &lt;h1 id=&#34;常用配置参数详解&#34;&gt;常用配置参数详解&lt;/h1&gt;
&lt;h2 id=&#34;服务端frpsini&#34;&gt;服务端&lt;sub&gt;frps.ini&lt;/sub&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 通用配置
[common] # 标识头 
bind_addr = 0.0.0.0 # 服务器IP，不指定默认0.0.0.0，支持IPV6
bind_port = 7000 # 服务端口，即FRP通讯端口
kcp_bind_port = 7000 # KCP通讯端口。用于和客户端内网穿透传输数据的端口。 也可以和bind_port共用端口，如果没有设置，则kcp在frps中被禁用
bind_udp_port = 7001 # UDP通讯端口。以帮助使UDP打洞穿透NAT
proxy_bind_addr = 127.0.0.1   # 代理监听地址，默认和bind_addr相同
token = 12345678 # 客户端与服务端通信的身份验证令牌
heartbeat_timeout = 90 # 心跳检测超时时间，不建议修改默认配置，默认值为90
allow_ports = 2000-3000,3001,3003,4000-50000  # 指定允许客户端使用的端口范围，未指定则没有限制
max_pool_count = 5 # 每个内网穿透服务限制最大连接池上限。避免大量资源占用。
max_ports_per_client = 0  # 每个客户端最大可以使用的端口，0表示无限制
authentication_timeout = 900 #客户端与服务端时间相差验证。假如客户端设备的时间和服务端的时间相差大于设定值，那么拒绝客户端连接。如果设置为0，则不验证时间，默认值为900秒 
subdomain_host = frps.com # 自定义子域名，需要在dns中将域名解析为泛域名
tcp_mux = true # 是否使用tcp复用，默认为true。frp只对同一客户端的连接进行复用；

# 仪表盘
dashboard_addr = 0.0.0.0 # 绑定服务端IP
dashboard_port = 7500 # WEB端口
dashboard_user = admin # 用户名。自定义WEB管理用户名，如果没有设置，默认值是admin
dashboard_pwd = admin # 登录密码，自定义WEB管理密码，如果没有设置，默认值是admin
assets_dir = ./static           # 仪表盘页面文件目录，只适用于调试

# 日志
log_file = /etc/frp/log/frps.log # 日志存放路径
log_level = info # 日志记录类别，可选：trace, debug, info, warn, error 
log_max_days = 7 # 最多保存多少天日志

# 虚拟主机
vhost_http_port = 80 # 支持http，必须指定http端口监听，指定端口为http网页协议，端口可以和bind_port相同
vhost_https_port = 443 # 支持https，必须指定https端口监听，指定端口为https网页协议
vhost_http_timeout = 60 # 后端虚拟主机响应超时时间，默认为60s
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;客户端frpcini&#34;&gt;客户端&lt;sub&gt;frpc.ini&lt;/sub&gt;&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[common] # 标识头
server_addr = 1.2.3.4 #frps服务端IP
server_port = 7000 # frps服务端通讯端口，客户端连接到服务端内网穿透传输数据的端口，请改为服务端已配置的对应端口
token = 12345678 # 客户端与服务端通信的身份验证令牌
pool_count = 5 # 限制本客户端内网穿透可以创建的总连接池上限，避免大量资源占用。默认为0不限制。注意：假如服务端已配置了限制，而客户端设置的高于服务端的，则以服务端的为准。 
tcp_mux = true # 是否启用tcp复用，默认为true
user = your_name # frpc的用户名，用于区别不用frpc的代理，将显示为 {名称}.{对应服务名称}。请填大小写字母和数字，不要用中文填写
login_fail_exit = true # 首次登录失败时退出程序，否则连续重新登录到frps
protocol = tcp # 用于连接服务器的协议，支持tcp、kcp、websocket
dns_server = 8.8.8.8 # 为frp客户端指定一个单独的DNS服务器
start = ssh,dns # 要启用的代理的名字（此代理需要在下面进行配置），默认为空表示所有代理
# 如果要通过http或socks5代理连接frps，可以在此处或在全局环境变量中设置代理，只支持tcp协议
# http_proxy = http://user:passwd@192.168.1.128:8080
# http_proxy = socks5://user:passwd@192.168.1.128:1080

# 管理地址，用于通过http api控制frpc的动作
admin_addr = 127.0.0.1
admin_port = 7400
admin_user = admin
admin_passwd = admin

#日志
log_file = /etc/frp/log/frpc.log # 日志存放路径
log_level = info # 日志记录类别，可选：trace, debug, info, warn, error 
log_max_days = 7 # 最多保存多少天日志

# 心跳检查
heartbeat_interval = 30   # 失败重试次数
heartbeat_timeout = 90    # 超时时间

# ------------------------------------------------------------------
#【上面用于总体对接frps服务端各参数，下面的用于客户端穿透各应用的配置参数】 
# ------------------------------------------------------------------

[name] # 对应穿透服务名称，每个穿透服务都需要一个此服务的名称，不能和其他已建立的相同。如果配置user=your_name，则显示为your_name.name
type = tcp # 穿透协议类型，可选：tcp，udp，http，https，stcp，xtcp。你要穿透什么应用要搞清楚，此应用是用什么协议的
local_ip = 127.0.0.1 # 本地监听IP。可以是本地的局域网IP，也可以是本机的127.0.0.1。例如你的局域网是互通的，你可以在本设备建立穿透局域网其他IP的应用
local_port = 22 # 本地监听端口，用于监听本地设备需要穿透的端口，比如我要穿透到本机的SSH端口，而SSH端口为22，则这样理解
remote_port = 6001 # 远程监听端口。用于frps服务端的，分配建立穿透到内网对应应用的公网端口。需要frps服务端已开放此端口给frpc客户端允许对接使用。例如我可以连接到此(frps服务端IP：端口)，则可以穿透到我的内网对应应用服务。 
use_encryption = false #穿透通讯加密。服务端和客户端的通信信息，默认为不加密
use_compression = false # 穿透通讯压缩，默认不开启
custom_domains = demo.com # 分配自定义域名访问穿透服务。用于你的穿透服务的唯一访问域名，假如没有域名，则此处请填为frps服务端的服务器(IP)。自己有多个域名，可以配置不同穿透应用服务，用不同域名，只需要将对应域名解析到frps服务端的服务器(IP)既可
subdomain = abc123 # 假如frps服务端已经配置了subdomain_host参数域名，并且已经泛(*)解析到frps服务端的服务器(VPS)IP，则可以使用此参数，否则不能用

# 负载均衡配置
group = test_group          # 负载均衡组名，会将同一组内的客户端进行负载
group_key = 123456          # 负载均衡组密钥

# 为HTTP协议，添加HTTP用户名和密码安全认证【仅支持http,https类型协议】
http_user = admin # 自定义用户名
http_pwd = admin # 自定义密码
locations = /,/pic  # 指定用于路由的URL前缀
host_header_rewrite = example.com # 配置http包头域名重写
header_X-From-Where = frp # 添加包头信息X-From-Where: frp
sk = abcdefg #此参数用于进一步验证，本地访问穿透服务的安全连接，需要双方frpc客户端都需要配置，仅适用于stcp和xtcp协议类型

# ------------------------------------------------------------------
#【客户端针对不同的服务配置举例】 
# ------------------------------------------------------------------

#  #原来 http 请求中的 host 字段 test.yourdomain.com 转发到后端服务时会被替换为 dev.yourdomain.com
[web]
type = http
local_port = 80
http_user = admin
http_pwd = admin
custom_domains = test.yourdomain.com
host_header_rewrite = dev.yourdomain.com。

# # web.yourdomain.com 这个域名下所有以 /news 以及 /about 作为前缀的 URL 请求都会被转发到 web02，其余的请求会被转发到 web01
[web01]
type = http
local_port = 80
custom_domains = web.yourdomain.com
locations = /
[web02]
type = http
local_port = 81
custom_domains = web.yourdomain.com
locations = /news,/about  

#映射本地 6000-6005, 6007 这6个端口，实际连接成功后会创建 6 个 proxy，命名为 test_tcp_0, test_tcp_1 ... test_tcp_5。主要配置如下
[range:test_tcp]
type = tcp
local_ip = 127.0.0.1
local_port = 6000-6006,6007
remote_port = 6000-6006,6007

# 服务器为客户端随意指定ssh端口
[ssh_random]
type = tcp
local_ip = 127.0.0.1
local_port = 22
remote_port = 0 # 如果此处设置为0，name服务端将随机分配端口

# 指定范围内随机分配，UDP和TCP均可
[range:tcp_port]
type = tcp
local_ip = 127.0.0.1
local_port = 6010-6020,6022,6024-6028
remote_port = 6010-6020,6022,6024-6028
use_encryption = false
use_compression = false
[range:udp_port]
type = udp
local_ip = 127.0.0.1
local_port = 6010-6020
remote_port = 6010-6020
use_encryption = false
use_compression = false


# 设置dns
[dns]
type = udp
local_ip = 114.114.114.114
local_port = 53
remote_port = 6002
use_encryption = false
use_compression = false

# 使用插件获取连接
[plugin_unix_domain_socket]
type = tcp
remote_port = 6003
plugin = unix_domain_socket
plugin_unix_path = /var/run/docker.sock

[plugin_http_proxy]
type = tcp
remote_port = 6004
plugin = http_proxy
plugin_http_user = abc
plugin_http_passwd = abc

[plugin_socks5]
type = tcp
remote_port = 6005
plugin = socks5
plugin_user = abc
plugin_passwd = abc

[plugin_static_file]
type = tcp
remote_port = 6006
plugin = static_file
plugin_local_path = /var/www/blog
plugin_strip_prefix = static
plugin_http_user = abc
plugin_http_passwd = abc

# SCTP
[secret_tcp]
type = stcp # 如果类型为secret tcp，则远程端口无效。想要连接本地端口的用户应该部署另一个带有stcp代理的frpc，角色是visitor
sk = abcdefg
local_ip = 127.0.0.1
local_port = 22
use_encryption = false
use_compression = false

# 在stcp服务器和stcp visitor中，frpc的用户应该是相同的
# frpc role visitor -&amp;gt; frps -&amp;gt; frpc role server
[secret_tcp_visitor]
role = visitor
type = stcp
server_name = secret_tcp # 要访问的服务器名称
sk = abcdefg
bind_addr = 127.0.0.1
bind_port = 9000
use_encryption = false
use_compression = false

# P2P+XTCP
[p2p_tcp]
type = xtcp
sk = abcdefg
local_ip = 127.0.0.1
local_port = 22
use_encryption = false
use_compression = false

[p2p_tcp_visitor]
role = visitor
type = xtcp
server_name = p2p_tcp
sk = abcdefg
bind_addr = 127.0.0.1
bind_port = 9001
use_encryption = false
use_compression = false
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;配置例子&#34;&gt;配置例子&lt;/h1&gt;
&lt;p&gt;环境：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端：linux，局域网地址为192.168.1.250，公网地址为1.1.1.250&lt;/li&gt;
&lt;li&gt;被远程端：win10，局域网地址为192.168.1.111&lt;/li&gt;
&lt;li&gt;远程端：win10，公网地址为2.2.2.250&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;客户端配置frpcini&#34;&gt;客户端配置frpc.ini&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[common]
server_addr=192.168.1.250
server_port=7000
token=123@456

[RDP]
type=tcp
local_ip=127.0.0.1
local_port=3389
remote_port=33389
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;服务端配置frpsini&#34;&gt;服务端配置frps.ini&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[common]
bind_addr=0.0.0.0
bind_port=7000
token=123@456

dashboard_port=7500
dashboard_user=admin
dashboard_user=admin@123456
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 二进制文件位置：/usr/bin/frps
# 配置文件位置：/etc/frp/frps.ini
# systemd文件位置：/usr/lib/systemd/system/frps.service
systemctl start frps
netstat -tulnp   # 可以查看到监听的端口
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;访问端使用&#34;&gt;访问端使用&lt;/h2&gt;
&lt;p&gt;访问端使用地址&lt;code&gt;1.1.1.250:33389&lt;/code&gt;进行远程&lt;/p&gt;
">FRP使用总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/che-di-guan-bi-win10-de-geng-xin/"" data-c="
          &lt;p&gt;&lt;code&gt;可以借助Dism++或者Windows Update Blocker&lt;/code&gt;&lt;br&gt;
有的简化系统，通过官方更新之后会导致系统报错，于是需要关闭官方的更新，需要更新的时候通过手动打补丁。下面说一下关闭更新的方法，主要分为4个方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;关闭服务，包含服务关闭和注册表修改&lt;/li&gt;
&lt;li&gt;关闭组策略&lt;/li&gt;
&lt;li&gt;删除下载的补丁文件&lt;/li&gt;
&lt;li&gt;关闭更新计划&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;服务关闭&#34;&gt;服务关闭&lt;/h1&gt;
&lt;p&gt;cmd命令services.msc打开服务管理，命令regedit打开注册表（注册表中对应的位置为：&lt;code&gt;计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\&lt;/code&gt;）&lt;br&gt;
涉及到的服务主要有4个：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Windows Update，服务名称&lt;code&gt;wuauserv&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Background Intelligent Transfer Service，服务名称&lt;code&gt;BITS&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Update Orchestrator Service，服务名称&lt;code&gt;UsoSvc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Windows Update Medic Service，服务名称&lt;code&gt;WaaSMedicSvc&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对上面服务进行操作，将&lt;code&gt;常规&lt;/code&gt;选项卡中的&lt;code&gt;启动类型&lt;/code&gt;设置为&lt;code&gt;禁用&lt;/code&gt;，然后停止；将&lt;code&gt;恢复&lt;/code&gt;选项卡中的前3个选项均设置为&lt;code&gt;无操作&lt;/code&gt;。如果遇到禁止操作（主要是Update Orchestrator Servic 和 Windows Update Medic Service），可在注册表中找到&lt;code&gt;wuauserv&lt;/code&gt;，将&lt;code&gt;start&lt;/code&gt;的值改为4， 将&lt;code&gt;FailureActions&lt;/code&gt;中的&lt;code&gt;第0010和0018行&lt;/code&gt;的左起&lt;code&gt;第5个&lt;/code&gt;数值由原来的&lt;code&gt;01改为00&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&#34;策略修改&#34;&gt;策略修改&lt;/h1&gt;
&lt;p&gt;cmd命令gpedit.msc打开组策略编辑器&lt;br&gt;
计算机配置--&amp;gt;管理模板--&amp;gt;windows组件--&amp;gt;windows更新&lt;br&gt;
--&amp;gt;配置自动更新--&amp;gt;已禁用&lt;br&gt;
--&amp;gt;删除使用所有Windows更新功能的访问权限--&amp;gt;已启用&lt;/p&gt;
&lt;h1 id=&#34;删除文件&#34;&gt;删除文件&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;cmd执行&lt;code&gt;net stop wuauserv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;C:\windows\softwareDistribution\&lt;/code&gt;下面的文件夹&lt;code&gt;Download&lt;/code&gt;和&lt;code&gt;DataStore&lt;/code&gt;中的所有内容&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;关闭更新计划&#34;&gt;关闭更新计划&lt;/h1&gt;
&lt;p&gt;cmd命令taskschd.msc打开任务计划程序&lt;br&gt;
任务计划程序库--&amp;gt;Microsoft--&amp;gt;Windows--&amp;gt;WindowsUpdate，把里面的项目选择右键禁用（只能禁用Scheduled Start）&lt;/p&gt;
">彻底关闭win10的更新</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/windows-hou-tai-qi-dong-fu-wu/"" data-c="
          &lt;p&gt;后台启动实现方式主要有两种：第一种是在前端启动，然后将界面隐藏；第二种是将需要后台启动的软件注册为系统服务，然后启动，此种方法比较常用。&lt;br&gt;
下面举例过程中以FRP客户端的后台启动为例进行配置。&lt;br&gt;
&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95%E4%B8%80srvanyui&#34;&gt;方法一：SrvanyUI&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95%E4%BA%8Cwinsw&#34;&gt;方法二：WinSW&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95%E4%B8%89nssm&#34;&gt;方法三：NSSM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;方法一srvanyui&#34;&gt;方法一：SrvanyUI&lt;/h1&gt;
&lt;p&gt;下载软件SrvanyUI，然后将需要启动的软件注册为自建服务，当然也可以注册为系统服务或者驱动服务&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1602916048925.png&#34; alt=&#34;SrvanyUI&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优点：不仅可以注册自定义服务，还可以管理系统自带的服务，比较方便&lt;/li&gt;
&lt;li&gt;缺点：需要额外开机自启软件SrvanyUI&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;方法二winsw&#34;&gt;方法二：WinSW&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;github上下载最新的WinSW&lt;a href=&#34;https://github.com/winsw/winsw/releases/&#34;&gt;https://github.com/winsw/winsw/releases/&lt;/a&gt;【winsw可以运行在.NET2和.NET4两个版本上，当然如果使用Win10等比较新的系统，最好下载更新版本的.NET】&lt;/li&gt;
&lt;li&gt;下载完成后，重命名为&lt;strong&gt;winsw.exe&lt;/strong&gt;，并放在frp相同的目录中&lt;/li&gt;
&lt;li&gt;编写配置文件【在frp相同目录中创建&lt;strong&gt;winsw.xml&lt;/strong&gt;，并加入以下内容（部分自行修改）】&lt;br&gt;
详细参数请参考&lt;a href=&#34;https://www.jianshu.com/p/1ee1a8526cc6&#34;&gt;https://www.jianshu.com/p/1ee1a8526cc6&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;service&amp;gt;
    &amp;lt;!--  指定在Windows系统内部使用的识别服务的ID   --&amp;gt;
    &amp;lt;!--  在系统中安装的所有服务中，这必须是唯一的，它应该完全由字母数字字符组成   --&amp;gt;
    &amp;lt;id&amp;gt;frpc&amp;lt;/id&amp;gt;
    &amp;lt;!--  服务的简短名称，它可以包含空格和其他字符  --&amp;gt;
    &amp;lt;!--  尽量简短，就像id一样，在系统的所有服务名称中，也要保持唯一   --&amp;gt;
    &amp;lt;name&amp;gt;frpc&amp;lt;/name&amp;gt;
    &amp;lt;!--  该服务可读描述   --&amp;gt;
    &amp;lt;!--  当选中该服务时，它将显示在Windows服务管理器中   --&amp;gt;
    &amp;lt;description&amp;gt;启动内网穿透服务&amp;lt;/description&amp;gt;
    &amp;lt;!--  该元素指定要启动的可执行文件 --&amp;gt;
    &amp;lt;!--  可以是绝对路径，也可以指定可执行文件的名称，然后从环境变量PATH中搜索 --&amp;gt;
    &amp;lt;executable&amp;gt;C:\frp\frpc.exe&amp;lt;/executable&amp;gt;
    &amp;lt;!--  该元素指定要传递给可执行文件的参数   --&amp;gt;
    &amp;lt;!--  如果有必要，Winsw会给每一个参数外加引号，所以为了避免双重引号，尽量不要在参数中使用引号  --&amp;gt;
    &amp;lt;arguments&amp;gt;-c C:\frp\frpc.ini&amp;lt;/arguments&amp;gt;
    &amp;lt;onfailure action=&amp;quot;restart&amp;quot; delay=&amp;quot;60 sec&amp;quot;/&amp;gt;
    &amp;lt;onfailure action=&amp;quot;restart&amp;quot; delay=&amp;quot;120 sec&amp;quot;/&amp;gt;
    &amp;lt;logmode&amp;gt;reset&amp;lt;/logmode&amp;gt;
&amp;lt;/service&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;注册服务。编写好配置文件之后，记得把配置文件和可执行文件放在一起，这样winsw才能正确识别配置文件，然后在当前目录下打开cmd窗口（shift+右键--&amp;gt;选择在此打开命令提示符），然后输入命令&lt;code&gt;winsw install&lt;/code&gt;，如果返回值为0，说明已将程序注册为服务。&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 启动
winsw start   
# 停止
winsw stop 
# 卸载
winsw uninstall           
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;方法三nssm&#34;&gt;方法三：NSSM&lt;/h1&gt;
&lt;p&gt;NSSM是一个服务封装程序,它可以将普通exe程序封装成服务,使之像windows服务一样运行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下载&lt;a href=&#34;http://www.nssm.cc/download&#34;&gt;http://www.nssm.cc/download&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;把下载的nssm文件放入frp客户端目录，然后在当前目录下打开cmd窗口，执行&lt;code&gt;nssm install&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;配置如下：(默认开机自启)&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1602917656266.png&#34; alt=&#34;NSSM&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 创建servername服务
nssm install frpc
# 启动服务
nssm start frpc
# 停止服务
nssm stop frpc
# 重启服务
nssm restart frpc
# 卸载服务
nssm remove frpc
&lt;/code&gt;&lt;/pre&gt;
">windows后台启动服务</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/centos7-la-ji-wen-jian-qing-li/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%90%E9%A1%B9%E6%9F%A5%E7%9C%8B%E5%90%8E%E5%88%A0%E9%99%A4&#34;&gt;逐项查看后删除&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E7%BB%88%E8%84%9A%E6%9C%AC&#34;&gt;最终脚本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
这里只删除最基本的日志、缓存等，至于自己部署的服务产生的缓存、日志等，可以根据自己需求进行定制。&lt;/p&gt;
&lt;h1 id=&#34;逐项查看后删除&#34;&gt;逐项查看后删除&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;删除用户后遗留下的垃圾文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find / -nouser 
find / -nouser -exec rm –rf {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;删除core文件&lt;br&gt;
在系统下运行某个程序出错的时候，系统会自动将残留在内存中的数据存成core文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find / -type f -name core
find /  -type f -name core -exec rm -rf {} \;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;清除yum缓存&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum clean all
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;系统日志清理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ty=`date +%Y`
find /var/log -name &amp;quot;*-$ty*&amp;quot; -exec rm -rf {} \;
for logfile in `find /var/log -type f -name &amp;quot;*log&amp;quot;`
do
cat /dev/null &amp;gt; $logfile
done
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;删除缓存文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rm -rf /var/cache/*
rm -rf /var/tmp/*
rm -rf /tmp/*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;释放内存&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo 3 &amp;gt; /proc/sys/vm/drop_caches
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;删除命令执行记录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;history -c
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;最终脚本&#34;&gt;最终脚本&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find / -nouser -exec rm –rf {} \;
find /  -type f -name core -exec rm -rf {} \;
yum clean all
ty=`date +%Y`
find /var/log -name &amp;quot;*-$ty*&amp;quot; -exec rm -rf {} \;
for logfile in `find /var/log -type f -name &amp;quot;*log&amp;quot;`
do
cat /dev/null &amp;gt; $logfile
done
rm -rf /var/cache/*
rm -rf /var/tmp/*
rm -rf /tmp/*
echo 3 &amp;gt; /proc/sys/vm/drop_caches
history -c
&lt;/code&gt;&lt;/pre&gt;
">Centos7垃圾文件清理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-bi-shi-fu-xi-ji-hua/"" data-c="
          &lt;h1 id=&#34;第一阶段0920-1008&#34;&gt;第一阶段（0920-1008）&lt;/h1&gt;
&lt;p&gt;通读两遍题库&lt;/p&gt;
&lt;h1 id=&#34;第二阶段1008-1021&#34;&gt;第二阶段（1008-1021）&lt;/h1&gt;
&lt;p&gt;使用模拟考试软件将题库中全部题进行测试，未能记住的截图保存，然后看图复习，在进行刷题，直至全部通关&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第1次&lt;sup&gt;20201009&lt;/sup&gt;：第1套124题，第2套83题&lt;/li&gt;
&lt;li&gt;第2次&lt;sup&gt;20201011&lt;/sup&gt;：第1套（小于）61题，第2套58题&lt;/li&gt;
&lt;li&gt;第3次&lt;sup&gt;20201012&lt;/sup&gt;：第1套32题，第2套28题&lt;/li&gt;
&lt;li&gt;第4次&lt;sup&gt;20201013&lt;/sup&gt;：第1套3题，第2套13题&lt;br&gt;
2020.1021，周三考试，成绩如下：&lt;br&gt;
900分通过&lt;/li&gt;
&lt;/ol&gt;
">HCIE 笔试复习计划（1个月0920-1021）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/mongodb-xue-xi-bi-ji-zheng-li/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C&#34;&gt;MongoDB的基本操作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E7%9A%84%E7%AE%80%E4%BB%8B%E5%92%8C%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8&#34;&gt;MongoDB的简介和安装启动&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E4%BB%8B&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85&#34;&gt;安装&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95%E4%B8%80%E5%9F%BA%E4%BA%8Eyum%E6%BA%90&#34;&gt;方法一：基于yum源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95%E4%BA%8C%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6&#34;&gt;方法二：基于文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE&#34;&gt;配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E4%BE%8B%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;最简单的单例配置文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8&#34;&gt;启动&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bin%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%87%E4%BB%B6%E8%AF%B4%E6%98%8E&#34;&gt;bin目录下的几个文件说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96&#34;&gt;MongoDB服务器的启动优化&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E8%AF%B4%E6%98%8E&#34;&gt;mongodb启动优化说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%8C%96&#34;&gt;优化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8&#34;&gt;MongoDB客户端基础使用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D&#34;&gt;mongodb的基础概念介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%A2%E6%88%B7%E7%AB%AF&#34;&gt;客户端&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C&#34;&gt;数据操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E9%9B%86%E5%90%88%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F&#34;&gt;MongoDB集合的多种查询方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E7%B4%A2%E5%BC%95%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%BB%BA%E7%AB%8B&#34;&gt;MongoDB索引查询与建立&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%9B%91%E6%8E%A7%E5%91%BD%E4%BB%A4&#34;&gt;MongoDB数据库的监控命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%89%AF%E6%9C%AC%E9%9B%86&#34;&gt;MongoDB副本集&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E7%9A%84%E6%90%AD%E5%BB%BA&#34;&gt;MongoDB副本集的搭建&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;mongodb副本集配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A83%E4%B8%AAmongodb%E6%9C%8D%E5%8A%A1%E5%99%A8&#34;&gt;启动3个mongodb服务器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E5%85%B6%E7%8A%B6%E6%80%81%E6%9F%A5%E7%9C%8B&#34;&gt;mongodb副本集的初始化及其状态查看&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E6%95%85%E9%9A%9C%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2&#34;&gt;MongoDB副本集故障自动切换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;MongoDB副本集的优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%89%AF%E6%9C%AC%E9%9B%86%E7%9A%84%E4%BC%B8%E7%BC%A9&#34;&gt;MongoDB副本集的伸缩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E7%9A%84%E5%A4%87%E4%BB%BD%E5%92%8C%E6%81%A2%E5%A4%8D&#34;&gt;MongoDB的备份和恢复&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#python%E6%93%8D%E4%BD%9Cmongodb&#34;&gt;Python操作MongoDB&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#python%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9Cmongodb&#34;&gt;Python简单操作MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#python%E8%8E%B7%E5%8F%96mongodb%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF&#34;&gt;Python获取MongoDB的状态信息&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4&#34;&gt;MongoDB分片集群&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2&#34;&gt;MongoDB分片集群角色&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A43%E7%A7%8D%E8%A7%92%E8%89%B2&#34;&gt;mongodb分片集群3种角色&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E8%A7%92%E8%89%B2%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB&#34;&gt;分片集群角色之间的依赖关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE&#34;&gt;MongoDB分片集群配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B9%8Bconfigsvr&#34;&gt;MongoDB分片集群之configsvr&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B9%8Brouter&#34;&gt;MongoDB分片集群之router&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%B9%8Bsharedsvr&#34;&gt;MongoDB分片集群之sharedsvr&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mongodb%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4%E4%BD%BF%E7%94%A8&#34;&gt;MongoDB分片集群使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
参考:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.mongodb.org.cn/&#34;&gt;https://www.mongodb.org.cn/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.runoob.com/mongodb/mongodb-tutorial.html&#34;&gt;https://www.runoob.com/mongodb/mongodb-tutorial.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/chenmh/p/8681867.html&#34;&gt;https://www.cnblogs.com/chenmh/p/8681867.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;mongodb的基本操作&#34;&gt;MongoDB的基本操作&lt;/h1&gt;
&lt;h2 id=&#34;mongodb的简介和安装启动&#34;&gt;MongoDB的简介和安装启动&lt;/h2&gt;
&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mongodb是个非关系型数据库，但操作跟关系型数据最类似（mysql是关系型数据库）&lt;/li&gt;
&lt;li&gt;mongodb是面向文档存储的非关系型数据库，数据以json的格式进行存储&lt;/li&gt;
&lt;li&gt;mongodb可用来永久存储，也可用来缓存数据&lt;/li&gt;
&lt;li&gt;mongodb提供副本集和分片集群功能，操作简单&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;h4 id=&#34;方法一基于yum源&#34;&gt;方法一：基于yum源&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;配置yum源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/yum.repos.d/mongo.repo
    # 社区版
    [mongodb-org-4.2]
    name=MongoDB Repository
    baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/4.2/x86_64/
    gpgcheck=0
    enabled=1
    # gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc

    # 企业版
    [mongodb-enterprise-4.2]
    name=MongoDB Enterprise Repository
    baseurl=https://repo.mongodb.com/yum/redhat/$releasever/mongodb-enterprise/4.2/$basearch/
    gpgcheck=0
    enabled=1
    # gpgkey=https://www.mongodb.org/static/pgp/server-4.2.asc
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 社区版和企业版，二选一，这里选择社区版
yum install -y mongodb-org*
# 如果指定版本和组件包，则使用如下命令
# yum install -y mongodb-org-4.2.6 mongodb-org-server-4.2.6 mongodb-org-shell-4.2.6 mongodb-org-mongos-4.2.6 mongodb-org-tools-4.2.6
# 企业版安装：
# yum install -y mongodb-enterprise
# yum install -y mongodb-enterprise-4.2.6 mongodb-enterprise-server-4.2.6 mongodb-enterprise-shell-4.2.6 mongodb-enterprise-mongos-4.2.6 mongodb-enterprise-tools-4.2.6
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以指定任何可用的MongoDB版本。但是&lt;code&gt;yum&lt;/code&gt; ，当有新版本可用时，将升级软件包。为防止意外升级，请固定包装。要固定包，&lt;code&gt;exclude&lt;/code&gt;请在&lt;code&gt;/etc/yum.conf&lt;/code&gt;文件中添加以下指令：&lt;code&gt;exclude=mongodb-org,mongodb-org-server,mongodb-org-shell,mongodb-org-mongos,mongodb-org-tools&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;方法二基于文件&#34;&gt;方法二：基于文件&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果是局域网环境，可以下载指定版本的rpm文件进行安装&lt;/li&gt;
&lt;li&gt;下载压缩包进行解压运行，社区版地址：&lt;a href=&#34;https://www.mongodb.com/try/download/community&#34;&gt;https://www.mongodb.com/try/download/community&lt;/a&gt;和&lt;a href=&#34;https://www.mongodb.com/download-center/community/releases&#34;&gt;https://www.mongodb.com/download-center/community/releases&lt;/a&gt;，企业版地址：&lt;a href=&#34;https://www.mongodb.com/try/download/enterprise&#34;&gt;https://www.mongodb.com/try/download/enterprise&lt;/a&gt;和&lt;a href=&#34;https://www.mongodb.com/download-center/enterprise/releases&#34;&gt;https://www.mongodb.com/download-center/enterprise/releases&lt;/a&gt;，选择自己想要的版本和安装方式，然后进行下载安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 以安装二进制文件为例（解压即运行）
cd /usr/local/src
wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.4.1.tgz
tar -zxvf mongodb-linux-x86_64-rhel70-4.4.1.tgz
mv mongodb-linux-x86_64-rhel70-4.4.1/bin/* /usr/bin
# 验证是否安装成功
ll -h /usr/bin | grep mongo
mongod --help
mongod --version
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;h4 id=&#34;最简单的单例配置文件&#34;&gt;最简单的单例配置文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 创建数据和日志目录
mkdir -p /data/mongodb/27017/
vim /data/mongodb/27017/mongodb.conf
  # 日志
  systemLog:
    destination: file
    logAppend: true
    path: /data/mongodb/27017/mongodb.log
  # 存储
  storage:
    dbPath: /data/mongodb/27017/
    journal:
      enabled: true
  # 进程
  processManagement:
    fork: true
  # 网络
  net:
    port: 27017
    bindIp: 0.0.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;【注意事项】&lt;/strong&gt;：如果是公网服务器，建议监听在127.0.0.1&lt;/p&gt;
&lt;h3 id=&#34;启动&#34;&gt;启动&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;启动mongodb服务器：&lt;code&gt;/usr/local/mongodb/bin/mongod -f /data/mongodb/27017/mongodb.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;mongodb的启动验证：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ll -h /data/mongodb/27017/ #数据文件查看
ps auxf  | grep mongo   #进程查看
netstat -tulnp|grep mongo #端口查看
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;mongodb的关闭：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kill 关闭 #不建议，后续介绍正确的关闭方法
kill -9和突然断电可能会导致mongodb数据的丢失
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;bin目录下的几个文件说明&#34;&gt;bin目录下的几个文件说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mongo：客户端程序，连接MongoDB&lt;/li&gt;
&lt;li&gt;mongod：服务端程序，启动MongoDB&lt;/li&gt;
&lt;li&gt;mongodump：备份程序&lt;/li&gt;
&lt;li&gt;mongoexport：数据导出程序&lt;/li&gt;
&lt;li&gt;mongofiles：GridFS工具，内建的分布式文件系统&lt;/li&gt;
&lt;li&gt;mongoimport：数据导入程序&lt;/li&gt;
&lt;li&gt;mongorestore：数据恢复程序&lt;/li&gt;
&lt;li&gt;mongos：数据分片程序，支持数据的横向扩展&lt;/li&gt;
&lt;li&gt;mongostat：监视程序&lt;br&gt;
从4.4版本开始，mongostat等相关工具不再随着数据库安装包一起发布了，将单独作为一个安装包发布&lt;a href=&#34;https://docs.mongodb.com/database-tools&#34;&gt;MongoDB Database Tools project&lt;/a&gt;，涉及工具如下：mongoimport、mongoexport、mongodump、mongorestore、mongotop、mongostat、bsondump。如需要使用，需要单独下载安装，有rpm包和tar包两种。安装也很简单，就是复制文件到bin目录下就行了。&lt;br&gt;
工具的安装命令如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/src
wget https://repo.mongodb.org/yum/redhat/7/mongodb-org/4.2/x86_64/RPMS/mongodb-org-tools-4.2.9-1.el7.x86_64.rpm
yum localinstall -y mongodb-org-tools-4.2.9-1.el7.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb服务器的启动优化&#34;&gt;MongoDB服务器的启动优化&lt;/h2&gt;
&lt;p&gt;mongodb提供一个mongo客户端，类似于mysql提供的客户端命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mongo 127.0.0.1:27017
mongo #默认连接到127.0.0.1:27017
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mongodb启动优化说明&#34;&gt;mongodb启动优化说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine ---&amp;gt;&lt;code&gt;建议使用xfs的文件系统&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;WARNING&lt;/strong&gt;: Access control is not enabled for the database.Read and write access to data and configuration is unrestricted. ---&amp;gt;&lt;code&gt;建议进行用户权限设置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WARNING: You are running this process as the root user, which is not recommended. ---&amp;gt;&lt;code&gt;不建议以root用户运行（此建议可以不理）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WARNING: /sys/kernel/mm/transparent_hugepage/enabled is &#39;always&#39;.We suggest setting it to &#39;never&#39; ---&amp;gt;&lt;code&gt;建议禁止Linux的最大内存页&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WARNING: /sys/kernel/mm/transparent_hugepage/defrag is &#39;always&#39;.We suggest setting it to &#39;never&#39; ---&amp;gt;&lt;code&gt;建议禁止Linux的最大内存页&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;WARNING: soft rlimits too low. rlimits set to 3895 processes, 65535 files. Number of processes should be at least 32767.5 : 0.5 times number of files.---&amp;gt;&lt;code&gt;建议将用户进程数修改为65535&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;优化&#34;&gt;优化&lt;/h3&gt;
&lt;p&gt;具体的系统内核参数设置可以通过命令&lt;code&gt;ulimit -a&lt;/code&gt;进行查看&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;打开文件数和内核进程数限制放开方式如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/security/limits.conf
    * - nofile 102400
    * - nproc 65536
# 需要重新登录
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;禁止内存巨大页&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/rc.local
    echo &#39;never&#39; &amp;gt;/sys/kernel/mm/transparent_hugepage/enabled
    echo &#39;never&#39; &amp;gt;/sys/kernel/mm/transparent_hugepage/defrag 
chmod +x /etc/rc.d/rc.local #centos7默认rc.local没有执行权限，需要支持执行权限
# /etc/rc.d/rc.local 用于添加开机启动命令，/etc/rc.local是/etc/rc.d/rc.local的软连接
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;修改centos7默认的进程数限制&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/security/limits.d/20-nproc.conf
    *          soft    nproc     65536  # 修改为65536
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;使用普通用户启动mongodb&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;useradd mongodb -s /sbin/nologin
chown -R mongodb:mongodb /data/mongodb/ /usr/local/mongodb/
su - mongodb -s /bin/bash  #  - 改变工作目录为mongodb的用户目录；-s 指定要执行的 shell 
mongod -f /data/mongodb/27017/mongodb.conf 
# 检查是否启动成功
logout # 回到root环境
ps auxf  | grep mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb客户端基础使用&#34;&gt;MongoDB客户端基础使用&lt;/h2&gt;
&lt;h3 id=&#34;mongodb的基础概念介绍&#34;&gt;mongodb的基础概念介绍&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;database：数据库&lt;/li&gt;
&lt;li&gt;collection：集合，类似于mysql中的表&lt;/li&gt;
&lt;li&gt;filed：类似于mysql中字段&lt;/li&gt;
&lt;li&gt;document：每行的记录&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;客户端&#34;&gt;客户端&lt;/h3&gt;
&lt;p&gt;mongo客户端的命令自动提示功能（使用tab键）&lt;br&gt;
查询所有的库，默认自带三个库&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;show dbs
show databases
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;mongo客户端提供一个&lt;strong&gt;正确关闭mongodb服务器的方法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;use admin
db.shutdownServer()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# mongodb创建库、创建集合、插入数据(key value的字典方式插入)
use shijiange  #use即可，无需显式创建数据库
db.myuser.insert({ name: &#39;shijiange1&#39;, age:28 }) #无需显示创建collection
db.myuser.insert( {&#39;name&#39;: &#39;shijiange2&#39;, age: 27} )
db.myuser.insert( {&#39;name&#39;: &#39;shijiange3&#39;, age: 26} )
show dbs
    # admin      0.000GB
    # config     0.000GB
    # local      0.000GB
    # shijiange  0.000GB
show collections
    # myuser
show tables
    # myuser

#---------------------------------------------------------------------------

# 查询集合数据，默认有个_id
use shijiange
db.myuser.find()     #查询所有数据
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b33842e21a0f61eddeef6&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange1&amp;quot;, &amp;quot;age&amp;quot; : 28 }
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b341c4bffd59d8b427d3a&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange2&amp;quot;, &amp;quot;age&amp;quot; : 27 }
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b34234bffd59d8b427d3b&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange3&amp;quot;, &amp;quot;age&amp;quot; : 26 }
db.myuser.find( { name: &#39;shijiange1&#39; } )
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b33842e21a0f61eddeef6&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange1&amp;quot;, &amp;quot;age&amp;quot; : 28 }
db.myuser.find( { age: 26 } )
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b34234bffd59d8b427d3b&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange3&amp;quot;, &amp;quot;age&amp;quot; : 26 }

#---------------------------------------------------------------------------

# 删除集合数据
use shijiange
db.myuser.remove({ name: &#39;shijiange2&#39; }) #有条件的删除
db.myuser.find()
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b33842e21a0f61eddeef6&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange1&amp;quot;, &amp;quot;age&amp;quot; : 28 }
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b34234bffd59d8b427d3b&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange3&amp;quot;, &amp;quot;age&amp;quot; : 26 }
db.myuser.remove( {} )      #删除数据
db.myuser.drop()      #删除集合

# 集合的field虽然不需要固定，但是一般来说不这样子使用
db.myuser.insert( {age: 28} )
db.myuser.insert( {&#39;location&#39;: &#39;hangzhou&#39;} )
db.myuser.find()

# 更新集合数据
use shijiange;
db.myuser.update({ &#39;location&#39;: &#39;hangzhou&#39; }, { $set: { &#39;location&#39;: &#39;shanghai&#39; } })
db.myuser.update({ age: 28 }, {$set: { age: 30 }})

# 删除数据库
use shijiange
db.dropDatabase()
# 【注意】：mongodb自带的三个库不要动
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb集合的多种查询方式&#34;&gt;MongoDB集合的多种查询方式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# collection数据准备
use shijiange
db.myuser.insert( {name:&amp;quot;shijiange1&amp;quot;, age: 20} )
db.myuser.insert( {name:&amp;quot;shijiange2&amp;quot;, age: 28} )
db.myuser.insert( {name:&amp;quot;shijiange3&amp;quot;, age: 38} )
db.myuser.insert( {name:&amp;quot;zhangsan1&amp;quot;, age: 58} )
db.myuser.insert( {name:&amp;quot;zhangsan2&amp;quot;, age: 68} )
db.myuser.insert( {name:&amp;quot;zhangsan3&amp;quot;, age: 25} )

# pretty易读的方式
db.myuser.find().pretty()

# 查询数据总共的记录数
db.myuser.find().count()

# limit限制条数查询
db.myuser.find()
db.myuser.find().limit(2)    #查看前面两条记录
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b39cefe38c3fe6a2b7f3e&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange1&amp;quot;, &amp;quot;age&amp;quot; : 20 }
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b39cefe38c3fe6a2b7f3f&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange2&amp;quot;, &amp;quot;age&amp;quot; : 28 }

# 使用skip跳过记录
db.myuser.find().skip(2).limit(2)
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b39cefe38c3fe6a2b7f40&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;shijiange3&amp;quot;, &amp;quot;age&amp;quot; : 38 }
    # { &amp;quot;_id&amp;quot; : ObjectId(&amp;quot;5f5b39cefe38c3fe6a2b7f41&amp;quot;), &amp;quot;name&amp;quot; : &amp;quot;zhangsan1&amp;quot;, &amp;quot;age&amp;quot; : 58 }

# mongodb分页查询（每次显示两条，递进显示）
db.myuser.find().skip(0).limit(2)
db.myuser.find().skip(2).limit(2)
db.myuser.find().skip(4).limit(2)

# 使用sort进行排序
db.myuser.find().sort({ age: 1 }) #按age升序
db.myuser.find().sort({ age: -1 }) #按age降序

# 根据字段进行数字比较查询
db.myuser.find({ age: {$lt: 30} })
    # $gt:大于；$lt:小于；$gte:大于或等于；$lte:小于或等于

# 查询多种条件的组合
db.myuser.find( {name: &#39;shijiange1&#39;} )
db.myuser.find( {name: &#39;shijiange2&#39;} )
db.myuser.find({ $or: [ {name: &#39;shijiange1&#39;},{name: &#39;shijiange2&#39;} ] })
db.myuser.find({ $and: [ {name: &#39;shijiange1&#39;},{age: 20} ] })

# mongodb正则查询，支持普通正则和扩展正则
db.myuser.find({ name: {$regex: &amp;quot;shijiange[1-9]&amp;quot;} }) #普通正则过滤
db.myuser.find( {&amp;quot;name&amp;quot;:{$regex:&amp;quot;(zhangsan)&amp;quot;}} )   #支持分组正则
db.myuser.find({ $and: [ {name:  {$regex: &amp;quot;shijiange[1-9]&amp;quot;}},{age: 20} ] })
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb索引查询与建立&#34;&gt;MongoDB索引查询与建立&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# mongodb数据准备
use shijiange
for(i=1; i&amp;lt;=500000;i++){
  db.myuser.insert( {name:&#39;mytest&#39;+i, age:i} )
}

# mongodb有慢查询的概念，默认是超过100ms会记录慢日志mongodb.log
db.getProfilingStatus()
    # { &amp;quot;was&amp;quot; : 0, &amp;quot;slowms&amp;quot; : 100, &amp;quot;sampleRate&amp;quot; : 1 } # 100为100ms
# 查询age为9999的，查看扫描的行数
# tail -f /data/mongodb/27017/mongodb.log  # 在另一个终端中执行
db.myuser.find( {age:9999} )
db.myuser.find( {age:9999} ).explain(true) #使用explain可以查看是否全表扫描
# 每查询一次，会多出如下一条日志记录：
# {&amp;quot;t&amp;quot;:{&amp;quot;$date&amp;quot;:&amp;quot;2020-09-11T17:24:01.364+08:00&amp;quot;},&amp;quot;s&amp;quot;:&amp;quot;I&amp;quot;,  &amp;quot;c&amp;quot;:&amp;quot;COMMAND&amp;quot;,  &amp;quot;id&amp;quot;:51803,   &amp;quot;ctx&amp;quot;:&amp;quot;conn3&amp;quot;,&amp;quot;msg&amp;quot;:&amp;quot;Slow query&amp;quot;,&amp;quot;attr&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;command&amp;quot;,&amp;quot;ns&amp;quot;:&amp;quot;shijiange.myuser&amp;quot;,&amp;quot;appName&amp;quot;:&amp;quot;MongoDB Shell&amp;quot;,&amp;quot;command&amp;quot;:{&amp;quot;find&amp;quot;:&amp;quot;myuser&amp;quot;,&amp;quot;filter&amp;quot;:{&amp;quot;age&amp;quot;:9999.0},&amp;quot;lsid&amp;quot;:{&amp;quot;id&amp;quot;:{&amp;quot;$uuid&amp;quot;:&amp;quot;b6e162bc-a7d7-4efb-9d6f-e717606b8f67&amp;quot;}},&amp;quot;$db&amp;quot;:&amp;quot;shijiange&amp;quot;},&amp;quot;planSummary&amp;quot;:&amp;quot;COLLSCAN&amp;quot;,&amp;quot;keysExamined&amp;quot;:0,&amp;quot;docsExamined&amp;quot;:500000,&amp;quot;cursorExhausted&amp;quot;:true,&amp;quot;numYields&amp;quot;:500,&amp;quot;nreturned&amp;quot;:1,&amp;quot;queryHash&amp;quot;:&amp;quot;3838C5F3&amp;quot;,&amp;quot;planCacheKey&amp;quot;:&amp;quot;3838C5F3&amp;quot;,&amp;quot;reslen&amp;quot;:164,&amp;quot;locks&amp;quot;:{&amp;quot;ReplicationStateTransition&amp;quot;:{&amp;quot;acquireCount&amp;quot;:{&amp;quot;w&amp;quot;:501}},&amp;quot;Global&amp;quot;:{&amp;quot;acquireCount&amp;quot;:{&amp;quot;r&amp;quot;:501}},&amp;quot;Database&amp;quot;:{&amp;quot;acquireCount&amp;quot;:{&amp;quot;r&amp;quot;:501}},&amp;quot;Collection&amp;quot;:{&amp;quot;acquireCount&amp;quot;:{&amp;quot;r&amp;quot;:501}},&amp;quot;Mutex&amp;quot;:{&amp;quot;acquireCount&amp;quot;:{&amp;quot;r&amp;quot;:1}}},&amp;quot;storage&amp;quot;:{},&amp;quot;protocol&amp;quot;:&amp;quot;op_msg&amp;quot;,&amp;quot;durationMillis&amp;quot;:137}}

# 添加索引，加快查询
db.myuser.getIndexes()    #获取当前索引，默认有_id的索引，所以用_id查是比较快
db.myuser.ensureIndex( {age:1} )  #增加age的升序索引
db.myuser.getIndexes()
db.myuser.find( {age:9999} )
db.myuser.find( {age:9999} ).explain(true)
db.myuser.dropIndex( {age:1} )  #删除索引

# 使用正则的话，索引无效果
db.myuser.find( {&amp;quot;name&amp;quot;:&amp;quot;mytest1&amp;quot;} )
db.myuser.ensureIndex( {name:1} )   #添加索引
db.myuser.find( {&amp;quot;name&amp;quot;:&amp;quot;mytest6&amp;quot;} )
db.myuser.find( {&amp;quot;name&amp;quot;:/99999/} )
db.myuser.find( {&amp;quot;name&amp;quot;:/99999/} ).explain(true)  #使用正则，全表扫描，也是慢

# mongodb建立唯一索引，唯一索引对应的值不能重复
use shijiange
db.myuser.insert( {userid:1} )
db.myuser.insert( {userid:1} ) # 此时没有建立唯一索引，是可以插入重复值的
db.myuser.remove({})   #清空数据
db.myuser.ensureIndex( {userid:1},{unique:true} )  #创建唯一索引
db.myuser.insert( {userid:1} )
db.myuser.insert( {userid:2} )
db.myuser.insert( {userid:1} )      #因为是唯一索引，所以会报错
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mongodb数据库的监控命令&#34;&gt;MongoDB数据库的监控命令&lt;/h1&gt;
&lt;p&gt;mongostat可以实时监控mongodb的状态，一直刷新输出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mongostat --help
mongostat  -h 127.0.0.1:27017
mongostat  # 默认监控127.0.0.1:27017

# 测试脚本
use shijiange
for(i=1; i&amp;lt;=300000;i++){
  db.myuser.insert( {name:&#39;mytest&#39;+i, age:i} )
}

# mongodb监控之serverStatus。serverStatus可用来获取mongodb的状态信息
db.serverStatus()   #查看所有的监控信息
db.serverStatus().network #单独查看网络流量信息
db.serverStatus().opcounters #统计增、删、改、查的次数
db.serverStatus().connections #连接

# 使用非交互式shell进行获取
echo &#39;db.serverStatus()&#39; | mongo
echo &#39;db.serverStatus().opcounters&#39; | mongo
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mongodb副本集&#34;&gt;MongoDB副本集&lt;/h1&gt;
&lt;p&gt;mongodb单台服务器，数据会有丢失的风险，且单台服务器无法做高可用性。&lt;br&gt;
mongodb副本集能够预防数据丢失，多台mongodb数据一致，mongodb副本集能够在有问题的时候自动切换。&lt;/p&gt;
&lt;h2 id=&#34;mongodb副本集的搭建&#34;&gt;MongoDB副本集的搭建&lt;/h2&gt;
&lt;p&gt;实验环境介绍：使用3台服务器实战mongodb副本集，&lt;strong&gt;生产环境中建议至少三台服务器&lt;/strong&gt;&lt;br&gt;
3台服务器的ip为：192.168.1.202、192.168.1.203、192.168.1.204&lt;/p&gt;
&lt;h3 id=&#34;mongodb副本集配置文件&#34;&gt;mongodb副本集配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置文件
vim /data/mongodb/27017/mongodb.conf
    # 日志
    systemLog:
      destination: file
      logAppend: true
      path: /data/mongodb/27017/mongodb.log
    # 存储
    storage:
      dbPath: /data/mongodb/27017/
      journal:
        enabled: true
    # 进程
    processManagement:  
      fork: true
    # 网络
    net:   
      port: 27017
      bindIp: 0.0.0.0
    # 副本集
    replication:   
      replSetName: shijiange # 目前MongoDB提供了三种Replication方式：Matser/Matser, Matser/Slave,Replica Sets
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;启动3个mongodb服务器&#34;&gt;启动3个mongodb服务器&lt;/h3&gt;
&lt;p&gt;需要对应更改端口、数据目录、日志路径&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 192.168.1.202、192.168.1.203、192.168.1.204
su - mongodb -s /bin/bash
mongod -f /data/mongodb/27017/mongodb.conf  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mongodb副本集的初始化及其状态查看&#34;&gt;mongodb副本集的初始化及其状态查看&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 192.168.1.202，只需要在其中一台上进行初始化即可
mongo
use admin
config = { _id:&amp;quot;shijiange&amp;quot;, members:[
  {_id:0,host:&amp;quot;192.168.1.202:27017&amp;quot;},
  {_id:1,host:&amp;quot;192.168.1.203:27017&amp;quot;},
  {_id:2,host:&amp;quot;192.168.1.204:27017&amp;quot;}]
}
rs.initiate( config ) #副本集初始化，需要一定时间
rs.status()  #副本集状态，一个PRIMARY（192.168.1.202），其它SECONDARY。PRIMARY是主，只有PRIMARY能写入

# 测试副本集的数据同步
# 在PRIMARY那台机器上
mongo
use shijiange
db.myuser.insert( {name:&amp;quot;shijiange1&amp;quot;, age: 20} )
db.myuser.insert( {name:&amp;quot;shijiange2&amp;quot;, age: 28} )
db.myuser.insert( {name:&amp;quot;shijiange3&amp;quot;, age: 38} )
db.myuser.insert( {name:&amp;quot;zhangsan1&amp;quot;, age: 58} )
db.myuser.insert( {name:&amp;quot;zhangsan2&amp;quot;, age: 68} )
db.myuser.insert( {name:&amp;quot;zhangsan3&amp;quot;, age: 25} )

# 在SECONDARY机器上查看
rs.secondaryOk() #4.4版本是rs.secondaryOk()，4.0版本是rs.slaveOk()。SECONDARY需要声明是slave才能查看数据【从库无法插入数据】
use shijiange
db.myuser.find()

# 查看slave的延时情况（所有机器都可以执行）
rs.printSlaveReplicationInfo()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb副本集故障自动切换&#34;&gt;MongoDB副本集故障自动切换&lt;/h2&gt;
&lt;p&gt;mongodb的副本集当primary挂了，会挑选其中的一台secondary升为主。挑选其中一台secondary升级为primary的条件是剩下的集群台数&amp;gt;=2，如果集群只剩下一个实例的话，会有异常。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#mongodb副本集自动切换演示
mongo #连接到primary
use admin
db.shutdownServer() #关闭主mongodb，会有其它mongodb提升为主。插入数据正常

# 关闭第二台
mongo
use admin
db.shutdownServer() #关闭两台mongodb的话，剩下一台不会提升为primary，插入数据将异常

# 同时启动192.168.1.202和192.168.1.203，没有固定的主，可通过优先级指定primary
mongod -f /data/mongodb/27017/mongodb.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb副本集的优先级&#34;&gt;MongoDB副本集的优先级&lt;/h2&gt;
&lt;p&gt;primary的选举依赖于各个实例的优先权重，默认权重都是1。副本集的主挑选权重最高的，权重一样的无法控制谁为主。&lt;br&gt;
设置各个实例的优先权重，挑选自己想要的实例为主，&lt;strong&gt;只有primary可以更改权重配置&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;conf = rs.config()   #获取副本集的配置，默认权重都是1
conf.members[0].priority = 5 #索引号从0开始，每次递增1，类似数组（目前这台为primary）
conf.members[1].priority = 10  
conf.members[2].priority = 15 # 让这台变成primary
rs.reconfig(conf)   #更新mongodb副本集的配置，优先权重最高的提升为primary，关闭启动后也为主
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb副本集的伸缩&#34;&gt;MongoDB副本集的伸缩&lt;/h2&gt;
&lt;p&gt;mongodb副本集的扩展非常好，往副本集里添加实例和移除实例都非常方便。往mongodb副本集添加实例数据能够自动同步，无需人工干预。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 往现有mongodb副本集中添加实例
# 创建mongodb_4(192.168.1.205)实例，配置和前三台机器一样（虚拟机克隆），注意副本集名称要保持一致replSetName: shijiange
# 连接primary（192.168.1.202）
mongo
use admin
rs.add(&#39;192.168.1.205:27017&#39;) #数据是自动同步
# rs.add的优先权重默认为1，id是顺序递增的

# 从mongodb副本集中移除实例，不可移除primary
use admin
rs.remove(&#39;192.168.1.204:27017&#39;)  # 状态由secondary变成other

# 副本集经过添加删除后顺序会乱，设置权重需要注意
rs.config() #获取到后，需要注意每个实例的位置。id不改变，即移除2之后，3不会变成2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb的备份和恢复&#34;&gt;MongoDB的备份和恢复&lt;/h2&gt;
&lt;p&gt;单台服务器一定需要备份，mongodump工具用来备份数据，mongorestore工具用来恢复数据。&lt;br&gt;
mongodb备份说明需要指定ip和端口，单台服务器直接使用mongodump进行备份，副本集需要连接到primary上备份。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 数据清空，启动单台mongodb(192.168.1.202)
vim /data/mongodb/27017/mongodb.conf
    # 日志
    systemLog:
    destination: file
    logAppend: true
    path: /data/mongodb/27017/mongodb.log
    # 存储
    storage:
    dbPath: /data/mongodb/27017/
    journal:
        enabled: true
    # 进程
    processManagement:
    fork: true
    # 网络
    net:
    port: 27017
    bindIp: 0.0.0.0

mongod -f /data/mongodb/27017/mongodb.conf
mongo
use shijiange
db.myuser.insert( {name:&amp;quot;shijiange1&amp;quot;, age: 20} )
db.myuser.insert( {name:&amp;quot;shijiange2&amp;quot;, age: 28} )
db.myuser.insert( {name:&amp;quot;shijiange3&amp;quot;, age: 38} )
db.myuser.insert( {name:&amp;quot;zhangsan1&amp;quot;, age: 58} )
db.myuser.insert( {name:&amp;quot;zhangsan2&amp;quot;, age: 68} )
db.myuser.insert( {name:&amp;quot;zhangsan3&amp;quot;, age: 25} )

# mongodb数据库的备份，备份所有库
mkdir -p /data/mongodbbackup/
mongodump -h 127.0.0.1:27017 -o /data/mongodbbackup/  # 备份所有的库
ll -h /data/mongodbbackup/
    # drwxr-xr-x 2 root root 69 9月  14 17:20 admin
    # drwxr-xr-x 2 root root 53 9月  14 17:20 shijiange

# mongodb数据库的恢复
# 先删除之前的数据
mongorestore -h 127.0.0.1:27017 /data/mongodbbackup/
# 测试数据是否恢复成功
mongo
show dbs
use shijiange
db.myuser.find()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;python操作mongodb&#34;&gt;Python操作MongoDB&lt;/h1&gt;
&lt;p&gt;mongodb可以使用java、python、php等语言去操作，运维使用Python居多，介绍使用python操作Mongodb数据库。&lt;/p&gt;
&lt;h2 id=&#34;python简单操作mongodb&#34;&gt;Python简单操作MongoDB&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 使用python操作mongodb，需要使用pip安装pymongo模块
# centos7(python2)
yum -y install epel-release python2-pip
pip install pymongo
# windows(python3)
pip install pymongo

# 连接代码，单实例的连接代码
import pymongo 
client = pymongo.MongoClient( &#39;192.168.1.202&#39;, 27017 )
shijiange=client.shijiange
myuser = shijiange.myuser
for item in myuser.find():
  print(item)
    # runfile(&#39;C:/Users/Administrator/.spyder-py3/temp.py&#39;, wdir=&#39;C:/Users/Administrator/.spyder-py3&#39;)
    # {&#39;_id&#39;: ObjectId(&#39;5f5f355cc7bc18dcf8165033&#39;), &#39;name&#39;: &#39;shijiange1&#39;, &#39;age&#39;: 20.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f355cc7bc18dcf8165034&#39;), &#39;name&#39;: &#39;shijiange2&#39;, &#39;age&#39;: 28.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f355cc7bc18dcf8165035&#39;), &#39;name&#39;: &#39;shijiange3&#39;, &#39;age&#39;: 38.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f355cc7bc18dcf8165036&#39;), &#39;name&#39;: &#39;zhangsan1&#39;, &#39;age&#39;: 58.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f355cc7bc18dcf8165037&#39;), &#39;name&#39;: &#39;zhangsan2&#39;, &#39;age&#39;: 68.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f355dc7bc18dcf8165038&#39;), &#39;name&#39;: &#39;zhangsan3&#39;, &#39;age&#39;: 25.0}

# pymongo副本集的连接代码，代码支持自动切换
import pymongo
client = pymongo.MongoClient( [&#39;192.168.1.203:27017&#39;, &#39;192.168.1.205:27017&#39;] )
shijiange = client.shijiange
myuser = shijiange.myuser
myvar = {&#39;age&#39;:20, &#39;name&#39;: &#39;shijiange&#39;}
myuser.insert(myvar)
for item in myuser.find():
  print(item)
    # runfile(&#39;C:/Users/Administrator/.spyder-py3/temp.py&#39;, wdir=&#39;C:/Users/Administrator/.spyder-py3&#39;)
    # {&#39;_id&#39;: ObjectId(&#39;5f5f3076d0a7709cefe0eea6&#39;), &#39;name&#39;: &#39;shijiange1&#39;, &#39;age&#39;: 20.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f3076d0a7709cefe0eea7&#39;), &#39;name&#39;: &#39;shijiange2&#39;, &#39;age&#39;: 28.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f3076d0a7709cefe0eea9&#39;), &#39;name&#39;: &#39;zhangsan1&#39;, &#39;age&#39;: 58.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f3076d0a7709cefe0eea8&#39;), &#39;name&#39;: &#39;shijiange3&#39;, &#39;age&#39;: 38.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f3076d0a7709cefe0eeaa&#39;), &#39;name&#39;: &#39;zhangsan2&#39;, &#39;age&#39;: 68.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f307dd0a7709cefe0eeab&#39;), &#39;name&#39;: &#39;zhangsan3&#39;, &#39;age&#39;: 25.0}
    # {&#39;_id&#39;: ObjectId(&#39;5f5f86463670b531ec7837c6&#39;), &#39;age&#39;: 20, &#39;name&#39;: &#39;shijiange&#39;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;python获取mongodb的状态信息&#34;&gt;Python获取MongoDB的状态信息&lt;/h2&gt;
&lt;p&gt;使用Python去监控mongodb状态，获取mongodb的serverStatus状态信息，一般状态信息需要每个实例都进行监控&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 获取状态信息
import pymongo 
client = pymongo.MongoClient(&#39;192.168.1.202&#39;,27017)
db = client.admin
serverStatus = db.command(&#39;serverStatus&#39;)
print(serverStatus)

# 每个状态信息单独打印
import pymongo
client = pymongo.MongoClient(&#39;192.168.1.202&#39;,27017)
db = client.admin
serverStatus = db.command(&#39;serverStatus&#39;)
for key,value in serverStatus.items():
  print(key, value)
  print()

# MongoDB建议的监控方向
# connections，连接信息；network ，流量信息；opcounters，增删改查信息
# 状态信息获取
import pymongo 
client = pymongo.MongoClient(&#39;192.168.1.202&#39;,27017)
db = client.admin
serverStatus = db.command(&#39;serverStatus&#39;)
print(serverStatus[&#39;connections&#39;])
print(serverStatus[&#39;network&#39;])
print(serverStatus[&#39;opcounters&#39;])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;mongodb分片集群&#34;&gt;MongoDB分片集群&lt;/h1&gt;
&lt;p&gt;mongodb分片一般用得比较少，需要较多的服务器，还有三种的角色，一般把mongodb的副本集应用得好就足够用了，可搭建多套mongodb副本集。&lt;br&gt;
mongodb分片技术，mongodb副本集可以&lt;strong&gt;解决数据备份、读性能&lt;/strong&gt;的问题，但由于&lt;strong&gt;mongodb副本集是每份数据都一模一样的，无法解决数据量过大问题&lt;/strong&gt;。&lt;br&gt;
mongodb分片技术&lt;strong&gt;能够把数据分成两份存储&lt;/strong&gt;，假如shijiange.myuser里面有1亿条数据，分片能够实现5千万左右存储在data1，5千万左右存储在data2，data1、data2需要使用副本集的形式，预防数据丢失。&lt;/p&gt;
&lt;h2 id=&#34;mongodb分片集群角色&#34;&gt;MongoDB分片集群角色&lt;/h2&gt;
&lt;h3 id=&#34;mongodb分片集群3种角色&#34;&gt;mongodb分片集群3种角色&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;router角色：mongodb的路由，提供入口，使得分片集群对外透明。router不存储数据&lt;/li&gt;
&lt;li&gt;configsvr角色：mongodb的配置角色，存储元数据信息。分片集群后端有多份存储，读取数据该去哪个存储上读取，依赖于配置角色。配置角色&lt;strong&gt;建议使用副本集&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;shardsvr角色：mongodb的存储角色，存储真正的数据。&lt;strong&gt;建议使用副本集&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;分片集群角色之间的依赖关系&#34;&gt;分片集群角色之间的依赖关系&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;当用户通过router角色&lt;strong&gt;插入数据&lt;/strong&gt;时，需要从configsvr知道这份数据插入到哪个节点，然后执行插入动作插入数据到sharedsvr&lt;/li&gt;
&lt;li&gt;当用户通过router角色&lt;strong&gt;获取数据&lt;/strong&gt;时，需要从configsvr知道这份数据是存储在哪个节点，然后再去sharedsvr获取数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mongodb分片集群配置&#34;&gt;MongoDB分片集群配置&lt;/h2&gt;
&lt;p&gt;mongodb分片集群的&lt;strong&gt;搭建说明&lt;/strong&gt;：使用同一份mongodb二进制文件，修改对应的配置就能实现分片集群的搭建&lt;br&gt;
mongodb分片集群实战环境搭建说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;router：使用&lt;code&gt;192.168.1.202&lt;/code&gt;来搭建&lt;/li&gt;
&lt;li&gt;configsvr：使用&lt;code&gt;192.168.1.203&lt;/code&gt;和&lt;code&gt;192.168.1.204&lt;/code&gt;来搭建&lt;/li&gt;
&lt;li&gt;shardsvr：使用&lt;code&gt;192.168.1.205&lt;/code&gt;、&lt;code&gt;192.168.1.206&lt;/code&gt;、&lt;code&gt;192.168.1.207&lt;/code&gt;、&lt;code&gt;192.168.1.208&lt;/code&gt;来搭建，&lt;code&gt;192.168.1.205&lt;/code&gt;和&lt;code&gt;192.168.1.206&lt;/code&gt;为一个集群，&lt;code&gt;192.168.1.207&lt;/code&gt;和&lt;code&gt;192.168.1.208&lt;/code&gt;为一个集群&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mongodb分片集群之configsvr&#34;&gt;MongoDB分片集群之configsvr&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 192.168.1.203和192.168.1.204
vim /data/mongodb/27017/mongodb.conf
    # 日志
    systemLog:
      destination: file
      logAppend: true
      path: /data/mongodb/27017/mongodb.log
    # 存储
    storage:
      dbPath: /data/mongodb/27017/
      journal:
        enabled: true
    # 进程
    processManagement:
      fork: true
    # 网络
    net:
      port: 27017
      bindIp: 0.0.0.0
    # 副本集
    replication:
      replSetName: shijiangeconf
    # 分片角色  
    sharding:
      clusterRole: configsvr
# mongodb配置服务集群的启动跟单例的启动方式一致，都是使用mongod
mongod -f /data/mongodb/27017/mongodb.conf

# 分片集群的配置角色副本集搭建
mongo
config = { _id:&amp;quot;shijiangeconf&amp;quot;, 
  configsvr: true,
  members:[
    {_id:0,host:&amp;quot;192.168.1.203:27017&amp;quot;},
    {_id:1,host:&amp;quot;192.168.1.204:27017&amp;quot;}
  ]
}
rs.initiate(config)
# 在SECONDARY机器上查看
rs.secondaryOk() #4.4版本是rs.secondaryOk()，4.0版本是rs.slaveOk()

# 验证是否搭建成功(192.168.1.203、192.168.1.204)
mongo
rs.status()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mongodb分片集群之router&#34;&gt;MongoDB分片集群之router&lt;/h3&gt;
&lt;p&gt;router最重要的配置：指定configsvr的地址，使用&lt;code&gt;configsvr副本集id(replSetName)/ip:port&lt;/code&gt;的方式指定。如果配置多个router，任何一个都能正常的获取数据。&lt;br&gt;
&lt;strong&gt;使用mongos启动，而不是mongod&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /data/mongodb/27017/mongodb.conf
    # 日志
    systemLog:
      destination: file
      logAppend: true
      path: /data/mongodb/27017/mongodb.log
    # 进程
    processManagement:
      fork: true
    # 网络
    net:
      port: 27017
      bindIp: 0.0.0.0
    # 分片角色
    sharding:
      configDB: shijiangeconf/192.168.1.203:27017,192.168.1.204:27017
# router的启动
mongos -f /data/mongodb/27017/mongodb.conf

# router的验证：需要等到数据角色搭建完才能够进行验证
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mongodb分片集群之sharedsvr&#34;&gt;MongoDB分片集群之sharedsvr&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 数据角色shijiangedata1：192.168.1.205和192.168.1.206
vim /data/mongodb/27017/mongodb.conf
    # 日志
    systemLog:
      destination: file
      logAppend: true
      path: /data/mongodb/29017/mongodb.log
    # 存储
    storage:
      dbPath: /data/mongodb/29017/
      journal:
        enabled: true
    # 进程
    processManagement:
      fork: true
    # 网络
    net:
      port: 27017
      bindIp: 0.0.0.0
    # 副本集
    replication:
      replSetName: shijiangedata1
    # 分片
    sharding:
      clusterRole: shardsvr
# 数据角色shijiangedata2：192.168.1.207和192.168.1.208
vim /data/mongodb/27017/mongodb.conf
    # 日志
    systemLog:
      destination: file
      logAppend: true
      path: /data/mongodb/29017/mongodb.log
    # 存储
    storage:
      dbPath: /data/mongodb/29017/
      journal:
        enabled: true
    # 进程
    processManagement:
      fork: true
    # 网络
    net:
      port: 27017
      bindIp: 0.0.0.0
    # 副本集
    replication:
      replSetName: shijiangedata2
    # 分片
    sharding:
      clusterRole: shardsvr

# 启动4个数据实例
mongod -f /data/mongodb/27017/mongodb.conf

# 数据角色shjiangedata1：192.168.1.205和192.168.1.206
mongo
config = { _id:&amp;quot;shijiangedata1&amp;quot;, 
  members:[
    {_id:0,host:&amp;quot;192.168.1.205:27017&amp;quot;},
    {_id:1,host:&amp;quot;192.168.1.206:27017&amp;quot;}
  ]
}
rs.initiate(config)
# 在SECONDARY机器上查看
rs.secondaryOk() #4.4版本是rs.secondaryOk()，4.0版本是rs.slaveOk()

# 数据角色shjiangedata2：192.168.1.207和192.168.1.208
mongo
config = { _id:&amp;quot;shijiangedata2&amp;quot;, 
  members:[
    {_id:0,host:&amp;quot;192.168.1.207:27017&amp;quot;},
    {_id:1,host:&amp;quot;192.168.1.208:27017&amp;quot;}
  ]
}
rs.initiate(config)
# 在SECONDARY机器上查看
rs.secondaryOk() #4.4版本是rs.secondaryOk()，4.0版本是rs.slaveOk()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mongodb分片集群使用&#34;&gt;MongoDB分片集群使用&lt;/h2&gt;
&lt;p&gt;所有的操作都是在route路由角色中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 分片集群添加数据角色，连接到路由角色里面配置，数据角色为副本集的方式
# 在角色route(192.168.1.202)上执行
mongo
sh.addShard(&amp;quot;shijiangedata1/192.168.1.205:27017,192.168.1.206:27017&amp;quot;)
sh.addShard(&amp;quot;shijiangedata2/192.168.1.207:27017,192.168.1.208:27017&amp;quot;)
sh.status()

# 默认添加数据没有分片存储，操作都是在路由角色里面
use shijiange
for(i=1; i&amp;lt;=500;i++){
  db.myuser.insert( {name:&#39;mytest&#39;+i, age:i} )
}
# 此时只有在shijiangedata2（或shijiangedata1）上有数据
db.dropDatabase() #验证完后删除

# 针对某个数据库的某个表使用hash分片存储，分片存储就会同一个colloection分配两个数据角色
use admin  # 此操作只能使用admin用户执行
db.runCommand( { enablesharding :&amp;quot;shijiange&amp;quot;});
db.runCommand( { shardcollection : &amp;quot;shijiange.myuser&amp;quot;,key : {_id: &amp;quot;hashed&amp;quot;} } )

# 插入数据校验，分布在两个数据角色上
use shijiange
for(i=1; i&amp;lt;=500;i++){
  db.myuser.insert( {name:&#39;mytest&#39;+i, age:i} )
}
# 此时在shijiangedata2（268条）和shijiangedata1（232条）上各有250条数据
&lt;/code&gt;&lt;/pre&gt;
">MongoDB学习笔记整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/geng-huan-pip-yuan/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#windows&#34;&gt;windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#linux&#34;&gt;Linux&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%91%E8%8E%93%E6%B4%BE&#34;&gt;树莓派&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
以阿里的镜像源为例，主要用于替换国内的pip源和替换用于内部网络的pip源&lt;/p&gt;
&lt;h1 id=&#34;windows&#34;&gt;windows&lt;/h1&gt;
&lt;p&gt;win+R --&amp;gt; %APPDATA%（或者%USERPROFILE%，这两个目录均可） --&amp;gt; 新建目录pip并进入 --&amp;gt; 新建文件pip.ini，并写入以下内容&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;[global]
timeout=6000
trusted-host=mirrors.aliyun.com
index-url=https://mirrors.aliyun.com/pypi/simple/
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;linux&#34;&gt;Linux&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt; ~/.pip/pip.conf &amp;lt;&amp;lt;EOF
[global]
timeout=6000
trusted-host=mirrors.aliyun.com
index-url=https://mirrors.aliyun.com/pypi/simple/
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;树莓派&#34;&gt;树莓派&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/etc/pip.conf &amp;lt;&amp;lt;EOF
[global]
timeout=6000
trusted-host=mirrors.aliyun.com
index-url=https://mirrors.aliyun.com/pypi/simple/
EOF
&lt;/code&gt;&lt;/pre&gt;
">更换pip源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/jin-yong-ipv6/"" data-c="
          &lt;p&gt;有的时候在使用wget下载文件的时候，默认使用ipv6地址进行解析，导致无法解析域名或者下载速度很慢，此时便需要禁用ipv6地址，具体方法如下：&lt;br&gt;
永久生效：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vi /etc/sysctl.conf
    # 全部网卡禁用ipv6
    net.ipv6.conf.all.disable_ipv6 =1
    net.ipv6.conf.default.disable_ipv6 =1
    # 指定网卡(enp0s3)禁用ipv6\
    net.ipv6.conf.enp0s3.disable_ipv6 =1
sysctl -p  # 使配置文件生效
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;临时生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo 1&amp;gt;/proc/sys/net/ipv6/conf/all/disable_ipv6
echo 1&amp;gt;/proc/sys/net/ipv6/conf/default/disable_ipv6
# 或者
sysctl -w net.ipv6.conf.all.disable_ipv6=1
sysctl -w net.ipv6.conf.default.disable_ipv6=1
&lt;/code&gt;&lt;/pre&gt;
">禁用IPv6</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/centos-guan-li-huan-jing-bian-liang/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F&#34;&gt;设置环境变量&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%B4%E6%97%B6%E7%94%9F%E6%95%88&#34;&gt;临时生效&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%92%88%E5%AF%B9%E5%BD%93%E5%89%8D%E7%94%A8%E6%88%B7%E6%B0%B8%E4%B9%85%E7%94%9F%E6%95%88&#34;&gt;针对当前用户（永久生效）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%92%88%E5%AF%B9%E6%89%80%E6%9C%89%E7%94%A8%E6%88%B7%E6%B0%B8%E4%B9%85%E7%94%9F%E6%95%88&#34;&gt;针对所有用户（永久生效）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8etcprofiled&#34;&gt;推荐使用/etc/profile.d&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bash_profile%E5%92%8Cbashrc&#34;&gt;.bash_profile和.bashrc&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#etcprofile&#34;&gt;/etc/profile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#etcbashrc%E6%8E%A8%E8%8D%90&#34;&gt;/etc/bashrc（推荐）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#~bash_profile&#34;&gt;~/.bash_profile&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#~bashrc%E6%8E%A8%E8%8D%90&#34;&gt;~/.bashrc（推荐）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#~bash_logout&#34;&gt;~/.bash_logout&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F&#34;&gt;启动文件的加载顺序&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%9A%84%E7%99%BB%E9%99%86shell&#34;&gt;交互式的登陆shell&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%99%BB%E9%99%86%E8%BF%87%E7%A8%8B&#34;&gt;登陆过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%99%BB%E5%87%BA%E8%BF%87%E7%A8%8B&#34;&gt;登出过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%9E%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%99%BB%E9%99%86shell&#34;&gt;非交互式登陆shell&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%99%BB%E9%99%86%E8%BF%87%E7%A8%8B-2&#34;&gt;登陆过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5&#34;&gt;其他情况&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;设置环境变量&#34;&gt;设置环境变量&lt;/h1&gt;
&lt;p&gt;以安装软件SoftA为例，路径为/usr/local/SoftA/bin/softa。&lt;/p&gt;
&lt;h2 id=&#34;临时生效&#34;&gt;临时生效&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export PATH=$PATH:/usr/local/SoftA/bin
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;针对当前用户永久生效&#34;&gt;针对当前用户（永久生效）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim ~/.bash_profile
vim ~/.bashrc
    # 修改文件中PATH 一行，PATH=$PATH:$HOME/bin之后添加 （注意以冒号分隔）
    # 修改完之后如下：
    PATH=$PATH:$HOME/bin:/usr/local/SoftA/bin
    export PATH
# source ~/.bash_profile
source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;针对所有用户永久生效&#34;&gt;针对所有用户（永久生效）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/profile
vim /etc/bashrc
    # 文件末尾追加
    PATH=$PATH:/usr/local/SoftA/bin
    export PATH
# source /etc/profile
source /etc/bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;推荐使用etcprofiled&#34;&gt;推荐使用/etc/profile.d&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;/etc/profile&lt;/code&gt;和&lt;code&gt;/etc/profile.d&lt;/code&gt;的区别：两个都是设置环境变量的，&lt;code&gt;/etc/profile.d/&lt;/code&gt;比&lt;code&gt;/etc/profile&lt;/code&gt;好维护，不想要什么变量直接删除&lt;code&gt;/etc/profile.d/&lt;/code&gt;下对应的shell脚本即可，不用像/etc/profile需要改动此文件。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/profile.d/softa.sh
    # 设置SoftA的环境变量
    SOFTA_HOME=/usr/local/SoftA
    PATH=$SOFTA_HOME/bin:$PATH
    export SOFTA_HOME PATH
chmod 755 /etc/profile.d/softa.sh
/etc/profile.d/softa.sh
echo $SOFTA_HOME
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;bash_profile和bashrc&#34;&gt;.bash_profile和.bashrc&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;“profile”系列文件的主要目的在于为“登录shell”设置环境变量和启动程序；而“rc”系列文件的主要目的在于设置功能和别名&lt;/code&gt;&lt;br&gt;
&lt;code&gt;crontab里面执行一个命令，.bashrc设置的环境变量会生效，而.bash_profile不会&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;etcprofile&#34;&gt;/etc/profile&lt;/h2&gt;
&lt;p&gt;此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，并从/etc/profile.d目录的配置文件中搜集shell的设置&lt;br&gt;
推荐使用这种方法，因为所有用户的shell都有权使用这些环境变量，缺点是可能会给系统带来安全性问题。 这里是针对所有的用户的，所有的shell&lt;br&gt;
&lt;strong&gt;需要注意的是&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在/etc/profile里设置系统环境变量时，路径末尾不能以&amp;quot;/&amp;quot;结尾，否则将导致整个PATH变量出错&lt;/li&gt;
&lt;li&gt;配置好环境变量后，要记得export输出这个变量，否则如下source后无效&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;etcbashrc推荐&#34;&gt;/etc/bashrc（推荐）&lt;/h2&gt;
&lt;p&gt;为每一个运行bash shell的用户执行此文件，当bash shell被打开时,该文件被读取&lt;/p&gt;
&lt;h2 id=&#34;~bash_profile&#34;&gt;~/.bash_profile&lt;/h2&gt;
&lt;p&gt;每个用户都可使用该文件输入专用于自己使用的shell信息，当用户&lt;strong&gt;登录时&lt;/strong&gt;，该文件&lt;strong&gt;仅仅执行一次&lt;/strong&gt;，默认情况下，他设置一些环境变量，执行用户的.bashrc文件&lt;br&gt;
&lt;code&gt;交互式、login方式进入bash运行的，通常会调用~/.bashrc&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;~bashrc推荐&#34;&gt;~/.bashrc（推荐）&lt;/h2&gt;
&lt;p&gt;该文件包含专用于你的bash shell的bash信息，当&lt;strong&gt;登录时以及每次打开新的shell&lt;/strong&gt;时,该该文件被读取&lt;br&gt;
&lt;code&gt;~/.bashrc是交互式、non-login方式进入bash运行的，所以一般优先把变量设置在.bashrc里面，比如在crontab里面执行一个命令，.bashrc设置的环境变量会生效，而.bash_profile不会&lt;/code&gt;&lt;br&gt;
修改.bashrc文件,这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别，这里是针对某一个特定的用户，如果需要给某个用户权限，使用这些环境变量，只需要修改其个人用户主目录下的.bashrc文件就可以了。&lt;/p&gt;
&lt;h2 id=&#34;~bash_logout&#34;&gt;~/.bash_logout&lt;/h2&gt;
&lt;p&gt;当每次**退出系统(退出bash shell)**时，执行该文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过名字的不同，我们可以直观地将startup文件分为“profile”与“rc”两个系列，其实他们的功能都很类似，但是使用的场景不同，这也是最容易忽略的地方。&lt;br&gt;
所谓的不同场景，其实就是shell的运行模式。运行中的bash有“交互”和“登陆”两种属性，而执行“profile”系列还是“rc”系列，就与shell的这两个属性有关。&lt;br&gt;
原理上讲，“登陆shell”启动时会加载“profile”系列的startup文件，而“交互式非登陆shell”启动时会加载“rc”系列的startup文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;启动文件的加载顺序&#34;&gt;启动文件的加载顺序&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1598841315874.png&#34; alt=&#34;启动文件的加载顺序&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;交互式的登陆shell&#34;&gt;交互式的登陆shell&lt;/h2&gt;
&lt;h3 id=&#34;登陆过程&#34;&gt;登陆过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;读取并执行/etc/profile文件&lt;/li&gt;
&lt;li&gt;读取并执行~/.bash_profile文件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若文件不存在，则读取并执行~/.bash_login文件&lt;/li&gt;
&lt;li&gt;若文件不存在，则读取并执行~/.profile文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;登出过程&#34;&gt;登出过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;读取并执行~/.bash_logout文件&lt;/li&gt;
&lt;li&gt;读取并执行/etc/bash.bash_logout文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;非交互式登陆shell&#34;&gt;非交互式登陆shell&lt;/h2&gt;
&lt;h3 id=&#34;登陆过程-2&#34;&gt;登陆过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;读取并执行/etc/profile文件&lt;/li&gt;
&lt;li&gt;读取并执行~/.bash_profile文件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若文件不存在，则读取并执行~/.bash_login文件&lt;/li&gt;
&lt;li&gt;若文件不存在，则读取并执行~/.profile文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;其他情况&#34;&gt;其他情况&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;图形模式登录时，顺序读取：/etc/profile和~/.profile&lt;/li&gt;
&lt;li&gt;图形模式登录后，打开终端时，顺序读取：/etc/bash.bashrc和~/.bashrc&lt;/li&gt;
&lt;li&gt;文本模式登录时，顺序读取：/etc/bash.bashrc，/etc/profile和~/.bash_profile&lt;/li&gt;
&lt;li&gt;从其它用户su到该用户，则分两种情况：
&lt;ol&gt;
&lt;li&gt;如果带-l参数（或-参数，–login参数），如：su -l username，则bash是lonin的，它将顺序读取以下配置文件：/etc/bash.bashrc，/etc/profile和~ /.bash_profile。&lt;/li&gt;
&lt;li&gt;如果没有带-l参数，则bash是non-login的，它将顺序读取：/etc/bash.bashrc和~/.bashrc&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;注销时，或退出su登录的用户，如果是longin方式，那么bash会读取：~/.bash_logout&lt;/li&gt;
&lt;li&gt;执行自定义的shell文件时，若使用“bash -l a.sh”的方式，则bash会读取行：/etc/profile和~/.bash_profile，若使用其它方式，如：bash a.sh， ./a.sh，sh a.sh（这个不属于bash shell），则不会读取上面的任何文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1598840866352.png&#34; alt=&#34;总结&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上图解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;“直接执行”表示此文件被系统直接调用，它的执行是无条件的；&lt;/li&gt;
&lt;li&gt;“条件执行”表示此文件被系统调用是有先决条件的（没有优先级更高的文件可用）；&lt;/li&gt;
&lt;li&gt;“引用执行”表示此文件不是被系统直接调用的，而是被其他文件显式调用的；&lt;/li&gt;
&lt;li&gt;后面的数字表示文件被调用的顺序，数字越大调用越靠后；&lt;/li&gt;
&lt;li&gt;“非交互非登陆”shell的配置文件可以由BASH_ENV环境变量指定；&lt;/li&gt;
&lt;/ol&gt;
">CentOS7管理环境变量</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/nginx-xue-xi-zheng-li/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AD%A6%E4%B9%A0%E7%9B%AE%E5%BD%95&#34;&gt;学习目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E4%BB%8B%E7%BB%8D&#34;&gt;nginx介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85&#34;&gt;nginx编译安装&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95%E4%B8%80%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85&#34;&gt;方法一：源码编译安装&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4%E4%BB%8B%E7%BB%8D&#34;&gt;操作命令介绍&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95%E4%BA%8Cyum%E6%BA%90%E5%AE%89%E8%A3%85%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8&#34;&gt;方法二：yum源安装（推荐使用）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E8%83%BD%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98&#34;&gt;可能存在问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E6%95%B4%E5%90%88php&#34;&gt;nginx整合php&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E4%B8%8Ephp%E5%90%88%E4%BD%9C%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AF%B4%E6%98%8E&#34;&gt;nginx与php合作的方式说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85php&#34;&gt;编译安装php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E6%95%B4%E5%90%88php&#34;&gt;修改nginx配置文件，整合php&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6&#34;&gt;nginx信号控制&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BF%A1%E5%8F%B7%E6%8E%A7%E5%88%B6%E9%80%89%E9%A1%B9&#34;&gt;信号控制选项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95&#34;&gt;使用方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE&#34;&gt;nginx虚拟主机配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84&#34;&gt;nginx配置文件结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3&#34;&gt;配置文件详解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3&#34;&gt;代理服务配置详解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3&#34;&gt;参数详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E4%B8%BE%E4%BE%8B&#34;&gt;常用配置举例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3&#34;&gt;负载均衡配置详解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%83%AD%E5%A4%87&#34;&gt;热备&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%AE%E8%AF%A2&#34;&gt;轮询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A0%E6%9D%83%E8%BD%AE%E8%AF%A2&#34;&gt;加权轮询&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ip_hash&#34;&gt;ip_hash&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%BE%E4%BE%8B&#34;&gt;配置文件举例&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B%E5%AD%901-%E5%9F%BA%E4%BA%8E%E5%9F%9F%E5%90%8D%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA&#34;&gt;例子1: 基于域名的虚拟主机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B%E5%AD%902-%E5%9F%BA%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%9A%84%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E9%85%8D%E7%BD%AE&#34;&gt;例子2: 基于端口的虚拟主机配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2&#34;&gt;nginx日志切割&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BB%E8%A6%81%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0&#34;&gt;主要配置参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2%E7%94%B1%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%AE%8C%E6%88%90&#34;&gt;日志切割（由定时任务完成）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E4%B8%8Egzip%E8%AE%BE%E7%BD%AE%E5%8E%8B%E7%BC%A9%E7%AE%A1%E7%90%86&#34;&gt;nginx与gzip设置（压缩管理）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%8B%E7%BB%8D&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E6%95%B0&#34;&gt;参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#location%E8%AF%A6%E8%A7%A3&#34;&gt;location详解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#location%E8%AF%AD%E6%B3%95&#34;&gt;location语法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&#34;&gt;工作流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BE%E4%BE%8B&#34;&gt;举例&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%A0%E6%AD%A3%E5%88%99&#34;&gt;无正则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%89%E6%AD%A3%E5%88%99&#34;&gt;有正则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9B%B4%E9%95%BF%E5%8C%B9%E9%85%8D&#34;&gt;更长匹配&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#name%E7%9A%84%E7%94%A8%E6%B3%95&#34;&gt;@name的用法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%BC%E5%90%88&#34;&gt;综合&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#url%E5%B0%BE%E9%83%A8%E7%9A%84%E9%9C%80%E4%B8%8D%E9%9C%80%E8%A6%81&#34;&gt;URL尾部的/需不需要&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rewrite%E8%AF%AD%E6%B3%95%E8%AF%A6%E8%A7%A3&#34;&gt;Rewrite语法详解&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89&#34;&gt;定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AF%AD%E6%B3%95&#34;&gt;语法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#flag%E6%A0%87%E5%BF%97%E4%BD%8D&#34;&gt;flag标志位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99&#34;&gt;常用正则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BE%E4%BE%8B-2&#34;&gt;举例&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B1&#34;&gt;例1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B2&#34;&gt;例2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#if%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&#34;&gt;if指令与全局变量&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B%E5%AD%90&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&#34;&gt;全局变量&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BE%8B%E5%AD%90-2&#34;&gt;例子&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E4%BA%8Eecshop%E7%9A%84rewrite%E5%AE%9E%E6%88%98&#34;&gt;基于ecshop的Rewrite实战&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E7%BC%93%E5%AD%98%E9%85%8D%E7%BD%AE&#34;&gt;nginx缓存配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#expires%E5%8F%82%E6%95%B0&#34;&gt;expires参数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#304not-modified&#34;&gt;304(Not Modified)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%92%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1nginxapache%E5%8A%A8%E9%9D%99%E5%88%86%E7%A6%BB&#34;&gt;nginx反向代理和负载均衡（nginx+apache动静分离）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86&#34;&gt;反向代理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&#34;&gt;负载均衡&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E8%BF%9E%E6%8E%A5memcached&#34;&gt;nginx连接memcached&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#memcached&#34;&gt;memcached&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85&#34;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&#34;&gt;使用教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E8%BF%9E%E6%8E%A5memcached-2&#34;&gt;nginx连接memcached&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3-2&#34;&gt;参数详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE&#34;&gt;配置&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%9A%E5%8F%B0memcache&#34;&gt;多台memcache&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A8%A1%E5%9D%97ngx_http_consistent_hash%E7%9A%84%E5%AE%89%E8%A3%85&#34;&gt;第三方模块（ngx_http_consistent_hash）的安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AEmemcache%E9%9B%86%E7%BE%A4&#34;&gt;配置memcache集群&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%9E%B6%E8%AE%BE&#34;&gt;高性能的服务器的架设&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4&#34;&gt;内核参数调整&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BD%91%E7%BB%9C&#34;&gt;网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%B2%E7%81%AB%E5%A2%99%E5%BB%BA%E8%AE%AE%E5%85%B3%E6%8E%89&#34;&gt;防火墙(建议关掉)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%87%E4%BB%B6&#34;&gt;文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%9B%E7%A8%8B%E6%9C%80%E5%A4%A7%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6&#34;&gt;进程最大文件描述符&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4&#34;&gt;nginx参数调整&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#php-fpm%E5%8F%82%E6%95%B0%E8%B0%83%E6%95%B4&#34;&gt;php-fpm参数调整&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://nginx.org/en/docs/&#34;&gt;http://nginx.org/en/docs/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.nginx.cn/doc/index.html&#34;&gt;https://www.nginx.cn/doc/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://tengine.taobao.org/book/#&#34;&gt;http://tengine.taobao.org/book/#&lt;/a&gt; or &lt;a href=&#34;http://tengine.taobao.org/&#34;&gt;http://tengine.taobao.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/dsh942642/p/7181388.html&#34;&gt;https://www.cnblogs.com/dsh942642/p/7181388.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;学习目录&#34;&gt;学习目录&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;基础篇
&lt;ol&gt;
&lt;li&gt;nginx介绍&lt;/li&gt;
&lt;li&gt;nginx编译安装&lt;/li&gt;
&lt;li&gt;nginx整合php&lt;/li&gt;
&lt;li&gt;nginx信号控制&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;应用篇
&lt;ol&gt;
&lt;li&gt;nginx虚拟主机配置&lt;/li&gt;
&lt;li&gt;nginx日志切割&lt;/li&gt;
&lt;li&gt;nginx与gzip设置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;实战篇
&lt;ol&gt;
&lt;li&gt;nginx与浏览器缓存配置&lt;/li&gt;
&lt;li&gt;nginx与rewrite规则&lt;/li&gt;
&lt;li&gt;nginx与memcached&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;优化篇
&lt;ol&gt;
&lt;li&gt;nginx连续数优化&lt;/li&gt;
&lt;li&gt;nginx反向代理&lt;/li&gt;
&lt;li&gt;nginx集群与负载平衡&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;nginx介绍&#34;&gt;nginx介绍&lt;/h1&gt;
&lt;p&gt;Nginx (&amp;quot;engine x&amp;quot;) 是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。 Nginx 是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的&lt;/p&gt;
&lt;h1 id=&#34;nginx编译安装&#34;&gt;nginx编译安装&lt;/h1&gt;
&lt;h2 id=&#34;方法一源码编译安装&#34;&gt;方法一：源码编译安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装依赖
yum -y install pcre pcre-devel gcc gcc-c++ autoconf automake make zip*
# 下载源码并解压
cd /usr/local/src
wget http://nginx.org/download/nginx-1.18.0.tar.gz
tar zxvf nginx-1.18.0.tar.gz
cd nginx-1.18.0
# 编译安装
./configure --prefix=/usr/local/nginx
make &amp;amp;&amp;amp; make install
# 启动
cd /usr/local/nginx
 ./sbin/nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;操作命令介绍&#34;&gt;操作命令介绍&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;-?,-h：显示该帮助信息&lt;/li&gt;
&lt;li&gt;-v：打印版本号并退出&lt;/li&gt;
&lt;li&gt;-V：打印版本号与编译信息并退出&lt;/li&gt;
&lt;li&gt;-t：测试配置并退出&lt;/li&gt;
&lt;li&gt;-T：测试配置、转储并退出&lt;/li&gt;
&lt;li&gt;-q：测试配置时只显示错误&lt;/li&gt;
&lt;li&gt;-s signal：发送信号给主进程，包括stop、 quit、 reopen、 reload&lt;/li&gt;
&lt;li&gt;-p prefix：指定nginx服务器路径前缀 (默认：/usr/local/nginx/)&lt;/li&gt;
&lt;li&gt;-c filename：指定nginx配置文件路径 (默认：conf/nginx.conf)&lt;/li&gt;
&lt;li&gt;-g directives：指定nginx附加配置文件路径&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;方法二yum源安装推荐使用&#34;&gt;方法二：yum源安装（推荐使用）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置yum源
vim /etc/yum.repos.d/nginx.repo
    [nginx-stable]
    name=nginx stable repo
    baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
    gpgcheck=1
    enabled=1
    gpgkey=https://nginx.org/keys/nginx_signing.key
    [nginx-mainline]
    name=nginx mainline repo
    baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
    gpgcheck=1
    enabled=0
    gpgkey=https://nginx.org/keys/nginx_signing.key
yum makecache
# 安装
yum -y install nginx
# 版本查看
nginx -v  # nginx version: nginx/1.18.0
# 开机自启与启动
systemctl enable nginx &amp;amp;&amp;amp; systemctl start nginx &amp;amp;&amp;amp; systemctl status nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;可能存在问题&#34;&gt;可能存在问题&lt;/h2&gt;
&lt;p&gt;不能绑定80端口,80端口已经被占用(有时是自己装了apache,nginx等,还有更多情况是操作系统自带了apache并作为服务启动)&lt;br&gt;
解决：使用&lt;code&gt;netstat -tulnp&lt;/code&gt;查看， 把占用80端口的软件或服务关闭即可&lt;/p&gt;
&lt;h1 id=&#34;nginx整合php&#34;&gt;nginx整合php&lt;/h1&gt;
&lt;p&gt;apache一般是把php当做自己的一个模块来启动的，而nginx则是把http请求变量(如get,user_agent等)转发给php进程，即php独立进程，与nginx进行通信，称为 fastcgi运行方式，因此，为apache所编译的php是不能用于nginx的。&lt;br&gt;
注意: 我们编译的PHP 要有如下功能：连接mysql, gd, ttf, 以fpm(fascgi)方式运行&lt;br&gt;
&lt;code&gt;./configure --prefix=/usr/local/fastphp --with-mysql=mysqlnd --enable-mysqlnd --with-gd --enable-gd-native-ttf --enable-gd-jis-conv --enable-fpm&lt;/code&gt;&lt;br&gt;
设计到具体选项，可以使用&lt;code&gt;./configure -help | grep mysql&lt;/code&gt;查看&lt;/p&gt;
&lt;h2 id=&#34;nginx与php合作的方式说明&#34;&gt;nginx与php合作的方式说明&lt;/h2&gt;
&lt;p&gt;nginx+php的配置比较简单，核心就一句话：把请求的信息转发给9000端口的PHP进程，让PHP进程处理 指定目录下的PHP文件。处理流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;碰到php文件&lt;/li&gt;
&lt;li&gt;把根目录定位到 html&lt;/li&gt;
&lt;li&gt;把请求上下文转交给9000端口PHP进程&lt;/li&gt;
&lt;li&gt;并告诉PHP进程，当前的脚本是&lt;code&gt;$document_root$fastcgi_scriptname&lt;/code&gt;【注：PHP会去找这个脚本并处理，所以脚本的位置要指对】&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;编译安装php&#34;&gt;编译安装php&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y libxml* libpng* mariadb* gd gd-devel freetype
cd /usr/local/src
wget https://www.php.net/distributions/php-7.4.9.tar.gz
tar zxf php-7.4.9.tar.gz
cd php-7.4.9
./configure --prefix=/usr/local/php \
--enable-mysqlnd \
--with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd \
--without-sqlite3 \
--enable-gd --enable-gd-jis-conv --enable-fpm
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;修改nginx配置文件整合php&#34;&gt;修改nginx配置文件，整合php&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cp /usr/local/src/php-7.4.9/php.ini-development /usr/local/php/lib/php.ini
cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf
cp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf
/usr/local/php/sbin/php-fpm     # 启动php-fpm
systemctl start mariadb  # 启动mysql数据库
vim /usr/local/nginx/conf/nginx.conf
    # 在server下面，取消注释后修改
    location ~ \.php$ {
        root           html;
        fastcgi_pass   127.0.0.1:9000;
        fastcgi_index  index.php;
        # 修改下面这一行
        fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;
        include        fastcgi_params;
        }
./sbin/nginx -s reload
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nginx信号控制&#34;&gt;nginx信号控制&lt;/h1&gt;
&lt;p&gt;如果不习惯或者不喜欢使用kill命令的这种方式，可以使用nginx自带的命令进行管理。&lt;/p&gt;
&lt;h2 id=&#34;信号控制选项&#34;&gt;信号控制选项&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;TERM, INT：立刻关闭（不推荐使用）&lt;/li&gt;
&lt;li&gt;QUIT：优雅的关闭进程,即等请求结束后再关闭&lt;/li&gt;
&lt;li&gt;HUP：改变配置文件,平滑的重读配置文件&lt;/li&gt;
&lt;li&gt;USR1：重读日志，在日志按月/日分割时有用&lt;/li&gt;
&lt;li&gt;USR2：平滑的升级&lt;/li&gt;
&lt;li&gt;WINCH：优雅关闭旧的进程(配合USR2来进行升级)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;主进程号查询命令： &lt;code&gt;ps aux | grep nginx | grep master&lt;/code&gt;&lt;br&gt;
进程号获取也可以读取nginx在配置文件中指定的pid文件，默认是&lt;code&gt;cat /usr/local/nginx/logs/nginx.pid&lt;/code&gt;&lt;br&gt;
使用方式：&lt;code&gt;kill -信号选项 nginx的主进程号&lt;/code&gt;，例如&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;重读配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kill -HUP 5415
或者
kill -HUP `cat /usr/local/nginx/logs/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;写入新的日志文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kill -USR1 5415
或者
kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nginx虚拟主机配置&#34;&gt;nginx虚拟主机配置&lt;/h1&gt;
&lt;h2 id=&#34;nginx配置文件结构&#34;&gt;nginx配置文件结构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。&lt;/li&gt;
&lt;li&gt;events块：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。&lt;/li&gt;
&lt;li&gt;http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。&lt;/li&gt;
&lt;li&gt;server块：配置虚拟主机的相关参数，一个http中可以有多个server。&lt;/li&gt;
&lt;li&gt;location块：配置请求的路由，以及各种页面的处理情况。&lt;br&gt;
&lt;code&gt;server继承 main，location 继承 server， upstream 既不会继承其他的配置，也不会被继承&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;...              #全局块

events {         #events块
   ...
}

http      #http块
{
    ...   #http全局块
    server        #server块
    { 
        ...       #server全局块
        location [PATTERN]   #location块
        {
            ...
        }
        location [PATTERN] 
        {
            ...
        }
    }
    server
    {
      ...
    }
    ...     #http全局块
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置文件详解&#34;&gt;配置文件详解&lt;/h3&gt;
&lt;p&gt;nginx配置文件博大精深，这里只是简单介绍部分常用参数，如果想了解更多参数以及使用方法，请参考网站&lt;a href=&#34;http://nginx.org/en/docs/&#34;&gt;http://nginx.org/en/docs/&lt;/a&gt;或者&lt;a href=&#34;https://www.nginx.cn/doc/index.html&#34;&gt;https://www.nginx.cn/doc/index.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#【注意】：每个指令必须有分号结束

# --------------------------- 全局块 --------------------------
# 配置用户或者组，默认为nobody nobody
user root root;  
# 允许生成的进程数，默认为1。可以自行修改，但太大无益，因为要争夺CPU，一般设置为CPU逻辑核心数
worker_processes 1;  
# 指定nginx进程运行文件存放地址
pid /nginx/pid/nginx.pid;   
#制定日志路径，级别（级别参数可省略，默认为crit）。这个设置可以放入全局块、http块、server块，级别以此为：debug|info|notice|warn|error|crit|alert|emerg
error_log log/error.log debug;  

# --------------------------- events块 --------------------------
events {
    # 设置网路连接序列化，防止惊群现象发生，默认为on
    #   惊群现象：一个网路连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能
    accept_mutex on;   
    # 设置一个进程是否同时接受多个网络连接，默认为off
    multi_accept on;  
    # 事件驱动模型，默认为epoll，select|poll|kqueue|epoll|resig|/dev/poll|eventport
    use epoll;      
    # 最大连接数，默认为512
    worker_connections  1024;    
}

# --------------------------- http块 --------------------------
http {

    # --------------------------- http块：http全局块 --------------------------
    # 文件扩展名与文件类型映射表
    include       mime.types;   
    # 默认文件类型，默认为text/plain
    default_type  application/octet-stream; 
    # 取消服务日志
    access_log off;     
    # 自定义日志格式，其中：
    #   1. $remote_addr 与 $http_x_forwarded_for：用以记录客户端的ip地址；
    #   2.$remote_user：用来记录客户端用户名称；
    #   3.$time_local：用来记录访问时间与时区；
    #   4.$request：用来记录请求的url与http协议；
    #   5.$status：用来记录请求状态；成功是200；
    #   6.$body_bytes_s ent：记录发送给客户端文件主体内容大小；
    #   7.$http_referer：用来记录从那个页面链接访问过来的；
    #   8.$http_user_agent ：记录客户端浏览器的相关信息；
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                                 &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                                 &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;
    # combined为日志格式的默认值，可以在全局块、http块、server块设置
    access_log log/access.log main; 
    # 允许sendfile方式传输文件，默认为off，可以在http块，server块，location块。 
    sendfile on;   
    # 每个进程每次调用传输数量不能大于设定的值，默认为0，即不设上限。
    sendfile_max_chunk 100k;  
    #连接超时时间，默认为75s，可以在http，server，location块。
    keepalive_timeout 65;  
    # 配置热备或者负载均衡等
    upstream mysvr {   
      server 127.0.0.1:7878;
      server 192.168.10.121:3333 backup;  #热备
    }
    # 错误页
    error_page 404 https://www.baidu.com; 
    # 关于缓存tcp_nopush、压缩gzip等参数，可详细参考官网说明

    # --------------------------- http块：server块 --------------------------
    server {
        # --------------------------- http块：server全局块 --------------------
        # 单连接请求上限次数
        keepalive_requests 120; 
        # 监听端口
        listen       4545;   
        # 监听地址   
        server_name  127.0.0.1;      
        # 设置编码格式为utf-8
        charset utf-8;

        # --------------------------- http块：location块 ----------------- 
        #请求的url过滤，正则匹配，~为区分大小写，~*为不区分大小写。
        location  ~*^.+$ { 
            # 根目录      
           root path;  
           # 设置默认页
           index vv.txt;  
           # 请求转向mysvr 定义的服务器列表
           proxy_pass  http://mysvr;  
           # 拒绝的ip
           deny 127.0.0.1;  
           # 允许的ip 
           allow 172.18.5.54;           
        } 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;代理服务配置详解&#34;&gt;代理服务配置详解&lt;/h4&gt;
&lt;h5 id=&#34;参数详解&#34;&gt;参数详解&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基本指令&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;proxy_pass：设置代理服务器的协议和地址。语法：&lt;code&gt;proxy_pass URL&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_hide_header：用于设置Nginx服务器发送http响应时，隐藏一些头域信息。语法：&lt;code&gt;proxy_hide_header field&lt;/code&gt;，field为需要隐藏的头域，可用于http、server、localtion&lt;/li&gt;
&lt;li&gt;proxy_pass_header：默认Nginx服务器在发送响应报文时，报文不包含date server X-accel等来自被代理服务器的头域信息，该指令可以设置这些头域信息已被发送。语法：&lt;code&gt;proxy_pass_header filed&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_pass_request_body：配置是否将客户端请求体发送给代理服务器。语法：&lt;code&gt;proxy_pass_request_body on | off&lt;/code&gt;，可用于http、server、localtion&lt;/li&gt;
&lt;li&gt;proxy_pass_request_header：配置是否将客户端的请求头发送给代理服务器&lt;/li&gt;
&lt;li&gt;proxy_set_header：用于更改Nginx服务器接收到的客户端请求的请求头，然后将新的请求头发送给被代理服务器。语法：&lt;code&gt;proxy_set_header filed value&lt;/code&gt;，field为要更改的信息所在的头域，value为要更改后的值&lt;/li&gt;
&lt;li&gt;proxy_set_body：更改Nginx服务器接收到的客户端请求的请求体信息，然后将新的请求体发送给被代理的服务器。语法：&lt;code&gt;proxy_set_body value&lt;/code&gt;，value为更改的信息&lt;/li&gt;
&lt;li&gt;proxy_bind：强制将与代理主机的连接绑定到指定的ip主机。语法：&lt;code&gt;proxy_bind address&lt;/code&gt; ，address为IP地址&lt;/li&gt;
&lt;li&gt;proxy_connect_timout：用于配置Nginx服务器与后端被代理服务器尝试连接的超时时间。语法：&lt;code&gt;proxy_connect_timout time&lt;/code&gt;，默认时间60秒&lt;/li&gt;
&lt;li&gt;proxy_read_timeout：用于配置Nginx服务器向后端被代理服务器(组)发出read请求后，等待响应的超时时间。语法：&lt;code&gt;proxy_read_timeout time&lt;/code&gt;，默认时间60秒&lt;/li&gt;
&lt;li&gt;proxy_send_timeout：用于配置Nginx服务器向后端被代理服务器(组)发出write请求后，等待响应的超时时间。语法：&lt;code&gt;proxy_send_timeout time&lt;/code&gt;，默认时间60秒&lt;/li&gt;
&lt;li&gt;proxy_http_version：用于设置Nginx服务器提供代理服务器的HTTP协议版本。语法：&lt;code&gt;proxy_http_version 1.0|1.1|2.0&lt;/code&gt;，默认是1.0&lt;/li&gt;
&lt;li&gt;proxy_method：用于设置Nginx服务器请求代理服务器使用的请求方法，设置了这个客户端的请求方法将会被忽略。语法：&lt;code&gt;proxy_method POST|GET&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_ignore_client_abort：用于设置在客户端中断网络请求的时候，Nginx服务器是否中断对被代理服务器的请求。语法：&lt;code&gt;proxy_ignore_client_abort on | off&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_ignore_headers：用于设置一些HTTP响应头的头域。语法：&lt;code&gt;proxy_ignore_headers filed ...&lt;/code&gt;，filed为要设置的HTTP相应头的头域信息，例如&amp;quot;X-Accel-Redirect&amp;quot;、&amp;quot;X-Accel-Expires&amp;quot;、&amp;quot;Expores&amp;quot;、&amp;quot;Cache-Control&amp;quot;、&amp;quot;Set-Cookie&amp;quot;&lt;/li&gt;
&lt;li&gt;proxy_headers_hash_max_size：存放HTTP报文头的哈希表的容量。语法：&lt;code&gt;proxy_headers_hash_max_size size&lt;/code&gt;，默认大小512&lt;/li&gt;
&lt;li&gt;proxy_headers_hash_bucket_size：Nginx服务器申请存放HTTP报文头的哈希表容量的单位大小。语法：&lt;code&gt;proxy_headers_hash_max_size 64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_next_upstream：如果Nginx定义了upstream后端服务器组，如果组内有异常情况，将请求顺次交给下一个组内服务器处理。语法：&lt;code&gt;proxy_next_upstream error|timeout|invalid_header|http_500 502 503 504 404|off&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_ssl_session_reuse：该指令用于配置是否使用基于SSL安全协议的会话连接（htts://）被代理服务器。语法：&lt;code&gt;proxy_ssl_session_reuse on | off&lt;/code&gt;，默认on&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ProxyBuffer指令&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;proxy_buffering：用于配置是否启用或者关闭proxybuff。语法：&lt;code&gt;proxy_buffering on | off&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_buffers：用于配置接收一次被代理服务器响应数据的Proxy Buffer个数和每个Buffer的大小。语法：&lt;code&gt;proxy_buffers number size&lt;/code&gt;，size一般设置为内存页大小，根据平台的不同，取值可能为4KB或者8KB，例如：&lt;code&gt;proxy_buffers 8 4KB|8KB&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_buffer_size：用于配置从被代理服务器获取的第一部分响应数据的大小，默认为4k或者8k，保持与proxy_buffers指令中的size变量相同。&lt;/li&gt;
&lt;li&gt;proxy_busy_buffers_size：用于限制同时处于BUSY状态的Proxy Buffer的总大小。语法：&lt;code&gt;proxy_busy_buffers_size size&lt;/code&gt;，size为设置处于BUSY状态的缓存区总大小。默认为8KB或者16KB。&lt;/li&gt;
&lt;li&gt;proxy_temp_path：用于配置磁盘上的一个文件路径，用于临时存放被代理服务器的大体积响应数据。如果Proxy Buffer被装满后，响应数据仍然没有被Nginx服务器完全接收，之后响应的数据就会被临时存放在该文件中。语法：&lt;code&gt;proxy_temp_path path [level1 [level2 [level3]]]&lt;/code&gt;，path为磁盘上临时存放文件的路径，levelN缓存文件存放在设置的路径的第几级hash目录中&lt;/li&gt;
&lt;li&gt;proxy_max_temp_file_size：用于设置所有临时文件的总大小。语法：&lt;code&gt;proxy_max_temp_file_size size&lt;/code&gt;，默认是1024M&lt;/li&gt;
&lt;li&gt;proxy_temp_file_write_size：用于配置同时写入临时文件的数据量的总大小，语法：&lt;code&gt;proxy_temp_file_write_size size&lt;/code&gt;，默认设置根据平台的不同，可以为8KB或者16KB，一般与平台的内存也大小相同&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Proxy Cache指令&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;proxy_cache：用于配置一块公用的内存区域的名称，该区域可以存放缓存的索引数据。这些数据在Nginx服务器启动时由缓存索引重建进程负责建立，在Nginx服务器的整个运行过程中由缓存管理进程负责定时检查过期数据、检索等管理工作。语法：&lt;code&gt;proxy_cache zone | off&lt;/code&gt;，zone为设置用于存放缓存索引的内存区域的名称，off为关闭proxy_cache功能（默认设置为on）&lt;/li&gt;
&lt;li&gt;proxy_cache_bypass：用于配置Nginx在响应客户端时不从缓存中获取数据的条件。语法：&lt;code&gt;proxy_cache_bypass string ...&lt;/code&gt;，string为条件变量，支持配置多个，当至少有一个字符串指令不为空或者不等于0时，响应数据不从缓存中获取。&lt;strong&gt;举例&lt;/strong&gt;：&lt;code&gt;proxy_cache_bypass $cookie_nocache $arg_nocache $arg_comment $http_pragma $http_authorization&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;proxy_cache_key：用于配置Nginx服务器在内存中为缓存数据建立索引时使用的关键字&lt;/li&gt;
&lt;li&gt;proxy_cache_lock_timeout：用于配置开启锁功能以后锁的超时时间，默认为5s。&lt;/li&gt;
&lt;li&gt;proxy_cache_in_uses：当客户端向被代理的服务器发送相同的请求达到该指令设定的次数后，Nginx服务器才对该其更年期的响应数据做缓存，默认为1。&lt;/li&gt;
&lt;li&gt;proxy_cache_path：用于设置Nginx服务器存储缓存数据的路径以及和缓存索引相关的内容，语法：&lt;code&gt;proxy_cache_path path [levels=levels] keys_zone=name:size1 [inactive=time1] [max_size=size2] [loader_files=number] [loader_sleep=time2] [loader_threshold=time3]&lt;/code&gt;，
&lt;ol&gt;
&lt;li&gt;path：设置缓存存放的根路径&lt;/li&gt;
&lt;li&gt;levels：设置相对于path指定目录的第几级hash目录中缓存数据。&lt;code&gt;levels=1&lt;/code&gt;表示一级hash目录，&lt;code&gt;levels=1:2&lt;/code&gt;，表示两级目录，以此类推。该目录是基于请求URL通过哈希算法得到的&lt;/li&gt;
&lt;li&gt;name:size1：Nginx服务器的缓存索引重建进程在内存中为缓存数据建立索引，这一对变量用来设置存放缓存索引的内存区域的名称和大小t&lt;/li&gt;
&lt;li&gt;time1：设置强制更新缓存数据的时间，当缓存数据在设定的时间内没有被访问时，Nginx服务器就强制从硬盘上将其删除，下次客户端访问该数据时重新缓存，默认为10&lt;/li&gt;
&lt;li&gt;size2：设置缓存数据大小，当缓存的大小超过该变量的设置时，索引管理进程将根据最近最少被访问的策略删除缓存&lt;/li&gt;
&lt;li&gt;number：设置缓存索引重建进程每次加载的数据元素的数量上限，默认为100&lt;/li&gt;
&lt;li&gt;time2：设置缓存索引重建进程在一次遍历结束后下一次遍历开始之间暂停的时长，默认为50ms&lt;/li&gt;
&lt;li&gt;time3：设置遍历一次磁盘缓存源数据的时间上限，默认为200ms&lt;br&gt;
指令比较复杂，一般需要设置前面3个指令的情形比较多，后面几个变量与Nginx服务器缓存索引重建进程以及管理进程性能有关，一般情况下保持默认设置就可以了。例如：&lt;code&gt;proxy_cache_path /data/nginx/cache/a levels=1 keys_zone=a:10m;&lt;/code&gt;或者&lt;code&gt;proxy_cache_path /data/nginx/cache/b levels=2:2 keys_zone=b:100m;&lt;/code&gt;或者&lt;code&gt;proxy_cache_path /data/nginx/cache/c levels=1:1:2 keys_zone=c:1000m;&lt;/code&gt;。【注：】&lt;strong&gt;该指令只能放在http块中&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;proxy_cache_use_stale：指定在哪种情况下，当被代理的服务器无法访问或者访问错误等现象时，Nginx服务器可以使用历史缓存响应客户端的请求。语法：&lt;code&gt;proxy_cache_use_stale error | timeout | invalid_header | updating | http_500 | off ...&lt;/code&gt;，默认为off&lt;/li&gt;
&lt;li&gt;proxy_cache_valid：该指令可以针对不能的HTTP响应状态设置不同的缓存时间。语法：&lt;code&gt;proxy_cache_valid [code ...] time&lt;/code&gt;，code为设置HTTP响应的状态码，默认只为响应码是200、301、302的响应数据做缓存，可以使用any，表示缓存所有该指令中未设定的其他响应数据；time为缓存时间。举例：&lt;code&gt;proxy_cache_valid 200 302 10m;&lt;/code&gt;或&lt;code&gt;proxy_cache_valid 301 1h;&lt;/code&gt;或&lt;code&gt;proxy_cache_valid any 10m;&lt;/code&gt; ，第三个例子表示对返回状态为不是200、301、302的响应数据缓存10分钟&lt;/li&gt;
&lt;li&gt;proxy_no_cache：配置在什么情况下不使用cache功能。语法：&lt;code&gt;proxy_no_cache string ...&lt;/code&gt;，string可以是一个或者多个变量，当string的值不为空或者不为0时，不启用cache功能。&lt;/li&gt;
&lt;li&gt;proxy_store：配置是否在本地磁盘缓存来自被代理服务器的响应数据。语法：&lt;code&gt;proxy_store on | off | string&lt;/code&gt;，&lt;code&gt;on | off&lt;/code&gt;设置是否开启Proxy Store功能，如果开启,缓存文件会存放到alias指令或root指令设置的本地路径，默认为off；string为自定义缓存文件存放路径，使用该配置时，默认开启Proxy Store&lt;/li&gt;
&lt;li&gt;proxy_store_access：用于设置用户或用户组对Proxy Store缓存文件的访问权限。语法：&lt;code&gt;proxy_store_access users:permissions ...&lt;/code&gt;，users可以设置为user、group或者all；permission设置方位权限。举例：&lt;code&gt;proxy_store on;proxy_store_access user:rw group:rw all:r;root /data/www;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;常用配置举例&#34;&gt;常用配置举例&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;当代理遇到状态码为404时，我们把404页面导向百度&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#错误页
error_page 404 https://www.baidu.com; 
#如果被代理服务器返回的状态码为400或者大于400，设置的error_page配置起作用。默认为off。
proxy_intercept_errors on;    
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果我们的代理只允许接受get，post请求方法的一种&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#支持客户端的请求方法：post/get
proxy_method get;    
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;设置支持的http协议版本&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#Nginx服务器提供代理服务的http协议版本1.0，1.1，默认设置为1.0版本
proxy_http_version 1.0 ; 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如果nginx服务器给2台web服务器做代理，负载均衡算法采用轮询，那么当一台机器web程序iis关闭，也就是说web不能访问，那么nginx服务器分发请求还是会给这台不能访问的web服务器，如果这里的响应连接时间过长，就会导致客户端的页面一直在等待响应，对用户来说体验就大打折扣，为了避免这样的情况发生。这里我配张图来说明下问题。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1599035925345.jpg&#34; alt=&#34;代理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果负载均衡中其中web2发生这样的情况，nginx首先会去web1请求，但是nginx在配置不当的情况下会继续分发请求道web2，然后等待web2响应，直到响应时间超时，才会把请求重新分发给web1，这里的响应时间如果过长，用户等待的时间就会越长。&lt;br&gt;
下面的配置是解决方案之一：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# nginx服务器与被代理的服务器建立连接的超时时间，默认60秒
proxy_connect_timeout 1;   
# nginx服务器想被代理服务器组发出read请求后，等待响应的超时间，默认为60秒
proxy_read_timeout 1; 
# nginx服务器想被代理服务器组发出write请求后，等待响应的超时间，默认为60秒
proxy_send_timeout 1; 
#客户端断网时，nginx服务器是否终端对被代理服务器的请求。默认为off
proxy_ignore_client_abort on;  
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;如果使用upstream指令配置一组服务器作为被代理服务器，服务器中的访问算法遵循配置的负载均衡规则，同时可以使用该指令配置在发生哪些异常情况时，将请求顺次交由下一组服务器处理。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#反向代理upstream中设置的服务器组，出现故障时，被代理服务器返回的状态值。error|timeout|invalid_header|http_500|http_502|http_503|http_504|http_404|off
proxy_next_upstream timeout;  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;error：建立连接或向被代理的服务器发送请求或读取响应信息时服务器发生错误&lt;/li&gt;
&lt;li&gt;timeout：建立连接，想被代理服务器发送请求或读取响应信息时服务器发生超时&lt;/li&gt;
&lt;li&gt;invalid_header：被代理服务器返回的响应头异常&lt;/li&gt;
&lt;li&gt;off：无法将请求分发给被代理的服务器&lt;/li&gt;
&lt;li&gt;http_400，....：被代理服务器返回的状态码为400、500、502等&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;如果想通过http获取客户的真是ip而不是获取代理服务器的ip地址，那么要做如下的设置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#只要用户在浏览器中访问的域名绑定了 VIP，VIP下面有RS，就用$host ，host是访问URL中的域名和端口，例如www.taobao.com:80
proxy_set_header Host $host; 
#把源IP 【$remote_addr,建立HTTP连接header里面的信息】赋值给X-Real-IP，这样在代码中 $X-Real-IP来获取源IP
proxy_set_header X-Real-IP $remote_addr; 
#在nginx 作为代理服务器时，设置的IP列表，会把经过的机器ip，代理机器ip都记录下来，用 【，】隔开，代码中用 echo $x-forwarded-for |awk -F, &#39;{print $1}&#39; 来作为源IP 
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;负载均衡配置详解&#34;&gt;负载均衡配置详解&lt;/h4&gt;
&lt;p&gt;配置模板如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;upstream mysvr { 
      server 192.168.10.121:3333;
      server 192.168.10.122:3333;
    }
 server {
        ....
        location  ~*^.+$ {         
           proxy_pass  http://mysvr;  #请求转向mysvr 定义的服务器列表         
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于nginx负载均衡配置的几个状态参数讲解：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;down，表示当前的server暂时不参与负载均衡&lt;/li&gt;
&lt;li&gt;backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻&lt;/li&gt;
&lt;li&gt;max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream模块定义的错误&lt;/li&gt;
&lt;li&gt;fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;upstream mysvr { 
      server 127.0.0.1:7878 weight=2 max_fails=2 fail_timeout=2;
      server 192.168.10.121:3333 weight=1 max_fails=2 fail_timeout=1;    
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;热备&#34;&gt;热备&lt;/h5&gt;
&lt;p&gt;如果有2台服务器，当一台服务器发生事故时，才启用第二台服务器给提供服务。服务器处理请求的顺序：AAAAAA突然A挂啦，BBBBBBBBBBBBBB.....&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;upstream mysvr { 
      server 127.0.0.1:7878; 
      server 192.168.10.121:3333 backup;  #热备     
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;轮询&#34;&gt;轮询&lt;/h5&gt;
&lt;p&gt;nginx默认就是轮询其权重都默认为1，服务器处理请求的顺序：ABABABABAB....&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;upstream mysvr { 
      server 127.0.0.1:7878;
      server 192.168.10.121:3333;       
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;加权轮询&#34;&gt;加权轮询&lt;/h5&gt;
&lt;p&gt;根据配置的权重的大小而分发给不同服务器不同数量的请求。如果不设置，则默认为1。下面服务器的请求顺序为：ABBABBABBABBABB....&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;upstream mysvr { 
      server 127.0.0.1:7878 weight=1;
      server 192.168.10.121:3333 weight=2;
      }
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;ip_hash&#34;&gt;ip_hash&lt;/h5&gt;
&lt;p&gt;nginx会让相同的客户端ip请求相同的服务器。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;upstream mysvr { 
      server 127.0.0.1:7878; 
      server 192.168.10.121:3333;
      ip_hash;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;配置文件举例&#34;&gt;配置文件举例&lt;/h4&gt;
&lt;h5 id=&#34;例子1-基于域名的虚拟主机&#34;&gt;例子1: 基于域名的虚拟主机&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;server {
    listen 80;  #监听端口
    server_name a.com; #监听域名

    location / {
            root a.com;   #根目录，此处使用相对路径，相对于/usr/local/nginx，也可以使用绝对路径
            index index.html;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;例子2-基于端口的虚拟主机配置&#34;&gt;例子2: 基于端口的虚拟主机配置&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;server {
    listen 8080;
    server_name 192.168.1.204;

    location / {
            root /var/www/html8080;  # 根目录，此处使用绝对路径，当然可以使用相对路径
            index index.html;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nginx日志切割&#34;&gt;nginx日志切割&lt;/h1&gt;
&lt;h2 id=&#34;主要配置参数&#34;&gt;主要配置参数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;access_log&lt;br&gt;
combined为日志格式的默认值，可以在全局块、http块、server块设置，格式为：&lt;code&gt;access_log logs/host.access.log main;&lt;/code&gt;,说明它的访问日志的文件是logs/host.access.log ,使用的格式为&amp;quot;main&amp;quot;格式。除了main格式，你可以自定义其他格式.&lt;/li&gt;
&lt;li&gt;log_format&lt;br&gt;
定义日志格式，便于下面引用，主要参数如下：
&lt;ol&gt;
&lt;li&gt;$remote_addr 与 $http_x_forwarded_for：用以记录客户端的ip地址；&lt;/li&gt;
&lt;li&gt;$remote_user：用来记录客户端用户名称；&lt;/li&gt;
&lt;li&gt;$time_local：用来记录访问时间与时区；&lt;/li&gt;
&lt;li&gt;$request：用来记录请求的url与http协议；&lt;/li&gt;
&lt;li&gt;$status：用来记录请求状态；成功是200；&lt;/li&gt;
&lt;li&gt;$body_bytes_s ent：记录发送给客户端文件主体内容大小；&lt;/li&gt;
&lt;li&gt;$http_referer：用来记录从那个页面链接访问过来的；&lt;/li&gt;
&lt;li&gt;$http_user_agent ：记录客户端浏览器的相关信息；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                            &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                            &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;
# 引用
server {
    listen 80;
    server_name a.com; 
    access_log logs/z.com.access.log main;
    location / {
            root a.com; 
            index index.html;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;main格式是我们定义好一种日志的格式，并起个名字main，便于引用。&lt;br&gt;
以上面的例子，main类型的日志，记录的remote_addr.... http_x_forwarded_for等选项。&lt;/p&gt;
&lt;h2 id=&#34;日志切割由定时任务完成&#34;&gt;日志切割（由定时任务完成）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;编辑脚本&lt;code&gt;/root/backup.sh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
# 原始日志文件
LOGPATH=/usr/local/nginx/logs/z.com.access.log
# 备份日志目录
BASEPATH=/data/$(date -d yesterday +%Y%m)
mkdir -p $BASEPATH
# 获取昨天的日期并生成备份文件名
bak=$BASEPATH/$(date -d yesterday +%d-%H:%M).zcom.access.log
# 备份
mv $LOGPATH $bak
touch $LOGPATH
kill -USR1 `cat /usr/local/nginx/logs/nginx.pid`
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;设置定时任务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;crontab -e
    01 00 * * * /root/backup.sh  # 每天0时1分(建议在02-04点之间,系统负载小)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nginx与gzip设置压缩管理&#34;&gt;nginx与gzip设置（压缩管理）&lt;/h1&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;gzip是一种压缩技术，经过gzip压缩后的页面大小可以变成原来的30%或者更小。用户浏览页面的时候速度也会更快，gzip的压缩页面需要服务端于浏览器同时支持，服务端压缩传到浏览器进行解压并解析，现在大多数的浏览器都已经支持解析gzip过的页面，gzip使用环境：http块、server块、location块、if(x)，一般把它定义在nginx.conf的http{…..}之间&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;浏览器请求 ----&amp;gt; 声明可以接受gzip压缩(或deflate压缩或compress或sdch压缩) ----&amp;gt; 服务器回应 ----&amp;gt; 把内容用gzip方式压缩发给浏览器 ----&amp;gt;浏览解码gzip ----&amp;gt; 显示收gzip压缩内容&lt;br&gt;
&lt;strong&gt;从http协议的角度看&lt;/strong&gt;：&lt;strong&gt;请求头&lt;/strong&gt;声明 &lt;code&gt;Accept-Encoding:gzip,deflate,sdch&lt;/code&gt; (是指压缩算法,其中sdch是google倡导的一种压缩方式，目前支持的服务器尚不多)，&lt;strong&gt;响应头&lt;/strong&gt;响应:Content-Encoding:gzip、Content-Length:36093&lt;br&gt;
&lt;strong&gt;注意&lt;/strong&gt;：图片/mp3这样的二进制文件,不必压缩，因为压缩率比较小，比如100-&amp;gt;80字节，而且压缩也是耗费CPU资源的。比较小的文件也不必压缩。&lt;br&gt;
&lt;code&gt;Nginx实现资源压缩的原理是通过ngx_http_gzip_module模块拦截请求，并对需要做gzip的类型做gzip，ngx_http_gzip_module是Nginx默认集成的，不需要重新编译，直接开启即可&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;加粗选项为常用选项&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;gzip on|off&lt;/strong&gt;；&lt;br&gt;
打开或关闭gzip&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gzip_buffers 32 4k&lt;/strong&gt;|16 8k|4 8k;&lt;br&gt;
设置用于处理请求压缩的缓冲区数量和大小。比如32 4K表示按照内存页大小以4K为单位（即一个系统中内存页为4K），申请32倍的内存空间。建议此项不设置，使用默认值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gzip_comp_level 6&lt;/strong&gt;；&lt;br&gt;
设置gzip压缩级别(1-9)，级别越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大，&lt;strong&gt;常用值为6&lt;/strong&gt;。&lt;br&gt;
随着压缩级别的升高，压缩比有所提高，但到了级别6后，很难再提高；随着压缩级别的升高，处理时间明显变慢；gzip很消耗cpu的性能，高并发情况下cpu达到100%。&lt;br&gt;
不是压缩级别越高越好，其实&lt;code&gt;gzip_comp_level 1&lt;/code&gt;的压缩能力已经够用了，后面级别越高，压缩的比例其实增长不大，反而很吃处理性能。压缩一定要和静态资源缓存相结合，缓存压缩后的版本，否则每次都压缩高负载下服务器肯定吃不住。&lt;/li&gt;
&lt;li&gt;gzip_disable msie6;&lt;br&gt;
通过表达式，表明哪些UA头不使用gzip压缩。(IE5.5和IE6 SP1使用msie6参数来禁止gzip压缩 )指定哪些不需要gzip压缩的浏览器(将和User-Agents进行匹配)，依赖于PCRE库&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gzip_min_length 200&lt;/strong&gt;;&lt;br&gt;
当返回内容大于此值时才会使用gzip进行压缩，以K为单位，当值为0时，所有页面都进行压缩&lt;/li&gt;
&lt;li&gt;gzip_http_version 1.0|1.1;&lt;br&gt;
用于识别http协议的版本，早期的浏览器不支持gzip压缩，用户会看到乱码，所以为了支持前期版本加了此选项。默认在http/1.0的协议下不开启gzip压缩&lt;/li&gt;
&lt;li&gt;gzip_proxied any;&lt;br&gt;
Nginx做为反向代理的时候启用：
&lt;ul&gt;
&lt;li&gt;off：关闭所有的代理结果数据压缩&lt;/li&gt;
&lt;li&gt;expired：如果header中包含”Expires”头信息，启用压缩&lt;/li&gt;
&lt;li&gt;no-cache：如果header中包含”Cache-Control:no-cache”头信息，启用压缩&lt;/li&gt;
&lt;li&gt;no-store：如果header中包含”Cache-Control:no-store”头信息，启用压缩&lt;/li&gt;
&lt;li&gt;private：如果header中包含”Cache-Control:private”头信息，启用压缩&lt;/li&gt;
&lt;li&gt;no_last_modified：启用压缩，如果header中包含”Last_Modified”头信息，启用压缩&lt;/li&gt;
&lt;li&gt;no_etag：启用压缩，如果header中包含“ETag”头信息，启用压缩&lt;/li&gt;
&lt;li&gt;auth：启用压缩，如果header中包含“Authorization”头信息，启用压缩&lt;/li&gt;
&lt;li&gt;any：无条件压缩所有结果数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;gzip_types text/html&lt;/strong&gt; | &lt;strong&gt;application/x-javascript&lt;/strong&gt; | &lt;strong&gt;text/css&lt;/strong&gt; | application/xml;&lt;br&gt;
设置需要压缩的MIME类型，如果不在设置类型范围内的请求不进行压缩，对应的详细类型，可以在conf/mime.types中查看&lt;/li&gt;
&lt;li&gt;gzip_vary on|off;&lt;br&gt;
是否传输gzip压缩标志，增加响应头”Vary: Accept-Encoding”&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;location详解&#34;&gt;location详解&lt;/h1&gt;
&lt;p&gt;location 有”定位”的意思, 根据Uri来进行不同的定位，在虚拟主机的配置中是必不可少的，location可以把网站的不同部分，定位到不同的处理方式上。比如, .php文件则调用PHP解释器，这时就需要location&lt;/p&gt;
&lt;h2 id=&#34;location语法&#34;&gt;location语法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;location [=|~|~*|^~] patt {...}&lt;/code&gt;，中括号可以不写任何参数，此时称为一般匹配。patt可以是目录、文件、正则表达式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;=&lt;/strong&gt;&lt;br&gt;
严格匹配（精确匹配）。只有请求的 url 路径与后面的字符串完全相等时，才会命中。如果这个查询匹配，那么将停止搜索并立即处理此请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;~&lt;/strong&gt;&lt;br&gt;
区分大小写匹配(可用正则表达式)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;~*&lt;/strong&gt;&lt;br&gt;
不区分大小写匹配(可用正则表达式)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;^~&lt;/strong&gt;&lt;br&gt;
表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找，一般用来匹配目录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;@ name&lt;/strong&gt;&lt;br&gt;
定义一个自定义命名的 location，主要用于内部重定向，不能用来处理正常的请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工作流程&#34;&gt;工作流程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1599099608853.jpg&#34; alt=&#34;工作流程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
location命中过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;先判断精确匹配，如果命中，立即返回结果并结束解析过程&lt;/li&gt;
&lt;li&gt;判断普通命中，如果有多个命中，记录下来最长的命中结果【注意：仅仅是记录，并没有结束解析过程，最长的为准】&lt;/li&gt;
&lt;li&gt;继续判断正则表达是的结果，按照配置中的正则表达式的顺序为准，由上至下开始匹配，一旦匹配成功则立即返回结果，并结束解析过程&lt;br&gt;
【注意：普通匹配的顺序无所谓，是因为按照命中的长短来确定；正则匹配顺序有所谓，因为是从前往后开始匹配】&lt;br&gt;
&lt;code&gt;【总结】优先级：精确匹配&amp;gt;正则匹配&amp;gt;普通匹配；匹配顺序：精确匹配&amp;gt;普通匹配&amp;gt;正则匹配&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;举例&#34;&gt;举例&lt;/h2&gt;
&lt;h3 id=&#34;无正则&#34;&gt;无正则&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;location = / {
   root  /var/www/html/;
   index index.htm index.html;
}
location / {
   root  /usr/local/nginx/html;
   index index.html index.htm;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;location配置如上,若访问&lt;code&gt;http://xxx.com/&lt;/code&gt;，定位的流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;精准匹配命中&amp;quot;/&amp;quot;，得到index页为&lt;code&gt;index.htm&lt;/code&gt;，所以请求的地址变为&lt;code&gt;http://xxx.com/index.htm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;再次匹配&lt;code&gt;/index.htm&lt;/code&gt;，此次内部转跳uri已经是&lt;code&gt;/index.htm&lt;/code&gt;，命中普通匹配&lt;code&gt;/&lt;/code&gt;，根目录为&lt;code&gt;/usr/local/nginx/html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最终结果访问了&lt;code&gt;/usr/local/nginx/html/index.htm&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;有正则&#34;&gt;有正则&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;location / {
  root  /usr/local/nginx/html;
  index index.html index.htm;
}
location ~ image {
  root  /var/www/;
  index index.html;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果访问&lt;code&gt;http://xx.com/image/logo.png&lt;/code&gt;，此时uri为&lt;code&gt;/image/logo.png&lt;/code&gt;命中了普通匹配&lt;code&gt;/&lt;/code&gt;，也命中了正则匹配&lt;code&gt;~ image&lt;/code&gt;，但是根据上述图片中匹配过程分析,最终是正则匹配生效。所以最终访问地址为&lt;code&gt;/var/www/image/logo.png&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;更长匹配&#34;&gt;更长匹配&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;location / {
            root   /usr/local/nginx/html;
            index  index.html index.htm;
        }
location /foo {
            root /var/www/html;
            index index.html;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;访问 &lt;code&gt;http://xxx.com/foo&lt;/code&gt;， 对于uri来说，&lt;code&gt;/foo&lt;/code&gt;两个location的patt都能匹配他们，即&lt;code&gt;/&lt;/code&gt;能从左前缀匹配 &lt;code&gt;/foo&lt;/code&gt;, &lt;code&gt;/foo&lt;/code&gt;也能左前缀匹配&lt;code&gt;/foo&lt;/code&gt;，此时真正访问&lt;code&gt;/var/www/html/index.html&lt;/code&gt;，原因：&lt;code&gt;/foo&lt;/code&gt;匹配的更长，因此使用之&lt;/p&gt;
&lt;h3 id=&#34;name的用法&#34;&gt;@name的用法&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;location / {
  try_files $uri $uri/ @custom
}
location @custom {
  # ...do something
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当访问url找不到对应的文件就重定向到我们自定义的命名location（此处为 custom）。命名 location中不能再嵌套其它的命名location。&lt;/p&gt;
&lt;h3 id=&#34;综合&#34;&gt;综合&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 只匹配&amp;quot;/&amp;quot;.
location = / { 
 [ configuration A ]  
} 
 # 匹配任何请求，因为所有请求都是以&amp;quot;/&amp;quot;开始，但是更长字符匹配或者正则表达式匹配会优先匹配 
location / { 
 [ configuration B ]  
} 
# 匹配任何以 /images/ 开始的请求，并停止匹配其它location 
location ^~ /images/ { 
 [ configuration C ]  
} 
# 匹配以 gif、jpg、jpeg结尾的请求，但是所有 /images/ 目录的请求将由 [Configuration C]处理.   
location ~* \.(gif|jpg|jpeg)$ { 
 [ configuration D ]  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;/&lt;/strong&gt;：精确匹配到第1个location，匹配停止，使用configurationA&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/some/other/url&lt;/strong&gt;：首先前缀部分字符串匹配到了第2个location，然后进行正则匹配，显然没有匹配上，则使用第2个location的配置configurationB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/images /1.jpg&lt;/strong&gt;：首先前缀部分字符串匹配到了第2个location，但是接着对第3个location也前缀匹配上了，而且这时已经是配置文件里面对这个url的最大字符串匹配了，并且location带有 &amp;quot;^~&amp;quot; 前缀，则不再进行正则匹配，最终使用configurationC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;/some/other/path/to/1.jpg&lt;/strong&gt;：首先前缀部分同样字符串匹配到了第2个location，然后进行正则匹配，这时正则匹配成功，则使用congifurationD&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;url尾部的需不需要&#34;&gt;URL尾部的/需不需要&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;location 中的字符有没有/都没有影响。也就是说/user/和/user是一样的。&lt;/li&gt;
&lt;li&gt;如果URL结构是https://domain.com/的形式，尾部有没有/都不会造成重定向。因为浏览器在发起请求的时候，默认加上了/，虽然很多浏览器在地址栏里也不会显示/，这一点，可以访问baidu验证一下。&lt;/li&gt;
&lt;li&gt;如果URL的结构是https://domain.com/some-dir/，尾部如果缺少/将导致重定向。因为根据约定，URL尾部的/表示目录，没有/表示文件。所以，访问/some-dir/时，服务器会自动去该目录下找对应的默认文件；访问/some-dir的话，服务器会先去找some-dir文件，找不到的话会将some-dir当成目录，重定向到/some-dir/，去该目录下找默认文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;rewrite语法详解&#34;&gt;Rewrite语法详解&lt;/h1&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;rewrite功能就是使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向。rewrite只能放在 server、 location、 if中，并且&lt;strong&gt;只能对域名后边的除去传递的参数外的字符串&lt;/strong&gt;起作用。例如 &lt;code&gt;http://seanlook.com/a/we/index.php?id=1&amp;amp;u=str&lt;/code&gt;只对&lt;code&gt;/a/we/index.php&lt;/code&gt;重写。&lt;/p&gt;
&lt;h2 id=&#34;语法&#34;&gt;语法&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;rewrite regex replacement [flag];&lt;/code&gt;&lt;br&gt;
如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。rewrite和location功能有点像，都能实现跳转，主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。&lt;br&gt;
很多情况下rewrite也会写在location里，它们的执行顺序是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行server块的rewrite指令&lt;/li&gt;
&lt;li&gt;执行location匹配&lt;/li&gt;
&lt;li&gt;执行选定的location中的rewrite指令&lt;br&gt;
如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500错误。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;flag标志位&#34;&gt;flag标志位&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;last : 相当于Apache的[L]标记，表示完成rewrite&lt;/li&gt;
&lt;li&gt;break : 停止执行当前虚拟主机的后续rewrite指令集&lt;/li&gt;
&lt;li&gt;redirect : 返回302临时重定向，地址栏会显示跳转后的地址&lt;/li&gt;
&lt;li&gt;permanent : 返回301永久重定向，地址栏会显示跳转后的地址&lt;br&gt;
因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301、302的原因了。这里last和break区别有点难以理解：&lt;/li&gt;
&lt;li&gt;last一般写在server和if中，而break一般使用在location中&lt;/li&gt;
&lt;li&gt;last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配&lt;/li&gt;
&lt;li&gt;break和last都能组织继续执行后面的rewrite指令&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常用正则&#34;&gt;常用正则&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;. ： 匹配除换行符以外的任意字符
? ： 重复0次或1次
+ ： 重复1次或更多次
* ： 重复0次或更多次
\d ：匹配数字
^ ： 匹配字符串的开始
$ ： 匹配字符串的结束
{n} ： 重复n次
{n,} ： 重复n次或更多次
[c] ： 匹配单个字符c
[a-z] ： 匹配a-z小写字母的任意一个
小括号()之间匹配的内容，可以在后面通过$1来引用，$2表示的是前面第二个()里的内容。
正则里面容易让人困惑的是\转义特殊字符
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;举例-2&#34;&gt;举例&lt;/h2&gt;
&lt;h3 id=&#34;例1&#34;&gt;例1&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http {
    # 定义image日志格式
    log_format imagelog &#39;[$time_local] &#39; $image_file &#39; &#39; $image_type &#39; &#39; $body_bytes_sent &#39; &#39; $status;
    # 开启重写日志
    rewrite_log on;
    
    server {
        root /home/www;
        
        location / {
            # 重写规则信息
            error_log logs/rewrite.log notice;
            # 注意这里要用‘&#39;单引号引起来，避免{}
            rewrite &#39;^/images/([a-z]{2})/([a-z0-9]{5})/(.*)\.(png|jpg|gif)$&#39; /data?file=$3.$4;
            # 注意不能在上面这条规则后面加上“last”参数，否则下面的set指令不会执行
            set $image_file $3;
            set $image_type $4;
            }
        
        location /data {
            # 指定针对图片的日志格式，来分析图片类型和大小
            access_log logs/images.log mian;
            root /data/images;
            # 应用前面定义的变量。判断首先文件在不在，不在再判断目录在不在，如果还不在就跳转到最后一个url里
            try_files /$arg_file /image404.html;
            }
        location = /image404.html {
            # 图片不存在返回特定的信息
            return 404 &amp;quot;image not found\n&amp;quot;;
        }
}

# 对形如/images/ef/uh7b3/test.png的请求，重写到/data?file=test.png，
# 于是匹配到location /data，先看/data/images/test.png文件存不存在，
# 如果存在则正常响应，
# 如果不存在则重写tryfiles到新的image404 location，直接返回404状态码。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例2&#34;&gt;例2&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rewrite ^/images/(.*)_(\d+)x(\d+)\.(png|jpg|gif)$ /resizer/$1.$4?width=$2&amp;amp;height=$3? last;
# 对形如/images/bla_500x400.jpg的文件请求，
# 重写到/resizer/bla.jpg?width=500&amp;amp;height=400地址，并会继续尝试匹配location。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;if指令与全局变量&#34;&gt;if指令与全局变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;if (condition){重写模式}&lt;/code&gt;，对给定的条件condition进行判断。如果为真，大括号内的rewrite指令将被执行，if条件可以是如下任何内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当表达式只是一个变量时，如果&lt;strong&gt;值为空或任何以0开头的字符串&lt;/strong&gt;都会当做false&lt;/li&gt;
&lt;li&gt;直接比较变量和内容时，使用=或!=&lt;/li&gt;
&lt;li&gt;~ 正则表达式匹配&lt;/li&gt;
&lt;li&gt;~* 不区分大小写的匹配&lt;/li&gt;
&lt;li&gt;!~ 区分大小写的不匹配&lt;/li&gt;
&lt;li&gt;-f和!-f 用来判断是否存在文件&lt;/li&gt;
&lt;li&gt;-d和!-d 用来判断是否存在目录&lt;/li&gt;
&lt;li&gt;-e和!-e 用来判断是否存在文件或目录&lt;/li&gt;
&lt;li&gt;-x和!-x 用来判断文件是否可执行&lt;br&gt;
重写模式中常用指令：&lt;/li&gt;
&lt;li&gt;set：设置变量用的, 可以用来达到多条件判断时作标志用，达到apache下的rewrite_condition的效果&lt;/li&gt;
&lt;li&gt;return：返回状态码&lt;/li&gt;
&lt;li&gt;break：跳出rewrite&lt;/li&gt;
&lt;li&gt;rewrite：重写&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;例子&#34;&gt;例子&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 如果UA包含&amp;quot;MSIE&amp;quot;，rewrite请求到/msid/目录下，即如果用户设备为IE浏览器的时候，重定向
if ($http_user_agent ~ MSIE) {
    rewrite ^(.*)$ /msie/$1 break;
    } 
 
# IE浏览器访问时，跳转到ie.htm
if ($http_user_agent ~ MSIE) {
    rewrite ^.*$ /ie.htm;
    break;  # 不break会导致循环重定向
    }

# 判断IE并重写，且不用break，用set变量来达到目的【判断是IE浏览器且方位的不是ie.html，则进行重写】
if ($http_user_agent ~* msie) {
    set $isie 1;
    }
if ($fastcgi_script_name = ie.html) {
    set $isie 0;
    }
if ($isie 1) {
    rewrite ^.*$ ie.html;   # $isie的值为1则重写
    }

 # 如果cookie匹配正则，设置变量$id等于正则引用部分
if ($http_cookie ~* &amp;quot;id=([^;]+)(?:;|$)&amp;quot;) {
    set $id $1;
    } 
 
 # 如果提交方法为POST，则返回状态405（Method not allowed）。return不能返回301、302
if ($request_method = POST) {
    return 405;
    } 
 
 # 限速，$slow可以通过set指令设置
if ($slow) {
    limit_rate 10k;
    } 
 
# 如果请求的文件名不存在，则反向代理到localhost 。这里的break也是停止rewrite检查
if (!-f $request_filename){
    break;
    proxy_pass http://127.0.0.1;
    } 
 
# 如果query string中包含&amp;quot;post=140&amp;quot;，永久重定向到example.com
if ($args ~ post=140){
    rewrite ^ http://example.com/ permanent;
    }
 
 # 禁止192.168.1.100访问
if  ($remote_addr = 192.168.1.100) {
    return 403;
    }

# 当访问的文件不存在时，重定向至404.html
if (!-e $document_root$fastcgi_script_name) {
    rewrite ^.*$ /404.html break;
    } 
# 以 xx.com/dsafsd.html这个不存在页面为例，观察访问日志, 日志中显示的访问路径依然是&amp;quot;GET /dsafsd.html HTTP/1.1&amp;quot;
# 提示: 服务器内部的rewrite和302跳转不一样. 
#         跳转的话URL都变了，变成重新http请求404.html，而内部rewrite, 上下文没变,
#         就是说 fastcgi_script_name 仍然是 dsafsd.html，因此会循环重定向。

 # 防盗链
location ~* \.(gif|jpg|png|swf|flv)$ {
    valid_referers none blocked www.123.com www.abc.com;
    if ($invalid_referer) {
        return 404;
        } 
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;全局变量&#34;&gt;全局变量&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;$args ： #这个变量等于请求行中的参数，同$query_string
$content_length ： 请求头中的Content-length字段。
$content_type ： 请求头中的Content-Type字段。
$document_root ： 当前请求在root指令中指定的值。
$host ： 请求主机头字段，否则为服务器名称。
$http_user_agent ： 客户端agent信息
$http_cookie ： 客户端cookie信息
$limit_rate ： 这个变量可以限制连接速率。
$request_method ： 客户端请求的动作，通常为GET或POST。
$remote_addr ： 客户端的IP地址。
$remote_port ： 客户端的端口。
$remote_user ： 已经经过Auth Basic Module验证的用户名。
$request_filename ： 当前请求的文件路径，由root或alias指令与URI请求生成。
$scheme ： HTTP方法（如http，https）。
$server_protocol ： 请求使用的协议，通常是HTTP/1.0或HTTP/1.1。
$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。
$server_name ： 服务器名称。
$server_port ： 请求到达服务器的端口号。
$request_uri ： 包含请求参数的原始URI，不包含主机名，如：”/foo/bar.php?arg=baz”。
$uri ： 不带请求参数的当前URI，$uri不包含主机名，如”/foo/bar.html”。
$document_uri ： 与$uri相同。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;例子-2&#34;&gt;例子&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://localhost:88/test1/test2/test.php
    $host：localhost
    $server_port：88
    $request_uri：http://localhost:88/test1/test2/test.php
    $document_uri：/test1/test2/test.php
    $document_root：/var/www/html
    $request_filename：/var/www/html/test1/test2/test.php
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基于ecshop的rewrite实战&#34;&gt;基于ecshop的Rewrite实战&lt;/h2&gt;
&lt;p&gt;注意：用url重写时, 正则里如果有&lt;code&gt;{}&lt;/code&gt;，正则要用双引号包起来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;location /ecshop {
    index index.php;
    # 将&amp;quot;goods-xxxxxxx.html&amp;quot;重写到&amp;quot;goods.php?id=xxxxxxx&amp;quot;
    rewrite &amp;quot;goods-(\d{1,7})\.html&amp;quot; /exshop/goods.php?id=$1;  # $1为正则匹配的后向引用
    # 或者
    rewrite goods-([\d]+)\.html$ /ecshop/goods.php?id=$1;

    # 下面为各个页面的重写配置
    rewrite article-([\d]+)\.html$ /ecshop/article.php?id=$1;
    rewrite category-(\d+)-b(\d+)\.html /ecshop/category.php?id=$1&amp;amp;brand=$2;
    rewrite category-(\d+)-b(\d+)-min(\d+)-max(\d+)-attr([\d\.]+)\.html /ecshop/category.php?id=$1&amp;amp;brand=$2&amp;amp;price_min=$3&amp;amp;price_max=$4&amp;amp;filter_attr=$5;
    rewrite category-(\d+)-b(\d+)-min(\d+)-max(\d+)-attr([\d+\.])-(\d+)-([^-]+)-([^-]+)\.html /ecshop/category.php?id=$1&amp;amp;brand=$2&amp;amp;price_min=$3&amp;amp;price_max=$4&amp;amp;filter_attr=$5&amp;amp;page=$6&amp;amp;sort=$7&amp;amp;order=$8;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nginx缓存配置&#34;&gt;nginx缓存配置&lt;/h1&gt;
&lt;p&gt;提高网站性能。对于网站的图片，尤其是新闻站,，图片一旦发布,，改动的可能是非常小的。能否在用户访问一次后，图片缓存在用户的浏览器端，且时间比较长的缓存。&lt;/p&gt;
&lt;h2 id=&#34;expires参数&#34;&gt;expires参数&lt;/h2&gt;
&lt;p&gt;使用nginx的expires设置 ，可以在location块或if块里，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;expires 30s;
expires 30m;
expires 2h;
expires 30d;
# 【注意】：服务器的日期要准确，如果服务器的日期落后于实际日期，可能导致缓存失效
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;304not-modified&#34;&gt;304(Not Modified)&lt;/h3&gt;
&lt;p&gt;304也是一种很好的缓存手段，&lt;em&gt;这个不需要设置&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;原理&lt;/strong&gt;：服务器响应文件内容时，同时响应&lt;code&gt;Etag&lt;/code&gt;标签（内容的签名，内容一变，他也变）和&lt;code&gt;Last_Modified&lt;/code&gt;这2个标签值（Expires为缓存内容到期时间），浏览器下次去请求时，头信息发送这两个标签, 服务器检测文件有没有发生变化，如过没有发生变化，直接头信息返回&lt;code&gt;Etag&lt;/code&gt;和&lt;code&gt;Last_Modified&lt;/code&gt;。浏览器知道内容无改变，于是直接调用本地缓存。&lt;br&gt;
这个过程，也请求了服务器，但是传着的内容极少。对于变化周期较短的，如静态html、js、css，比较适于用这个方式。&lt;/p&gt;
&lt;h1 id=&#34;nginx反向代理和负载均衡nginxapache动静分离&#34;&gt;nginx反向代理和负载均衡（nginx+apache动静分离）&lt;/h1&gt;
&lt;p&gt;用nginx做反向代理和负载均衡非常简单，支持两个用法&lt;code&gt;proxy&lt;/code&gt;和&lt;code&gt;upstream&lt;/code&gt;，分别用来做反向代理和负载均衡。&lt;br&gt;
详细的配置参考上面的内容。&lt;/p&gt;
&lt;h2 id=&#34;反向代理&#34;&gt;反向代理&lt;/h2&gt;
&lt;p&gt;以反向代理为例，nginx不自己处理php的相关请求，而是把php的相关请求转发给apache来处理。&lt;br&gt;
下图为“动静分离”，动静分离不是一个严谨的说法，叫&lt;strong&gt;反向代理&lt;/strong&gt;比较规范。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1599397999403.png&#34; alt=&#34;动静分离&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主要配置：&lt;code&gt;proxy_pass http://192.168.1.200:8080&lt;/code&gt;，其中&lt;code&gt;http://&lt;/code&gt;必须添加，这是指明协议&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Apache配置
cd /usr/local/httpd
vim conf/httpd.conf
    Listen 8080
    Include conf/extra/httpd-vhosts.conf
    &amp;lt;Directory /&amp;gt;
        Option FollowSymLinks
        AllowOverride all
        Order deny,allow
        Allow from all
    &amp;lt;/Directory&amp;gt;
vim conf/extra/httpd-vhost.conf
    NameVirtualHost *:8080
    &amp;lt;VirtualHost *:8080&amp;gt;
        ServerAdmin webmaster@dummy-host.example.com
        DocumentRoot &amp;quot;/usr/local/nginx/html&amp;quot;
        ServerName &amp;quot;192.168.1.200&amp;quot;
        ServerAlias www.dummy-host.example.com
    &amp;lt;/VirtualHost&amp;gt;

# Nginx配置
cd /usr/local/nginx
vim conf/nginx.conf
    location ~ \.php$ {
        proxy_pass http://192.168.1.200:8080 # 将php文件交给apache处理
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试脚本test.php：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;// 动态
&amp;lt;?php  
//phpinfo();
echo rand(1,1000);  //产生1~1000内的随机数
?&amp;gt;
// 静态
&amp;lt;img src=&amp;quot;image/logo.png&amp;quot; /&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;
&lt;p&gt;反向代理后端如果有多台服务器，自然可形成负载均衡，但proxy_pass需要指向多台服务器，把多台服务器用&lt;code&gt;upstream&lt;/code&gt;指定绑定在一起并起个组名，然后proxy_pass指向该组&lt;br&gt;
默认的均衡的算法很简单，就是针对后端服务器的按照顺序逐个请求，也有其他负载均衡算法，如一致性哈希等（需要安装第3方模块）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim conf/nginx.conf
    upstream imgserver {
        server 192.168.1.200:81 weight=1 fail_timeout=3 max_fails=2;
        server 192.168.1.200:82 weight=1 fail_timeout=3 max_fails=2;
        
    } 
    server {
        listen 81;
        serber_name localhost;
        root html;
        access_log logs/81-access.log main;
    }
    server {
        listen 82;
        serber_name localhost;
        root html;
        access_log logs/82-access.log main;
    }
    location ~* \.(jpg|jpeg|gif|png) {
        # 反向代理导致了后端服务器收到的源IP为前端服务器的IP，而不是客户真正的IP，解决方法如下
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_pass http://imgserver;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;nginx连接memcached&#34;&gt;nginx连接memcached&lt;/h1&gt;
&lt;h2 id=&#34;memcached&#34;&gt;memcached&lt;/h2&gt;
&lt;p&gt;memcached是一套分布式的高速缓存系统，被许多网站使用。&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install libmemcache* memcache* # 安装memcached及php的memcached扩展
memcached -d -l 127.0.0.1 -p 11211 -m 500 -u root
    # -d：守护进程。当从终端窗口退出的时候memcached还会继续运行
    # -l：指定ip地址，这里指定本地ip
    # -p：指定端口号，端口号为11211
    # -m：分配内存，这里分配了500M内存
    # -u：使用哪个用户运行memcached
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;php连接memecached的配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 编译php连接memecached的扩展
vim conf/php.ini
    extension=memcached.so
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用教程&#34;&gt;使用教程&lt;/h3&gt;
&lt;p&gt;参考：&lt;a href=&#34;https://www.runoob.com/Memcached/Memcached-tutorial.html&#34;&gt;https://www.runoob.com/Memcached/Memcached-tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 连接 
telnet 127.0.0.1 11211
# 创建值
add /user1.html 0 0 7 # key=&amp;quot;/user1.html&amp;quot;，flag=0，exptime=0，bytes=7
i am lisi  # value=&amp;quot;i am lisi&amp;quot;
# 如果数据添加成功，则输出STORED
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nginx连接memcached-2&#34;&gt;nginx连接memcached&lt;/h2&gt;
&lt;p&gt;nginx的memcached_module模块可以直接从memcached服务器中读取内容后输出，后续的请求不再经过应用程序处理，如php-fpm、django等，大大的提升动态页面的速度。&lt;br&gt;
nginx只负责从memcached服务器中读取数据，要往memcached写入数据还得需要后台的应用程序来完成，主动的将要缓存的页面缓存到memcached中，可以通过404重定向到后端去处理的。&lt;br&gt;
ngx_http_memcached_module可以操作任何兼用memcached协议的软件。如ttserver、membase等。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1599442580458.jpg&#34; alt=&#34;nginx连接memcached&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
memcached的key可以通过&lt;code&gt;memcached_key&lt;/code&gt;来设置。如果命中，那么直接输出内容，没有命中就意味着nginx需要从应用程序请求页面。同时，该应用程序将键值对写入到memcached，以便下一个请求可以直接从memcached获取。&lt;br&gt;
如果键值不存在，nginx将报告&lt;code&gt;not found&lt;/code&gt;错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;最好的方法是&lt;/strong&gt;使用&lt;code&gt;error_page&lt;/code&gt;指定和location请求处理。同时包含&lt;code&gt;Bad Gateway&lt;/code&gt;错误和&lt;code&gt;Gateway Timeout&lt;/code&gt;错误，例如&lt;code&gt;error_page 404 502 504 = @app;&lt;/code&gt;。【注意】：需要设置default_type，否则可能会显示不正常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;参数详解-2&#34;&gt;参数详解&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;memcached_bind：指定从哪个IP来连接memcached服务器。语法: &lt;code&gt;memcached_bind address | off&lt;/code&gt;，默认值none。配置段http, server, location&lt;/li&gt;
&lt;li&gt;memcached_buffer_size：读取从memcached服务器接收到响应的缓冲大小，尽快的将响应同步传给客户端。语法: &lt;code&gt;memcached_buffer_size size&lt;/code&gt;，默认值4k|8k。配置段: http, server, location&lt;/li&gt;
&lt;li&gt;memcached_connect_timeout：与memcached服务器建立连接的超时时间，通常不超过75s。语法：&lt;code&gt;memcached_connect_timeout time&lt;/code&gt;，默认值60s。配置段：http, server, location&lt;/li&gt;
&lt;li&gt;memcached_gzip_flag：测试memcached服务器响应标志，如果设置了，将在响应头部添加了Content-Encoding：gzip。语法：&lt;code&gt;memcached_gzip_flag flag&lt;/code&gt;，默认值none。配置段：http, server, location&lt;/li&gt;
&lt;li&gt;memcached_next_upstream：指定在哪些状态下请求将转发到另外的负载均衡服务器上，仅当memcached_pass有两个或两个以上时使用。语法：&lt;code&gt;memcached_next_upstream error | timeout | invalid_response | not_found | off ...&lt;/code&gt;，默认值error timeout。配置段: http, server, location&lt;/li&gt;
&lt;li&gt;memcached_pass：指定memcached服务器地址。使用变量$memcached_key为key查询值，如果没有相应的值则返回error_page 404。语法：&lt;code&gt;memcached_pass address:port or socket&lt;/code&gt;，默认值none。配置段：location, if in location&lt;/li&gt;
&lt;li&gt;memcached_read_timeout：定义从memcached服务器读取响应超时时间。语法：&lt;code&gt;memcached_read_timeout time&lt;/code&gt;，默认值60s。配置段：http, server, location&lt;/li&gt;
&lt;li&gt;memcached_send_timeout：设置发送请求到memcached服务器的超时时间。语法：&lt;code&gt;memcached_send_timeout&lt;/code&gt;，默认值60s。配置段：http, server, location&lt;/li&gt;
&lt;li&gt;$memcached_key 变量：memcached key的值，可以设置为&lt;code&gt;$request_uri&lt;/code&gt;、&lt;code&gt;$uri&lt;/code&gt;、&lt;code&gt;$request_method$request_uri&lt;/code&gt;、&lt;code&gt;$uri?$args&lt;/code&gt;等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim conf/nginx.conf
    server {
        location / {
            # set            $memcached_key &amp;quot;$uri?$args&amp;quot;;
            set            $memcached_key &amp;quot;$uri&amp;quot;;
            memcached_pass 127.0.0.1:11211;
            # error_page     404 502 504 = @fallback;
            error_page 404 /callback.php
        }
        # location @fallback {
        #     proxy_pass     http://backend;
        # }
    }

vim php.ini
    memcache.hash_strategy=consistent

vim html/callback.php
    &amp;lt;?php
    //print_r($_SERVER);
    //获取uri，用来当memcached的key
    $uri = $_SERVER[&#39;REQUEST_URI&#39;];
    //echo $uri

    //添加多台服务器，php也需要添加和nginx一样多的服务器
    $mem = new memcache();
    $mem-&amp;gt;addServer(&#39;192.168.1.200&#39;,11211); # 此时不能用localhost
    $mem-&amp;gt;addServer(&#39;192.168.1.200&#39;,11212);
    $mem-&amp;gt;addServer(&#39;192.168.1.200&#39;,11213);

    //提取uri中的uid
    $uid=substr($uri,5,strpos($uri,&amp;quot;.&amp;quot;)-5);
    //echo $uid;
    // 连接数据库，查询并写入memcached
    $conn = mysql_connect(&#39;localhost&#39;,&#39;root&#39;,&#39;&#39;);
    $sql = &#39;use test&#39;;
    mysql_query($sql,$conn);
    $sql = &#39;use names utf8&#39;;
    mysql_query($sql,$conn);
    $sql = &#39;select * from user where uid=&#39;.$uid;
    $rs = mysql_query($sql,$conn);
    echo &#39;from mysql query&amp;lt;br /&amp;gt;&#39;;
    $user = mysql_fetch_assoc($rs);
    if (empty($user)){
        echo &amp;quot;no this user&amp;quot;;        
    }else{
        //print_r($user);
        $html = &#39;&amp;lt;h1&amp;gt;&#39;. $user[&#39;username&#39;] .&#39;&amp;lt;/h1&amp;gt;&#39;;
        echo $html
        //$mem = new memcache();
        //$mem-&amp;gt;connect(&#39;localhost&#39;,11211);
        $mem-&amp;gt;add($uri,$html,0,300);
        $mem-&amp;gt;close();
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;多台memcache&#34;&gt;多台memcache&lt;/h2&gt;
&lt;p&gt;多台memcache时，nginx与php如何保持集群上的算法同步？&lt;/p&gt;
&lt;h3 id=&#34;第三方模块ngx_http_consistent_hash的安装&#34;&gt;第三方模块（ngx_http_consistent_hash）的安装&lt;/h3&gt;
&lt;p&gt;Nginx upstream可以实现负载均衡。第三方模块ngx_http_consistent_hash通过一致性哈希算法来选择合适的后端节点。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/src
wget https://codeload.github.com/replay/ngx_http_consistent_hash/zip/master
unzip master.zip
cd nginx-1.18.0
./configure --prefix=/usr/local/nginx --add-module=/usr/local/src/ngx_http_consistent_hash-master   # --add-module后面是第三方模块的路径
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置memcache集群&#34;&gt;配置memcache集群&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim conf/nginx.conf
    upstream mcserver {
        consistent_hash &amp;quot;$request_uri&amp;quot;;
        server 192.168.1.200:11211;  # 此时不能用localhost
        server 192.168.1.200:11212;
        server 192.168.1.200:11213;
    }
    location / {
        set $memcached_key &amp;quot;$uri&amp;quot;;
        memcached_pass mcserver;
        error_page 404 /callback.php;
       }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;高性能的服务器的架设&#34;&gt;高性能的服务器的架设&lt;/h1&gt;
&lt;p&gt;主要讲解大量访问整体优化思路，对于高性能网站 ，请求量大，如何支撑？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;要减少请求：对于开发人员，合并css, 背景图片, 减少mysql查询等&lt;/li&gt;
&lt;li&gt;对于运维nginx的expires，利用浏览器缓存等，减少查询&lt;/li&gt;
&lt;li&gt;利用cdn来响应请求&lt;/li&gt;
&lt;li&gt;最终剩下的，不可避免的请求，通过服务器集群+负载均衡来支撑。来到这步，就不要再考虑减少请求这个方向了，而是思考如何更好的响应高并发请求。既然响应是不可避免的，就把要做的把工作内容”平均”分给每台服务器，最理想的状态是每台服务器的性能都被充分利用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;内核参数调整&#34;&gt;内核参数调整&lt;/h2&gt;
&lt;h3 id=&#34;网络&#34;&gt;网络&lt;/h3&gt;
&lt;p&gt;net.core.somaxconn = 4096 允许等待中的监听&lt;br&gt;
net.ipv4.tcp_tw_recycle = 1  tcp连接快速回收&lt;br&gt;
net.ipv4.tcp_tw_reuse = 1    tcp连接重用&lt;br&gt;
net.ipv4.tcp_syncookies = 0  不抵御洪水攻击&lt;/p&gt;
&lt;h3 id=&#34;防火墙建议关掉&#34;&gt;防火墙(建议关掉)&lt;/h3&gt;
&lt;p&gt;net.nf_conntrack_max = 655350&lt;br&gt;
net.netfilter.nf_conntrack_tcp_timeout_established = 120&lt;/p&gt;
&lt;h3 id=&#34;文件&#34;&gt;文件&lt;/h3&gt;
&lt;p&gt;fs.file-max = 655360   系统最大文件描述符&lt;/p&gt;
&lt;h3 id=&#34;进程最大文件描述符&#34;&gt;进程最大文件描述符&lt;/h3&gt;
&lt;p&gt;/etc/security/limits.conf&lt;br&gt;
soft nofile 50000&lt;br&gt;
hard nofile 50000&lt;/p&gt;
&lt;h2 id=&#34;nginx参数调整&#34;&gt;nginx参数调整&lt;/h2&gt;
&lt;p&gt;work process  打开的进程数量,为CPU核心数即可&lt;br&gt;
worker_rlimit_nofile 30000; 进程打开文件的最大数量&lt;br&gt;
keepalive_timeout  0;&lt;/p&gt;
&lt;h2 id=&#34;php-fpm参数调整&#34;&gt;php-fpm参数调整&lt;/h2&gt;
&lt;p&gt;pm = static&lt;br&gt;
pm.max_children = 32&lt;/p&gt;
">Nginx学习整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/shan-chu-mu-lu-xia-de-kong-wen-jian-he-kong-wen-jian-jia/"" data-c="
          &lt;p&gt;要实现此目标，需要先删除空文件。如果先删除空文件夹，则会导致删除空文件之后，新产生的空文件夹无法被删除，或者需要进行二次操作，因此为提高效率和代码的质量，需要先删除空文件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;删除空文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;for root,dirs,files in os.walk(dir):
    for file in files:
        src_file=os.path.join(root,file)
        if os.path.getsize(src_file) == 0:
            os.remove(src_file)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;删除空文件夹&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;​dir_list=[]
for root,dirs,files in os.walk(dir):
    dir_list.append(root)
# 先生成文件夹的列表，重点是下边
for root in dir_list[::-1]:  # 先删除空子目录，然后才能删除空的父目录
    if not os.listdir(root): # 判断文件夹中文件列表长度为0则删除文件
        os.rmdir(root)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;合并函数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import os
def Remove_Null(dir,size):  # dir指定目录，size指定要删除的文件大小
    dir_list=[]
    # 删除空文件，删除小于等于size的文件
    for root,dirs,files in os.walk(dir):
        dir_list.append(root)
        for file in files:
            src_file=os.path.join(root, file)
            if os.path.getsize(src_file)&amp;lt;=size:
                os.remove(src_file)
    # 删除空目录
    for root in dir_list[::-1]:
        if not os.listdir(root):
            os.rmdir(root)
&lt;/code&gt;&lt;/pre&gt;
">删除目录下的空文件和空文件夹</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/try-yi-chang-chu-li/"" data-c="
          &lt;p&gt;为了处理异常，使用&lt;code&gt;try...except&lt;/code&gt;，把可能发生错误的语句放在try模块里，用except来处理异常。except可以处理一个专门的异常，也可以处理一组圆括号中的异常，如果except后没有指定异常，则默认处理所有的异常。每一个try，都必须至少有一个except。&lt;br&gt;
在python的异常中，有一个万能异常：Exception，可以捕获任意异常：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s1 = &#39;hello&#39;
try:
  int(s1)
except Exception,e:
  print(e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要考虑到try代码块中可能出现的多个异常，可以这样写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s1 = &#39;hello&#39;
try:
  int(s1)
except IndexError,e:
  print(e)
except KeyError,e:
  print(e)
except ValueError,e:
  print(e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;异常的简单结构和复杂结构&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
　　pass
except Exception as e: #python2 中还可以这样写：except Exception,e
　　pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;完整实列&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
  # 主代码块
  pass
except KeyError,e:
  # 异常时，执行该块
  pass
else:
  # 主代码块执行完，执行该块
  pass
finally:
  # 无论异常与否，最终执行该块
  pass
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先定义特殊提醒的异常，最后定义Exception,来确保程序正常运行。&lt;br&gt;
先特殊，后万能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;s1 = &#39;hello&#39;
try:
  int(s1)
except KeyError,e:
  print(&#39;键错误&#39;)
except IndexError,e:
  print(&#39;索引错误&#39;)
except Exception, e:
  print(&#39;错误&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主动触发异常：&lt;code&gt;raise Exception(&#39;messages&#39;)&lt;/code&gt;可以自定义报错信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=2
if a &amp;gt; 1:
  raise ValueError(&#39;值大于1&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;raise 触发异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;try:
  raise Exception(&#39;错误了。。。&#39;)
except Exception,e:
  print e
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自定义异常&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class XXXXXException(Exception):
  def __init__(self, msg):
    self.message = msg
  def __str__(self):
    return self.message
try:
  raise XXXXXException(&#39;我的异常&#39;)
except XXXXXException,e:
  print(e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;python所有的标准异常类&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BaseException：所有异常的基类
&lt;ul&gt;
&lt;li&gt;SystemExit：解释器请求退出&lt;/li&gt;
&lt;li&gt;KeyboardInterrupt：用户中断执行(通常是输入^C)&lt;/li&gt;
&lt;li&gt;GeneratorExit：生成器(generator)发生异常来通知退出&lt;/li&gt;
&lt;li&gt;Exception：常规错误的基类
&lt;ul&gt;
&lt;li&gt;StopIteration：迭代器没有更多的值&lt;/li&gt;
&lt;li&gt;StopAsyncIteration：异步迭代器对象停止迭代&lt;/li&gt;
&lt;li&gt;ArithmeticError：所有数值计算错误的基类
&lt;ul&gt;
&lt;li&gt;FloatingPointError：浮点计算错误&lt;/li&gt;
&lt;li&gt;OverflowError：数值运算超出最大限制&lt;/li&gt;
&lt;li&gt;ZeroDivisionError：除(或取模)零 (所有数据类型）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AssertionError：断言语句失败&lt;/li&gt;
&lt;li&gt;AttributeError：对象没有这个属性&lt;/li&gt;
&lt;li&gt;BufferError：当无法执行与缓冲区相关的操作时引发&lt;/li&gt;
&lt;li&gt;EOFError：没有内建输入,到达EOF标记&lt;/li&gt;
&lt;li&gt;ImportError：导入模块/对象失败
&lt;ul&gt;
&lt;li&gt;ModuleNotFoundError：在找不到模块时由import引发，当在系统模块中找不到时也会引发此问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LookupError：无效数据查询的基类
&lt;ul&gt;
&lt;li&gt;IndexError：序列中没有没有此索引(index)&lt;/li&gt;
&lt;li&gt;KeyError：映射中没有这个键&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MemoryError：内存溢出错误(对于Python解释器不是致命的)&lt;/li&gt;
&lt;li&gt;NameError：未声明/初始化对象 (没有属性)
&lt;ul&gt;
&lt;li&gt;UnboundLocalError：访问未初始化的本地变量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OSError：操作系统错误
&lt;ul&gt;
&lt;li&gt;BlockingIOError：当一个操作将阻塞为非阻塞操作设置的对象(如套接字)时引发&lt;/li&gt;
&lt;li&gt;ChildProcessError：子进程上的操作失败时引发&lt;/li&gt;
&lt;li&gt;ConnectionError：连接相关问题的基类
&lt;ul&gt;
&lt;li&gt;BrokenPipeError：当试图在管道上写而另一端已关闭时，或试图在已关闭以进行写的套接字上写时引发&lt;/li&gt;
&lt;li&gt;ConnectionAbortedError：当对等方中止连接尝试时引发&lt;/li&gt;
&lt;li&gt;ConnectionRefusedError：当对等方拒绝连接尝试时引发&lt;/li&gt;
&lt;li&gt;ConnectionResetError：当对等方重置连接时引发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;FileExistsError：试图创建已经存在的文件或目录时引发&lt;/li&gt;
&lt;li&gt;FileNotFoundError：当请求文件或目录但不存在时引发&lt;/li&gt;
&lt;li&gt;InterruptedError：当系统调用被传入信号中断时引发&lt;/li&gt;
&lt;li&gt;IsADirectoryError：在目录上请求文件操作(如&lt;code&gt;os.remove()&lt;/code&gt;)时引发&lt;/li&gt;
&lt;li&gt;NotADirectoryError：当在非目录上请求目录操作(如&lt;code&gt;os.listdir()&lt;/code&gt;)时引发&lt;/li&gt;
&lt;li&gt;PermissionError：试图在没有足够访问权限的情况下运行操作时引发，例如文件系统权限&lt;/li&gt;
&lt;li&gt;ProcessLookupError：当给定的进程不存在时引发&lt;/li&gt;
&lt;li&gt;TimeoutError：当系统功能在系统级别超时时引发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ReferenceError：弱引用(Weak reference)试图访问已经垃圾回收了的对象&lt;/li&gt;
&lt;li&gt;RuntimeError：一般的运行时错误
&lt;ul&gt;
&lt;li&gt;NotImplementedError：尚未实现的方法&lt;/li&gt;
&lt;li&gt;RecursionError：此异常源自运行时错误。当解释器检测到超过了最大递归深度(请参见&lt;code&gt;sys.getrecursionlimit()&lt;/code&gt;)时，将引发该事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SyntaxError：Python语法错误
&lt;ul&gt;
&lt;li&gt;IndentationError：缩进错误
&lt;ul&gt;
&lt;li&gt;TabError：Tab和空格混用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SystemError：一般的解释器系统错误&lt;/li&gt;
&lt;li&gt;TypeError：对类型无效的操作&lt;/li&gt;
&lt;li&gt;ValueError：传入无效的参数
&lt;ul&gt;
&lt;li&gt;UnicodeError：Unicode相关的错误
&lt;ul&gt;
&lt;li&gt;UnicodeDecodeError：解码时的错误&lt;/li&gt;
&lt;li&gt;UnicodeEncodeError：编码时错误&lt;/li&gt;
&lt;li&gt;UnicodeTranslateError：转换时错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Warning：警告的基类
&lt;ul&gt;
&lt;li&gt;DeprecationWarning：关于被弃用的特征的警告&lt;/li&gt;
&lt;li&gt;PendingDeprecationWarning：关于特性将会被废弃的警告&lt;/li&gt;
&lt;li&gt;RuntimeWarning：可疑的运行时行为(runtime behavior)的警告&lt;/li&gt;
&lt;li&gt;SyntaxWarning：可疑的语法的警告&lt;/li&gt;
&lt;li&gt;UserWarning：用户代码生成的警告&lt;/li&gt;
&lt;li&gt;FutureWarning：关于构造将来语义会有改变的警告&lt;/li&gt;
&lt;li&gt;ImportWarning：关于模块导入中可能错误的警告的基类&lt;/li&gt;
&lt;li&gt;UnicodeWarning：与Unicode相关的警告的基类&lt;/li&gt;
&lt;li&gt;BytesWarning：与字节和字节数组相关的警告的基类&lt;/li&gt;
&lt;li&gt;ResourceWarning：与资源使用相关的警告的基类。被默认警告过滤器忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">try异常处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/import-dao-ru/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95%E8%A7%84%E8%8C%83%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95&#34;&gt;最常用的方法【规范的工程文件目录】&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95&#34;&gt;其他方法&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%BC%E5%85%A5%E5%90%8C%E7%BA%A7%E6%A8%A1%E5%9D%97&#34;&gt;导入同级模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%BC%E5%85%A5%E4%B8%8B%E7%BA%A7%E6%A8%A1%E5%9D%97&#34;&gt;导入下级模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%BC%E5%85%A5%E4%B8%8A%E7%BA%A7%E6%A8%A1%E5%9D%97&#34;&gt;导入上级模块&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%BC%E5%85%A5%E9%9A%94%E5%A3%81%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E6%A8%A1%E5%9D%97&#34;&gt;导入隔壁文件夹下的模块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
以下目录作为例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;FOO
|-- foo
|----foo.py
|----test.py
|----main
|------model.py
|--bin
|----lib.py
|----bin64
|------model64.py
|--source.py
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;最常用的方法规范的工程文件目录&#34;&gt;最常用的方法【规范的工程文件目录】&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 1. 同级目录
import test
# 2. 子目录下
import foo.main.model as model
# 3. 父目录的同级目录下
import bin.lib as lib
# 4. 父目录的同级目录下的子目录
import bin.bin64.model64 as model64
# 5. 导入上级目录
import source
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;其他方法&#34;&gt;其他方法&lt;/h1&gt;
&lt;h2 id=&#34;导入同级模块&#34;&gt;导入同级模块&lt;/h2&gt;
&lt;p&gt;python导入同级模块（在同一个文件夹中的py文件）直接导入即可。&lt;br&gt;
例如&lt;code&gt;foo.py&lt;/code&gt;中导入&lt;code&gt;test.py&lt;/code&gt;，则直接在&lt;code&gt;foo.py&lt;/code&gt;中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import test
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;导入下级模块&#34;&gt;导入下级模块&lt;/h2&gt;
&lt;p&gt;导入下级目录模块需在下级目录中新建一个空白的&lt;code&gt;__init__.py&lt;/code&gt;文件再导入。&lt;br&gt;
例如在&lt;code&gt;foo.py&lt;/code&gt;中导入&lt;code&gt;model.py&lt;/code&gt;，则需要在&lt;code&gt;main&lt;/code&gt;目录中创建一个文件&lt;code&gt;__init__.py&lt;/code&gt;，然后在&lt;code&gt;foo.py&lt;/code&gt;中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 方法一：
from dir3 import file3

# 方法二：
import dir3.file3
# 或者
import dir3.file3 as df3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;导入上级模块&#34;&gt;导入上级模块&lt;/h2&gt;
&lt;p&gt;要导入上级目录下模块，可以使用&lt;code&gt;sys.path&lt;/code&gt;。&lt;br&gt;
例如&lt;code&gt;foo.py&lt;/code&gt;中导入&lt;code&gt;source.py&lt;/code&gt;，则需要在&lt;code&gt;foo.py&lt;/code&gt;中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys 
sys.path.append(&amp;quot;..&amp;quot;) 
import source
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&lt;code&gt;sys.path&lt;/code&gt;的作用：当使用&lt;code&gt;import&lt;/code&gt;语句导入模块时，解释器会搜索当前模块所在目录以及&lt;code&gt;sys.path&lt;/code&gt;指定的路径去找需要&lt;code&gt;import&lt;/code&gt;的模块，因此在这里需要把上级目录加到了&lt;code&gt;sys.path&lt;/code&gt;里。&lt;br&gt;
“..”的含义：等同于linux里的‘..’，表示当前工作目录的上级目录。实际上python中的‘.’也和linux中一致，表示当前目录。&lt;/p&gt;
&lt;h2 id=&#34;导入隔壁文件夹下的模块&#34;&gt;导入隔壁文件夹下的模块&lt;/h2&gt;
&lt;p&gt;这其实是前面两个操作的组合，其思路本质上是将上级目录加到&lt;code&gt;sys.path&lt;/code&gt;里，再按照对下级目录模块的方式导入，同样需要被引用文件夹下有空的&lt;code&gt;__init__.py&lt;/code&gt;文件。&lt;br&gt;
例如在&lt;code&gt;foo.py&lt;/code&gt;中引入&lt;code&gt;bin&lt;/code&gt;目录下的&lt;code&gt;lib.py&lt;/code&gt;，需要在&lt;code&gt;bin&lt;/code&gt;目录下添加文件&lt;code&gt;__init__.py&lt;/code&gt;，然后在&lt;code&gt;foo.py&lt;/code&gt;中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
sys.path.append(&amp;quot;..&amp;quot;)
from bin import lib
&lt;/code&gt;&lt;/pre&gt;
">import导入</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/chuang-jian-zi-ding-yi-yum-yuan-he-rpm-bao-feng-zhuang/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89yum%E6%BA%90&#34;&gt;创建自定义yum源&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85wireshark&#34;&gt;安装wireshark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89yum%E6%BA%90&#34;&gt;自定义yum源&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
【说明】：本环境使用的是之前创建的虚拟机集群部署的环境，如果不了解，请前往Linux或者运维标签下面寻找相应的文章进行查看。&lt;br&gt;
&lt;code&gt;以源码安装wireshark2.6.16为例，创建相应的yum源&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;创建自定义yum源&#34;&gt;创建自定义yum源&lt;/h1&gt;
&lt;h2 id=&#34;安装wireshark&#34;&gt;安装wireshark&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;保留yum安装后的rpm包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir /yum
vim /etc/yum.conf
    [main]
    cachedir=/yum/$basearch/$releasever #【安装包保存位置】
    keepcache=1  #【默认0是不保存安装包，改为1即可】
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;安装依赖环境&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install gcc* libpcap* bison* byacc* flex* perl-podlators* libgcrypt* glib* gtk* qt5*
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;下载wireshark并解压、编译、安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/src
wget https://1.eu.dl.wireshark.org/src/all-versions/wireshark-2.6.16.tar.xz
tar -Jxvf wireshark-2.6.16.tar.xz
cd wireshark-2.6.16
./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;自定义yum源&#34;&gt;自定义yum源&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装createrepo包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install createrepo
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;生成repodata目录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /yum
createrepo ./
ls  #查看是否有repodata目录生成
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;修改yum配置文件进行测试&lt;br&gt;
修改之前需要将之前的repo文件全部备份（在末尾加bak即可）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /etc/yum.repos.d/
find -name &amp;quot;*.repo&amp;quot; -exec mv {} {}bak \;
vim wireshark.repo
    [wireshark]
    name=wireshark
    baseurl=file:///yum/
    gpgcheck=0
    enabled=1
yum clean all
yum makecache
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;如果需要更新则使用&lt;code&gt;createrepo --update 路径&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试&lt;br&gt;
测试环节需要将本yum共享给其他机器进行测试，或者直接打包发送给其他机器&lt;/li&gt;
&lt;/ol&gt;
">创建自定义yum源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-mpls-zhuan-ti-202008015/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%A6%82%E8%BF%B0&#34;&gt;MPLS概述&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%A0%E7%BB%9Fip%E8%BD%AC%E5%8F%91&#34;&gt;传统IP转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E7%9F%A5%E8%AF%86%E7%82%B9&#34;&gt;MPLS知识点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E9%87%8D%E7%82%B9&#34;&gt;MPLS重点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%8A%A5%E6%96%87%E8%BD%AC%E5%8F%91&#34;&gt;MPLS报文转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&#34;&gt;MPLS体系结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2&#34;&gt;控制平面&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%AC%E5%8F%91%E5%B9%B3%E9%9D%A2&#34;&gt;转发平面&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97&#34;&gt;MPLS标签嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92%E5%92%8C%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;路由传递和数据转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E6%96%BDmpls-vpn%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4&#34;&gt;实施MPLS VPN的基本步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp&#34;&gt;LDP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&#34;&gt;基本概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E6%B6%88%E6%81%AF&#34;&gt;LDP消息&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B1%BB%E5%9E%8B&#34;&gt;类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%9C%E7%94%A8&#34;&gt;作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%B4%E9%83%A8%E6%A0%BC%E5%BC%8F%E7%B1%BB%E5%9E%8B&#34;&gt;头部格式类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E5%8F%91%E7%8E%B0%E6%9C%BA%E5%88%B6&#34;&gt;LDP发现机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E4%BC%9A%E8%AF%9D%E5%BB%BA%E7%AB%8B%E8%BF%87%E7%A8%8B&#34;&gt;LDP会话建立过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E7%8A%B6%E6%80%81%E6%9C%BA&#34;&gt;LDP状态机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86&#34;&gt;LDP标签管理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%87%E7%AD%BE%E5%88%86%E5%8F%91%E9%80%9A%E5%91%8A%E6%A8%A1%E5%BC%8F&#34;&gt;标签分发（通告）模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#dod-%E4%B8%8B%E6%B8%B8%E6%8C%89%E9%9C%80%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F&#34;&gt;DoD 下游按需(被动)模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ud%E6%88%96%E8%80%85du%E4%B8%8B%E6%B8%B8%E8%87%AA%E4%B8%BB%E4%B8%BB%E5%8A%A8%E6%A8%A1%E5%BC%8F&#34;&gt;UD（或者DU）下游自主(主动)模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%87%E7%AD%BE%E5%88%86%E9%85%8D%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8Flsp%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F&#34;&gt;标签分配控制模式（LSP控制模式）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8B%AC%E7%AB%8B%E6%A0%87%E7%AD%BE%E5%88%86%E9%85%8D%E6%8E%A7%E5%88%B6&#34;&gt;独立标签分配控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9C%89%E5%BA%8F%E6%A0%87%E7%AD%BE%E5%88%86%E9%85%8D%E6%8E%A7%E5%88%B6&#34;&gt;有序标签分配控制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%87%E7%AD%BE%E4%BF%9D%E7%95%99%E6%A8%A1%E5%BC%8F&#34;&gt;标签保留模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#llr-%E8%87%AA%E7%94%B1%E6%A0%87%E7%AD%BE%E4%BF%9D%E7%95%99%E6%A8%A1%E5%BC%8F&#34;&gt;LLR 自由标签保留模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#clr-%E4%BF%9D%E5%AE%88%E6%A0%87%E7%AD%BE%E4%BF%9D%E7%95%99%E6%A8%A1%E5%BC%8F&#34;&gt;CLR 保守标签保留模式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#php%E6%AC%A1%E6%9C%AB%E8%B7%B3%E5%BC%B9%E5%87%BA%E5%80%92%E6%95%B0%E7%AC%AC%E4%BA%8C%E8%B7%B3%E5%BC%B9%E5%87%BA&#34;&gt;PHP次末跳弹出（倒数第二跳弹出）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6&#34;&gt;LDP环路检测机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%AF%B9ttl%E7%9A%84%E5%A4%84%E7%90%86uniform%E6%A8%A1%E5%BC%8F&#34;&gt;MPLS对TTL的处理（Uniform模式）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%BC%8F&#34;&gt;统一模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%A1%E9%81%93%E6%A8%A1%E5%BC%8F&#34;&gt;管道模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%B8%E5%BF%83%E7%BD%91%E7%BB%9C%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F&#34;&gt;核心网络处理方式&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls-vpn&#34;&gt;MPLS VPN&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#vpn%E6%A8%A1%E5%9E%8B&#34;&gt;VPN模型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#overlay-vpn&#34;&gt;Overlay VPN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#peer-to-peer-vpn&#34;&gt;Peer-to-Peer VPN&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B1%E4%BA%ABpe&#34;&gt;共享PE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%93%E7%94%A8pe&#34;&gt;专用PE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;解决的问题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E9%87%8D%E5%8F%A0&#34;&gt;地址空间重叠&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%93%E7%94%A8pe%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&#34;&gt;专用PE的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B1%E4%BA%ABpe%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&#34;&gt;共享PE的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%BA%E5%88%86%E5%86%B2%E7%AA%81%E8%B7%AF%E7%94%B1rdroute-distinguisher&#34;&gt;区分冲突路由（RD，Route Distinguisher）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vpn%E8%B7%AF%E7%94%B1%E7%9A%84%E5%BC%95%E5%85%A5rtroute-target&#34;&gt;VPN路由的引入（RT，Route Target）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%86%B2%E7%AA%81%E8%B7%AF%E7%94%B1%E7%9A%84%E6%9F%A5%E6%89%BE&#34;&gt;冲突路由的查找&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86&#34;&gt;工作原理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mpls-vpn%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BC%A0%E9%80%92%E8%BF%87%E7%A8%8B&#34;&gt;MPLS VPN路由的传递过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ce%E4%B8%8Epe%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2&#34;&gt;1. CE与PE之间的路由交换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-vrf%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%85%A5mp-bgp%E7%9A%84%E8%BF%87%E7%A8%8B&#34;&gt;2. VRF路由注入MP-BGP的过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-%E5%85%AC%E7%BD%91%E6%A0%87%E7%AD%BE%E7%9A%84%E5%88%86%E9%85%8D%E8%BF%87%E7%A8%8B&#34;&gt;3. 公网标签的分配过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#4-mp-bgp%E8%B7%AF%E7%94%B1%E6%B3%A8%E5%85%A5vrf%E7%9A%84%E8%BF%87%E7%A8%8B&#34;&gt;4. MP-BGP路由注入VRF的过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls-vpn%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BD%AC%E5%8F%91%E8%BF%87%E7%A8%8B&#34;&gt;MPLS VPN数据的转发过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#1-ce%E8%AE%BE%E5%A4%87%E5%88%B0pe%E8%AE%BE%E5%A4%87%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;1. CE设备到PE设备的数据转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2-%E5%85%AC%E7%BD%91%E8%AE%BE%E5%A4%87%E4%B8%8A%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;2. 公网设备上的数据转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3-pe%E8%AE%BE%E5%A4%87%E5%88%B0ce%E8%AE%BE%E5%A4%87%E7%9A%84%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;3. PE设备到CE设备的数据转发&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93-2&#34;&gt;总结&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92&#34;&gt;路由传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;数据转发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2pe-ce%E8%B7%AF%E7%94%B1%E7%9A%84%E5%B0%8F%E6%8F%90%E7%A4%BA&#34;&gt;部署PE-CE路由的小提示&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%B2%E7%8E%AF&#34;&gt;防环&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%9A%E5%AE%BF%E4%B8%BB%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84sooeigrp%E5%8D%8F%E8%AE%AE&#34;&gt;多宿主环境下的SoO（EIGRP协议）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E7%90%86&#34;&gt;原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E&#34;&gt;举例说明&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84%E9%98%B2%E7%8E%AF&#34;&gt;OSPF的防环&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#domain-id&#34;&gt;Domain-ID&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E7%B1%BBlsa%E9%98%B2%E7%8E%AFdown-bit&#34;&gt;三类LSA防环（Down bit）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%96%E9%83%A8%E8%B7%AF%E7%94%B1%E7%9A%84%E7%8E%AF%E8%B7%AF%E9%A2%84%E9%98%B25%E7%B1%BB7%E7%B1%BBlsa%E9%98%B2%E7%8E%AF&#34;&gt;外部路由的环路预防(5类/7类LSA防环)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#sham-linkv-link%E8%99%9A%E5%81%87%E9%93%BE%E8%B7%AF&#34;&gt;sham-link（v-link虚假链路）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ospf%E7%9A%84mecvrf-lite&#34;&gt;OSPF的MEC/VRF-LITE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E6%8E%A5%E5%85%A5mpls-vpn&#34;&gt;BGP接入MPLS VPN&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E6%8E%A5%E5%85%A5mpls-vpn%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;BGP接入MPLS VPN解决的问题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%82%E6%9E%9C%E4%B8%8D%E9%87%87%E7%94%A8%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%98%8E%E7%BB%86%E8%B7%AF%E7%94%B1%E5%91%A2&#34;&gt;如果不采用默认路由的方式，如何传递明细路由呢？&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0&#34;&gt;问题描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AF%B9%E5%BA%94%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&#34;&gt;对应的解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls-vpn%E6%95%85%E9%9A%9C%E6%8E%92%E6%9F%A5&#34;&gt;MPLS VPN故障排查&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C&#34;&gt;实验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%80mpls-ldp&#34;&gt;实验一：MPLS-LDP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8Cr2%E5%92%8Cr4%E5%BB%BA%E7%AB%8B%E8%BF%9C%E7%AB%AFldp%E4%BC%9A%E8%AF%9D&#34;&gt;实验二：R2和R4建立远端LDP会话&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%89php&#34;&gt;实验三：PHP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%9B%9B%E7%A0%94%E7%A9%B6mpls%E8%A7%A3%E5%86%B3bgp%E8%B7%AF%E7%94%B1%E9%BB%91%E6%B4%9E%E7%9A%84%E5%8E%9F%E7%90%86&#34;&gt;实验四：研究MPLS解决BGP路由黑洞的原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%94%E5%9F%BA%E6%9C%ACmpls-vpn%E9%83%A8%E7%BD%B2&#34;&gt;实验五：基本MPLS VPN部署&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%85%ADospf%E6%8E%A5%E5%85%A5mpls-vpn&#34;&gt;实验六：OSPF接入MPLS VPN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%83%E9%85%8D%E7%BD%AEospf%E7%9A%84domain-id&#34;&gt;实验七：配置ospf的domain-id&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%85%AB%E4%B8%89%E7%B1%BBlsa%E9%98%B2%E7%8E%AF%E9%80%86%E5%90%91%E5%AE%9E%E9%AA%8C&#34;&gt;实验八：三类LSA防环逆向实验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B9%9D%E5%9C%A8r1%E5%92%8Cr4%E4%B9%8B%E9%97%B4%E9%83%A8%E7%BD%B2-sham-link&#34;&gt;实验九：在R1和R4之间部署 sham-link&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E9%85%8D%E7%BD%AE%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%99%A8%E6%9C%AC%E5%AE%9E%E9%AA%8C%E6%98%AF%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%AA%8C%E7%9A%84%E9%A2%84%E9%85%8D%E7%BD%AE&#34;&gt;实验十：配置路由反射器（本实验是下一个实验的预配置）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80%E4%BD%BF%E7%94%A8vrf-lite%E5%B0%86%E7%94%A8%E6%88%B7%E6%8E%A5%E5%85%A5mpls-vpnhub-spoke&#34;&gt;实验十一：使用VRF-LITE将用户接入MPLS VPN（hub-spoke）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%86%85%E5%AE%B9&#34;&gt;实验内容&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%87%8D%E7%82%B9&#34;&gt;重点&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8Cbgp%E6%8E%A5%E5%85%A5mpls-vpn&#34;&gt;实验十二：BGP接入MPLS VPN&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89%E5%A6%82%E6%9E%9C%E4%B8%8D%E9%87%87%E7%94%A8%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E5%BC%8F%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E6%98%8E%E7%BB%86%E8%B7%AF%E7%94%B1%E5%91%A2bgp%E6%8E%A5%E5%85%A5mpls-vpn&#34;&gt;实验十三：如果不采用默认路由的方式，如何传递明细路由呢？（BGP接入MPLS VPN）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%BA%E6%99%AF%E4%B8%80&#34;&gt;场景一：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%BA%E6%99%AF%E4%BA%8C&#34;&gt;场景二：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%BA%E6%99%AF%E4%B8%89&#34;&gt;场景三：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9C%BA%E6%99%AF%E5%9B%9B&#34;&gt;场景四：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9Bvrf%E4%B8%8B%E7%9A%84%E8%B7%AF%E7%94%B1%E6%93%8D%E6%8E%A7%E4%B8%8A%E4%B8%AA%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%9C%BA%E6%99%AF%E4%B8%89&#34;&gt;实验十四：VRF下的路由操控（上个实现的场景三）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;mpls概述&#34;&gt;MPLS概述&lt;/h1&gt;
&lt;p&gt;本节课主要内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对比传统IP转发与MPLS：IP转发回顾、MPLS转发特点、MPLS应用场景&lt;/li&gt;
&lt;li&gt;MPLS基本原理：MPLS基本构架、MPLS标签格式、MPLS转发&lt;/li&gt;
&lt;li&gt;LDP协议：共有标准协议  标签分发协议&lt;/li&gt;
&lt;li&gt;MPLS VPN体系构架&lt;/li&gt;
&lt;li&gt;MP-BGP在MPLS VPN中的重要作用&lt;/li&gt;
&lt;li&gt;MPLS VPN路由隔离模型（vrf）&lt;/li&gt;
&lt;li&gt;MPLS VPN路由区分原理（RD）&lt;/li&gt;
&lt;li&gt;MPLS VPN路由传递原理（RT）&lt;/li&gt;
&lt;li&gt;MPLS VPN数据转发原理（label）&lt;/li&gt;
&lt;li&gt;MPLS VPN环境下的路由反射器及路由区分器&lt;/li&gt;
&lt;li&gt;在MPLS VPN环境中部署不同overlay动态路由协议（基础理论及实验）&lt;/li&gt;
&lt;li&gt;backup link 环境：EIGRP路由还原、OSPF sham-link&lt;/li&gt;
&lt;li&gt;多宿主环境：EIGRP SOO、BGP SOO&lt;/li&gt;
&lt;li&gt;vrf-lite环境下的OSPF&lt;/li&gt;
&lt;li&gt;BGP as-override&lt;/li&gt;
&lt;li&gt;BGP allowas-in&lt;/li&gt;
&lt;li&gt;控制MPLS VPN中的路由更新：通过RT、vrf条件性路由控制&lt;/li&gt;
&lt;li&gt;MPLS VPN接入互联网&lt;/li&gt;
&lt;li&gt;MPLS VPN故障排查&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;传统ip转发&#34;&gt;传统IP转发&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;传统路由循规蹈矩：每跳都检查是否有去往目标的，如若没则丢弃报文&lt;/li&gt;
&lt;li&gt;传统IP转发在流量工程方面的缺陷。传统IP网络基于IGP Metric计算最优路径，这是远远不够的，往往在现实网络中还需考虑带宽、链路属性等其他因素。基于 IP 的流量工程是基于 IGP 面向目的地址转发，是hop-by-hop的转发，无法实现根据来源控制流量转发。另外基于IP的流量工程是面向无连接的，不能实现显式路径&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mpls知识点&#34;&gt;MPLS知识点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;MPLS能够提高转发效率，但同时它将消耗更多资源&lt;/li&gt;
&lt;li&gt;MPLS更多的是解决了每个数据包都要进行头部分析或者运算的问题，不再对IP报文做分析&lt;/li&gt;
&lt;li&gt;MPLS的标签栈，比IP年轻、比IP轻量。MPLS并不是一种业务或应用，他实际上是一种隧道技术，这种技术不仅支持多种高层协议与业务，而且在一定程度上可以保证信息传输的安全性&lt;/li&gt;
&lt;li&gt;帧模式MPLS&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597565321121.png&#34; alt=&#34;帧模式MPLS&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MPLS帧模式封装在2、3层之间，信元模式的MPLS已经淘汰&lt;/li&gt;
&lt;li&gt;MPLS头&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597565565322.png&#34; alt=&#34;MPLS头&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;MPLS头部总长度为4bytes (32bits)&lt;/li&gt;
&lt;li&gt;标签Label长度20bits标签值域&lt;/li&gt;
&lt;li&gt;EXP（Experimental Use）长度3bits用于扩展。现在通常用做CoS，当设备阻塞时，优先发送优先级高的报文&lt;/li&gt;
&lt;li&gt;S（Bottom of Stack）长度1bit栈底标识。MPLS支持多层标签，即标签嵌套。S值为1时表明为最底层标签&lt;/li&gt;
&lt;li&gt;TTL长度8bits 和IP报文中的TTL（Time To Live）意义相同&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标签空间&lt;/strong&gt;：指标签的取值范围。标签空间划分如下：
&lt;ul&gt;
&lt;li&gt;0～15：特殊标签
&lt;ul&gt;
&lt;li&gt;0：IPv4 Explicit NULL Label（显示空标签），&lt;strong&gt;表示该标签必须被弹出&lt;/strong&gt;（即标签被剥掉），且报文的转发必须基于IPv4。如果出节点分配给&lt;strong&gt;倒数第二跳节点的标签值为0&lt;/strong&gt;，则倒数第二跳LSR需要&lt;strong&gt;将值为0的标签正常压入报文标签值顶部，转发给最后一跳&lt;/strong&gt;。最后一跳发现报文携带的标签值为0，则将标签弹出。&lt;/li&gt;
&lt;li&gt;1：Router Alert Label（警告标签），只有出现在非栈底时才有效。类似于IP报文的“Router Alert Option”字段，节点收到Router Alert Label时，需要将其送往本地软件模块进一步处理。实际报文转发由下一层标签决定。如果报文需要继续转发，则节点需要将Router Alert Label压回标签栈顶。&lt;/li&gt;
&lt;li&gt;2：IPv6 Explicit NULL Label（显示空标签），表示该标签必须被弹出，且报文的转发必须基于IPv6。如果出节点分配给倒数第二跳节点的标签值为2，则倒数第二跳节点需要将值为2的标签正常压入报文标签值顶部，转发给最后一跳。最后一跳发现报文携带的标签值为2，则直接将标签弹出。&lt;/li&gt;
&lt;li&gt;3：Implicit NULL Label（隐式空标签），倒数&lt;strong&gt;第二跳LSR进行标签交换&lt;/strong&gt;时，如果发现交换后的标签值为3，则&lt;strong&gt;将标签弹出&lt;/strong&gt;，&lt;strong&gt;并将报文发给最后一跳&lt;/strong&gt;。最后一跳收到该报文直接进行IP转发或下一层标签转发。&lt;/li&gt;
&lt;li&gt;4～13：保留&lt;/li&gt;
&lt;li&gt;14：OAM Router Alert Label（MPLS的操作管理），MPLS OAM通过发送OAM报文检测和通告LSP故障。OAM报文使用MPLS承载。OAM报文对于Transit LSR和倒数第二跳LSR是透明的。&lt;/li&gt;
&lt;li&gt;15：保留&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;16～1023：静态LSP和静态CR-LSP共享的标签空间&lt;/li&gt;
&lt;li&gt;1024及以上：LDP、RSVP-TE、MP-BGP等动态信令协议的标签空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标签可以由多种方法产生：LDP、MP-BGP。标签产生的依据是路由，为路由分配标签（TCP/IP环境中）&lt;/li&gt;
&lt;li&gt;入站LSR上有路由表（RiB），但其实会被拷贝为转发信息库（FiB）、标签信息库（LiB），递归为标签转发信息库（LFib），标签信息库存储的是标签，实际上，可以将其理解为标签与路由的映射&lt;/li&gt;
&lt;li&gt;一旦开启了LDP，它会自动的为每个路由分配标签值，路由协议把路由更新给邻居，LDP把标签和路由的映射信息更新给邻居&lt;code&gt;LDP为IGP路由分配标签&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;LDP标签值，遵循 独立、自主、自由的原则。每台设备独立分配标签，每台设备自主分发标签，每台设备自由选择标签保留方式。&lt;/li&gt;
&lt;li&gt;标签行为总结：
&lt;ol&gt;
&lt;li&gt;压入标签push&lt;/li&gt;
&lt;li&gt;交换标签swap&lt;/li&gt;
&lt;li&gt;弹出标签pop（remove，隐式空标签）&lt;/li&gt;
&lt;li&gt;UNTAG/No label(没有标签)出现问题，在MPLS VPN的环境中只能丢弃报文&lt;code&gt;关于标签断裂：所有的环回口配置32位主机路由，核心网不许汇总&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Aggregate（聚合），把报文拿掉MPLS之后转发给一个vpn-instance接口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;分发标签的协议：
&lt;ol&gt;
&lt;li&gt;LDP（标签分发协议）；思科私有的有TDP，SR（segment routing）&lt;/li&gt;
&lt;li&gt;RSVP（资源预留协议）&lt;/li&gt;
&lt;li&gt;MP-BGP（多协议BGP），来分发标签&lt;/li&gt;
&lt;li&gt;静态的方式分发标签&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;MPLS重要理念：转控分离
&lt;ol&gt;
&lt;li&gt;控制层面：路由协议、标签的分发协议&lt;/li&gt;
&lt;li&gt;转发层面：FIB（转发信息库）、LFIB（标签转发信息库）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;术语
&lt;ol&gt;
&lt;li&gt;CE：客户边界设备。CE(Customer Edge)，用户边缘设备，服务提供商所连接的用户端路由器。CE路由器通过连接一个或多个PE路由器，为用户提供服务接入。CE路由器通常是一台IP路由器，它与连接的PE路由器建立邻接关系。&lt;code&gt;通常就是传统操作&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PE：运营商边界设备。PE(Provider Edge)，即Provide的边缘设备，服务提供商骨干网的边缘路由器，它相当于标签边缘路由器（LER）。PE路由器连接CE路由器和P路由器，是最重要的网络节点。用户的流量通过PE路由器流入用户网络，或者通过PE路由器流到MPLS骨干网。&lt;code&gt;通常会为每个与CE相连的部分做出特殊处理&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;P：运营商内部的设备。仅仅负责帮助转发数据。P(Provider)，是核心层设备，提供商路由器，服务提供商是不连接任何CE路由器的骨干网路由设备，它相当于标签交换路由器（LSR）&lt;/li&gt;
&lt;li&gt;LSR：标签交换路由器&lt;/li&gt;
&lt;li&gt;LER：标签边缘路由器（PE）&lt;/li&gt;
&lt;li&gt;CPE：三巨头中两个互联，为同一个客户服务&lt;/li&gt;
&lt;li&gt;MCE：MCE功能是Multi-CE的简称，具有MCE功能的交换机可以在BGP/MPLS VPN组网应用中承担多个VPN实例的CE功能，减少用户网络设备的投入&lt;/li&gt;
&lt;li&gt;vrf（华为称vpn instance）：&lt;strong&gt;在PE设备上起到隔离作用&lt;/strong&gt;，每一个vrf提供一个独立的路由表，同时甚至能够提供独立的路由协议进程。用一个PE为多个用户提供服务,通过VRF实例将连接到同一台PE上的不同客户隔离开来&lt;/li&gt;
&lt;li&gt;LSP：标签交换通道，LSP是一个单向通道，与数据流的方向一致&lt;/li&gt;
&lt;li&gt;FIB：转发信息库，来自路由表拷贝&lt;/li&gt;
&lt;li&gt;LIB：标签信息库，由标签协议根据路由产生的&lt;strong&gt;标签和路由的对应关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;LFIB：标签转发信息库，把FIB和LIB两者结合在一起&lt;/li&gt;
&lt;li&gt;FEC：转发等价类。MPLS将&lt;strong&gt;具有相同特征的报文&lt;/strong&gt;归为一类，称为转发等价类FEC，属于相同FEC的报文在转发过程中被LSR以相同方式处理。FEC可以根据&lt;strong&gt;源地址、目的地址、源端口、目的端口、VPN、隧道、COS等要素&lt;/strong&gt;进行划分。例如，在传统的采用最长匹配算法的IP转发中，到同一条路由的所有报文就是一个转发等价类
&lt;ul&gt;
&lt;li&gt;一组或者一系列沿着相同路径转发的，且都按照相同的规则执行的数据流&lt;/li&gt;
&lt;li&gt;相同的转发方式、相同的转发路径LSP、相同的转发待遇&lt;/li&gt;
&lt;li&gt;同属一个FEC的报文拥有相同的标签，拥有相同标签的报文不一定同属一个FEC，由入站LSR决定报文属于哪一个FEC&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;种类&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;属于某特定组的组播报文&lt;/li&gt;
&lt;li&gt;目的IP地址匹配了某一个特定前缀的报文&lt;/li&gt;
&lt;li&gt;根据DCSP字段，有相同的QoS策略的报文&lt;/li&gt;
&lt;li&gt;MPLS VPN中，属于同一个VPN的报文&lt;/li&gt;
&lt;li&gt;报文的目的IP地址数据BGP学习到的路由，并且该路由的下一跳地址相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NHLFE：下一跳标签转发表项，用于指导MPLS报文的转发，包括Tunnel ID、出接口、下一跳、出标签、标签操作类型等信息。FEC到一组NHLFE的映射称为FTN（FEC-to-NHLFE），通过查看FIB表中Tunnel ID值不为0x0的表项，能够获得FTN的详细信息，FTN只在Ingress存在&lt;/li&gt;
&lt;li&gt;Tunnel ID：为了给使用隧道的上层应用（如VPN、路由管理）提供统一的接口，系统自动为隧道分配了一个ID，也称为Tunnel ID。该Tunnel ID的长度为32比特，只是本地有效&lt;/li&gt;
&lt;li&gt;ILM：入标签到一组下一跳标签转发表项的映射称为入标签映射ILM，ILM包括Tunnel ID、入标签、入接口、标签操作类型等信息。ILM在Transit节点的作用是将标签和NHLFE绑定。通过标签索引ILM表，就相当于使用目的IP地址查询FIB，能够得到所有的标签转发信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mpls重点&#34;&gt;MPLS重点&lt;/h1&gt;
&lt;h2 id=&#34;mpls报文转发&#34;&gt;MPLS报文转发&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从CE到Ingress PE&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597587418563.png&#34; alt=&#34;从CE到Ingress PE&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;CE将报文发给其相连的VRF接口，PE在本VRF的路由表中进行查找，得到了该路由的&lt;strong&gt;公网下一跳地址&lt;/strong&gt;和&lt;strong&gt;私网标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;再把该报文封装一层私网标签后，在&lt;strong&gt;公网的标签转发表中查找下一跳地址&lt;/strong&gt;，在&lt;strong&gt;封装一层公网标签&lt;/strong&gt;后，交予MPLS转发&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Ingress PE--&amp;gt;Egress PE--&amp;gt;CE&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597590091682.png&#34; alt=&#34;从Ingress PE到CE&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;该报文在公网上沿着LSP转发，并根据途径的每一台设备的标签转发表进行标签交换&lt;/li&gt;
&lt;li&gt;在&lt;strong&gt;倒数第二跳&lt;/strong&gt;处，将&lt;strong&gt;外层的公网标签弹出&lt;/strong&gt;，交给目的的PE设备&lt;/li&gt;
&lt;li&gt;PE设备根据&lt;strong&gt;内层的私网标签判断该报文属于哪一个VRF&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;弹出内层私网标签&lt;/strong&gt;，在目的VRF中查找路由表，根据下一跳&lt;strong&gt;发给相应的CE&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mpls体系结构&#34;&gt;MPLS体系结构&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;MPLS结构&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597620255352.png&#34; alt=&#34;MPLS结构&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MPLS VPN中的数据转发模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP报文入站，通过&lt;strong&gt;路由表&lt;/strong&gt;做转发决策，出方向的路由上&lt;strong&gt;有标签转发信息&lt;/strong&gt;，则可以&lt;strong&gt;选择压入标签&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;标签报文入站，通过&lt;strong&gt;标签转发表&lt;/strong&gt;做出转发决策，出方向如果&lt;strong&gt;有标签则执行标签交换&lt;/strong&gt;，然后转发，如果出方向&lt;strong&gt;没有标签&lt;/strong&gt;，则&lt;strong&gt;移除标签然后路由转发&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;MPLS体系结构&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597619000162.png&#34; alt=&#34;MPLS体系结构&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;控制平面&#34;&gt;控制平面&lt;/h3&gt;
&lt;p&gt;负责产生和维护路由信息以及标签信息&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;路由信息表RIB：由IP路由协议生成，用于选择路由&lt;/li&gt;
&lt;li&gt;标签分发协议：负责标签的分配，标签转发信息表的建立，标签交换路径的建立、拆除等工作&lt;/li&gt;
&lt;li&gt;标签信息表LIB：由标签分发协议生成，用于管理标签信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;转发平面&#34;&gt;转发平面&lt;/h3&gt;
&lt;p&gt;即数据平面，负责普通IP报文的转发以及带MPLS标签报文的转发&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;转发信息表FIB：从RIB提取必要的路由信息生成，负责普通IP报文的转发&lt;/li&gt;
&lt;li&gt;标签转发信息表LFIB：简称标签转发表，由标签分发协议在LSR上建立LFIB，负责带MPLS标签报文的转发&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mpls标签嵌套&#34;&gt;MPLS标签嵌套&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;内层标签（栈底标签）&lt;/strong&gt;：靠近用户数据，MP-BGP分配&lt;br&gt;
&lt;strong&gt;外层标签&lt;/strong&gt;：靠近二层头，LDP分配，作为MP-BGP路由的下一跳地址&lt;br&gt;
&lt;code&gt;一般情况为2层，跨域的一般3层标签，CSC架构一般4层标签&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597620314374.png&#34; alt=&#34;MPLS标签嵌套&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID标识二层头部后面的报文类型
&lt;ul&gt;
&lt;li&gt;Ethernet
&lt;ul&gt;
&lt;li&gt;0x0800 IPv4&lt;/li&gt;
&lt;li&gt;0x8847 MPLS单播报文&lt;/li&gt;
&lt;li&gt;0x8848 MPLS多播报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PPP
&lt;ul&gt;
&lt;li&gt;0x8021 IPv4&lt;/li&gt;
&lt;li&gt;0x8281 MPLS单播报文&lt;/li&gt;
&lt;li&gt;0x8283 MPLS多播报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;S标识是否是栈底标签&lt;/li&gt;
&lt;li&gt;标签嵌套应用
&lt;ul&gt;
&lt;li&gt;MPLS VPN&lt;/li&gt;
&lt;li&gt;MPLS TE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;路由传递和数据转发&#34;&gt;路由传递和数据转发&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597660879038.png&#34; alt=&#34;路由传递&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;MP-BGP跨越核心网络传递客户路由，中间存在路由黑洞，路由的下一跳是PE设备的环回口&lt;/li&gt;
&lt;li&gt;VPN路由在PE设备上产生，PE（PE1）设备通过MP-BGP为VPN路由分配一个标签（内层），该标签随着VPN路由被MP-BGP传递至远端对等体（PE2）&lt;/li&gt;
&lt;li&gt;PE2上就有远端站点的路由和标签，通过LDP协议为MP-BGP（VPN）路由的下一跳分配外层标签&lt;/li&gt;
&lt;li&gt;数据从客户始发，由CE2转发到PE2&lt;/li&gt;
&lt;li&gt;PE2查找vrf路由表，压入内层标签，查找全局路由表，压入外层标签&lt;/li&gt;
&lt;li&gt;标签报文沿着核心网（core network）转发，逐跳交换外层标签，外层标签次末跳弹出&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实施mpls-vpn的基本步骤&#34;&gt;实施MPLS VPN的基本步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;MPLS Core/Core network/核心网 的IGP&lt;/li&gt;
&lt;li&gt;Core network的LDP&lt;/li&gt;
&lt;li&gt;PE之间部署MP-BGP，实施VPNv4&lt;/li&gt;
&lt;li&gt;在PE设备上部署VRF/VPN-instance&lt;/li&gt;
&lt;li&gt;在PE-CE之间部署路由交互&lt;/li&gt;
&lt;li&gt;将vrf的路由与MP-BGP双向重分布&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ldp&#34;&gt;LDP&lt;/h1&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;LDP是用来在LSR之间建立LDP会话并交换Label/FEC映射信息的协议&lt;/li&gt;
&lt;li&gt;LDP
&lt;ul&gt;
&lt;li&gt;用UDP发现邻居：组播（&lt;strong&gt;224.0.0.2&lt;/strong&gt;）在链路上发送hello报文，&lt;strong&gt;目标端口646&lt;/strong&gt;，通告传输地址&lt;/li&gt;
&lt;li&gt;用TCP建立邻居：目标端口646&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ldp消息&#34;&gt;LDP消息&lt;/h2&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597668635041.png&#34; alt=&#34;LDP消息类型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Discovery message：宣告和维护网络中一个LSR的存在&lt;/li&gt;
&lt;li&gt;Session message：建立、维护和终止LDP邻居之间的LDP会话&lt;/li&gt;
&lt;li&gt;Advertisement message：生成、改变和删除FEC的标签映射&lt;/li&gt;
&lt;li&gt;Notification message：宣告告警和错误信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597668992707.png&#34; alt=&#34; LDP消息作用&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;头部格式类型&#34;&gt;头部格式类型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597671143763.png&#34; alt=&#34;格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597671149312.png&#34; alt=&#34;字段含义&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ldp发现机制&#34;&gt;LDP发现机制&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;LDP基本发现机制&lt;br&gt;
发现直接连接在同一链路上的LSR邻居&lt;/li&gt;
&lt;li&gt;LDP扩展发现机制&lt;br&gt;
发现非直连的LSR邻居，即跨越设备的LDP会话&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ldp会话建立过程&#34;&gt;LDP会话建立过程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597671884262.png&#34; alt=&#34;TCP连接建立&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597671890472.png&#34; alt=&#34;TCP连接关闭&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ldp状态机&#34;&gt;LDP状态机&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597673326522.png&#34; alt=&#34;LDP状态机&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;ldp标签管理&#34;&gt;LDP标签管理&lt;/h2&gt;
&lt;p&gt;0代表基于平台的标签，基于平台的标签空间中，LSR为一个目的网段分配一个标签，并将该标签&lt;br&gt;
发送给所有的LDP Peers。&lt;/p&gt;
&lt;h3 id=&#34;标签分发通告模式&#34;&gt;标签分发（通告）模式&lt;/h3&gt;
&lt;p&gt;缺省情况下，华为根据32位地址的主机IP路由（不包括接口的32位地址的主机IP路由）触发LDP建立LSP；思科为所有的IGP路由分发标签。&lt;br&gt;
使用命令&lt;code&gt;mpls ldp advertisement [dod|du]&lt;/code&gt;进行修改&lt;/p&gt;
&lt;h4 id=&#34;dod-下游按需被动模式&#34;&gt;DoD 下游按需(被动)模式&lt;/h4&gt;
&lt;p&gt;（思科采取的模式）&lt;br&gt;
每台&lt;strong&gt;LSR主动向LSP中的下一跳LSR请求&lt;/strong&gt;绑定于特定FEC的标签&lt;br&gt;
每台LSR只会从下游LSR为每一个FEC接收到一个捆绑的标签&lt;br&gt;
这里所说的下游，是指IP路由表中的下一跳路由器&lt;/p&gt;
&lt;h4 id=&#34;ud或者du下游自主主动模式&#34;&gt;UD（或者DU）下游自主(主动)模式&lt;/h4&gt;
&lt;p&gt;每台&lt;strong&gt;LSR主动向邻接LSR分发&lt;/strong&gt;捆绑的标签，也就是说不需要邻居来请求&lt;/p&gt;
&lt;h3 id=&#34;标签分配控制模式lsp控制模式&#34;&gt;标签分配控制模式（LSP控制模式）&lt;/h3&gt;
&lt;h4 id=&#34;独立标签分配控制&#34;&gt;独立标签分配控制&lt;/h4&gt;
&lt;p&gt;（思科采取的模式）&lt;br&gt;
当使用独立的LSP控制时，每个LSR都可以在需要时随时向其邻居通告标签映射。&lt;br&gt;
例如，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当以独立的下游按需模式（UD模式）运行时，LSR可以立即回答对标签映射的请求，而无需等待来自下一跳的标签映射。&lt;/li&gt;
&lt;li&gt;当以独立的下游非请求模式（DOD模式）运行时，只要准备对标签交换该FEC，LSR就会向其邻居通告FEC的标签映射。&lt;br&gt;
&lt;code&gt;使用独立模式的结果是可以在接收下游标签之前通告上游标签&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;有序标签分配控制&#34;&gt;有序标签分配控制&lt;/h4&gt;
&lt;p&gt;（华为采取的模式）&lt;br&gt;
当使用LSP顺序控制时，LSR可以仅针对FEC为其启动具有FEC下一跳标签映射的FEC或LSR为出口的FEC发起标签映射的传输。&lt;br&gt;
对于不是LSR出口且&lt;strong&gt;不存在映射&lt;/strong&gt;的每个FEC，LSR&lt;strong&gt;必须等到收到来自下游LSR的标签&lt;/strong&gt;，然后再映射FEC并将相应的标签传递给上游LSR。&lt;br&gt;
对于某些FEC，LSR可能是出口，而对于其他FEC，LSR可能不是出口。对于特定的FEC，LSR可以充当出口LSR，在以下任何条件下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;FEC是指LSR本身（包括其直接连接的接口之一）。&lt;/li&gt;
&lt;li&gt;FEC的下一跳路由器在标签交换网络之外。&lt;/li&gt;
&lt;li&gt;通过跨越路由域边界即可到达FEC元素，例如OSPF摘要网络的另一个区域，或OSPF AS外部和BGP路由的另一个自治系统&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;标签保留模式&#34;&gt;标签保留模式&lt;/h3&gt;
&lt;h4 id=&#34;llr-自由标签保留模式&#34;&gt;LLR 自由标签保留模式&lt;/h4&gt;
&lt;p&gt;（华为、思科采取的模式）&lt;br&gt;
保留所有标签，被使用的保存到LFIB中&lt;br&gt;
这样如果网络发生变化，可以快速收敛&lt;/p&gt;
&lt;h4 id=&#34;clr-保守标签保留模式&#34;&gt;CLR 保守标签保留模式&lt;/h4&gt;
&lt;p&gt;（思科 LC-ATM接口）&lt;br&gt;
不使用的标签不保留，节省维护资源&lt;/p&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;思科：DU+Independent+LLR，即自主分发+独立分配+自由保留&lt;/li&gt;
&lt;li&gt;华为：DU+Order+LLR，即自主分发+有序分配+自由保留，华为配置独立标签分配控制命令为&lt;code&gt;mpls ldp &amp;amp;&amp;amp; label distribution control-mode independent&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标签分发模式：
&lt;ul&gt;
&lt;li&gt;下游自主方式DU：给邻居通告标签&lt;br&gt;
对于一个特定的FEC，LSR无需从上游获得标签请求消息即进行标签分发，该模式为默认行为&lt;/li&gt;
&lt;li&gt;下游按需方式DOD：&lt;br&gt;
LSR会主动向下游请求特定的FEC(路由下一跳)的分配信息，下游LSR获得标签请求消息之后才进行标签分发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标签捆绑/分配控制（LSP控制模式）：为FEC分配标签
&lt;ul&gt;
&lt;li&gt;Independent 独立控制：&lt;br&gt;
一旦发现一个FEC，就会为其创建一个本地捆绑标签(分配)，即使该路由并不是本地起源的，缺点在于可能在成LSP建立不完整的情况下开始转发报文&lt;/li&gt;
&lt;li&gt;Order 有序控制(非独立控制)：&lt;br&gt;
仅当自身为出站LSR，或者从下游收到该FEC的标签才进行分配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标签保留/保持模式：LSP的保持
&lt;ul&gt;
&lt;li&gt;Conservative 保守的 CLR：&lt;br&gt;
仅当邻居是相应路由的下一跳的时候才保留&lt;/li&gt;
&lt;li&gt;Liberal 自由的 LLR：&lt;br&gt;
统统保留，一旦IGP路径切换，其实表桥已经存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;php次末跳弹出倒数第二跳弹出&#34;&gt;PHP次末跳弹出（倒数第二跳弹出）&lt;/h2&gt;
&lt;p&gt;在LSP的最后一跳节点，已不再需要在进行标签交换，此时，可以配置倒数第二跳弹出特性PHP，在倒数第二跳节点处将标签弹出，最后一跳节点直接进行IP转发或者下一层标签转发，减少最后一跳标签交换负担。&lt;br&gt;
Egress PE向倒数第二跳节点分配隐式空标签，值为3。&lt;br&gt;
在次末跳交换为隐式空标签，意味着应当弹掉这层标签，如果只有一层标签，则变成IP报文了，同时请注意，该&lt;strong&gt;转发决策由LFIB决定&lt;/strong&gt;，转发出接口、二层重写信息已经就绪。&lt;/p&gt;
&lt;h2 id=&#34;ldp环路检测机制&#34;&gt;LDP环路检测机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;IGP环路检测机制：TTL环路检测
&lt;ul&gt;
&lt;li&gt;帧模式中的MPLS中使用TTL，信源模式中的MPLS中为TTL&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;LDP环路检测机制
&lt;ul&gt;
&lt;li&gt;距离向量法&lt;br&gt;
标签绑定报文中记录路径信息，即标签交换路由器会检查本设备的ID是否包含在路径信息中。路由路径中没有本设备的ID，那么添加，否则认为出现了环路，终止LSP建立。类似于BGP的as-path参数&lt;/li&gt;
&lt;li&gt;最大跳数法&lt;br&gt;
标签绑定报文中包含跳数信息，即每经过一个子网（设备）跳数值会增加1，一旦跳数值超过规定的最大值，则认为出现环路，从而终止LSP建立&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mpls对ttl的处理uniform模式&#34;&gt;MPLS对TTL的处理（Uniform模式）&lt;/h2&gt;
&lt;h3 id=&#34;统一模式&#34;&gt;统一模式&lt;/h3&gt;
&lt;p&gt;Uniform统一模式，IP的TTL和标签的TTL相互拷贝：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在入口PE不做改变的把IP的TTL拷贝到标签TTL&lt;/li&gt;
&lt;li&gt;在MPLS区域按照外层的TTL进行转发，在次末跳上把标签的TTL拷贝回IP&lt;/li&gt;
&lt;li&gt;多层标签默认只处理外层标签，只有外层标签弹出之后再处理内层标签&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597849957948.png&#34; alt=&#34;MPLS对TTL的处理&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;管道模式&#34;&gt;管道模式&lt;/h3&gt;
&lt;p&gt;在入接点，IP TTL值减1，MPLS TTL字段为固定值，此后报文在MPLS网络中按照标准的TTL处理方式处理。在出节点会将IP TTL字段的值减1。&lt;br&gt;
即IP分组经过MPLS网络时，无论经过多少跳，IP TTL只有在入接点和出节点时分别减1。&lt;br&gt;
PIPE管道模式，核心网对用户是透明的，整个MPLS区域被看做一个设备，标签的TTL和IP的TTL没有相互拷贝。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597850965516.png&#34; alt=&#34;管道模式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;核心网络处理方式&#34;&gt;核心网络处理方式&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;如果我们需要隐藏MPLS核心网，则强制进入MPLS核心网的报文，将标签上的TTL强制设置为255&lt;/code&gt;&lt;br&gt;
核心网络处理方式为将标签的TTL设置为255，IP标签在MPLS网络中不改变，当标签弹出之后再重新启用IP的TTL&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597850414609.png&#34; alt=&#34;核心网处理方式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;mpls-vpn&#34;&gt;MPLS VPN&lt;/h1&gt;
&lt;h2 id=&#34;vpn模型&#34;&gt;VPN模型&lt;/h2&gt;
&lt;h3 id=&#34;overlay-vpn&#34;&gt;Overlay VPN&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597963665156.png&#34; alt=&#34;Overlay VPN&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Overlay VPN可以在CE设备上建立隧道，也可以在PE设备上建立隧道，特点：&lt;strong&gt;客户路由协议总是在客户设备之间交换，而运营商对客户网络结构一无所知&lt;/strong&gt;。典型的协议：二层——帧中继；三层——GRE与IPSec；应用层——SSL VPN。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在CE与CE之间建立隧道&lt;/strong&gt;，并直接传递路由信息，路由协议数据总是在客户设备之间交换，运营商对客户网络结构一无所知
&lt;ul&gt;
&lt;li&gt;优点：不同的客户地址空间可以重叠，保密性、安全性非常好&lt;/li&gt;
&lt;li&gt;缺点：本质是一种“静态”VPN，无法反应网络的实时变化，并且当有新增站点时，需要手工在所有站点上建立与新增站点的连接，配置与维护复杂，不易管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在PE上为每一个VPN用户建立相应的隧道&lt;/strong&gt;，路由信息在PE与PE之间传递，公网中的P设备不知道私网的路由信息。
&lt;ul&gt;
&lt;li&gt;优点：客户把VPN的创建及维护完全交给运营商，保密性、安全性比较好&lt;/li&gt;
&lt;li&gt;缺点：不同的VPN用户不能共享相同的地址空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;peer-to-peer-vpn&#34;&gt;Peer-to-Peer VPN&lt;/h3&gt;
&lt;p&gt;在&lt;strong&gt;CE设备与PE设备之间交换私网信息，由PE设备将私网信息在运营商网络中传播&lt;/strong&gt;，实现了VPN部署及路由发布的动态性，解决了Overlay VPN的“静态”性质不太适合大规模应用和部署的问题。&lt;/p&gt;
&lt;h4 id=&#34;共享pe&#34;&gt;共享PE&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597964004180.png&#34; alt=&#34;共享PE&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所有VPN用户的CE设备都连到同一台PE上，PE与不同的CE之间运行不同的路由协议（或者是相同路由协议的不同进程）。由始发PE将路由发布到公网上，在接收端的PE上将路由过滤后再发给相应的CE设备。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Peer-to-Peer是在&lt;strong&gt;CE与PE之间交换私网路由信息&lt;/strong&gt;，&lt;strong&gt;然后由PE将私网路由在运营商网络中传播&lt;/strong&gt;，由于CE与PE之间运行了路由协议，所以私网路由会自动地传播到PE上；由于Peer-to-Peer VPN将私网路由泄露到公网上，所以必须通过严格的路由过滤和选择机制来控制私网路由的传播。&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;
&lt;li&gt;为了防止连接在同一台PE上的不同CE之间互通，&lt;strong&gt;必须在PE上配置大量的ACL&lt;/strong&gt;，但这种操作也增加了管理PE设备的负担&lt;/li&gt;
&lt;li&gt;VPN客户之间&lt;strong&gt;如果出现地址重叠问题，PE设备无法识别重叠的地址&lt;/strong&gt;。&lt;br&gt;
图中的Peer-to-Peer VPN使用的是共享PE的接入方式，为了减少配置复杂度，便于管理，可以采用Peer-to-Peer VPN的专用PE接入方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;专用pe&#34;&gt;专用PE&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597964239883.png&#34; alt=&#34;专用PE&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Peer-to-Peer VPN的专用PE的接入方式特点：运营商为每一个VPN单独准备一台PE设备，PE和CE之间可以运行任意的路由协议，与其他VPN无关。
&lt;ul&gt;
&lt;li&gt;优点：无需配置任何的ACL，配置复杂度、管理难度有所降低&lt;/li&gt;
&lt;li&gt;缺点：每新增一个VPN站点都需要新增一台专用的PE设备，代价过于昂贵。而且没有解决VPN客户之间地址空间重叠的问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;解决的问题&#34;&gt;解决的问题&lt;/h2&gt;
&lt;h3 id=&#34;地址空间重叠&#34;&gt;地址空间重叠&lt;/h3&gt;
&lt;p&gt;两个客户的VPN存在相同的地址空间，传统VPN网络结构中的设备无法区分客户重叠的路由信息，即&lt;strong&gt;地址空间的重叠问题&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PE设备怎么区分不同VPN客户的相同路由？&lt;br&gt;
可以通过在同一台PE设备上为不同的VPN建立单独的路由，这样冲突的的路由就被隔离开来&lt;/li&gt;
&lt;li&gt;冲突路由在公网中传播时，接收端PE如何正确导入VPN客户路由？&lt;br&gt;
在路由传递过程中，为不同的VPN路由添加不同的标识，以示区别，这些标识可以作为BGP属性进行传递&lt;/li&gt;
&lt;li&gt;PE设备收到IP数据包后，如何正确的发送给目的VPN客户？&lt;br&gt;
由于IP报文不可更改，可以在IP报文头前加一些信息。由始发路由器打上标记，接收路由器在收到带标记的的数据包时，根据标记转发给正确的VPN&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;专用pe的解决方案&#34;&gt;专用PE的解决方案&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597964868282.png&#34; alt=&#34;专用PE的解决方案&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
专用PE设备分工明确，每个&lt;strong&gt;PE设备只保存自己的VPN路由，P设备只保存公网路由&lt;/strong&gt;。因此解决共享PE设备上地址空间重叠的思路是：&lt;strong&gt;将专用PE设备与P设备的功能在同一台PE设备上完成，并实现VPN路由的隔离&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;共享pe的解决方案&#34;&gt;共享PE的解决方案&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597965012348.png&#34; alt=&#34;共享PE的解决方案&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在共享PE设备上使用&lt;strong&gt;VRF技术&lt;/strong&gt;将重叠的路由隔离：&lt;strong&gt;每个VPN的路由放入自己对应的VPN Routing Table中&lt;/strong&gt;。&lt;br&gt;
PE设备在&lt;strong&gt;维护多个VPN Routing Table时，同时还维护一个公网的路由表&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;共享PE设备上实现重叠路由的隔离就是在PE设备上将来自每个VPN的路由放入自己对应的VPN Routing Table中，每个VPN Routing Table只记录对应VPN中学来的路由，就像是专用PE一样。这个VPN Routing Table称谓VRF，即VPN路由转发表。&lt;/li&gt;
&lt;li&gt;每一个VRF都需要对应一个VPN instance，VPN用户对应的接口绑定到VPN instance中。&lt;/li&gt;
&lt;li&gt;对于每个PE，可以维护一个或多个VPN instance ，同时维护一个公网的路由表（也叫全局路由表），多个VPN instance实例相互独立且隔离。其实实现VPN instance并不困难，关键在于如何在PE上使用特定的策略规则来协调各VPN instance和全局路由表之间的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;区分冲突路由rdroute-distinguisher&#34;&gt;区分冲突路由（RD，Route Distinguisher）&lt;/h3&gt;
&lt;p&gt;将VPN路由发布到全局路由表之前，使用一个&lt;strong&gt;全局唯一的标识和路由绑定&lt;/strong&gt;，以区分冲突的私网路由，这个标识被称为RD&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597965289822.png&#34; alt=&#34;区分冲突路由&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RD即VPN路由标识符，由8字节组成，配置时同一PE设备上分配给每个VPN的RD必须唯一&lt;/li&gt;
&lt;li&gt;RD用于区分使用相同地址空间的IPv4前缀，增加了RD的IPv4地址称为VPN-IPv4地址（即VPNv4地址）&lt;/li&gt;
&lt;li&gt;运营商设备采用BGP协议作为承载VPN路由的协议，并将BGP协议进行了扩展，称为MP-BGP。PE从CE接收到客户的IPv4私网路由后，将客户的私网路由添加各种标识信息后变为VPNv4路由放入MP-BGP的VPNv4路由表中，并通过MP-BGP协议在公网上传递。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vpn路由的引入rtroute-target&#34;&gt;VPN路由的引入（RT，Route Target）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Hub-Spoke场景中VPN路由的引入问题&lt;/strong&gt;：&lt;br&gt;
如图所示，某公司分部1与分部2中存在172.16.1.1/32与172.16.2.1/32的私网地址，公司希望实现各分部只能与总部通信，分部之间不能相互通信。分配给分部1的VPN RD为1:1，分配给分部2的VPN RD为2:2。如果要使用RD解决路由引入VPN的问题，总部与分部1通信，则RD的值需要配置成1:1，总部与分部2通信，则RD的值需要配置成为2:2。但RD的值在本地PE上是唯一的，并且只能配置一个。因此，不能使用RD来解决路由正确引入的问题。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597965542281.png&#34; alt=&#34;VPN路由的引入问题&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
RD不能解决VPN路由正确引入VPN的问题。需要一种类似于Tag的标识，这个标识由人工分配，发送端PE发送时打上标识，接收端PE收到后，根据需要将带有相应标识的路由引入VPN。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597965764129.png&#34; alt=&#34;RT&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
RT属性用于将路由正确引入VPN，有两类VPN Target属性，Import Target和Export Target，分别用于VPN路由的导出与导入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如图所示，希望实现分部只能与总部通信，分部之间不能通信。
&lt;ul&gt;
&lt;li&gt;分配给分部1的Export Target为1:1，Import Target为3:3&lt;/li&gt;
&lt;li&gt;分配给分部2的Export Target为2:2，Import Target为3:3&lt;/li&gt;
&lt;li&gt;分配给总部的Export Target为3:3，Import Target为1:1，2:2&lt;/li&gt;
&lt;li&gt;PE2上收到对端PE1发送的VPNv4的路由后，检查其Export Target。因为总部的Import Target为1:1，2:2，所以值为1:1或2:2的路由被引入总部的VRF。PE1的VPNv4的路由引入各分部VRF的过程类似。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RT封装在&lt;strong&gt;BGP的扩展Community属性中&lt;/strong&gt;，在路由传递过程中作为可选可传递属性进行传递&lt;/li&gt;
&lt;li&gt;RT的本质是每个VRF表达自己的路由取舍及喜好的属性，有两类VPN Target属性：
&lt;ul&gt;
&lt;li&gt;Export Target：本端的路由在导出VRF，转变为VPNv4的路由时，标记该属性&lt;/li&gt;
&lt;li&gt;Import Target：对端收到路由时，检查其Export Target属性。当此属性与PE上某个VPN实例的Import Target匹配时，PE就把路由加入到该VPN实例中。&lt;/li&gt;
&lt;li&gt;使用RT实现本端与对端的路由正确引入VPN，原则为：
&lt;ul&gt;
&lt;li&gt;本端的Export Target=对端的Import Target&lt;/li&gt;
&lt;li&gt;本端的Import Target=对端的Export Target&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;冲突路由的查找&#34;&gt;冲突路由的查找&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966162225.png&#34; alt=&#34;冲突路由的查找&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因为数据包没有携带任何标识，所以在ICMP的数据包到达PE1时，PE1并不知道该查找哪个VPN的路由表找到正确的目标地址。&lt;strong&gt;解决该问题的方案有两种&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;在数据包中增加标识信息&lt;/strong&gt;，并且使用&lt;strong&gt;RD作为区分数据包所属VPN的标识符&lt;/strong&gt;，数据转发时也携带RD信息。缺点是由于RD由8字节组成，额外增大数据包，会导致转发效率降低&lt;/li&gt;
&lt;li&gt;借助公网中已经实施的MPLS协议&lt;strong&gt;建立的标签隧道&lt;/strong&gt;，&lt;strong&gt;采用标签作为数据包正确转发的标识&lt;/strong&gt;，MPLS标签支持嵌套，可以将区分数据包所属VPN的标签封装在公网标签内。&lt;br&gt;
使用标签嵌套解决数据转发过程中冲突路由的查找问题：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966350316.png&#34; alt=&#34;标签嵌套解决数据转发&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Outer MPLS Label在MPLS VPN中被称为公网标签，用于MPLS网络中转发数据。一般公网标签会在到达PE设备时已被倒数第二跳剥掉，漏出Inner Label。Inner MPLS Label在MPLS VPN中被称为私网标签，用于将数据正确发送到相应的VPN中，PE依靠Inner Label区分数据包属于哪个VPN。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工作原理&#34;&gt;工作原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966545952.png&#34; alt=&#34;工作原理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MPLS VPN的工作过程分为两部分：&lt;/p&gt;
&lt;h3 id=&#34;mpls-vpn路由的传递过程&#34;&gt;MPLS VPN路由的传递过程&lt;/h3&gt;
&lt;h4 id=&#34;1-ce与pe之间的路由交换&#34;&gt;1. CE与PE之间的路由交换&lt;/h4&gt;
&lt;p&gt;PE与CE之间可以通过静态路由协议交换路由信息，也可以通过动态路由协议（如：RIP，OSPF，ISIS，BGP等）交换路由信息&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966629967.png&#34; alt=&#34;CE与PE之间的路由交换&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-vrf路由注入mp-bgp的过程&#34;&gt;2. VRF路由注入MP-BGP的过程&lt;/h4&gt;
&lt;p&gt;VRF中的IPv4路由被添加上RD、RT与标签等信息成为VPN-IPv4的路由放入到MP-BGP的路由表中，并通过MP-BGP协议在PE设备之间交换路由信息&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966762427.png&#34; alt=&#34;VRF路由注入MP-BGP的过程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;3-公网标签的分配过程&#34;&gt;3. 公网标签的分配过程&lt;/h4&gt;
&lt;p&gt;MPLS协议在运营商网络分配公网标签，建立标签隧道，实现私网数据在公网上的转发。&lt;br&gt;
PE之间运行的MP-BGP协议为VPN路由分配私网标签，PE设备根据私网标签将数据正确转发给相应的VPN。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966793051.png&#34; alt=&#34;公网标签的分配过程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;4-mp-bgp路由注入vrf的过程&#34;&gt;4. MP-BGP路由注入VRF的过程&lt;/h4&gt;
&lt;p&gt;PE2在接收到PE1发送的VPNv4路由后将检查路由的扩展团体属性，将携带的Export Target值与本端VPN的Import Target值比较，数值相同则将路由引入VPN的路由表，实现路由的正确导入。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966855157.png&#34; alt=&#34;MP-BGP路由注入VRF的过程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mpls-vpn数据的转发过程&#34;&gt;MPLS VPN数据的转发过程&lt;/h3&gt;
&lt;h4 id=&#34;1-ce设备到pe设备的数据转发&#34;&gt;1. CE设备到PE设备的数据转发&lt;/h4&gt;
&lt;p&gt;数据从CE4转发给PE2，在PE2设备上需要查找VPN2的路由表，确定数据进行标签转发后，再查找下一跳与出接口，根据分配的标签进行MPLS的封装。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597966918842.png&#34; alt=&#34;CE设备到PE设备的数据转发&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CE4所连接的VPN2的用户要与对端VPN2中的172.16.1.1/32用户通信，PE2收到数据包后，查找本地VPN2的路由表，发现数据包需要进行标签转发，分配的私网标签为1027，到达目标地址的下一跳为PE1&lt;/li&gt;
&lt;li&gt;PE2通过查找LFIB表，发现到达PE1被分配的公网标签为1030，出接口为G0/0/0，PE2将数据包进行MPLS封装，内层为1027，外层为1030，从接口G0/0/0转发出去。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-公网设备上的数据转发&#34;&gt;2. 公网设备上的数据转发&lt;/h4&gt;
&lt;p&gt;数据包在公网上转发时，通过MPLS协议已建立好的标签隧道将数据报文转发到PE1。转发过程中，只改变公网标签。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597967009598.png&#34; alt=&#34;公网设备上的数据转发&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PE2收到VPN用户的数据包后，封装上MPLS的标签，将私网数据通过MPLS建立的标签隧道进行转发，PE2上数据包封装的公网标签为1030，转发给P设备后，查找LFIB表，进标签为1030的数据包，对应的出标签为3，即将公网标签标签剥离后，将数据包发送给PE1，PE1收到的是只有内层私网标签的数据包。&lt;/p&gt;
&lt;h4 id=&#34;3-pe设备到ce设备的数据转发&#34;&gt;3. PE设备到CE设备的数据转发&lt;/h4&gt;
&lt;p&gt;PE1收到剥离公网标签的数据包后，根据私网标签查找转发数据包的下一跳，将数据包正确发送给相应VPN客户&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597967052503.png&#34; alt=&#34;PE设备到CE设备的数据转发&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
PE1收到只有一层标签的数据包，查找标签表，发现标签为1027的数据包对应的下一跳为CE2，于是PE2将数据包剥离私网标签，进行IP封装，查找出接口，将数据包发送给CE2处理，数据包到达正确的目标用户 。&lt;/p&gt;
&lt;h2 id=&#34;总结-2&#34;&gt;总结&lt;/h2&gt;
&lt;h3 id=&#34;路由传递&#34;&gt;路由传递&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;RD&lt;/strong&gt;：路由区分器 ，是一个64bit的数值，PE设备将这个值加在来自vrf的IPv4或者IPv6路由前面形成VPNv4/VPNv6路由，该路由被通告进MP-BGP&lt;br&gt;
&lt;code&gt;VRF是在PE设备上起到路由隔离作用，而RD是在传递过程中起到路由区分作用&lt;/code&gt;&lt;br&gt;
在PE设备上产生了经过RD做了全局区分的VPNv4路由，那么现在需要解决路由如何通过MP-BGP传递的问题：建立一个专为VPNv4服务的地址族下的邻居会话。通过一个附加的操控方案，保障只有那些有需要被传递至指定PE设备的路由才会被传递。&lt;strong&gt;RT route-target， 一个BGP扩展团体属性&lt;/strong&gt;，通过针对BGP收发路由定义根据扩展团体属性RT的策略实现&lt;/p&gt;
&lt;h3 id=&#34;数据转发&#34;&gt;数据转发&lt;/h3&gt;
&lt;p&gt;当PE设备产生VPNv4路由时，会通过MP-BGP为其分配一个标签。&lt;br&gt;
IP报文进入PE设备，根据目标IP地址查找LFIB。&lt;br&gt;
内层标签用于数据到达远端之后，决定转发至哪个接口（vrf里面），外层标签用于在MPLS核心网中转发数据。&lt;/p&gt;
&lt;h3 id=&#34;部署pe-ce路由的小提示&#34;&gt;部署PE-CE路由的小提示&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果使用静态，则PE需要在vrf下写静态；&lt;/li&gt;
&lt;li&gt;如果使用IGP，则需要双向重分布；&lt;/li&gt;
&lt;li&gt;如果是BGP，则不需要重分布，但PE在vrf地址族下做配置；&lt;br&gt;
内层标签由PE MP-BGP分配，标识报文到达本PE后转发至哪个出接口或者vrf；&lt;br&gt;
外层标签由LDP分配，在Core network依据外层标签转发；&lt;br&gt;
标签在产生VPNv4路由时，由MP-BGP分配，同时标签将跟随路由更新给对等体&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;防环&#34;&gt;防环&lt;/h1&gt;
&lt;h2 id=&#34;多宿主环境下的sooeigrp协议&#34;&gt;多宿主环境下的SoO（EIGRP协议）&lt;/h2&gt;
&lt;p&gt;SoO（sign of origin）BGP的扩展团体属性用于在多出口情况下阻止环路。唯一的SoO值必须为每个VPN站点配置，该值（sitemap）应用于PE-CE连接的接口下，SoO值通过一个route-map配置，其本质是&lt;strong&gt;不把收到的路由再传给客户站点&lt;/strong&gt;，&lt;strong&gt;部署在PE的vrf接口下&lt;/strong&gt;，其值一般为ASN:nn或者IP-address:nn&lt;br&gt;
EIGRP协议接入MPLS VPN的防环：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1598189427404.png&#34; alt=&#34;EIGRP协议接入MPLS VPN的防环&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在双出口（多归属）的环境，极有可能会出现路由环路，图中10.1.2.0/24，SoO之后在PE收到的时候就不会再传给CE，即PE-Y不会再传给CE-A2&lt;/p&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;从CE收到的路由引入MP-BGP，增加扩展团体属性值自定义SoO&lt;/li&gt;
&lt;li&gt;其它PE设备不将携带特定SoO属性值的路由传递给同站点的CE&lt;/li&gt;
&lt;li&gt;相同SoO值，被PE认为是同站点&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;举例说明&#34;&gt;举例说明&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1598626932182.png&#34; alt=&#34;举例说明&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;在PE1上针对CE1对等体指定SoO属性，该属性相当于标识了CE1所在Site&lt;/li&gt;
&lt;li&gt;当CE1发布路由给PE1时，PE1为这些路由携带上该SoO属性&lt;/li&gt;
&lt;li&gt;PE1通过骨干网将这些路由发布给PE2时也将携带此SoO属性&lt;/li&gt;
&lt;li&gt;PE2将这些路由发布给自己的CE2对等体时，如果PE2发现路由中携带的SoO属性与其上针对CE2对等体配置的SoO属性相同，说明这些路由就是由该Site（CE1所在的site）发出的，从而拒绝将路由发布给CE2对等体，从而避免了VPN site内路由环路的产生&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ospf的防环&#34;&gt;OSPF的防环&lt;/h2&gt;
&lt;h3 id=&#34;domain-id&#34;&gt;Domain-ID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;域标识符（Domain ID）用来标识和区分不同的域&lt;/li&gt;
&lt;li&gt;本地OSPF区域和VPN远端的OSPF区域间如果相互发布区域间路由Type3 LSA，则这些区域必须属于同一个OSPF域，即使用domain-id命令配置相同的OSPF域标识&lt;/li&gt;
&lt;li&gt;通常情况下，从PE路由器引入的路由将会作为External-LSA发布出去，但对属于同一个OSPF域不同节点的目的地，这样的路由应该作为Type3 LSA发布，这就需要为同一个OSPF域使用相同的域标识符，华为设备默认为NULL，思科设备上默认为进程ID&lt;/li&gt;
&lt;li&gt;当有了vrf之后，就会有domain-id的概念，即不同的ospf域，默认情况下为ospf的进程号，所有当两端的进程号不一致时，会被认为是External-LSA。当然也可以手动配置domain-id&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三类lsa防环down-bit&#34;&gt;三类LSA防环（Down bit）&lt;/h3&gt;
&lt;p&gt;多协议BGP引入OSPF时自动增加Down位，会在区域内保留，其他PE检测到Down位，拒绝把OSPF引入BGP，即此条三类LSA的路由不参与路由选择，也保证数据的优先转发。&lt;br&gt;
&lt;code&gt;vrf或者vpn实例下绑定的OSPF进程，对带有down bit的三类LSA不能计算&lt;/code&gt;&lt;br&gt;
OSPF接入MPLS VPN，本身自己设置了防环规则和解决方案，是自动的，华为可以使用&lt;code&gt;vpn-instance-capability simple&lt;/code&gt;进行关闭&lt;br&gt;
从PE引入到OSPF LSDB的外部LSA，down bit置位&lt;/p&gt;
&lt;h3 id=&#34;外部路由的环路预防5类7类lsa防环&#34;&gt;外部路由的环路预防(5类/7类LSA防环)&lt;/h3&gt;
&lt;p&gt;外部路由（5、7类）：TAG（BGP的AS号码），PE检测到5类LSA的TAG=设备自身的AS号码则拒绝引入。&lt;br&gt;
默认情况下，与vrf实例绑定的OSPF不仅检测三类LSA的down bit，还检测TAG&lt;/p&gt;
&lt;h3 id=&#34;sham-linkv-link虚假链路&#34;&gt;sham-link（v-link虚假链路）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;场景：站点之间存在其它专有链路（后门链路，如下图中R8与R10间粉红色背景的链路）的情况下&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1598362348451.png&#34; alt=&#34;后门链路&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;原理：在PE上的vrf实例之间通过单播建立sham-link，然后单播传递LSA，还原MPLS环境下OSPF的LSA报文的正常传输&lt;/li&gt;
&lt;li&gt;配置：
&lt;ol&gt;
&lt;li&gt;在PE设备上为vrf创建独立环回口，必须/32&lt;/li&gt;
&lt;li&gt;将其注入BGP的vrf对应地址族，绝不允许注入OSPF&lt;/li&gt;
&lt;li&gt;配置sham-link&lt;br&gt;
&lt;code&gt;在sham-link中，内层标签由多协议BGP分配，从vrf的客户路由协议OSPF到BGP的重分布是需要做的，否则没有内层标签&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ospf的mecvrf-lite&#34;&gt;OSPF的MEC/VRF-LITE&lt;/h3&gt;
&lt;p&gt;MCE是Multi-VPN-Instance CE（多实例CE）的简称，具有MCE功能的设备在BGP/MPLS IP VPN组网应用中承担多个VPN实例的CE功能，减少用户网络设备的投入，一个私有网络内的用户需要划分成多个VPN，不同的VPN用户的业务需要完全隔离&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1598451072279.png&#34; alt=&#34;OSPF的MEC&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
VPNv4的路由反射器与所有PE建立邻居关系，负责反射路由。cisco和huawei的区别：默认情况下，cisco的VPNv4反射器收取所有VPNv4路由，但华为的正好相反。&lt;/p&gt;
&lt;h1 id=&#34;bgp接入mpls-vpn&#34;&gt;BGP接入MPLS VPN&lt;/h1&gt;
&lt;h2 id=&#34;bgp接入mpls-vpn解决的问题&#34;&gt;BGP接入MPLS VPN解决的问题&lt;/h2&gt;
&lt;p&gt;可以不用做OSPF与BGP的双向重分布&lt;/p&gt;
&lt;h2 id=&#34;如果不采用默认路由的方式如何传递明细路由呢&#34;&gt;如果不采用默认路由的方式，如何传递明细路由呢？&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1598539126910.png&#34; alt=&#34;传递明细路由&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;问题描述&#34;&gt;问题描述&lt;/h3&gt;
&lt;p&gt;例如使用默认路由的方式，如果R8/9访问互联网，则访问互联网的流量也经过总部的R10。&lt;br&gt;
目前R8与R9的路由可以正常传到R1，然后传递给R10，但是R10不会再传递给R1（ebgp防环）。&lt;br&gt;
此时需要解决的问题如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;R10如何将路由传递给R1【ebgp防环】&lt;/li&gt;
&lt;li&gt;R8将路由通过R3-R2-R1传递给R10，R10再传递下来（给R1）之后，会导致R1上有两条R8的路由，这两条路由不能共存，此时会选择从R8发来的路由，而不选择从R10传过来的【bgp的路由优选】&lt;/li&gt;
&lt;li&gt;R2是vpnv4的路由反射器，路由从R1传递给R2，站在R2路由反射器的角度看，R3和R1上都有R8的路由，这只能选择一个【RD需要区分开】&lt;/li&gt;
&lt;li&gt;如何控制收发的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;对应的解决方案&#34;&gt;对应的解决方案&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;中心场点的PE修改eBGP防环&lt;/li&gt;
&lt;li&gt;中心场点PE通过多vrf区分传出和传入的路由&lt;/li&gt;
&lt;li&gt;中心场点PE通过不同RD区分传出和传入的路由，以使得VPNv4的RR能够同时保存传出和传入的路由&lt;/li&gt;
&lt;li&gt;通过RT控制传出的路由和传入的路由的更新方向，中心PE：vrfA收、vrfB发；分支PE：发给vrfA、收取vrfB。
&lt;ul&gt;
&lt;li&gt;Import Route-Policy可以过滤VPN实例IPv4地址族引入的路由信息，以及为通过过滤的路由信息设置路由属性&lt;/li&gt;
&lt;li&gt;Export Route-Policy命令用于将当前VPN实例的IPv4地址族与一条出方向的Route-Policy进行关联&lt;/li&gt;
&lt;li&gt;Routing-table limit命令用来配置当前VPN实例地址族下所能容纳的路由数量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mpls-vpn故障排查&#34;&gt;MPLS VPN故障排查&lt;/h1&gt;
&lt;p&gt;用户不能互访&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;控制平面故障
&lt;ul&gt;
&lt;li&gt;CE之间是否有路由可达&lt;/li&gt;
&lt;li&gt;CE是否发布路由给PE，检查PE与CE之间的路由&lt;/li&gt;
&lt;li&gt;PE是否发布路由给PE&lt;/li&gt;
&lt;li&gt;PE之间是否建立MP-IBGP邻居&lt;/li&gt;
&lt;li&gt;PE之间LSP是否建立&lt;/li&gt;
&lt;li&gt;检查MPLS和LDP配置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据平面故障
&lt;ul&gt;
&lt;li&gt;是否存在MTU问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;p&gt;实验拓扑：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597664732776.png&#34; alt=&#34;实验拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
预配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
sys
sys R1
ospf 1
a 0
network 0.0.0.0 255.255.255.255
int lo 0
ip addr 11.1.1.1 32
int lo 1
ip addr 11.11.11.11 32
int g0/0/0
ip addr 12.1.1.1 24
# R2
sys
sys R2
ospf 1
a 0
network 0.0.0.0 255.255.255.255
int lo 0
ip addr 22.1.1.1 32
int g0/0/0
ip addr 12.1.1.2 24
int g0/0/1
ip addr 23.1.1.2 24
# R3
sys
sys R3
ospf 1
a 0
network 0.0.0.0 255.255.255.255
int lo 0
ip addr 33.1.1.1 32
int g0/0/0
ip addr 23.1.1.3 24
int g0/0/1
ip addr 34.1.1.3 24
# R4
sys
sys R4
ospf 1
a 0
network 0.0.0.0 255.255.255.255
int lo 0
ip addr 44.1.1.1 32
int g0/0/0
ip addr 34.1.1.4 24
int g0/0/1
ip addr 45.1.1.4 24
# R5
sys
sys R5
ospf 1
a 0
network 0.0.0.0 255.255.255.255
int lo 0
ip addr 55.1.1.1 32
int lo 0
ip addr 55.55.55.55 32
int g0/0/0
ip addr 45.1.1.5 24
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验一mpls-ldp&#34;&gt;实验一：MPLS-LDP&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置LDP
# R1
mpls lsr-id 11.1.1.1   # 全局配置，系统视图
mpls  # 进入MPLS视图
mpls ldp  # 开启LDP协议
int g0/0/0  # 接口下开启MPLS和LDP
mpls
mpls ldp
# R2
mpls lsr-id 22.1.1.1
mpls
mpls ldp
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
# R3
mpls lsr-id 33.1.1.1
mpls
mpls ldp
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
# R4
mpls lsr-id 44.1.1.1
mpls
mpls ldp
int g0/0/0
mpls
mpls ldp
int g0/0/1
mpls
mpls ldp
# R5
mpls lsr-id 55.1.1.1
mpls
mpls ldp
int g0/0/0
mpls
mpls ldp

# 检查
# R1~5
dis mpls ldp peer
# R1
ping lsp -a 11.1.1.1 ip 55.1.1.1 32  # 测试LSP（标签是单向交换的）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二r2和r4建立远端ldp会话&#34;&gt;实验二：R2和R4建立远端LDP会话&lt;/h2&gt;
&lt;p&gt;应用于L2 VPN以及会话保护&lt;br&gt;
常见的LDP邻居问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IGP协议错误导致RID地址不可达（环回接口掩码错误，华为仅仅为/32的路由分标签）&lt;/li&gt;
&lt;li&gt;修改传输地址&lt;/li&gt;
&lt;li&gt;认证，LDP支持认证&lt;/li&gt;
&lt;li&gt;ACL引发的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R2
mpls ldp remote-peer QYT
remote-ip 44.1.1.1
# R4
mpls ldp remote-peer QYT
remote-ip 22.1.1.1

# 查看
# R2/4
dis mpls ldp remote-peer
dis mpls ldp lsp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三php&#34;&gt;实验三：PHP&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看（默认为隐式空标签）
# R4
dis mpls ldp lsp 
dis mpls lsp  # 查看去往55.1.1.1的标签
# 同时抓取AR4的两个接口进行报文对比，g0/0/0接口有标签，g0/0/1接口无标签

# R5
mpls
label advertise explicit-null   # 显示空标签
# R4
reset mpls ldp all
# 此时重复上面抓包动作，发现g0/0/1接口有标签0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验四研究mpls解决bgp路由黑洞的原理&#34;&gt;实验四：研究MPLS解决BGP路由黑洞的原理&lt;/h2&gt;
&lt;p&gt;1和5使用传统的IP转发，2、3、4使用MPLS转发&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置IGP路由&lt;/li&gt;
&lt;li&gt;配置静态路由，1、2、4、5&lt;/li&gt;
&lt;li&gt;配置BGP并通告静态路由&lt;/li&gt;
&lt;li&gt;R2、3、4开启 LDP&lt;/li&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置IGP路由：预配置

# 配置静态路由
# R1
ip route-static 55.55.55.55 32 12.1.1.2
# R2
ip route-static 11.11.11.11 32 12.1.1.1
# R4
ip route-static 55.55.55.55 32 45.1.1.5
# R5
ip route-static 11.11.11.11 32 45.1.1.4

# 配置BGP并通告静态路由
# R2
bgp 100
peer 44.1.1.1 as-number 100
peer 44.1.1.1 next-hop-local
peer 44.1.1.1 connect-interface lo 0
network 11.11.11.11 32
# R4
bgp 100
peer 22.1.1.1 as-number 100
peer 22.1.1.1 next-hop-local
peer 22.1.1.1 connect-interface lo 0
network 55.55.55.55 32

# 测试
# R1
ping -a 11.11.11.11 55.55.55.55   #  此时R1无法ping通R5
# R1/2/4/5
undo mpls  # 关闭mpls，然后重新配置
# R2
mpls lsr-id 22.1.1.1
mpls ldp
int g0/0/1
mpls 
mpls ldp
# R4
mpls lsr-id 44.1.1.1
mpls ldp
int g0/0/0
mpls 
mpls ldp
# 查看邻居
# R2/3/4
dis mpls ldp peer
# R2 
ping lsp -a 22.1.1.1 ip 44.1.1.1 32 # R2和R4是通的，但此时R1和R5不通，原因是在R2的路由表中去往55.55.55.55的IBGP路由下一跳为44.1.1.1（44.1.1.1是OSPF路由，下一跳为23.1.1.3，出接口为g0/0/1）,递归之后为23.1.1.3，不通过lsp隧道进行转发，因此需要使用下面的命令，即R3上没有55.55.55.55的路由，这条路由的路径是1-2-4-5
# R2\4
route recursive-lookup tunnel 
# 此时R1上：ping -a 11.11.11.11 55.55.55.55 是能够通的
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验五基本mpls-vpn部署&#34;&gt;实验五：基本MPLS VPN部署&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;部署域内IGP（预配置）&lt;/li&gt;
&lt;li&gt;部署域内LDP（上面实验已经配置）&lt;/li&gt;
&lt;li&gt;部署MP-BGP，建立起VPNv4邻居&lt;/li&gt;
&lt;li&gt;定义VPN实例并绑定到接口（注意此步会清空接口配置），不要忘记配置静态路由&lt;/li&gt;
&lt;li&gt;在PE设备上为VPN实例与VPNv4交互路由&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 删除ospf
# R1/5
undo ospf 1
# R2
int g0/0/0 
undo ospf en 1 ar 0
# R4
int g0/0/01
undo ospf en 1 ar 0

# 开始配置

# 部署MP-BGP，建立起VPNv4邻居
# R2
bgp 100
ipv4-family unicast
undo network 11.11.11.11 32
undo peer 44.1.1.1 enable
q
ipv4-family vpnv4 unicast
peer 44.1.1.1 enable
q
# R4
bgp 100
ipv4-family unicast
undo network 55.55.55.55 32
undo peer 22.1.1.1 enable
q
ipv4-family vpnv4 unicast
peer 22.1.1.1 enable

# 定义VPN实例并绑定到接口
# R2
ip vpn-instance qyt666
route-distinguisher 100:100
vpn-target 100:24 export-extcommunity
vpn-target 100:42 import-extcommunity
int g0/0/0
ip binding vpn-instance qyt666  # 此时地址会被清空，需要重新配置
ip addr 12.1.1.2 24
q
undo ip route-static  11.11.11.11 32 12.1.1.1
ip route-static vpn-instance qyt666 11.11.11.11 32 12.1.1.1
# R4
ip vpn-instance qyt666
route-distinguisher 100:100
vpn-target 100:42 export-extcommunity
vpn-target 100:24 import-extcommunity
int g0/0/1
ip binding vpn-instance qyt666
ip addr 45.1.1.4 24
q
undo ip route-static  55.55.55.55 32 45.1.1.5
ip route-static vpn-instance qyt666 55.55.55.55 32 45.1.1.5

# 在PE设备上为VPN实例与VPNv4交互路由
# R2
bgp 100
ipv4-family vpn-instance qyt666
network 11.11.11.11 32
# R4
bgp 100
ipv4-family vpn-instance qyt666
network 55.55.55.55 32

# 测试
# R2/4
dis ip rou vpn-instance qyt666
dis mpls lsp
dis bgp vpnv4 all rou
dis ip vpn-instance verbose 
# R1
ping -a 11.11.11.11 55.55.55.55
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;下面实验使用BGP专题的路由：&lt;/p&gt;
&lt;h2 id=&#34;实验六ospf接入mpls-vpn&#34;&gt;实验六：OSPF接入MPLS VPN&lt;/h2&gt;
&lt;p&gt;只需要开启R1/2/3/4/8/9/10，其中R10为总部支点，R8/9为分支站点，R1/2/3/4为运营商网络&lt;br&gt;
配置步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置核心网域内IGP&lt;/li&gt;
&lt;li&gt;配置域内LDP&lt;/li&gt;
&lt;li&gt;配置域内MP-BGP&lt;/li&gt;
&lt;li&gt;配置VRF绑定到接口（注意IP地址）、定义RD、RT&lt;/li&gt;
&lt;li&gt;配置PE-CE路由交互及重分布&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1. 配置核心网域内IGP
# R4
int lo 0
ip addr 44.1.1.1 24

# 2. 配置域内LDP
# R1
mpls
mpls lsr-id 11.1.1.1
mpls ldp
q
int g0/0/1
mpls ldp
int g0/0/2
mpls ldp
int s1/0/0
mpls ldp
# R2
mpls
mpls lsr-id 22.1.1.1
mpls ldp
q
int s1/0/1
mpls ldp
int g0/0/2
mpls ldp
int g0/0/0
mpls ldp
# R3
mpls
mpls lsr-id 33.1.1.1
mpls ldp
q
int g0/0/0
mpls ldp
int g0/0/2
mpls ldp
int g0/0/1
mpls ldp
# R4
mpls
mpls lsr-id 44.1.1.1
mpls ldp
lsp-trigger all    # 默认是host，只为主机路由（/32）分配标签，此处改成host，否则lo0的地址无法分配标签
q
int s1/0/1
mpls ldp
int g0/0/2
mpls ldp
int s1/0/0
mpls ldp
# 测试
# R1
ping lsp -a 11.1.1.1 ip 44.1.1.1 32
dis mpls ldp lsp
dis mpls ldp peer

# 3. 配置域内MP-BGP
# R1
bgp 100
ipv4-family vpnv4 unicast
peer 44.1.1.1 enable
# R4
bgp 100
ipv4-family vpnv4 unicast
peer 11.1.1.1 enable
# 查看
# R1/4
dis bgp vpnv4 all peer

# 4. 配置VRF绑定到接口（注意IP地址）、定义RD、RT
# R1
ip vpn-instancce michael
route-distinguisher 100:1
vpn-target 100:110 export-extcommunity
vpn-target 100:409 import-extcommunity
q
int g2/0/0
ip binding vpn-instance michael
ip address 10.1.110.1 24
# R4
ip vpn-instancce michael
route-distinguisher 100:1
vpn-target 100:409 export-extcommunity
vpn-target 100:110 import-extcommunity
q
int g0/0/0
ip binding vpn-instance michael
ip address 10.1.49.4 24

# 5. 配置PE-CE路由交互及重分布
# R9
int lo 0
ip addr 99.1.1.1 32
int g0/0/0
ip addr 10.1.49.9 24
ping 10.1.49.4
# R10
int lo 0
ip addr 110.1.1.1 32
int g2/0/0
ip addr 10.1.110.10 24
ping 10.1.110.1
# 进程号码配置为109，注意如果核心网的IGP是OSPF，PE的进程号不能与全局冲突
# R9
ospf 109
a 0
int lo 0
ospf enable 109 area 0
int g0/0/0
ospf network-type p2p
ospf enable 109 area 0
# R10
ospf 109
a 0
int lo 0
ospf enable 109 area 0
int g2/0/0
ospf network-type p2p
ospf enable 109 area 0
# R1
ospf 109 vpn-instance michale
a 0
int g2/0/0
ospf network-type p2p
ospf enable 109 area 0
# R4
ospf 109 vpn-instance michale
a 0
int g0/0/0
ospf network-type p2p
ospf enable 109 area 0
# 双向重分布
# R1
bgp 100
ipv4-family vpn-instance michael
import-route ospf 109
q
ospf 109
import-route bgp
q
dis ip rou pro ospf
dis ip rou pro bgp
# R4
bgp 100
ipv4-family vpn-instance michael
import-route ospf 109
q
ospf 109
import-route bgp
dis ip rou pro ospf
dis ip rou pro bgp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验七配置ospf的domain-id&#34;&gt;实验七：配置ospf的domain-id&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
ospf 109
domain-id 109
# 此时在R9上dis ip rou pro ospf，可以看到所有的路由都变成外部路由O_ASE

# R4
ospf 109
domain-id 109
# 此时再在R9上dis ip rou pro ospf，可以看到所有的路由110.1.1.1/32又变回OSPF内部路由了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验八三类lsa防环逆向实验&#34;&gt;实验八：三类LSA防环逆向实验&lt;/h2&gt;
&lt;p&gt;关闭down bit 检测，允许计算路由，从而产生环路&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R8
ospf 109
area 0
int lo 0
ip add 88.1.1.1 32
ospf en 109 a 0 
int s1/0/0
ip addr 83.1.1.8 24
ospf en 109 a 0
ospf network-type p2p
int g0/0/1
ip addr 89.1.1.8 24
ospf en 109 a 0
ospf network-type p2p
#R9 
int g0/0/1
ip addr 89.1.1.9 24
ospf en 109 a 0
ospf network-type p2p
# R3
ip vpn-instance michael
ipv4-family 
route-distinguisher 100:1
vpn-target 100:308 export-extcommunity
vpn-target 100:110 import-extcommunity
q
int s1/0/0
ip binding vpn-instance michael
ip add 83.1.1.3 24
ospf en 109 a 0
ospf network-type p2p
q
ospf 109 vpn-instance michael
a 0
q
import-route bgp
bgp 100
ipv4-family vpn-instance michael
import-route ospf 109
q
ipv4-family vpnv4
peer 11.1.1.1 enable
# R1
bgp 100
ipv4-family vpnv4
peer 33.1.1.1 enable
# R4
ospf 109
domain-id 1
# R3
ospf 109
domain-id 1

# 查看
# R3
dis ip rou vpn-instance michael pro ospf    # 此时没有ospf的路由
dis ospf 109 lsdb # 110.1.1.1的路由时三类LSA
# 关闭down bit 检测
# R3
ospf 109
vpn-instance-capability simple
# 然后再在R3上进行查看
dis ip rou vpn-instance michael pro ospf    # 此时有多条ospf的路由
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验九在r1和r4之间部署-sham-link&#34;&gt;实验九：在R1和R4之间部署 sham-link&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
undo ospf 109
ospf 901 vpn-instance michael
a 0
import-route bgp
domain-id 0.0.0.1
q
ip vpn-instance michael 
vpn-target 100:308 import-extcommunity
# R3
ospf 109
undo vpn-instance-capability
# R8
int g0/0/2
ip addr 108.1.1.8 24
ospf network-tyoe p2p
ospf enable 109 area 0
# R10
int g0/0/2
ip addr 108.1.1.10 24
ospf network-tyoe p2p
ospf enable 109 area 0

# 配置sham-link
# R1
int lo 6
ip binding vpn-instance michael
ip addr 11.11.11.11 32
bgp 100
ipv4-family vpn-instance michael
network 11.11.11.11 32
# R4
int lo 6
ip binding vpn-instance michael
ip addr 44.44.44.44 32
bgp 100
ipv4-family vpn-instance michael
network 44.44.44.44 32
# 查看是否通信，然后继续配置
# R4
dis ip rou vpn-instance michael
ping -vpn-instance michael -a 44.44.44.44 11.11.11.11
tracert -vpn-instance michael -a 44.44.44.44 11.11.11.11
# R4
ospf 109
area 0
sham-link 44.44.44.44 11.11.11.11
# R1
ospf 901
area 0
sham-link 11.11.11.11 44.44.44.44
# 此时sham-link与串口链路同时存在，各自独立，串口链路下的三类LSA仍然存在，如果想去掉三类LSA，则需要在R1和R4上去掉bgp进入ospf的重发布，此时只有sham-link工作
# R1
# ospf 901
# undo import-route bgp
# R4
# ospf 109
# undo import-route bgp

# 查看路由情况
# R8
int g0/0/2 
ospf cost 100
# R10
int g0/0/2 
ospf cost 100
dis ip rou pro ospf # 此时ospf路由都走R1方向
# R9
int lo 1
ip add 99.99.99.99 32
ospf enable 109 a 0
# R9更新路由之后再在R10上进行查看
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十配置路由反射器本实验是下一个实验的预配置&#34;&gt;实验十：配置路由反射器（本实验是下一个实验的预配置）&lt;/h2&gt;
&lt;p&gt;R2作为反射器&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 首先需要断开R8与R9、R10的连接
# R8
int g0/0/1
shutdown
int g0/0/2
shutdown

# 开始配置R2为路由反射器
# R1：PE
bgp 100
undo peer 33.1.1.1
undo peer 44.1.1.1
ipv4-family vpnv4 
peer 22.1.1.1 enable
# R3：PE
bgp 100
undo peer 11.1.1.1
undo peer 44.1.1.1
ipv4-family vpnv4 
peer 22.1.1.1 enable
# R4：PE
bgp 100
undo peer 33.1.1.1
undo peer 11.1.1.1
ipv4-family vpnv4 
peer 22.1.1.1 enable
# R2：反射器
bgp 100
ipv4-family vpnv4 
peer 11.1.1.1 enable
peer 11.1.1.1 reflect-client
peer 33.1.1.1 enable
peer 33.1.1.1 reflect-client
peer 44.1.1.1 enable
peer 44.1.1.1 reflect-client
undo policy vpn-target   # 放行路由
# 查看路由
# R2
dis bgp vpnv4 all rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十一使用vrf-lite将用户接入mpls-vpnhub-spoke&#34;&gt;实验十一：使用VRF-LITE将用户接入MPLS VPN（hub-spoke）&lt;/h2&gt;
&lt;h3 id=&#34;实验内容&#34;&gt;实验内容&lt;/h3&gt;
&lt;p&gt;R10与R1 建立两个OSPF邻居关系&lt;br&gt;
R10上不做vrf，R1做两个vrf实例&lt;br&gt;
构建一个hub-spoke结构的IP路由网络&lt;br&gt;
数据转发路径为 site-a（R8） -- hub（R10） -- site-b（R9）&lt;br&gt;
R1上两个vrf：一个负责收取来自spoke站点的路由，传递给hub；一个负责收取来自hub的路由，传递给spoke。&lt;/p&gt;
&lt;h3 id=&#34;重点&#34;&gt;重点&lt;/h3&gt;
&lt;p&gt;在中心场点OSPF下发默认路由&lt;br&gt;
中心场点PE加参数，将OSPF默认路由导入VPNv4&lt;br&gt;
分支站点PE通过OSPF将BGP默认路由通告给CE&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
ospf 901
import-route bgp
a 0
undo sham-link 11.11.11.11 44.44.44.44
# R4
ospf 109
import-route bgp
a 0
undo sham-link 44.44.44.44 11.11.11.11 
# 此时R8（88.1.1.1）与R9（99.1.1.1）上没有对方的路由，但是R10（110.1.1.1）的路由再R8与R9上都有。即两个spoke站点（R8/9）不能互通，但是可与中心站点（R10）互通

# R10：为了让R8与R9能够通信（但是数据必须经过R10），需要下放一条默认路由
undo ospf 901
ospf 109
default-route-advertise always
# R1：查看下发的默认路由：dis ip rou vpn-instance micheal
# 此时OSPF下放的默认路由，但是此条路由无法引入BGP
# R1
bgp 100
ipv4-family vpn-instance michael
undo network 11.11.11.11 32
default-route imported   # 将ospf的默认路由也引入进来
dis bgp vpnv4 all rou
# R3：查看路由，但是此时bgp的默认路由无法进行ospf
dis bgp vpnv4 all rou
ospf 109
default-route-advertise
# R9/8：此时R9/8上有默认路由，但是能给对方发数据，无法收到对方的回应数据
dis ip rou
# R4
ospf 109
default-route-advertise
# R9/8：此时能够进行通信
# R9
ping -a 99.1.1.1 88.1.1.1
tracert -a 99.1.1.1 88.1.1.1   # 10.1.49.4--&amp;gt;10.1.34.3--&amp;gt;10.1.23.2--&amp;gt;10.1.12.2--&amp;gt;83.1.1.3--&amp;gt;83.1.1.8
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十二bgp接入mpls-vpn&#34;&gt;实验十二：BGP接入MPLS VPN&lt;/h2&gt;
&lt;p&gt;规划AS号码 ，假设使用的AS不分公有私有&lt;br&gt;
R10 AS1000，R8 AS1008，R9 AS1009&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 删除OSPF 
# R1
undo ospf 901
# R3/4/8/9/10
undo ospf 109
# R10
int lo 0
undo ospf enable 109 area 0
int g2/0/0
undo ospf enable 109 area 0  # 目前ospf已经undo了，关于接口下的ospf使能已经失效，可以不删除
# R9
int g0/0/0
ip addr 49.1.1.9 24
undo ospf en 109 a 0
# R4
int g0/0/0
ip addr 49.1.1.4 24
undo ospf en 109 a 0

# 删除下放的默认路由和引入的路由
# R1
bgp 100
ipv4-family vpn-instance michael
undo default-route imported
undo import-route ospf 901
# R3
bgp 100
ipv4-family vpn-instance michael
undo import-route ospf 109
# R4
bgp 100
undo ipv4-family vpn-instance michael
ipv4-family vpn-instance michael

# BGP接入MPLS VPN
# CE端做正常的BGP配置
# R10
bgp 1000
peer 10.1.110.1 as-number 100
network 110.1.1.1 32
# R9
bgp 1009
peer 49.1.1.4 as-number 100
network 99.1.1.1 32
# R9
bgp 1008
peer 83.1.1.3 as-number 100
network 88.1.1.1 32
# PE端，在vrf地址族下针对CE做BGP对等体
# R1
bgp 100
ipv4-family vpn-instance michael
peer 10.1.110.10 as-number 1000 
# R4
bgp 100
ipv4-family vpn-instance michael
peer 49.1.1.9 as-number 1009
# R3
bgp 100
ipv4-family vpn-instance michael
peer 83.1.1.8 as-number 1008

# 测试
# R1/4/3
ping -vpn-instance michael 10.1.110.10
dis bgp vpnv4 all rou
dis bgp vpnv4 all peer
# 查看hub点R10的路由
dis ip rou pro bgp  # 可以收到来自R8和R9的两条路由88.1.1.1和99.1.1.1，但是分支站点R8/R9上只有总部路由110.1.1.1，没有分支站点之间的路由

# R10：总部针对邻居下发默认路由
bgp 100
peer 10.1.110.1 default-route-advertise
# R1：在邻居上查看相应默认路由
dis bgp vpnv4 all rou
# R8/9：查看远端的收到的下发的默认路由
dis ip rou
ping -a 88.1.1.1 99.1.1.1
tracert -a 88.1.1.1 99.1.1.1 # R8上：83.1.1.3--10.1.23.2--***--10.1.12.2--10.1.23.3--49.1.1.4--49.1.1.9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十三如果不采用默认路由的方式如何传递明细路由呢bgp接入mpls-vpn&#34;&gt;实验十三：如果不采用默认路由的方式，如何传递明细路由呢？（BGP接入MPLS VPN）&lt;/h2&gt;
&lt;h3 id=&#34;场景一&#34;&gt;场景一：&lt;/h3&gt;
&lt;p&gt;客户使用hub-spoke架构网络，并要求传递明细路由&lt;br&gt;
解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;中心场点的PE修改eBGP防环&lt;/li&gt;
&lt;li&gt;中心场点PE通过多vrf区分传出和传入的路由
&lt;ol&gt;
&lt;li&gt;HUB--数据去往中心站点&lt;/li&gt;
&lt;li&gt;Spoke--数据去往分支站点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;中心场点PE通过不同RD区分传出和传入的路由，以使得VPNv4的RR能够同时保存传出和传入的路由&lt;/li&gt;
&lt;li&gt;通过RT控制传出的路由和传入的路由的更新方向&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;场景二&#34;&gt;场景二：&lt;/h3&gt;
&lt;p&gt;客户所有站点使用相同AS： 针对CE设备操作，将所有AS路径上的AS号码修改为本地AS号码&lt;br&gt;
解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;完成BGP配置&lt;/li&gt;
&lt;li&gt;HUB点PE针对从hub收取路由的vrf实例下BGP peer allowas-in&lt;/li&gt;
&lt;li&gt;针对所有站点做as-override，即将as-path中的所有AS号码替换为本地AS号码&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;场景三&#34;&gt;场景三：&lt;/h3&gt;
&lt;p&gt;多宿主站点接入MPLS VPN（SoO一般配置在PE设备上）&lt;/p&gt;
&lt;h3 id=&#34;场景四&#34;&gt;场景四：&lt;/h3&gt;
&lt;p&gt;vrf实例下的额外路由操控策略&lt;br&gt;
解决方法：&lt;br&gt;
RT用于在PE设备之间控制路由的更新&lt;br&gt;
vrf实例下，可以增加额外的策略，用做辅助手段来控制vrf实例的路由表（入），或者出自本vrf实例的VPNv4路由的RT&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R10
bgp 1000
undo peer 10.1.110.1 default-route-advertise
q
int s1/0/1
ip addr 10.1.111.10 24

# 1. 完成BGP配置
# R1
int g0/0/2
undo ospf en 901 a 0
undo ospf network-type
q
undo ip vpn-instance michael
ip vpn-instance HUB
route-distinguisher 100:10
q
q
ip vpn-instance SPOKE
route-distinguisher 100:20
int g2/0/0
ip binding vpn-instance HUB
ip address 10.1.110.1 24
int s1/0/1
ip binding vpn-instance SPOKE
ip address 10.1.111.1 24
q
bgp 100
ipv4-family vpn-instance HUB
peer 10.1.110.10 as-number 1000
ipv4-family vpn-instance SPOKE
peer 10.1.111.10 as-number 1000
# R10
bgp 1000
peer 10.1.111.1 as-number 100
# R3
bgp 100
ipv4-family vpn-instance michael
undo peer 83.1.1.8 
peer 83.1.1.8 as-number 1000
# R4
bgp 100
ipv4-family vpn-instance michael
undo peer 49.1.1.9
peer 49.1.1.9 as-number 1000
# R8
undo bgp 1008
bgp 1000
network 88.1.1.1 32
peer 83.1.1.3 as-number 100
# R9
undo bgp 1009
bgp 1000
network 99.1.1.1 32
peer 49.1.1.4 as-number 100
# 查看路由
#R2/1
dis bgp vpnv4 all rou # 路由反射器R1上有全部路由，但R1上没有分支站点路由


# 2. 针对所有站点做as-override
# R1
ip vpn-instance HUB
vpn-target 100:308 import-extcommunity
vpn-target 100:409 import-extcommunity
q
dis bgp vpnv4 all rou  # 此时有R8/9的路由，但因为bgp防环的原因，此时路由无法传递给hub
bgp 100
ipv4 vpn-instance HUB
peer 10.1.110.10 substitute-as  # 将as-path中的所有AS号码替换为本地AS号码，即重写as号

# 3. HUB点PE针对从hub收取路由的vrf实例下BGP peer allowas-in
# R1
bgp 100
ipv4 vpn-instance SPOKE
peer 10.1.111.10 allow-as-loop 2 
# 查看路由
# R1/2/3
dis bgp vpnv4 all rou  # R3上没有R9的路由，下一步需要做RT
# R1
ip vpn-instance SPOKE
vpn-target 100:110 export-extcommunity  # 此时再看R3/4，均有R8和R9的路由
# R4
ipv4-family vpn-instance michael
peer 49.1.1.9 substitute-as
# R3
ipv4-family vpn-instance michael
peer 83.1.1.8 substitute-as

# 查看路由
# R8/9
dis bgp rou  # 此时能收到所有的路由
tracert -a 88.1.1.1 99.1.1.1 # 83.1.1.3-10.1.23.2-10.1.111.1-10.1.111.10-10.1.110.1-10.1.12.2-10.1.23.3-49.1.1.4-49.1.1.9
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十四vrf下的路由操控上个实现的场景三&#34;&gt;实验十四：VRF下的路由操控（上个实现的场景三）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置SoO
# R3
bgp 100
ipv4-family vpn-instance michael
peer 83.1.1.8 soo 123:123
&lt;/code&gt;&lt;/pre&gt;
">HCIE-MPLS专题(2020.08.015，第4专题)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-multicast-zhuan-ti-20200804/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#ip%E7%BB%84%E6%92%AD%E5%9F%BA%E7%A1%80&#34;&gt;IP组播基础&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%BF%B0&#34;&gt;概述&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%8A%BF&#34;&gt;优势&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A3%E5%8A%BF&#34;&gt;劣势&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8&#34;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84&#34;&gt;组播地址结构&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADip%E5%9C%B0%E5%9D%80&#34;&gt;组播IP地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADip%E6%A8%A1%E5%9E%8B%E5%88%86%E7%B1%BB&#34;&gt;组播IP模型分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADip%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB&#34;&gt;组播IP地址分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%ADmac%E5%9C%B0%E5%9D%80&#34;&gt;组播MAC地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ip%E5%9C%B0%E5%9D%80%E5%88%B0mac%E5%9C%B0%E5%9D%80%E7%9A%84%E6%98%A0%E5%B0%84&#34;&gt;IP地址到MAC地址的映射&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%98%A0%E5%B0%84%E5%AF%BC%E8%87%B4%E7%9A%84%E9%97%AE%E9%A2%98&#34;&gt;映射导致的问题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&#34;&gt;组播基本原理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE&#34;&gt;组播相关协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E5%88%86%E5%8F%91%E6%A0%91%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B&#34;&gt;组播分发树的两个基本类型&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%BA%90%E8%B7%AF%E5%BE%84%E6%A0%91spt&#34;&gt;源路径树SPT&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B1%E4%BA%AB%E6%A0%91rpt&#34;&gt;共享树RPT&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91&#34;&gt;组播数据转发&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%8D%E5%90%91%E8%B7%AF%E5%BE%84%E8%BD%AC%E5%8F%91rpf&#34;&gt;反向路径转发RPF&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%8E%E4%B8%BArpf%E6%A3%80%E6%9F%A5%E8%BF%87%E7%A8%8B&#34;&gt;华为RPF检查过程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E6%9D%A1%E7%90%86%E6%B8%85%E6%99%B0&#34;&gt;面试回答（条理清晰）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE&#34;&gt;相关协议&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#igmp-%E4%BA%92%E8%81%94%E7%BD%91%E7%BB%84%E7%AE%A1%E7%90%86%E5%8D%8F%E8%AE%AE&#34;&gt;IGMP 互联网组管理协议&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#v1&#34;&gt;v1&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5%E8%BF%87%E7%A8%8B&#34;&gt;组成员加入过程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%93%8D%E5%BA%94&#34;&gt;组播路由器的查询与响应&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%93%8D%E5%BA%94%E6%8A%91%E5%88%B6%E6%9C%BA%E5%88%B6&#34;&gt;响应抑制机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E7%A6%BB%E5%BC%80&#34;&gt;组成员离开&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BE%E4%BE%8B&#34;&gt;举例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v2&#34;&gt;v2&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F-2&#34;&gt;报文格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5&#34;&gt;组成员加入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E8%AF%A2%E4%B8%8E%E5%93%8D%E5%BA%94&#34;&gt;查询与响应&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E8%AF%A2%E5%99%A8%E9%80%89%E4%B8%BE&#34;&gt;查询器选举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90%E5%91%98%E7%A6%BB%E5%BC%80-2&#34;&gt;组成员离开&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v1%E5%92%8Cv2%E7%9A%84%E4%BA%92%E6%93%8D%E4%BD%9C%E6%80%A7&#34;&gt;v1和v2的互操作性&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#v2%E4%B8%BB%E6%9C%BA%E4%B8%8Ev1%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;v2主机与v1路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v1%E4%B8%BB%E6%9C%BA%E4%B8%8Ev2%E8%B7%AF%E7%94%B1%E5%99%A8&#34;&gt;v1主机与v2路由器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B7%B7%E5%90%88%E7%89%88%E6%9C%AC&#34;&gt;混合版本&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#v3&#34;&gt;v3&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6&#34;&gt;工作机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%94%B9%E8%BF%9B%E4%B9%8B%E5%A4%84&#34;&gt;改进之处&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#igmp%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E6%AF%94%E8%BE%83&#34;&gt;IGMP三个版本的比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim%E5%8D%8F%E8%AE%AE%E6%97%A0%E5%85%B3%E7%BB%84%E6%92%AD&#34;&gt;PIM（协议无关组播）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#pimv2%E6%8A%A5%E6%96%87%E5%A4%B4%E6%A0%BC%E5%BC%8F&#34;&gt;PIMv2报文头格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim-dmdense_mode%E5%AF%86%E9%9B%86%E6%A8%A1%E5%BC%8F&#34;&gt;PIM-DM（Dense_mode，密集模式）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A6%82%E8%BF%B0-2&#34;&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%A5%E6%96%87&#34;&gt;报文&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hello%E6%8A%A5%E6%96%87&#34;&gt;Hello报文&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AF%84%E4%BB%B7&#34;&gt;总结与评价&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim-sm&#34;&gt;PIM-SM&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0&#34;&gt;基本概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E6%8E%A5%E6%94%B6%E8%80%85%E4%BE%A7dr%E4%B8%8E%E7%BB%84%E6%92%AD%E6%BA%90%E4%BE%A7dr&#34;&gt;组播接收者侧DR与组播源侧DR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#g%E4%B8%8Esg%E6%9D%A1%E7%9B%AE%E5%85%B3%E7%B3%BB&#34;&gt;（*，G）与（S，G）条目关系&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#pim-sm%E5%8D%8F%E8%AE%AE%E6%9C%BA%E5%88%B6&#34;&gt;PIM-SM协议机制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rp&#34;&gt;RP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rp%E5%8F%91%E7%8E%B0&#34;&gt;RP发现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rp%E9%80%89%E4%B8%BE%E5%8E%9F%E5%88%99&#34;&gt;RP选举原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A8%E6%80%81rpauto-rp&#34;&gt;动态RP（Auto-RP）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%87%AA%E4%B8%BE%E8%B7%AF%E7%94%B1%E5%99%A8bsr-bootstrap-router&#34;&gt;自举路由器BSR (BootStrap Router)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%80%89%E4%B8%BE%E8%A7%84%E5%88%99&#34;&gt;选举规则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B&#34;&gt;工作流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rp%E4%B8%8Ebsr%E7%9A%84%E5%85%B3%E7%B3%BB&#34;&gt;RP与BSR的关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E6%92%AD%E6%B3%A8%E5%86%8C&#34;&gt;单播注册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%BB%E4%BD%93%E8%AF%84%E4%BB%B7&#34;&gt;总体评价&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ssm%E4%B8%8Easm%E6%A8%A1%E5%9E%8B%E6%AF%94%E8%BE%83&#34;&gt;SSM与ASM模型比较&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#msdp%E5%92%8Canycastrp&#34;&gt;MSDP和AnycastRP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%BB%E6%84%8F%E6%92%AD&#34;&gt;任意播&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#msdp%E5%AF%B9%E7%AD%89%E4%BD%93%E5%BB%BA%E7%AB%8B&#34;&gt;MSDP对等体建立&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%92%AD%E6%BA%90%E4%BF%A1%E6%81%AF%E5%9C%A8%E5%9F%9F%E9%97%B4%E7%9A%84%E4%BC%A0%E9%80%92&#34;&gt;组播源信息在域间的传递&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C&#34;&gt;实验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%80igmpv1&#34;&gt;实验一：IGMPv1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8Cigmpv1%E6%9F%A5%E8%AF%A2%E5%99%A8%E9%80%89%E4%B8%BEpim%E5%8D%8F%E8%AE%AE&#34;&gt;实验二：IGMPv1查询器选举（PIM协议）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%89igmpv2&#34;&gt;实验三：IGMPv2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%9B%9Bigmpv3&#34;&gt;实验四：IGMPv3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%94%E9%85%8D%E7%BD%AEpim-dm&#34;&gt;实验五：配置PIM-DM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%85%ADpim-sm&#34;&gt;实验六：PIM-SM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%83bsr&#34;&gt;实验七：BSR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%85%AB%E7%BB%93%E5%90%88msdp%E5%8F%8A%E4%BB%BB%E6%84%8F%E6%92%AD%E5%8E%9F%E7%90%86%E5%AE%9E%E7%8E%B0anycast-rp&#34;&gt;实验八：结合MSDP及任意播原理实现Anycast-RP&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596550033528.png&#34; alt=&#34;组播内容&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DM：密集模式&lt;br&gt;
SM：稀疏模式&lt;br&gt;
ASM：任意源组播&lt;br&gt;
SSM：指定源组播&lt;/p&gt;
&lt;h1 id=&#34;ip组播基础&#34;&gt;IP组播基础&lt;/h1&gt;
&lt;p&gt;二层组播协议：STP、VTP、CDP、LLDP、DTP、EC、ISIS等&lt;br&gt;
三层组播协议：OSPF（224.0.0.5和224.0.0.6）、EIGRP（224.0.0.10）、VRRP（224.0.0.18）、RSVP（224.0.0.14）、IGMPv3（224.0.0.22）、dhcp（224.0.0.12）、RIPv2（224.0.0.9）等&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单播、组播、广播的区别：IP组播可以将相同的数据流分发到位于&lt;strong&gt;不同广播域中的不同主机&lt;/strong&gt;上&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;组播的出现，主要解决了网络中用户数量不确定的问题。&lt;br&gt;
IP组播技术实现了IP网络中点到多点的高效数据传送，能够有效地节约网络带宽、降低网络负载，在实时数据传送、多媒体会议、数据拷贝、游戏和仿真等诸多方面都有广泛的应用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单播&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596605504981.png&#34; alt=&#34;单播&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;广播&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596605517957.png&#34; alt=&#34;广播&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;组播&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596605531347.png&#34; alt=&#34;组播&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;组播组：用IP组播地址进行标识的一个集合。任何用户主机（或其他接收设备），加入一个组播组，就成为了该组成员，可以识别并接收发往该组播组的组播数据。&lt;/li&gt;
&lt;li&gt;组播源：信息的发送者称为“组播源”。一个组播源可以同时向多个组播组发送数据，多个组播源也可以同时向一个组播组发送报文。组播源通常不需要加入组播组。&lt;/li&gt;
&lt;li&gt;组播组成员：所有加入某组播组的主机便成为该组播组的成员。组播组中的成员是动态的，主机可以在任何时刻加入或离开组播组。组播组成员可以广泛地分布在网络中的任何地方。&lt;/li&gt;
&lt;li&gt;组播路由器：支持三层组播功能的路由器或交换机。组播路由器不仅能够提供组播路由功能，也能够在与用户连接的末梢网段上提供组播组成员的管理功能。&lt;/li&gt;
&lt;li&gt;叶路由器：组播网络边缘，直接面对接收者的路由器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;h3 id=&#34;优势&#34;&gt;优势&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;提高效率：降低网络流量、减轻硬件负荷&lt;/li&gt;
&lt;li&gt;优化性能：减少冗余流量、节约网络带宽、降低网络负载&lt;/li&gt;
&lt;li&gt;分布式应用：使多点应用成为可能&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;劣势&#34;&gt;劣势&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;组播是基于UDP的&lt;/li&gt;
&lt;li&gt;尽力而为&lt;/li&gt;
&lt;li&gt;没有拥塞避免机制&lt;/li&gt;
&lt;li&gt;报文重复&lt;/li&gt;
&lt;li&gt;报文失序&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;应用&#34;&gt;应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;多媒体&lt;/li&gt;
&lt;li&gt;培训、联合作业场合的通信&lt;/li&gt;
&lt;li&gt;数据仓库、金融应用（股票）&lt;/li&gt;
&lt;li&gt;任何的“单到多”数据发布应用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;组播地址结构&#34;&gt;组播地址结构&lt;/h2&gt;
&lt;h3 id=&#34;组播ip地址&#34;&gt;组播IP地址&lt;/h3&gt;
&lt;p&gt;一个组播组就是一个IP地址，不表示具体的主机，而是表示一系列系统的集合，主机加入某个组播组&lt;br&gt;
即声明自己接收目的为某个IP地址的报文&lt;br&gt;
IP组播组地址&lt;strong&gt;224.0.0.0–239.255.255.255&lt;/strong&gt;，“D”类地址空间，&lt;strong&gt;第一个字节的高四位&lt;/strong&gt;为“&lt;strong&gt;1110&lt;/strong&gt;”&lt;/p&gt;
&lt;h3 id=&#34;组播ip模型分类&#34;&gt;组播IP模型分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ASM（Any-Source Multicast）任意组播源&lt;br&gt;
ASM模型就是任意源组播模型。在该模型中，任意发送者都可以成为组播源，向某组播组地址发送信息。众多接收者通过加入由该地址标识的主机组，从而接收到发往该组播组的所有信息。在ASM模型中，接收者无法预知组播源的地址，接收者可以在任意时间加入或者离开该主机组。&lt;/li&gt;
&lt;li&gt;SFM（Source-Filtered Multicast）&lt;br&gt;
SFM模型继承了ASME模型，从发送者角度来看，组播组成员关系完全相同。SFM在功能上对ASM进行了扩展：上层软件对接收到的组播报文的源地址进行检查，允许或禁止来自某些组播源的报文通过。最终，接收者只能接收来自部分组播源的数据。从接收者角度来看，只有部分组播源是有效的，组播源经过了筛选。&lt;/li&gt;
&lt;li&gt;SSM（Source-Specific Multicast）指定源组播&lt;br&gt;
SSM模型针对特定源和组的绑定数据流提供服务，接收者主机在加入组播组时，可以指定只接收哪些源的数据。加入组播组以后，主机只会收到指定源发送到该组的数据。SSM模型对组地址不再要求全网唯一，只需要每个组播源保持唯一。这里的“唯一”指的是同一个源上不同的组播应用必须使用不同的SSM地址来区分。不同的源之间可以使用相同的组地址，因为SSM模型中针对每一个（源，组）信息都会生成表项。这样一方面节省了组播组地址，另一方面也不会造成网络拥塞&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;组播ip地址分类&#34;&gt;组播IP地址分类&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;永久组地址&lt;br&gt;
IANA为路由协议预留的组播地址，用于标识一组特定的网络设备（也称为保留组播组）。例如：224.0.0.5是OSPF路由器。永久组地址保持不变，组成员的数量可以是任意的，甚至可以为零。&lt;/li&gt;
&lt;li&gt;临时组地址&lt;br&gt;
为用户组播组临时分配的IP地址，组成员的数量一旦为零，即取消。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596607503545.png&#34; alt=&#34;组播IP地址分类&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;常见的永久组地址列表&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597066331855.png&#34; alt=&#34;常见的永久组地址列表&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
专用地址（224.0.0.0-224.0.0.255）用于网络协议组的广播；公用地址（224.0.1.0-238.255.255.255）用于全球网络组播；私用地址（239.0.0.0-239.255.255.255）用于本地测试、局域网使用。   ASM（任意源组播）地址为（224.0.1.0-231.255.255.255、33.0.0.0.0-238.255.255.255.255）；SSM（指定源组播）地址为（232.0.0.0.0-232.255.255.255.255)，全网用在IPv6协议中，第一个字节必须是0xFF。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;组播mac地址&#34;&gt;组播MAC地址&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596607753123.png&#34; alt=&#34;组播MAC地址&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IANA规定，&lt;strong&gt;组播MAC地址的高24bit为0x01005e，第25bit固定为0&lt;/strong&gt;，低23bit为组播IP地址的低23bit。就以太网而言，IP组播帧都使用以0x0100.5Exx.xxxx的24位前缀开始的MAC层地址。&lt;/p&gt;
&lt;h3 id=&#34;ip地址到mac地址的映射&#34;&gt;IP地址到MAC地址的映射&lt;/h3&gt;
&lt;p&gt;需要将组播IP地址映射到组播MAC地址。组播MAC地址的高24bit为0x01005e，MAC地址的低23bit为组播IP地址的低23b。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596608065677.png&#34; alt=&#34;IP地址到MAC地址的映射&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;映射导致的问题&#34;&gt;映射导致的问题&lt;/h4&gt;
&lt;p&gt;存在当第3层IP地址映射成第2层MAC地址时导致32:1的地址不明确问题&lt;sub&gt;（原因：第25bit固定为0，IP地址32bit，只映射后23bit）&lt;/sub&gt;，如下图：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596608304089.png&#34; alt=&#34;映射导致的问题&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因此在规划组播网络的时候，为防止出现相同的组播MAC，需要组播IP的后23bit不相同。&lt;/p&gt;
&lt;h2 id=&#34;组播基本原理&#34;&gt;组播基本原理&lt;/h2&gt;
&lt;h3 id=&#34;组播相关协议&#34;&gt;组播相关协议&lt;/h3&gt;
&lt;p&gt;组播协议包括用于主机注册的组播组管理协议，和用于组播选路转发的组播路由协议。组播相关协议有IGMP、PIM、MSDP、MBGP&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596609093773.png&#34; alt=&#34;组播相关协议&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IGMP&lt;br&gt;
在&lt;strong&gt;接收者与叶路由器之间交互&lt;/strong&gt;的一个协议，帮助叶路由器确定该接口下是否还有需要组播流的接收者。IGMP协议在主机端实现组播组成员加入与离开，在上游的三层设备中实现组成员关系的维护与管理，同时支持与上层组播路由协议的信息交互。&lt;/li&gt;
&lt;li&gt;PIM&lt;br&gt;
协议无关组播。无关乎单播协议是什么，也无关乎组播路由协议是什么。在组播路由器之间建立PIM的邻居关系，能够根据规则产生组播路由表。用于&lt;strong&gt;组播路由器之间&lt;/strong&gt;。PIM协议包括&lt;strong&gt;PIM-SM（稀疏模式）和PIM-DM（密集模式）&lt;/strong&gt;。PIM-SM适合规模较大、组成员相对比较分散的网络；PIM-DM适合规模较小、组播组成员相对比较集中的网络。在PIM-DM模式下不需要区分ASM模型和SSM模型。在PIM-SM模式下根据数据和协议报文中的组播地址区分ASM模型和SSM模型：如果在SSM组播地址范围内，则按照PIM-SM在SSM中的实现流程进行处理。PIM-SSM不但效率高，而且简化了组播地址分配流程，特别适用于对于特定组只有一个特定源的情况。如果在ASM组播地址范围内，则按照PIM-SM在ASM中的实现流程进行处理。&lt;/li&gt;
&lt;li&gt;MSDP&lt;br&gt;
MSDP是为了解决多个PIM-SM域之间的互连的一种域间组播协议，用来发现其他PIM-SM域内的组播源信息，远端域内的活动信源信息传递给本地域内的接收者，从而实现组播报文的跨域转发。只有PIM-SM使用ASM模型时，才需要使用MSDP。&lt;/li&gt;
&lt;li&gt;MBGP&lt;br&gt;
实现了跨AS域的组播转发。适用于组播源与组播接收者在不同AS域的场景。&lt;/li&gt;
&lt;li&gt;IGMP Snooping &amp;amp; IGMP Snooping Proxy&lt;br&gt;
IGMP Snooping功能可以使交换机工作在二层时，通过侦听上游的三层设备和用户主机之间发送的IGMP报文来建立组播数据报文的二层转发表，管理和控制组播数据报文的转发，进而有效抑制组播数据在二层网络中扩散。&lt;br&gt;
IGMP Snooping Proxy功能在IGMP Snooping的基础上使交换机代替上游三层设备向下游主机发送IGMP Query报文和代替下游主机向上游设备发送IGMP Report和Leave报文，这样能够有效的节约上游设备和本设备之间的带宽。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组播分发树的两个基本类型&#34;&gt;组播分发树的两个基本类型&lt;/h3&gt;
&lt;p&gt;用来描述IP组播报文在网络中经过的路径。&lt;/p&gt;
&lt;h4 id=&#34;源路径树spt&#34;&gt;源路径树SPT&lt;/h4&gt;
&lt;p&gt;以组播源作为树根，将组播源到每一个接收者的最短路径结合起来构成的转发树。&lt;br&gt;
每一个组播源与接收者之间建立一棵独立的SPT&lt;br&gt;
&lt;code&gt;这个机制的作用是实现组播流量的最优转发路径&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596610760187.png&#34; alt=&#34;源路径树&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;特点&lt;/strong&gt;：路径最优，延迟最小，占用内存较多&lt;/p&gt;
&lt;h4 id=&#34;共享树rpt&#34;&gt;共享树RPT&lt;/h4&gt;
&lt;p&gt;使用放在网络的某些节点的单独的公用根。根据组播路由协议，这个根常被称为汇合点（RP）或核心，因此，共享树也可以称为RPT。&lt;br&gt;
对应某个组，网络中只有一棵树&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596611226847.png&#34; alt=&#34;共享树&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;特点&lt;/strong&gt;：路径不是最优的，引入额外的延迟，占用内存较少（单个表项）&lt;/p&gt;
&lt;h2 id=&#34;组播数据转发&#34;&gt;组播数据转发&lt;/h2&gt;
&lt;p&gt;组播路由和单播路由是相反的，单播路由关心数据报文要到哪里去，组播路由关心数据报文从哪里来（防环）。组播路由使用 “反向路径转发”机制(RPF, Reverse Path Forwarding)&lt;/p&gt;
&lt;h3 id=&#34;反向路径转发rpf&#34;&gt;反向路径转发RPF&lt;/h3&gt;
&lt;p&gt;路由器收到组播数据报文后，只有确认这个数据报文是&lt;strong&gt;从自身连接到组播源的接口上收到的，才进行转发&lt;/strong&gt;，否则丢弃。&lt;br&gt;
&lt;code&gt;这个机制的作用是防止组播流量转发环路&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;RPF检查&lt;/strong&gt;：在&lt;strong&gt;单播路由表中&lt;/strong&gt;查找到&lt;strong&gt;组播报文源地址的路由&lt;/strong&gt;，如果&lt;strong&gt;该路由的出接口&lt;/strong&gt;就是&lt;strong&gt;组播报文的入接口&lt;/strong&gt;【即确保组播流的入接口是单播路由的出接口】，RPF检查成功；否则RPF检查失败，报文丢弃&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RPF举例&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596613155173.png&#34; alt=&#34;RPF举例&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;组播转发RPF举例&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596613223608.png&#34; alt=&#34;组播转发RPF举例1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596613270842.png&#34; alt=&#34;组播转发RPF举例2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;华为rpf检查过程&#34;&gt;华为RPF检查过程&lt;/h4&gt;
&lt;p&gt;除单播路由外，MBGP路由、组播静态路由也是RPF检查的依据。当路由器收到一份组播报文之后，如果这三种路由表都存在，具体检查过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先，通过报文源地址，分别从单播路由表、MBGP路由表和组播静态路由表中各选出一条最优路由。单播路由、MBGP路由的出借口为RPF接口，下一条为RPF邻居。需要注意的是，组播静态路由实际上属于手工配置的组播路由，已经明确制订了RPF接口与RPF邻居&lt;/li&gt;
&lt;li&gt;然后，根据以下原则从这三条最优路由中选择一条作为RPF路由
&lt;ol&gt;
&lt;li&gt;如果配置了按照最长匹配选择路由
&lt;ol&gt;
&lt;li&gt;从这三条路由中选出最长匹配的那条路由&lt;/li&gt;
&lt;li&gt;如果这三条路由的掩码一样，则选择优先级最高的那条路由&lt;/li&gt;
&lt;li&gt;如果优先级也相同（即手工修改了协议优先级），则按照组播静态路由&amp;gt;MBGP路由&amp;gt;单播路由的顺序进行选择&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果没有配置最长匹配选择路由
&lt;ol&gt;
&lt;li&gt;从者三条路由中选出优先级最高的那条路由（默认参考原则）&lt;/li&gt;
&lt;li&gt;如果优先级相同，则按照组播静态路由&amp;gt;MBGP路由&amp;gt;单播路由的顺序进行选择&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最后，路由器会将报文的入接口与RPF路由的RPF接口进行比较。如果一样则RPF检查通过，表明报文来源路径正确，会将其向下游转发；如果不一致即RPF检查失败，表明该报文来源路径错误，就将其丢弃。&lt;/li&gt;
&lt;li&gt;静态组播路由的优先级为1，BGP可以在不同地址族进行修改&lt;br&gt;
&lt;code&gt;【总结】：如果同时存在关于组播源地址的组播静态、组播BGP、单播路由，默认情况下，按照组播静态&amp;gt;组播BGP&amp;gt;单播路由的顺序进行选择&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;面试回答条理清晰&#34;&gt;面试回答（条理清晰）&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;默认情况下采用优先级选取路由来进行RPF检查&lt;/li&gt;
&lt;li&gt;如果配置了最长匹配选择路由，则从这三条路由中选出最长匹配的那条路由，命令为&lt;code&gt;multicast longest-match&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;如果前缀和掩码相同，则选取路由优先级最高的路由&lt;/li&gt;
&lt;li&gt;如果前缀、掩码、优先级都相同，按照组播静态路由、组播BGP路由、单播路由的顺序选择&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;RPF检查可以根据源地址或者是RP的地址进行检查&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;相关协议&#34;&gt;相关协议&lt;/h2&gt;
&lt;h3 id=&#34;igmp-互联网组管理协议&#34;&gt;IGMP 互联网组管理协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;运行在接收者与叶路由器之间，用于维护组播网络中叶路由器是否需要向特定接口转发组播流。三个版本 v1（RFC1112）、v2（RFC2236）、v3（RFC3376、4604）。v2比较常用，v1、v2、v3 均支持ASM，v3主要是针对SSM模型做有力支撑。&lt;/li&gt;
&lt;li&gt;IGMP协议是主机和路由器之间的协议。主机通过IGMP协议向组播路由器报告自己想加入的组；路由器通过IGMP协议查询网段山是否还有特定组的成员&lt;/li&gt;
&lt;li&gt;主机跟路由器之间的组控制协议对IPv6有连个版本：MLDv1和MLDv2&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;v1&#34;&gt;v1&lt;/h4&gt;
&lt;h5 id=&#34;报文格式&#34;&gt;报文格式&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596636710868.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Version：表示版本标识，版本1为1，版本2没有这个字段，在RFC988中说明，这个字段已经废弃&lt;/li&gt;
&lt;li&gt;Type：版本1只有成员关系查询（membership query，0x11）和成员关系报告（membership report，0x12），没有特定的组关系查询，也没有主机发送的离开报告&lt;/li&gt;
&lt;li&gt;组地址：当一个成员关系报告正被发送时，组地址字段包含组播地址；当用于成员关系查询时，本字段为0，并被主机忽略&lt;br&gt;
版本1不能设定响应时间，&lt;strong&gt;所有的响应时间都是默认的10秒&lt;/strong&gt;，这容易引起&lt;strong&gt;响应突发&lt;/strong&gt;。版本1成员离开的时候是默默离开的，不发送离开报告，这样离开延迟比较大，也不会引起特定的组查询，因此v1版本的路由器会&lt;strong&gt;周期性（60s）的查询&lt;/strong&gt;是否还有接收者。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;组成员加入过程&#34;&gt;组成员加入过程&lt;/h5&gt;
&lt;p&gt;当一个主机希望接收一个组播组的数据，则&lt;strong&gt;发送成员加入报告给组播组&lt;/strong&gt;，该报文中组地址为主机想加入的组播组的地址&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596638205183.png&#34; alt=&#34;组成员加入过程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;组播路由器的查询与响应&#34;&gt;组播路由器的查询与响应&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;IGMP查询器周期性的向共享网段内所有主机以组播方式（目的地址为224.0.0.1）发送成员关系查询消息（组地址为0）&lt;/li&gt;
&lt;li&gt;网络内所有主机都接收到该查询消息，如果某主机对某一组播组（比如，组播组G）感兴趣，则以组播方式发送“成员关系报告”报文（其中携带组播组G的地址）来宣告自己将加入该组播组，假设PC2首先发送此报告&lt;/li&gt;
&lt;li&gt;经过查询/响应过程后，IGMP路由器了解到本网络内存在组播组G对应的接收者，生成（*，G）【*表示任意组播源，G表示某个组播组】组播项并依据此作为组播信息的转发依据&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596639701738.png&#34; alt=&#34;组播路由器的查询&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IGMPv1规定，当共享网络中有多台路由器时，由组播路由协议选举查询器。不同的组播路由协议有不同的选举机制。&lt;strong&gt;IGMP查询器选举，由组播协议决定，如果是PIM协议，PIM的DR将做为查询器&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;224.0.0.1-代表所有的组播节点；224.0.0.2-代表所有的组播路由器&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;响应抑制机制&#34;&gt;响应抑制机制&lt;/h5&gt;
&lt;p&gt;IGMP成员关系查询报文的目的地址为224.0.0.1，就是说网段内所有的设备都会收到该查询报文。但并不是所有收到该报文的主机都会响应查询请求的。下图中只有一个主机会以成员关系报告报文响应，而其它主机则抑制成员关系报告的发送。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596639715421.png&#34; alt=&#34;响应&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
实际上主机收到IGMP成员关系查询时，会对它已经加入的每个组播组启动一个倒计数报告计时器。IGMPv1中计时器固定使用10s。计时器到时的主机则主动发送成员关系报告，组地址为该组播组地址，目的地址为224.0.0.1。于是网段内其他主机都会收到该成员关系报告报文，接收到成员关系报告报文的主机抑制成员关系报告的发送，并删除计时器。当路由器周期性的发送成员关系查询报文时，每个主机都会再次启动计时器进行查询\响应\抑制。&lt;/p&gt;
&lt;h5 id=&#34;组成员离开&#34;&gt;组成员离开&lt;/h5&gt;
&lt;p&gt;华为周期为130秒（思科默认为3个周期，即180s）&lt;br&gt;
成员悄悄离开组播组，不发送任何报文，&lt;strong&gt;路由器依旧周期性的发送成员关系查询报文，周期为60s&lt;/strong&gt;，当路由器发送3次成员关系查询报文都没欧收到响应的成员关系报告报文时，路由器认为组内已经没有成员，不再向该网段转发组播报文。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596639902390.png&#34; alt=&#34;组成员离开&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;举例&#34;&gt;举例&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596699712692.png&#34; alt=&#34;举例&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
主机加入组播组的基本过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IGMP 查询器（RouterB）周期性地向共享网段内所有主机以组播方式（目的地址为组播地址）发送普遍组Query 查询消息。该报文的目的地址为224.0.0.1，表示该网段上的所有主机和路由器。&lt;/li&gt;
&lt;li&gt;网段内所有主机都接收到该普遍组查询消息。如果主机（如HostB 和HostC）希望加入某组播组G1，则以组播方式发送Report 报告。该报文的目的地址为224.0.0.1，报文中携带组播组G1 的地址信息。&lt;/li&gt;
&lt;li&gt;网段中所有主机和路由器都接收到该Report 报告，并获知组播组G1 地址信息，此时网段中其它也希望加入该组播组G1 的主机将不再发送针对相同组播组的Report 报告。同时，网段中预备加入另一组播组G2 的主机发送针对组播组G2 的Report 报告以响应普遍组查询消息。&lt;/li&gt;
&lt;li&gt;经过查询和响应过程后，IGMP 路由器了解到本网段内存在组播组G1 对应的组播组成员，则由组播路由协议生成（*，G1）组播转发项并以此作为组播数据的转发依据。之后，组播路由协议将发起上游路由更新以维护组播转发树。&lt;/li&gt;
&lt;li&gt;组播源发出的组播数据经过组播路由到达IGMP 路由器，如果IGMP 路由器上存在（*，G1）组播转发项，则转发该组播数据到此共享网段，G1 组播组成员主机接收该数据。&lt;/li&gt;
&lt;li&gt;IGMPv1 中没有专门定义离开组播组的消息。当主机离开某组播组后，将不再发送以此组播组地址为目的地址的Report 报告。当网段中不再存在该组播组成员后，IGMP 路由器将不能收到任何针对此组播组的Report 报告，则IGMP 路由器删除该组播组对应的转发项。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;v2&#34;&gt;v2&lt;/h4&gt;
&lt;h5 id=&#34;报文格式-2&#34;&gt;报文格式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596697000398.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
IGMPv2报文相比IGMPv1报文，取消了版本字段而相应增加了最大响应时间的字段&lt;br&gt;
IGMPv2支持特定组查询、增加了离组消息（增加了触发查询机制）、报告抑制机制优化了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;最大响应时间：仅用于组成员关系查询时主机可以响应查询，返回报告的时间范围，可以适当调高，给主机足够的响应时间。以0.1秒为单位，默认值是100，即10秒&lt;/li&gt;
&lt;li&gt;组地址：
&lt;ul&gt;
&lt;li&gt;在成员查询消息中，发送一个常规查询报文时组地址为0，当发送一个特定组的查询报文时，则设置为该组的地址。&lt;/li&gt;
&lt;li&gt;在成员报告或离开组的消息中，目的地址是224.0.0.2则为所有的组播路由器，&lt;strong&gt;但华为设备上实现为特定组&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;类型：IGMPv2报文中有三种报文类型：
&lt;ul&gt;
&lt;li&gt;Type=0x11：成员关系查询报文，分为两种子类型：
&lt;ul&gt;
&lt;li&gt;常规查询：用于确定哪些组播组是有效的，即该组是否还有成员在使用，&lt;strong&gt;常规查询组地址全零&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;特定查询：用于查询特定的组播组是否还有组成员，&lt;strong&gt;组地址为特定的组播地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Type=0x16：IGMPv2组成员关系报告
&lt;ul&gt;
&lt;li&gt;为了和IGMPv1兼容，还有另外的一个附加消息类别：0x12为IGMPv1成员报告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Type=0x17：离开组消息，主机发送的离开报告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;组成员加入&#34;&gt;组成员加入&lt;/h5&gt;
&lt;p&gt;当一个主机加入一个组播组，则应该立即发送一个或多个成员关系报告给组播组&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596699055945.png&#34; alt=&#34;组成员加入&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;查询与响应&#34;&gt;查询与响应&lt;/h5&gt;
&lt;p&gt;与IGMPv1相同，都存在抑制机制。&lt;br&gt;
&lt;strong&gt;增加了最大响应时间&lt;/strong&gt;来指定延时值来规定所有主机的查询响应延时的上限，此外最大响应时间在&lt;strong&gt;IGMP查询器&lt;/strong&gt;(&lt;strong&gt;选举原则则为IP地址小的设备&lt;/strong&gt;)上配置，只应用在成员关系查询信息。&lt;br&gt;
在常规查询之外增加了特定组查询，这种查询报文的目的IP地址为某个组播组的IP地址，保温中的组地址字段也为该组播组的IP地址，网络中属于该组播组成员的主机才会进行响应，这样就避免了属于其他组播组成员的主机发送响应报文&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596699127088.png&#34; alt=&#34;查询与响应&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;查询器选举&#34;&gt;查询器选举&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596700187559.png&#34; alt=&#34;查询器选举&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查询器也会有失效的时间，当查询器失效时，另一个路由器成为查询器，所以非查询路由器会启动一个查询计时器，周期检查IGMP查询路由器的状态，&lt;strong&gt;缺省情况下为120秒，但是查询路由器的死亡时间为125秒&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;组成员离开-2&#34;&gt;组成员离开&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596700612639.png&#34; alt=&#34;组成员离开&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当一个主机决定离开一个组播组时，他会向所有组播路由器以组播的形式（224.0.0.2）发送离开组消息，为了明确该组播组中是否还包含其他成员主机，该组播路由器会向网络中发送特定组查询消息。&lt;br&gt;
在查询的最大响应时间内（默认为1s）没有收到该组的报告，则再次发特定组查询。2次特定组查询之后仍然没有收到成员报告，则认为该组播成员全部离开。&lt;/p&gt;
&lt;h4 id=&#34;v1和v2的互操作性&#34;&gt;v1和v2的互操作性&lt;/h4&gt;
&lt;h5 id=&#34;v2主机与v1路由器&#34;&gt;v2主机与v1路由器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596710458120.png&#34; alt=&#34; v2主机与v1路由器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
v1路由器把v2报告看作无效的IGMP信息类型并且&lt;strong&gt;忽略它&lt;/strong&gt;&lt;br&gt;
当v1路由器作为有效的IGMP查询器时，v2的主机必须发送v1报告。&lt;br&gt;
当v2的的主机检测出IGMP查询器时v1的路由器时，他必须始终用v1报告作出响应。在这种情况下，v2的主机也可以抑制发送离开组消息。&lt;br&gt;
为了维护接口的状态，无论何时v1查询在接口处被收到，&lt;strong&gt;v2主机会启动一个400秒的倒数计时器&lt;/strong&gt;（&lt;strong&gt;向下兼容v1&lt;/strong&gt;），当另一个v1查询被收到时，计时器被复位。如果计时器到时，此接口恢复成为v2接口并且v2信息被再次发送。&lt;/p&gt;
&lt;h5 id=&#34;v1主机与v2路由器&#34;&gt;v1主机与v2路由器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596710463619.png&#34; alt=&#34;v1主机与v2路由器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
局域网中v1的主机也是同一组成员，那么该组的v1报告总是被收到，因为v2报告在v1的主机中不会被抑制，v1的主机不兼容v2的报告，因此&lt;strong&gt;忽略它们&lt;/strong&gt;。无论何时，只要v1的主机成为组成员，v2离开过程都将被搁置&lt;/p&gt;
&lt;h5 id=&#34;混合版本&#34;&gt;混合版本&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596710522472.png&#34; alt=&#34;混合版本&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果一些&lt;strong&gt;运行v1的路由器&lt;/strong&gt;存在于子网中，那么必须强制性地为子网中的&lt;strong&gt;所有路由器配置v1以便正常使用&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;组播节点分为三个类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不支持主机侧（报告）、不支持路由侧（查询），（即不支持开启IGMP）但是可以做为组播源&lt;br&gt;
支持主机侧、不支持路由侧&lt;br&gt;
支持主机侧、支持路由侧&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;v3&#34;&gt;v3&lt;/h4&gt;
&lt;p&gt;服务于SSM模型；允许主机指定接收某些网络发送的某些组播组；增加了主机的控制能力，&lt;strong&gt;不仅可以指定组播组，还能指定组播的源&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&#34;工作机制&#34;&gt;工作机制&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596777748104.png&#34; alt=&#34;工作机制&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;v3响应消息的目的地址为224.0.0.22&lt;/strong&gt;（代表所有运行v3的路由器），其中可以携带至少一个组记录，在每个组记录中，包含组播组地址、数目不等的源地址信息。&lt;br&gt;
组记录可以分为多种类型，如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前状态记录，报告了接口当前状态，分为Include和Exclude两种状态类型
&lt;ul&gt;
&lt;li&gt;Include表示包含指定源地址列表，Exclude表示包含除指定源地址之外的所有源地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过滤模式改变记录，报告接口接收状态在Include和Exclude之间的切换&lt;/li&gt;
&lt;li&gt;源地址列表改变记录：报告新源地址加入或者删除某源地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;改进之处&#34;&gt;改进之处&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596780155795.png&#34; alt=&#34;改进之处&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
v3不仅支持v1的普遍组查询、v2的特定组查询，还支持v3的指定源/组查询。在IGMP消息中携带组播源地址和多种控制字段（如查询器强壮性系数、查询间隔等）。&lt;br&gt;
对于普遍组查询，既不携带组地址(0.0.0.0)，也不携带源地址；对于特定组查询，携带组地址，但是不携带源地址；对于指定源/组查询，既携带组地址，而且还携带至少一个源地址&lt;/p&gt;
&lt;h5 id=&#34;igmp三个版本的比较&#34;&gt;IGMP三个版本的比较&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596780880584.png&#34; alt=&#34;三个版本的比较&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;pim协议无关组播&#34;&gt;PIM（协议无关组播）&lt;/h1&gt;
&lt;p&gt;PIM称为协议无关组播，表示组播依靠的单播路由可以由静态路由、RIP、OSPF、ISIS、BGP等提供，组播路由和单播路由协议无关，只要单播路由协议产生所需路由表项能够完成RPF检查即可。&lt;br&gt;
协议号为103（0x67），目前使用的是v2版本，PIM路由器目的组播地址为224.0.0.13，PIM协议分为PIM-DM密集模式和PIM-SM稀疏模式。&lt;/p&gt;
&lt;h2 id=&#34;pimv2报文头格式&#34;&gt;PIMv2报文头格式&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596788566300.png&#34; alt=&#34;报文头格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;版本：版本字段标识版本信息，目前为2&lt;/li&gt;
&lt;li&gt;报文类型：
&lt;ul&gt;
&lt;li&gt;0：Hello（周期30秒，死亡时间105秒）&lt;/li&gt;
&lt;li&gt;1：注册（单播）&lt;/li&gt;
&lt;li&gt;2：停止注册（SM，单播）&lt;/li&gt;
&lt;li&gt;3：加入/剪枝&lt;/li&gt;
&lt;li&gt;5：Boostrap（SM）&lt;/li&gt;
&lt;li&gt;6：嫁接&lt;/li&gt;
&lt;li&gt;7：嫁接确认&lt;/li&gt;
&lt;li&gt;8：候选RP公告（SM）&lt;/li&gt;
&lt;li&gt;9：状态刷新&lt;br&gt;
&lt;code&gt;ping一个组播组，有时第一个包通，但是后面的包不通，局势因为第一个包是用来注册的，后面的不通说明组播网络有问题&lt;/code&gt;&lt;br&gt;
优先级值大的选举为DR，具备抢占性，组播地址为224.0.0.13，使用hello报文进行选举。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pim-dmdense_mode密集模式&#34;&gt;PIM-DM（Dense_mode，密集模式）&lt;/h2&gt;
&lt;h3 id=&#34;概述-2&#34;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;采用“&lt;strong&gt;推（Push）模式&lt;/strong&gt;”转发组播报文，因此此模式只关心两件事：哪些接口开启了PIM-DM模式；RPF检查。&lt;code&gt;采用推的机制的目的是在DM中产生组播路由表，现有组播路由表再去推组播流&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;PIM-DM的&lt;strong&gt;关键任务&lt;/strong&gt;：建立SPT（Shortest Path Tree，最短路径树）&lt;/li&gt;
&lt;li&gt;PIM-DM的&lt;strong&gt;工作机制&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;邻居发现&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596868793202.png&#34; alt=&#34;邻居发现&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;泛洪&lt;/strong&gt;：为了确保所有可能存在的接收者都感知到组播源&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;扩散&lt;/strong&gt;：为了后来可能出现的需要流量的枝杈，即重新泛洪（180s倒计时）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596868872374.png&#34; alt=&#34;扩散&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;剪枝&lt;/strong&gt;：剪枝是为了优化成SPT，剪枝行为是由下游设备发起。&lt;strong&gt;剪枝延迟&lt;/strong&gt;，上游设备收到剪枝消息，&lt;strong&gt;默认延迟3秒&lt;/strong&gt;再剪枝。剪枝后形成SPT树&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596868942161.png&#34; alt=&#34;剪枝&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
SPT树的形成：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596869039461.png&#34; alt=&#34;SPT树的形成&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;(剪枝)状态刷新&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;嫁接&lt;/strong&gt;：针对在剪枝之后出现的接收者向上请求组播流，下游设备向上发嫁接消息，上游设备向下发嫁接确认。嫁接之后形成新的SPT树&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596869086872.png&#34; alt=&#34;嫁接&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新的SPT树形成：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596869146249.png&#34; alt=&#34;新的SPT树形成&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;断言（声明/Assert机制）&lt;/strong&gt;：避免流量重复拷贝。&lt;br&gt;
竞选规则如下：单播路由协议优先级较高者获胜。如果优先级相同（即本质是最先比较的是开销，可以在同一协议下不同接口上配置不同的cost），则到组播源的开销较小者获胜。如果以上都相同，则下游接口IP地址最大者获胜。&lt;br&gt;
根据Assert竞选结果，路由器将执行不同的操作：获胜一方的下游接口称为Assert Winner，将负责后续对该网段组播报文的转发；落败一方的下游接口称为Assert Loser，后续不会对该网段转发组播报文，PIM路由器也会将其从（S,G）表项下游接口列表中删除，所有Assert Loser可以周期性的恢复组播报文转发，从而引发周期性的Assert竞选&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596875016182.png&#34; alt=&#34;断言&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协议假设：网络中的每个子网都存在至少一个对组播源感兴趣的接受站点，因此组播数据包被扩散到网络中的所有网段。因此适应于小型网络&lt;/li&gt;
&lt;li&gt;PIM-DM对没有组播数据转发的分支进行Prune剪枝操作，只保留包含接收者的分支（如果没有消费者即接收者，暂时中断该区域）&lt;/li&gt;
&lt;li&gt;为了使剪掉的有组播数据转发需求的分支能够重新接收组播流数据，剪掉的分支周期性的恢复成转发状态（即定期考察市场契机）&lt;/li&gt;
&lt;li&gt;为了减少等待被剪掉的分支恢复成转发状态的延时时间，PIM-DM使用Graft嫁接机制主动恢复组播报文的转发&lt;/li&gt;
&lt;li&gt;PIM-DM域中数据包的转发路径是有源树
&lt;ul&gt;
&lt;li&gt;以组播源为根，组播组成员为枝叶的一棵树&lt;/li&gt;
&lt;li&gt;由于有源树使用的是从组播源到接收者的最短路径，因此也称为最短路径树SPT（取消了中间商渠道，是消费者到生产商的直供式服务）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PIM-DM不依赖于特定的单播路由协议，而是使用现存的单播路由表（可以是任意路由协议）进行RPF检查&lt;/li&gt;
&lt;li&gt;路由器收到组播数据的接口称为上游接口，转发组播数据的接口称为下游接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;报文&#34;&gt;报文&lt;/h3&gt;
&lt;h4 id=&#34;hello报文&#34;&gt;Hello报文&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596875197726.png&#34; alt=&#34;Hello报文&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
组播路由器需要使用Hello消息来发现邻居，并维护邻居关系。&lt;br&gt;
Holdtime定时器为105秒，这个定时器指示接收方何时终止与发送方的邻接关系。&lt;br&gt;
priority通过比较Hello消息上携带的优先级（越高越优）和IP地址（越大越优），各路由器为各网段选举指定路由器DR&lt;/p&gt;
&lt;h3 id=&#34;总结与评价&#34;&gt;总结与评价&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PIM-DM对于小型网络来说非常有效&lt;/li&gt;
&lt;li&gt;优势：
&lt;ul&gt;
&lt;li&gt;易于配置&lt;/li&gt;
&lt;li&gt;实现机制简单：泛洪--扩散--剪枝--嫁接--断言&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;潜在问题：
&lt;ul&gt;
&lt;li&gt;扩散剪枝过程不够高效&lt;/li&gt;
&lt;li&gt;复杂的Assert机制&lt;/li&gt;
&lt;li&gt;不支持共享树【共享树不用于转发数据，其入接口为NULL，仅用于产生（S,G），这是和SM模式的重要区别】&lt;/li&gt;
&lt;li&gt;控制和数据平面混合导致网络内部的所有路由器上都由（S，G）表项存在【一旦有任意组播源出现，所有设备会自动生成表项，占用内存】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pim-sm&#34;&gt;PIM-SM&lt;/h2&gt;
&lt;h3 id=&#34;基本概述&#34;&gt;基本概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;术语：
&lt;ul&gt;
&lt;li&gt;源：发送组播数据的终端主机或PC&lt;/li&gt;
&lt;li&gt;接收者：接收组播数据的终端主机或PC&lt;/li&gt;
&lt;li&gt;指定路由器（向RP注册）：在共享网段上选举&lt;strong&gt;优先级最高（数值最大）或者IP地址最大&lt;/strong&gt;的路由器为DR；源DR（注册）负责将数据从源转发至RP；接收者DR（发送join），负责将数据从RP转发到接收者或称最后一跳DR&lt;/li&gt;
&lt;li&gt;汇聚点RP：接收者从这里获取源信息，并且是共享树的根，是SM中的核心解决方案&lt;/li&gt;
&lt;li&gt;RPT：从接收者DR到RP逐跳建立起来的，&lt;strong&gt;以RP为根的共享树&lt;/strong&gt;。RPT实现了组播数据按需转发的目的，减少了数据泛洪对网络带宽的占用&lt;/li&gt;
&lt;li&gt;SPT：从接收者DR到源DR建立起来的，&lt;strong&gt;以源为根的最短路径树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;使用“&lt;strong&gt;拉（Pull）模式&lt;/strong&gt;”转发组播报文，从接收者开始向RP方向尝试拉取组播流。&lt;code&gt;先有组播路由表，后有组播流&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;适用于组播成员分布较为稀疏的网络环境&lt;/li&gt;
&lt;li&gt;PIM的DR在SM中源一侧和接收者一侧的DR都有了实际意义。组播源一侧的DR负责数据的转发 （注册）；接受者一侧的DR负责向下转发数据以及向上发送 join&lt;/li&gt;
&lt;li&gt;PIM-SM的&lt;strong&gt;关键任务&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;建立RPT（Rendezvous Point Tree，汇聚点树也称共享树）：以RP为根，以及所有拥有接收者的叶路由器和接收者共同形成的分发树。
&lt;ul&gt;
&lt;li&gt;接收者通过IGMP向叶路由器报告组播流需求，叶路由器产生（*，G）&lt;/li&gt;
&lt;li&gt;SM要求整个组播网络的所有参与路由器都需要知道RP的位置&lt;/li&gt;
&lt;li&gt;叶路由器向RP方向做RPF检查，从RPF邻居接口向上游发送PIM的join消息&lt;/li&gt;
&lt;li&gt;上游路由器产生（*，G） ，同时向上传递join消息，直至RP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立SPT（源路径树，为了RPT区分，此处称为源路径树）：包含组播源，是从组播源到RP的最短路径树
&lt;ul&gt;
&lt;li&gt;第一跳路由器最先感知到组播流和组播源，将执行注册，将组播流封装在单播报文中，单播转发至RP  ，向RP注册组播源地址&lt;/li&gt;
&lt;li&gt;RP主动向着组播源方向发起PIM join（S,G），这个过程会形成SPT&lt;/li&gt;
&lt;li&gt;注册停止，当SPT 建立完毕，第一跳路由器将能够沿着SPT向下转发组播流，当RP收到来自SPT的组播流，将单播向第一跳路由器发送注册停止消息&lt;/li&gt;
&lt;li&gt;第一跳路由器收到注册停止消息，停止发送注册报文&lt;br&gt;
&lt;code&gt;此时，SM中RPT也负责转发组播流，但是，目前为止，组播的转发路径依然不是最优的&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;建立SPT（Shortest Path Tree，最短路径树）：
&lt;ul&gt;
&lt;li&gt;当叶路由器接收到组播流，将感知到组播源地址，默认的情况下，叶路由器会立刻触发一个叫做SPT切换的过程&lt;/li&gt;
&lt;li&gt;叶路由器将根据感知到的组播源地址，针对组播源做RPF检查。向着源方向做(S,G) join，完成后组播流将沿着SPT转发&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组播接收者侧dr与组播源侧dr&#34;&gt;组播接收者侧DR与组播源侧DR&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596965698949.png&#34; alt=&#34;组播接收者侧DR与组播源侧DR&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
运行PIM-SM的网络，都会进行DR（Designated Router）的选举。其中有两种DR分别称为接收者侧DR和组播源侧DR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组播接收者侧DR：与组播组成员相连的DR，负责向RP发送（*，G）的Join加入消息，负责将数据从RP转发到接收者或称最后一跳DR。&lt;/li&gt;
&lt;li&gt;组播源侧DR：与组播源相连的DR，负责向RP发送单播的Register消息，负责将数据从源转发至RP。&lt;br&gt;
PIM-SM中DR的选举原则与PIM-DM相同【&lt;strong&gt;优先级值越大越优先，IP地址越大越优先&lt;/strong&gt;】。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;g与sg条目关系&#34;&gt;（*，G）与（S，G）条目关系&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596965258370.png&#34; alt=&#34;条目关系&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;pim-sm协议机制&#34;&gt;PIM-SM协议机制&lt;/h3&gt;
&lt;p&gt;邻居发现--&amp;gt;DR选举--&amp;gt;RP发现--&amp;gt;加入--&amp;gt;剪枝--&amp;gt;注册--&amp;gt;SPT&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;邻居发现Hello报文，进行DR选举&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966112856.png&#34; alt=&#34;邻居发现Hello报文&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966118534.png&#34; alt=&#34;DR选举&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;RPT共享树加入&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966163608.png&#34; alt=&#34;RPT共享树加入&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;组播源注册过程&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966208752.png&#34; alt=&#34;组播源注册过程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;停止注册过程&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966244843.png&#34; alt=&#34;停止注册过程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;组播流转发过程&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966317716.png&#34; alt=&#34;组播流转发过程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;RPT向SPT切换&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966338069.png&#34; alt=&#34;RPT向SPT切换&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;切换后的组播转发&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966515012.png&#34; alt=&#34;切换后的组播转发&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;切换后的剪枝&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966520057.png&#34; alt=&#34;切换后的剪枝1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596966525926.png&#34; alt=&#34;切换后的剪枝2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rp&#34;&gt;RP&lt;/h3&gt;
&lt;h4 id=&#34;rp发现&#34;&gt;RP发现&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在PIM-SM组播我那个萝莉，担当共享树的树根节点的被称为RP&lt;/li&gt;
&lt;li&gt;作用：
&lt;ul&gt;
&lt;li&gt;共享树里所有组播流都通过RP转发到接收者&lt;/li&gt;
&lt;li&gt;RP可以负责几个或者所有组播组的转发，所以网络中可以有一个或者多个RP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;发现RP
&lt;ul&gt;
&lt;li&gt;在DR和叶路由器以及组播数据流将要经过的所有路由器上手工指定RP的IP地址&lt;/li&gt;
&lt;li&gt;动态选举RP的两种方式：利用Auto-RP（思科私有）、BootStrap协议动态选举RP&lt;/li&gt;
&lt;li&gt;正常情况下静态方式弱于动态，可以&lt;strong&gt;使用override使得静态优于动态&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rp选举原则&#34;&gt;RP选举原则&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果PIM-SM域中只有一个候选RP（C-RP），那么这个节点就是域里的RP&lt;/li&gt;
&lt;li&gt;如果域中存在多个C-RP并都拥有不同的优先级时，则优先级最高（优先级数值越小优先级越高）的将会被选举为域中的RP&lt;/li&gt;
&lt;li&gt;如果域中存在多个C-RP并都拥有相同的优先级时，则依靠Hash算法算出的数值来决定RP，数值最大的成为RP。Hash算法参数：组地址；掩码长度；C-RP地址&lt;/li&gt;
&lt;li&gt;如果域中存在多个C-RP并都拥有相同的优先级与Hash数值时，则&lt;strong&gt;拥有最大IP地址的C-RP为该域的RP&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;C-RP周期（60秒）性发送候选信息，超时时间为150秒，选举规则：服务范围小的、优先级值小的优先级高、hash结果大的、IP地址大的&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;动态rpauto-rp&#34;&gt;动态RP（Auto-RP）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;动态RP可以提供弹性的网络服务&lt;/li&gt;
&lt;li&gt;C-RP将候选信息发送至224.0.1.39，周期性(60秒)的发送 ，默认有效期181秒。MA（映射代理，裁决者）侦听 224.0.1.39，&lt;strong&gt;裁决地址大的作为RP&lt;/strong&gt;通过224.0.1.40通告给所有组播网络【候选接口要使能pim】&lt;/li&gt;
&lt;li&gt;PIMv2用标准的BSR方式公告RP&lt;/li&gt;
&lt;li&gt;基于UDP的496端口，同一网络中存在BSR和Auto-RP，则会优选Auto-RP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;自举路由器bsr-bootstrap-router&#34;&gt;自举路由器BSR (BootStrap Router)&lt;/h3&gt;
&lt;p&gt;在PIM-SM网络启动后，负责收集网络内的RP信息，为每个组播组选举出RP，然后将RP集（即组-RP的映射数据库）发布到整个PIM-SM网络的路由器，称之为BSR。&lt;br&gt;
一个PIM-SM域里只有一台BSR，并同时可以存在多台候选BSR（C-BSR）&lt;/p&gt;
&lt;h4 id=&#34;选举规则&#34;&gt;选举规则&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;如果域中只有一台C-BSR，该台路由器就是该域里的BSR&lt;/li&gt;
&lt;li&gt;如果域中存在多台C-BSR，则拥有最高优先级（默认0）的路由器为BSR&lt;/li&gt;
&lt;li&gt;如果域里存在多台拥有相同优先级的C-BSR，则拥有最高IP地址的路由器为BSR&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;工作流程&#34;&gt;工作流程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;先选出BSR&lt;br&gt;
C-BSR的消息通过PIM传递，目标地址为 224.0.0.13，选举完成后通过bootstrap消息公告自己是BSR（默认60S），该消息通常情况下TTL为1，但pim路由器会续传该消息。未胜出的C-BSR监听BSR，BSR超时时间默认为130秒&lt;/li&gt;
&lt;li&gt;C-RP发送至BSR&lt;br&gt;
C-RP通过bootstrap消息得知BSR位置，使用单播报文（默认60S）将自身C-RP信息传递给BSR&lt;/li&gt;
&lt;li&gt;BSR收集C-RP信息&lt;br&gt;
BSR收集所有C-RP信息，形成RP-set&lt;/li&gt;
&lt;li&gt;BSR泛洪RP-set&lt;br&gt;
BSR通过bootstrap 消息将RP-set发送至全网（泛洪）&lt;/li&gt;
&lt;li&gt;自举&lt;br&gt;
每台路由器均使用相同的RP选举算法得出相同的RP结果&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;rp与bsr的关系&#34;&gt;RP与BSR的关系&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596980329704.png&#34; alt=&#34;RP与BSR的关系&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;单播注册&#34;&gt;单播注册&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Source发出组播流量给First Route（R1）&lt;/li&gt;
&lt;li&gt;R1将源发过来的组播信息流的组播包封装为单播包（unicast register packet）发送到RP（源是出接口，目标地址是RP，组播被封装到单播内）进行注册。在该表项中设置F位表明它直连了源，同时设置注册“registering”flag表明它在注册&lt;/li&gt;
&lt;li&gt;R4（RP）收到register packet后：
&lt;ol&gt;
&lt;li&gt;解封装，并沿共享树发下去&lt;/li&gt;
&lt;li&gt;产生（S，G）条目，并RPF校验指向源&lt;/li&gt;
&lt;li&gt;向Source发起一个（S，G）的加入&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;R2形成源树（S，G），并且向R1发起一个（S，G）的加入&lt;/li&gt;
&lt;li&gt;R1形成到RP的源树（S，G），当其再次收到组播包时：
&lt;ol&gt;
&lt;li&gt;沿（S，G）源树发出组播&lt;/li&gt;
&lt;li&gt;同时还会封装unicast register packet继续发，此时RP会收到来自源的组播包和来自第一跳的单播包。【包的复制，这是一种必不可少的平滑过渡过程】&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;RP从（S，G）收到Multicast packet后，向R1发出register-stop包&lt;/li&gt;
&lt;li&gt;R1收到register-stop包后，停止单播register packet&lt;/li&gt;
&lt;li&gt;last router切换为源树，向源发出（S，G）的join消息&lt;br&gt;
&lt;code&gt;PIM-SM中，偶尔会出现的组播初始流量通，后续流量不通的情况：最开始是单播注册转发&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;总体评价&#34;&gt;总体评价&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据流仅沿“加入”的分支向下发送&lt;/li&gt;
&lt;li&gt;可以根据流量等条件动态的切换到源树&lt;/li&gt;
&lt;li&gt;与具体的单播路由协议无关&lt;/li&gt;
&lt;li&gt;是域间组播路由的基础（和MBGP、MSDP共同结合使用可以完成跨域的组播）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ssm与asm模型比较&#34;&gt;SSM与ASM模型比较&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597065999629.png&#34; alt=&#34;SSM与ASM模型比较&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;msdp和anycastrp&#34;&gt;MSDP和AnycastRP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MSDP，&lt;strong&gt;组播源发现协议&lt;/strong&gt;，是为了解决多个PIM-SM域之间的互连而开发的一种域间组播解决方案，用来发现其他PIM-SM域内的组播源信息。&lt;/li&gt;
&lt;li&gt;MSDP目前&lt;strong&gt;只支持在IPv4网络部署&lt;/strong&gt;，域内组播路由协议&lt;strong&gt;必须是PIM-SM&lt;/strong&gt;，MSDP&lt;strong&gt;仅支持ASM模型&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;SDP通过在不同PIM-SM域的路由器（通常在RP上）之间建立MSDP对等体，MSDP对等体之间交互SA（Source-Active）消息，共享组播源信息，最终可以使一个域内的组播用户接收到其他域的组播源发送的组播数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;任意播&#34;&gt;任意播&lt;/h3&gt;
&lt;p&gt;任意播地址是从单播地址空间中划分出来的。当&lt;strong&gt;一个单播地址分配给多个接口&lt;/strong&gt;，就变成了任意播地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任意播地址是一个标识符对应多个接口的情况。如果一个数据报文要求被传送到一个任意点地址，则将被传送到最近一个接口（路由器决定）&lt;/li&gt;
&lt;li&gt;单播就是一对一；任意波就是&lt;strong&gt;一对最近&lt;/strong&gt;；组播就是一对多&lt;/li&gt;
&lt;li&gt;任意播（Anycast）是指某组中任意发送方对应拓朴结构中几个&lt;strong&gt;最接近的接收方&lt;/strong&gt;之间的通信。与之比较，组播是指单个发送方对应一组选定接收方的一种通信，单播是指单个发送方对应单个接收方的一种通信。&lt;/li&gt;
&lt;li&gt;任意播是&lt;strong&gt;IPv6 中更新路由表时所采用的一种方法&lt;/strong&gt;。某台主机在更新一个主机组的路由表时，先发送&lt;strong&gt;数据到最接近的主机&lt;/strong&gt;上，IPv6 决定哪个网关主机最接近并发送数据包到该主机，就如单播通信一样，然后主机发送信息到其最接近的路由器上，该过程直至组中的所有路由表都被更新为止。&lt;/li&gt;
&lt;li&gt;IPv6 支持单播（Unicast）、组播（Multicast）和任意播（Anycast）三种类型。&lt;strong&gt;IPv6 中没有关于广播（Broadcast）的具体划分，而是作为组播的一个典型类型&lt;/strong&gt;。IPv6 中包含三种与网络设备相联的地址：单播地址、组播地址和任意播地址。在路由选择过程中，IPv6 对单播和任意播地址不加区分。在答复数据包头中，收到 Anycast 数据包的节点需要将其自己的单播地址作为发送方地址。任意播中广告和收听的路由选择使用地址解析协议（ARP）或链路级组播完成。任意播中转发数据包的过程类似于单播，而最后一跳路由选择过程类似于组播。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;msdp对等体建立&#34;&gt;MSDP对等体建立&lt;/h3&gt;
&lt;p&gt;使用MSDP实现跨域组播的首要任务是：&lt;strong&gt;建立MSDP对等体，MSDP对等体通常建立在RP上&lt;/strong&gt;。&lt;br&gt;
通常，在各个PIM-SM域的RP之间配置MSDP对等体关系，MSDP对等体之间交互SA消息，SA消息中携带组播源DR在RP上注册时的（S，G）信息。通过这些MSDP对等体之间的信息传递，任意一个RP发出的SA消息能够被其他所有的RP收到&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597137821942.png&#34; alt=&#34;MSDP对等体通常建立在RP上&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MSDP对等体&lt;strong&gt;通过TCP连接建立，使用端口639&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;两台设备使能MSDP并互相指定对方为MSDP对等体后，两端&lt;strong&gt;先比较IP地址，IP地址较小的一端会启动连接重试定时器，并主动发起TCP连接，通过keepalive维持&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;IP地址较大的一端负责确认是否有TCP连接在端口639建立。TCP连接建立后，MSDP对等体关系就建立了，对等体之间通过KeepAlive消息维持连接关系&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;组播源信息在域间的传递&#34;&gt;组播源信息在域间的传递&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1597138136312.png&#34; alt=&#34;组播源信息在域间的传递&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;当PIM-SM1域内的组播源Source向组播组G发送第一个组播数据包时，DR1将该组播数据封装在注册报文中，并发给RP1，RP1因此获知了该组播源的相关信息&lt;/li&gt;
&lt;li&gt;RP1作为源端RP，创建SA消息，并周期性地向它的对等体RP2发送。SA消息中包含组播源的地址S、组播组的地址G以及创建该SA消息的源端RP（即RP1）的地址&lt;/li&gt;
&lt;li&gt;RP2接收到该SA消息后，执行RPF检查。检查通过，向RP3转发，同时检查本域内是否存在组G成员。由于PIM-SM2域内没有组G的接收者，故RP2不做其他动作&lt;/li&gt;
&lt;li&gt;RP3接收到该SA消息后，执行RPF检查，检查通过。由于PIM-SM3域内存在组G成员，会通过IGMP协议在RP3上生成（*，G）表项，表示本域内存在组G成员&lt;/li&gt;
&lt;li&gt;RP3创建（S，G）表项，向组播源Source逐跳发送（S，G）加入报文，创建一条从Source到RP3的组播路径（SPT）。组播数据沿SPT到达RP3后，再沿RPT向接收者转发。&lt;/li&gt;
&lt;li&gt;当接收者侧DR3收到Source发出的组播数据后，可以自行决定是否发起SPT切换&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;p&gt;实验拓扑：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596674828574.png&#34; alt=&#34;原理图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596674536546.png&#34; alt=&#34;实验拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
预配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
sys
sys R1
int g0/0/0
ipp addr 100.1.1.254 24
int g0/0/1
ip addr 10.1.1.1 24
ospf 1
area 0
network 0.0.0.0 255.255.255.255   # 所有接口地址均宣告进入OSPF中
# R2
sys
sys R2
int lo 0
ip addr 22.1.1.1 32
int g0/0/0
ip addr 42.1.1.2 24
int g0/0/1
ip addr 10.1.1.2 24
int s1/0/0
ip addr 24.1.1.2 24
ospf 1
area 0
network 0.0.0.0 255.255.255.255
# R3
sys
sys R3
int g0/0/1
ip addr 10.1.1.3 24
int g0/0/0
ip addr 35.1.1.3 24
ospf 1
area 0
network 0.0.0.0 255.255.255.255
# R4
sys
sys R4
int g0/0/0
ip addr 42.1.1.4 24
int g0/0/1
ip addr 45.1.1.4 24
int g0/0/2
ip addr 10.1.2.4 24
int s1/0/0
ip addr 24.1.1.4 24
ospf 1
area 0
network 0.0.0.0 255.255.255.255
# R5
sys
sys R5
int g0/0/0
ip addr 35.1.1.5 24
int g0/0/1
ip addr 45.1.1.5 24
int g0/0/2
ip addr 10.1.2.5 24
ospf 1
area 0
network 0.0.0.0 255.255.255.255
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验一igmpv1&#34;&gt;实验一：IGMPv1&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R4
multicast routing-enable   # 全局开启组播
int g0/0/2
igmp version 1
pim dm
igmp enable
# PC1：设置--组播--选择Version1、源IP为10.1.2.1、目的IP为239.1.1.1--点击加入
# 查看
# R4
dis igmp int
dis igmp group
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二igmpv1查询器选举pim协议&#34;&gt;实验二：IGMPv1查询器选举（PIM协议）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R5
multicast routing-enable
int g0/0/2
igmp version 1
pim dm
igmp enable
# R4
int g0/0/2
pim hello-option dr-priority  1000 # 通过修改优先级，将R4设置为PIM的DR（默认优先级为1）
# 查看
dis igmp int
dis pim neighbor
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三igmpv2&#34;&gt;实验三：IGMPv2&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R4
int g0/0/2
igmp version 2
# R5
int g0/0/2
igmp version 2
# PC1先离开--选择Version2--再加入
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验四igmpv3&#34;&gt;实验四：IGMPv3&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R4
int g0/0/2
igmp version 2
# R5
int g0/0/2
igmp version 2
# PC1先离开--选择Version3--源IP设置为10.1.2.1--组播组IP起始232.1.1.1和组播源IP起始100.1.1.1--其他4个0改为1--类型选择MODE_IS_INCLUDE--点击发送
# 查看
# R4/5
dis igmp group
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验五配置pim-dm&#34;&gt;实验五：配置PIM-DM&lt;/h2&gt;
&lt;p&gt;步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署IGP&lt;/li&gt;
&lt;li&gt;开启组播：multicast routing-enable&lt;/li&gt;
&lt;li&gt;接口开启PIM：面对组播源的接口需要开启pim、面对接收者的接口需要开启pim&lt;/li&gt;
&lt;li&gt;接收者加组（使用IGMPv2）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
multicast routing-enable
int g0/0/0
pim dm
int g0/0/1
pim dm
# R2
multicast routing-enable
int s1/0/0
pim dm
int g0/0/1
pim dm
# R3
multicast routing-enable
int g0/0/0
pim dm
int g0/0/1
pim dm
# R4
multicast routing-enable
int g0/0/2
igmp version 2
undo igmp robust-count
undo pim hello-option dr-priority
pim dm
int s1/0/0
pim dm
int g0/0/1
pim dm
# R5
multicast routing-enable
int g0/0/0
pim dm
int g0/0/1
pim dm
int g0/0/2
pim dm
# 加入组播组
# PC1：Version2 -- 源IP10.1.2.1 -- 目的IP239.1.1.1 -- 加入【IP地址10.1.2.1/24  gw10.1.2.4】
# PC2：Version2 -- 源IP10.1.2.2-- 目的IP239.1.1.1 -- 加入【IP地址10.1.2.2/24  gw10.1.2.4】
# PC3：Version2 -- 源IP10.1.2.3 -- 目的IP239.1.1.1 -- 加入【IP地址10.1.2.3/24  gw10.1.2.4】
# 产生组播流
# Client 1：IP100.1.1.1/24 gw100.1.1.254，组播源选择一个MP4的文件，组播组IP239.1.1.1，源IP地址100.1.1.1--运行
# 检验
# PC1 ：启动VLC（比较卡）
# R3/2
dis pim rou
dis pim neighbor
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验六pim-sm&#34;&gt;实验六：PIM-SM&lt;/h2&gt;
&lt;p&gt;大致步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IGP（完成RPF检查）【上面实验已经做过】&lt;/li&gt;
&lt;li&gt;使能组播和PIM&lt;/li&gt;
&lt;li&gt;配置RP，所有设备都需要知道RP的位置，目的是组测，RPT的形成也需要RP的位置&lt;br&gt;
实验内容：&lt;/li&gt;
&lt;li&gt;在vrp上部署 PIM-SM&lt;/li&gt;
&lt;li&gt;创造一个由于RPF检查失败造成的单播注册通，组播不通&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 清除之前的配置
# R1
int g0/0/0
undo pim dm
int g0/0/1
undo pim dm
# R2
int s1/0/0
undo pim dm
int g0/0/0
undo pim dm
int g0/0/1
undo pim dm
# R3
int g0/0/0
undo pim dm
int g0/0/1
undo pim dm
# R4
int s1/0/0
undo pim dm
int g0/0/0
undo pim dm
int g0/0/1
undo pim dm   
int g0/0/2
undo pim dm 
# R5
int g0/0/0
undo pim dm
int g0/0/1
undo pim dm   
int g0/0/2
undo pim dm 

# 部署PIM-SM
# R1
pim
static-rp 22.1.1.1
q
int g0/0/0
pim sm
int g0/0/1
pim sm
# R2
pim
static-rp 22.1.1.1
q
int s1/0/0
pim sm
int g0/0/0
pim sm
int g0/0/1
pim sm
# R3
pim
static-rp 22.1.1.1
q
int g0/0/0
pim sm
int g0/0/1
pim sm
# R4
pim
static-rp 22.1.1.1
q
int s1/0/0
pim sm
int g0/0/0
pim sm
int g0/0/1
pim sm
int g0/0/2
pim sm
# R5
pim
static-rp 22.1.1.1
q
int g0/0/0
pim sm
int g0/0/1
pim sm 
int g0/0/2
pim sm

# 其他配置
# R4
int g0/0/2 
pim hello-option dr-priority 200
dis pim neighbor    # 原来R5是DR，执行上一条命令之后，R4变为DR
# 检查：PC1 ，Version2加入组播，启动VLC


# 声明先对比优先级（本质是路径开销），最后对比IP
# 修改R4和R5连接的接口的cost，从而影响开销值
# R4/5
int g0/0/1
ospf cost 2
dis pim rou  # 此时，R5的RPF邻居由R4变为R3，R4的RPF邻居由R5变为R2【R2是RP】

# 让组播流量走R5，即让R5称为DR
# R5
int g0/0/2
pim hello-option dr-priority  3333

# 创造一个由于RPF检查失败造成的单播注册通，组播不通（R5）
# 即组播流的入接口和单播路由的出接口不一样，目前两者都为g0/0/0
# 下面修改组播流的入接口为g0/0/1（使用下一跳地址），即添加组播静态路由
# R5
ip rpf-route-static 100.1.1.1 32 45.1.1.4  # 此时虽然组播还正常，但是其走的路由时1--2--4--5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验七bsr&#34;&gt;实验七：BSR&lt;/h2&gt;
&lt;p&gt;此实验拓扑为BGP专题的拓扑：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1597154925186.png&#34; alt=&#34;BSR&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
预配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由器的配置：&lt;br&gt;
除了开启BGP和IGP，还需要保证所有接口都工作在PIM-SM模式下
&lt;ul&gt;
&lt;li&gt;R1的g0/0/1、g0/0/2、s1/0/0、loop 0&lt;/li&gt;
&lt;li&gt;R2的g0/0/0、g0/0/2、s1/0/1、loop 0&lt;/li&gt;
&lt;li&gt;R3的g0/0/1、g0/0/2、g0/0/0、loop 0&lt;/li&gt;
&lt;li&gt;R4的g0/0/1、g0/0/2、s1/0/0、s1/0/1&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PC的配置：
&lt;ul&gt;
&lt;li&gt;PC1：组播Version2，源IP为10.1.1.1，目的IP为239.1.1.1；基础配置IP为10.1.1.1/24，GW为10.1.1.254&lt;/li&gt;
&lt;li&gt;PC2：组播Version2，源IP为10.7.1.1，目的IP为239.1.1.1；基础配置IP为10.7.1.1/24，GW为10.7.1.254&lt;br&gt;
实验内容：&lt;br&gt;
R1、R2做为C-RP，R3、R4做为C-BSR&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
pim
c-rp loopback 0
c-rp loopback 0 advertisement-interval 5 # 5秒通告一次
c-rp priority 100 
dis pim rp-info
# R2
int g0/0/1
ip addr 10.1.1.254 24
igmp enable
igmp version 2
q
pim
c-rp loopback 0
c-rp loopback 0 advertisement-interval 5
c-rp priority 80  # 使R2为RP
dis pim rp-info
# R3
pim
c-bsr loopback 0
c-bsr hash-length 0
c-bsr interval 10 # 10秒通告一次
c-bsr priority 100 # 使R3为RP
q
dis pim bsr-info
# R4
pim
c-bsr loopback 0
c-bsr hash-length 0
c-bsr interval 10
c-bsr priority 80
q
dis pim bsr-info
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验八结合msdp及任意播原理实现anycast-rp&#34;&gt;实验八：结合MSDP及任意播原理实现Anycast-RP&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;：源向最近的RP注册，RP之间通过MSDP共享源信息，获得源信息意味着（S,G）的join成为可能&lt;br&gt;
实验内容：&lt;br&gt;
R1、R2为Anycast-RP 100.100.100.100&lt;br&gt;
应用任意播，务必要注意&lt;strong&gt;任意播地址绝不允许做为任何路由协议的router-id&lt;/strong&gt;&lt;br&gt;
逻辑RP的作用：RPF&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
int lo 1
ip addr 100.100.100.100 32
ospf en  1 a 0
pim sm
q
pim
undo c-rp  lo 0
c-rp lo 1 advertisement-interval 5
q
msdp 
peer 22.1.1.1 connect-interface lo 0
originating-rp lo 0  # 逻辑RP
# R2
int lo 1
ip addr 100.100.100.100 32
ospf en  1 a 0
pim sm
q
pim
undo c-rp  lo 0
c-rp priority 100
c-rp lo 1 advertisement-interval 5
q
msdp 
peer 11.1.1.1 connect-interface lo 0
originating-rp lo 0
# 在PC1上测试组播
# R2
dis pim rou
dis pim neighbor
&lt;/code&gt;&lt;/pre&gt;
">HCIE-Multicast专题(2020.08.04，第3专题)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-ipsec-zhuan-ti-20200731/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A0%E5%AF%86%E5%AD%A6%E5%8E%9F%E7%90%86&#34;&gt;加密学原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipsec%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA&#34;&gt;IPSec基本理论&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ipsec%E6%A1%86%E6%9E%B6&#34;&gt;IPSec框架&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90&#34;&gt;组成&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#esp%E8%B4%9F%E8%BD%BD%E5%AE%89%E5%85%A8%E5%B0%81%E8%A3%85%E5%8D%8F%E8%AE%AE&#34;&gt;ESP（负载安全封装）协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%A4%E8%AF%81%E5%A4%B4ah%E5%8D%8F%E8%AE%AE&#34;&gt;认证头（AH）协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#internet%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2ike%E5%8D%8F%E8%AE%AE&#34;&gt;Internet密钥交换（IKE）协议&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ike%E7%9A%84%E4%B8%89%E4%B8%AA%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86&#34;&gt;IKE的三个组成部分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ike%E7%9A%843%E4%B8%AA%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B8%A4%E4%B8%AA%E9%98%B6%E6%AE%B5&#34;&gt;IKE的3个模式和两个阶段&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BB%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5&#34;&gt;主模式（第一阶段）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BF%AB%E9%80%9F%E6%A8%A1%E5%BC%8F%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5&#34;&gt;快速模式（第二阶段）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F&#34;&gt;工作模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F&#34;&gt;传输模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9A%A7%E9%81%93%E6%A8%A1%E5%BC%8Flan-to-lan&#34;&gt;隧道模式（lan to lan）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ipsec%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%BA%93&#34;&gt;IPSec的两个数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8svti%E5%AE%9E%E7%8E%B0%E7%AB%99%E7%82%B9%E9%97%B4%E9%80%9A%E4%BF%A1&#34;&gt;使用SVTI实现站点间通信&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#gre-over-ipsec-%E4%B8%8Esvti%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;GRE over IPSec 与SVTI的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#vpn%E8%A7%A6%E5%8F%91%E8%BF%87%E7%A8%8B%E5%8C%85%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B&#34;&gt;VPN触发过程（包处理流程）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A8%E6%80%81vpnds-vpn%E5%8A%A8%E6%80%81%E6%99%BA%E8%83%BD&#34;&gt;动态VPN（DS VPN，动态智能）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E7%82%B9&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88&#34;&gt;应用场景（部署方案）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BB%84%E6%88%90-2&#34;&gt;组成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#dmvpn%E5%8E%86%E5%8F%B2%E5%8F%91%E5%B1%95&#34;&gt;DMVPN历史发展&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C&#34;&gt;实验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%80%E4%BD%BF%E7%94%A8%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F%E5%8A%A0%E5%AF%86%E9%9A%A7%E9%81%93%E5%86%85%E6%B5%81%E9%87%8Fipsec-lan-to-lan-vpn%E7%9A%84%E9%83%A8%E7%BD%B2&#34;&gt;实验一：使用传输模式加密隧道内流量（IPSec LAN to LAN VPN的部署）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E6%96%B0%E7%9A%84gre-over-ipsec%E9%85%8D%E7%BD%AE%E6%97%A0%E9%9C%80%E5%AE%9A%E4%B9%89%E6%84%9F%E5%85%B4%E8%B6%A3%E6%B5%81%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7%E6%AF%94%E8%BE%83%E5%BC%BA&#34;&gt;实验二：新的GRE over IPSec配置（无需定义感兴趣流，可扩展性比较强）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%89%E4%BD%BF%E7%94%A8svti%E5%AE%9E%E7%8E%B0%E7%AB%99%E7%82%B9%E9%97%B4%E9%80%9A%E4%BF%A1&#34;&gt;实验三：使用SVTI实现站点间通信&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%9B%9B%E9%83%A8%E7%BD%B2%E5%8A%A8%E6%80%81vpn&#34;&gt;实验四：部署动态VPN&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#normal%E6%AD%A3%E5%B8%B8%E6%A8%A1%E5%BC%8F-hub-spoke%E6%A8%A1%E5%BC%8F&#34;&gt;Normal（正常）模式 （Hub-Spoke模式）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9F%AD%E8%B7%AFshortcut%E6%A8%A1%E5%BC%8F%E5%B1%82%E6%AC%A1%E5%8C%96%E6%A0%91%E7%8A%B6%E8%AE%BE%E8%AE%A1&#34;&gt;短路（shortcut）模式（层次化（树状）设计）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;加密学原理&#34;&gt;加密学原理&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;信息安全的目标&lt;/strong&gt;：数据私密性、数据完整性、发送源认证、不可否认性
&lt;ol&gt;
&lt;li&gt;私密性：保证机密信息在传输、存储和使用过程中不被未授权的第三方进行窃听，或窃听者无法了解信息的真正含义&lt;/li&gt;
&lt;li&gt;完整性：确保收到的数据和对方所发出的信息完全一样，防止数据在传输或存储过程中被非法篡改&lt;/li&gt;
&lt;li&gt;源认证：对信息的真实来源进行判断，确认信息真实的发送者和接收者，并能对伪造来源的信息予以鉴别&lt;/li&gt;
&lt;li&gt;不可否认性：防止通信双方中的某一方事后否认其行为，包括：发送者不能否认信息的发送、接收方不能否认信息的接受&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加密算法分类&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;对称式密钥算法：相同的密钥进行加解密，例如DES、3DES、AES、RC4。密钥长度一般为40~256bit。&lt;strong&gt;特点&lt;/strong&gt;：速度非常快；使用简单的数据操作，很容易实现硬件加速；用于大块数据的加密；密钥管理是严重的问题
&lt;ol&gt;
&lt;li&gt;DES：数据加密标准；广泛使用的对称密钥算法；被IBM开发于1975年；固定长度为56bit；算法非常好，并没有任何漏洞，仅仅因为密钥长度太短，易受到暴力破解攻击。DES块加密的两种模式：电子密码本，加密块链接（思科IPSec VPN只支持这种模式）&lt;/li&gt;
&lt;li&gt;3DES：密钥长度放大3倍，长度168bit；暴力破解几乎不能实现；基于一个很好的算法DES&lt;/li&gt;
&lt;li&gt;AES：高级加密标准，又称Rijndael加密算法，AES在软件及硬件上都能快速的加解密，变长密钥和块长度，广泛应用于对无线和语音的加密&lt;/li&gt;
&lt;li&gt;RC4：流加密算法，软件运行效率非常高，广泛用于SSL加密&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;非对称式密钥算法：不同的密钥进行加解密，例如RSA、DH、ECC。公共密钥系统，密钥长度一般在512~2048bit，因为和对称密钥算法的数据理论有本质的不同，所以密钥长度没有可比性。&lt;strong&gt;特点&lt;/strong&gt;：与对称密钥算法相比非常慢，基于已有的数据难题，能够实现简单的密钥管理，只能加密很小的数据，两大用途为签名和密钥交换
&lt;ol&gt;
&lt;li&gt;RSA：公共密钥加密系统，基于大素数因式分解的数学难题，不可能从公钥推导出私钥，一个密钥加密，另一个密钥解密，这些密钥能够长时间的保障安全性。仅仅用于如下两种服务：加密密钥，实现密钥交换；加密散列，完成数字签名，实现源认证和不可否认性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;哈希算法&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;四大特点：计算结果固定长度、雪崩效应、单向运算、冲突避免&lt;/li&gt;
&lt;li&gt;主流的散列算法有MD5和SHA-1。通过散列函数计算得到的结果叫做散列值（数据指纹）&lt;/li&gt;
&lt;li&gt;哈希算法的主要用途：认证、使用数字签名保障数据的完整性。哈希算法解决数据完整性问题，HMAC（哈希消息认证码）解决了完整性基础之上的源认证，特别主要保护HAMC的预共享密钥。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数字签名和数字证书&lt;/strong&gt;&lt;br&gt;
数字签名能够帮我们实现两个功能：数据完整性验证；源认证&lt;br&gt;
数字证书技术，用于解决谁是公钥持有者的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;总结：&lt;br&gt;
数据的私密性：对称加密；数据的完整性：哈希；数据来源的认证：HMAC；数据收发的不可否认性：数据指纹/数字证书&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596296422083.png&#34; alt=&#34;思科设备数据处理流程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;ipsec基本理论&#34;&gt;IPSec基本理论&lt;/h1&gt;
&lt;h2 id=&#34;ipsec框架&#34;&gt;IPSec框架&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596342996288.png&#34; alt=&#34;IPSec框架&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;组成&#34;&gt;组成&lt;/h2&gt;
&lt;h3 id=&#34;esp负载安全封装协议&#34;&gt;ESP（负载安全封装）协议&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;IP协议号50，能够为数据提供私密性、完整性和源认证，同时可抵御防重放攻击（反复发送相同的报文，接收方解密消耗系统资源而导致的DOS攻击），不对原始IP头部进行安全防护。&lt;/li&gt;
&lt;li&gt;ESP包结构&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596294363841.png&#34; alt=&#34;ESP包结构&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;SPI：安全参数索引，是确认单方向IPSec SA的标识&lt;/li&gt;
&lt;li&gt;SA：安全关联，可以理解为定义了需要加密的数据的处理方式。SA是SADB的一个条目，它包含双方关于IKE和IPSec已经协商完毕的安全信息。以下两种类型的SA都由IKE协议协商产生：
&lt;ul&gt;
&lt;li&gt;IKE or ISAKMP SA：双向的；决定了IKE协议处理相关细节&lt;/li&gt;
&lt;li&gt;IPSec SA：单向的；与封装协议相关；决定了具体加密流量的处理方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SADB：安全关联数据库&lt;/li&gt;
&lt;li&gt;Sequence number：用来标识一个数据包。接收方通过序列号来防止重放攻击，接收方收到序列号为x的ESP包，如果再次收到序列号为x的报文则视为重放攻击&lt;/li&gt;
&lt;li&gt;IV字段：和CBC块加密方式有关，每个数据包需要使用CBC加密的数据生成一个随机值，用于对数据进行扰乱，该随机值即为IV字段&lt;/li&gt;
&lt;li&gt;Next Header：如果是隧道模式，下一个头部一定是IP&lt;/li&gt;
&lt;li&gt;Authentication：ESP对ESP头部到ESP尾部所有数据都进行验证，即做HMAC的散列计算，得到的值会放到认证数据部分&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;认证头ah协议&#34;&gt;认证头（AH）协议&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;IP协议号51，数据不能加密（&lt;strong&gt;第一个问题&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;AH包结构&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596295226046.png&#34; alt=&#34;AH包结构&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;AH保护的IP头部字段：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596295386779.png&#34; alt=&#34;AH保护的IP头部字段&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因为IP地址被认为是需要被认证的，所以如果IPSec VPN使用AH封装，就不能穿越NAT（&lt;strong&gt;第二个问题&lt;/strong&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;internet密钥交换ike协议&#34;&gt;Internet密钥交换（IKE）协议&lt;/h3&gt;
&lt;p&gt;IKE负责建立和维护IKE SAs和IPSec SAs。功能主要体现在如下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对双方进行认证&lt;/li&gt;
&lt;li&gt;交换公共密钥，产生密钥资源，管理密钥&lt;/li&gt;
&lt;li&gt;协商协议参数（封装、加密、认证等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ike的三个组成部分&#34;&gt;IKE的三个组成部分&lt;/h4&gt;
&lt;p&gt;IKE是一个混合协议：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;SKEME：实现公钥加密认证的机制。定义如何通过公共密钥技术（DH算法）实现密钥交换&lt;/li&gt;
&lt;li&gt;Oakley：基于到达两个对等体间的加密密钥的机制。提供了IPSec对各种技术的支持，例如对新的加密与散列技术&lt;/li&gt;
&lt;li&gt;ISAKMP：定义了消息交换的体系结构，包括两个IPSec对等体间分组形式和状态转换（&lt;code&gt;定义封装格式和协商包交换的方式&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;IKE和ISAKMP的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;配置IPSec VPN的时候主要配置的是ISAKMP，所以常常认为IKE和ISAKMP是相同的。由于SKEME的存在，IKE能够决定密钥交换的方式，但ISAKMP只能够为密钥交换交换信息，但是不能决定密钥交换如何实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;ike的3个模式和两个阶段&#34;&gt;IKE的3个模式和两个阶段&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596343359168.png&#34; alt=&#34;IKE的3个模式和两个阶段&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;主模式第一阶段&#34;&gt;主模式（第一阶段）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596343626771.png&#34; alt=&#34;主模式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
信息被封装在UDP包中，目的端口为UDP/500&lt;br&gt;
6个报文：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发起方提供加密和验证算法&lt;/li&gt;
&lt;li&gt;响应方回应接收的提案&lt;/li&gt;
&lt;li&gt;发起方的DH公共值和随机数&lt;/li&gt;
&lt;li&gt;响应方的DH公共值和随机数&lt;/li&gt;
&lt;li&gt;发起方的签名、个人信息、密钥&lt;/li&gt;
&lt;li&gt;响应方的签名、个人信息、密钥&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596344219028.png&#34; alt=&#34;1-2协商示意图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596344818728.png&#34; alt=&#34;DH算法示意图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;相互认证
&lt;ol&gt;
&lt;li&gt;1-2个包协商的认证、加密和验证方式都是为5-6包认证服务的&lt;/li&gt;
&lt;li&gt;3-4个包DH交换计算出来的密钥也是为加密和验证（HMAC）5-6包而提前准备的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;建立IKE/ISAKMP SA（双向）&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;快速模式第二阶段&#34;&gt;快速模式（第二阶段）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596345191856.png&#34; alt=&#34;快速模式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3个报文：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HASH值、SA提案、IPSec转换集、密钥材料和感兴趣流&lt;/li&gt;
&lt;li&gt;相应方的HASH值、接受的SA提案、响应方的SPI、密钥&lt;/li&gt;
&lt;li&gt;HASH用于确认隧道建立&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;协商IPSec策略（处理感兴趣流）&lt;/li&gt;
&lt;li&gt;建立IPSec SA
&lt;ol&gt;
&lt;li&gt;单向&lt;/li&gt;
&lt;li&gt;协议相关&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;工作模式&#34;&gt;工作模式&lt;/h2&gt;
&lt;p&gt;通信点：收发数据节点&lt;br&gt;
加解密点：负责加解密的节点&lt;/p&gt;
&lt;h3 id=&#34;传输模式&#34;&gt;传输模式&lt;/h3&gt;
&lt;p&gt;传输模式&lt;strong&gt;只加密IP负载&lt;/strong&gt;，适合于通信点和加解密点位于相同的节点上，即不加密也能正常通信的情况下使用。&lt;/p&gt;
&lt;h3 id=&#34;隧道模式lan-to-lan&#34;&gt;隧道模式（lan to lan）&lt;/h3&gt;
&lt;p&gt;适合于通信点和加解密点位于不同的节点上，即双发无法通信，经过IPSec隧道之后可以通信了。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596293506427.png&#34; alt=&#34;隧道模式示意图&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596293574910.png&#34; alt=&#34;隧道模式实例分析&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ipsec的两个数据库&#34;&gt;IPSec的两个数据库&lt;/h2&gt;
&lt;p&gt;为了实现IPSec的互操作性，IPSec模型描述了两个数据库&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SPD 安全策略数据库。决定了什么流量将接受IPSec处理&lt;/li&gt;
&lt;li&gt;SADB 安全关联数据库。维护每一个SA（安全关联）包含的参数，本质为ACL。&lt;br&gt;
在SADB里面的每一个条目决定了一个特定SA的参数，当一个IPSec SA被创建，SADB更新所有关于这个SA的参数。&lt;br&gt;
当一个inbound IPSec数据包抵达，SADB基于外层IP头部的目的地址、SPI和IPSec封装协议（ESP/AH）检索数据库以获得相应的SA，然后用这个SA的相关参数处理这个inbound IPSec数据包。&lt;br&gt;
对于outbound IPSec数据包处理的相关参数，是由SPD相关联的SA来获取的。&lt;br&gt;
包含9大部分：Sequence number、Sequence number overflow、Anti-replay window、SA lifetime、Modes、AH authentication algorithm、ESP authentication algorithm、ESP encryption algorithm、Path MTU&lt;br&gt;
&lt;strong&gt;SPD和SADB示意图&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596297505442.png&#34; alt=&#34;SPD和SADB示意图&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用svti实现站点间通信&#34;&gt;使用SVTI实现站点间通信&lt;/h2&gt;
&lt;p&gt;SVTI：静态虚拟隧道接口。&lt;br&gt;
相比加密GRE隧道流量，节省了GRE头部所占的MTU。&lt;/p&gt;
&lt;h3 id=&#34;gre-over-ipsec-与svti的区别&#34;&gt;GRE over IPSec 与SVTI的区别&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;模式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;使用何种方式&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;原理&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;优点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GRE over IPSec&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;传输模式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;GRE先创建隧道，然后IPSec保护创建的隧道&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以运行动态路由协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;SVTI&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用IPSec ipv4隧道模式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;直接使用IPSec来创建一个VTI隧道接口&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以运行动态路由协议，比GRE over IPSec少4字节的GRE头部&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;vpn触发过程包处理流程&#34;&gt;VPN触发过程（包处理流程）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数据包进入VPN设备，检查远端通信点的路由，路由引导流量出适当的接口&lt;/li&gt;
&lt;li&gt;包在出接口过程中撞击上MAP&lt;/li&gt;
&lt;li&gt;流量匹配上MAP的ACL（感兴趣流），触发加密&lt;/li&gt;
&lt;li&gt;发起和PEER的IKE协商，VPN设备检查去往PEER（远端加密点）的路由&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596384039954.png&#34; alt=&#34;包处理流程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;动态vpnds-vpn动态智能&#34;&gt;动态VPN（DS VPN，动态智能）&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;相比较传统的静态L2L VPN，最显著的特点就是&lt;strong&gt;资源按需消耗&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;静态隧道+动态隧道的方式，实现&lt;strong&gt;全互联&lt;/strong&gt;的连通性的架构&lt;/li&gt;
&lt;li&gt;分支站点Spoke可以使用&lt;strong&gt;动态地址&lt;/strong&gt;，甚至支持经过NAT&lt;/li&gt;
&lt;li&gt;部署完成后，增加新的分支站点Spoke，&lt;strong&gt;不需要动中心Hub&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分支站点的配置几乎也很相似&lt;/strong&gt;，能够非常快速的部署新的办公环境&lt;/li&gt;
&lt;li&gt;分支站点之间&lt;strong&gt;动态的触发隧道&lt;/strong&gt;，站点之间通信流量&lt;strong&gt;无需穿越Hub&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;站点之间流量&lt;strong&gt;使用IPSec加固&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;零丢包&lt;/li&gt;
&lt;li&gt;支持动态路由协议OSPF、BGP、EIGRP&lt;/li&gt;
&lt;li&gt;支持Hub-Spoke之间的组播流量&lt;/li&gt;
&lt;li&gt;支持运行在MPLS之上&lt;/li&gt;
&lt;li&gt;支持虚拟路由转发VRF （i-VRF、F-VRF）&lt;/li&gt;
&lt;li&gt;拥有自愈能力&lt;/li&gt;
&lt;li&gt;支持高可用性（主备）、弹性设计（负载）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596441037496.png&#34; alt=&#34;DMVPN&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;应用场景部署方案&#34;&gt;应用场景（部署方案）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一个Hub&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596442270555.png&#34; alt=&#34;一个Hub&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;主备Hub&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596442284810.png&#34; alt=&#34;主备Hub&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;双Hub&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596442290629.png&#34; alt=&#34;双Hub&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;层次化设计&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596442393302.png&#34; alt=&#34;层次化设计&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;组成-2&#34;&gt;组成&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;多点GRE隧道mGRE：站点间连通性。mGRE的IP协议号与GRE一样都是47&lt;/li&gt;
&lt;li&gt;下一跳解析NHRP：注册、解析、路由优化&lt;/li&gt;
&lt;li&gt;动态路由协议：路由传递、下一跳优化&lt;/li&gt;
&lt;li&gt;IPSec：流量加固&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dmvpn历史发展&#34;&gt;DMVPN历史发展&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第一阶段：星型拓扑设计Hub-to-Spoke&lt;br&gt;
DMVPN第一阶段的星型拓扑设计是DMVPN技术的最原始阶段，除了&lt;strong&gt;中心站点为mGRE隧道，所有分支站点均为普通的点对点GRE隧道&lt;/strong&gt;。分支站点间的流量都必须经过中心站点进行转发。第一阶段星型拓扑DMVPN的优势在于，增加分支站点并不会增加中心站点的配置量，并且分支站点支持动态获取IP地址。&lt;/li&gt;
&lt;li&gt;第二阶段：虚拟网拓扑设计Spoke-to-Spoke&lt;br&gt;
在DMVPN第二阶段的虚拟网状拓扑设计中，&lt;strong&gt;所有站点配置mGRE隧道&lt;/strong&gt;。中心站点与分支站点间维护一个永恒隧道，&lt;strong&gt;分支站点与分支站点间按需建立隧道，形成虚拟网状拓扑&lt;/strong&gt;，真正实现DMVPN的高扩展性。&lt;/li&gt;
&lt;li&gt;第三阶段：层次化（树状）设计Hierarchical (Tree-Based) Design&lt;br&gt;
DMVPN第三阶段和第二阶段基本一致，&lt;strong&gt;所有站点都使用mGRE&lt;/strong&gt;。 第三阶段主要对大规模的DMVPN实施优化调整，&lt;strong&gt;整体呈现树状拓扑&lt;/strong&gt;。中心站点和分支之间只需要维持一条VPN隧道即可，Spoke和Spoke之间通讯是按需建立隧道，可以实现虚拟全互连的效果，真正的实现了DMVPN的高扩展性。&lt;strong&gt;Spoke-to-Spoke的流量无需通过中心站点进行转发&lt;/strong&gt;，通过动态建立的隧道，可以使通讯双方直接通讯，相对于第一阶段的DMVPN的优势在于减少了中心性能的消耗，保证了中心的带宽。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;第二阶段 vs 第三阶段  NHRP的工作方式有所不同&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二阶段，主要由动态路由协议负责路由下一跳优化&lt;br&gt;
三阶段，主要由NHRP负责下一跳优化，支持路由汇总&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596468895416.png&#34; alt=&#34;隧道处理方法比较表&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;p&gt;实验拓扑如下：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596290894542.png&#34; alt=&#34;实验拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
预配置：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R2
sys
sys R2
int g0/0/0
ip addr 192.168.1.254 24
int g0/0/1
ip addr 202.100.1.1 24
# R3
sys
sys R3
int lo 0
ip addr 1.2.3.4 32
int g0/0/0
ip addr 202.100.1.254 24
int g0/0/1
ip addr 61.128.1.254 24
# R4
sys
sys R4
int g0/0/0
ip addr 10.1.1.254 24
int g0/0/1
ip addr 61.128.1.1 24
# PC1
192.168.1.1/24  GW:192.168.1.254
# PC2
10.1.1.1/24  GW:10.1.1.254
# 配置路由
# R2
ip route-static 61.128.1.0 24 202.100.1.254
# ip route-static 10.1.1.0 24 202.100.1.254
# R4
ip route-static 202.100.1.0 24 61.128.1.254
# ip route-static 192.168.1.0 24 61.128.1.254
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验一使用传输模式加密隧道内流量ipsec-lan-to-lan-vpn的部署&#34;&gt;实验一：使用传输模式加密隧道内流量（IPSec LAN to LAN VPN的部署）&lt;/h2&gt;
&lt;p&gt;回顾GRE：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IP协议号47&lt;/li&gt;
&lt;li&gt;报文格式：IP:GRE:IP:ip payload&lt;/li&gt;
&lt;li&gt;有明确的源和目的，流量直接封装进单播，包括动态路由协议的组播报文交互，但没有任何安全机制&lt;br&gt;
GRE over IPSec，加密点和通信点是同一设备（IPSec看的是最外层IP头部），推荐使用传输模式&lt;br&gt;
实验内容：&lt;/li&gt;
&lt;li&gt;使能OSPF并确保PC1和PC2可以通信&lt;/li&gt;
&lt;li&gt;在VRP上部署基于GRE的L2L VPN
&lt;ul&gt;
&lt;li&gt;准备部署通过ipsec保护VPN流量的方案。首要问题，即定义好选择器
&lt;ul&gt;
&lt;li&gt;方案一：在物理出接口下、使用传输模式、加密所有GRE封装的报文&lt;/li&gt;
&lt;li&gt;方案二：在隧道下、使用传输模式、加密所有负载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;步骤：
&lt;ul&gt;
&lt;li&gt;定义IKE提案&lt;/li&gt;
&lt;li&gt;定义IKE对等体以及预共享密钥&lt;/li&gt;
&lt;li&gt;定义ipsec提案&lt;/li&gt;
&lt;li&gt;定义ipsec和ike的策略集&lt;/li&gt;
&lt;li&gt;调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置GRE隧道
# R2
int tunnel 0/0/0
tunnel-protocol gre
source g0/0/1
destination 61.128.1.1
ip addr 12.1.1.1 30
# R4
int tunnel 0/0/0
tunnel-protocol gre
source g0/0/1
destination 202.100.1.1
ip addr 12.1.1.2 30

#---------------------------------------

# 打通VPN通道（即PC1可以访问PC2） 
# R2
ospf 1
a 0
int g0/0/0
ospf en 1 a 0
int t0/0/0
ospf en 1 a 0
# R4
ospf 1
a 0
int g0/0/0
ospf en 1 a 0
int t0/0/0
ospf en 1 a 0

#---------------------------------------

# 在VRP上部署基于GRE的L2L VPN
# R2
#1.  定义感兴趣流
acl name GRE 3333   
rule permit gre
#2. 定义IKE提案，此处使用默认策略（仅创建）
ike proposal 10  
q   # 查看默认策略：dis ike proposal
#3. 定义对等体以及调用IKE提案
ike peer 2424 v1  # 使用IKEv1
pre-shared-key simple qytang666
ike-proposal 10
remote-address 61.128.1.1  # 【注意：此处通信两端设置时不相同，其他地方都一样（第6步调用的接口也有可能不同）】
q
# 4. 定义IPSec提案
ipsec proposal QYT
esp authentication-algorithm sha1
esp encryption-algorithm 3des
encapsulation-mode transport    # 选择传输模式（默认是隧道模式）
q
# 5. 定义IPSec整合策略
ipsec policy L2L 10 isakmp
security acl 3333    # 调用感兴趣流
ike-peer 2424   # 调用IKE提案
proposal QYT  # 调用IPSec提案
q
# 6. 调用
int g0/0/1
ipsec policy L2L

# R4
acl name GRE 3333
rule permit gre
ike proposal 10
q
ike peer 2424 v1
pre-shared-key simple qytang666
ike-proposal 10
remote-address 202.100.1.1
q
ipsec proposal QYT
esp authentication-algorithm sha1
esp encryption-algorithm 3des
encapsulation-mode transport 
q
ipsec policy L2L 10 isakmp
security acl 3333
ike-peer 2424
proposal QYT
q
int g0/0/1
ipsec policy L2L

#---------------------------------------

# 验证：R2/4
dis ike peer  # IKE对等体
dis ike proposal  # IKE策略
dis ike sa  # SA
dis ike statistics v1  # IKEv1统计信息
dis ipsec sa
dis ipsec sa brief
dis ipsec int brief
dis ipsec proposal
dis ipsec statistics esp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二新的gre-over-ipsec配置无需定义感兴趣流可扩展性比较强&#34;&gt;实验二：新的GRE over IPSec配置（无需定义感兴趣流，可扩展性比较强）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -------------------------------完整配置
# 定义IKE提案
# ike proposal 1
# 定义IKE对等体策略及调用方案
# ike peer QYT v1  
# pre-shared-key simple qytang666
# ike-proposal 1
# 定义IPSec提案
# ipsec proposal QYT
# encapsulation-mode transport 
# 定义IPSec profile
# ipsec profile QYT
# ike-peer QYT
# proposal QYT
# 调用
# int t0/0/0
# shutdown
# ipsec profile QYT


# -------------------------------承接上个实验配置
# 清除无用配置
# R2
int g0/0/1
undo ipsec policy
q
undo ipsec policy L2L 10
ike peer 2424 v1
undo remote-address
q
undo acl 3333
# R4
int g0/0/1
undo ipsec policy
q
undo ipsec policy L2L 10
ike peer 2424 v1
undo remote-address
q
undo acl 3333
# 使用新方案配置
# R2
ipsec profile L2L
ike-peer 2424
proposal QYT
int t0/0/0
ipsec profile L2L

# R4
ipsec profile L2L
ike-peer 2424
proposal QYT
int t0/0/0
ipsec profile L2L
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三使用svti实现站点间通信&#34;&gt;实验三：使用SVTI实现站点间通信&lt;/h2&gt;
&lt;p&gt;配置本试验之前需要将之前两个实验的配置全部删除，但是预配置中的4条静态路由需要保留&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R2
# 1. 定义感兴趣流
acl name SVTI 3333
rule 10 permit ip source 192.168.1.0 0.0.0.255 destination 10.1.1.0 0.0.0.255
q
# 2. 定义IKE提案
ike proposal 10
q
# 3. 定义对等体以及调用IKE提案
ike peer 2424 v1
pre-shared-key simple qytang666
ike-proposal 10
remote-address 62.128.1.1
q
# 4. 定义IPSec提案
ipsec proposal QYT
esp authentication-algorithm sha1
esp encryption-algorithm 3des
encapsulation-mode tunnel
q
# 5. 定义IPSec整合策略
ipsec policy L2L 10 isakmp
security acl 3333
ike-peer 2424
proposal QYT
q
# 6. 调用
int g0/0/1
ipsec policy L2L

# R4
acl name SVTI 3333
rule 10 permit ip source 10.1.1.0 0.0.0.255 destination 192.168.1.0 0.0.0.255
ike proposal 10
q
ike peer 2424 v1
pre-shared-key simple qytang666
ike-proposal 10
remote-address 202.100.1.1
q
ipsec proposal QYT
esp authentication-algorithm sha1
esp encryption-algorithm 3des
encapsulation-mode tunnel
q
ipsec policy L2L 10 isakmp
security acl 3333
ike-peer 2424
proposal QYT
q
int g0/0/1
ipsec policy L2L
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验四部署动态vpn&#34;&gt;实验四：部署动态VPN&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596465889357.png&#34; alt=&#34;部署动态VPN&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596466211075.png&#34; alt=&#34;R1配置&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
配置步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署隧道接口 —— spoke-hub的永恒隧道mGRE&lt;/li&gt;
&lt;li&gt;NHRP&lt;/li&gt;
&lt;li&gt;配置动态路由协议&lt;/li&gt;
&lt;li&gt;使用ipsec加固&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;normal正常模式-hub-spoke模式&#34;&gt;Normal（正常）模式 （Hub-Spoke模式）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 1. 基础网络配置（已经预配置，此处省略）

# 2. 定义mGRE
# Hub（R1）
int tunnel 0/0/0
tunnel-protocol gre p2mp  # 隧道模式
source g0/0/0   # 隧道源地址
ip addr 172.16.1.1 24 # 隧道地址
# S1（R2）
int tunnel 0/0/0
tunnel-protocol gre p2mp
source g0/0/0
ip addr 172.16.1.2 24
# S2（R3）
int tunnel 0/0/0
tunnel-protocol gre p2mp
source g0/0/0
ip addr 172.16.1.3 24

# 3. 定义NHRP
# S1
int tunnel 0/0/0
nhrp entry 172.16.1.1 61.128.1.1 register  # spoke注册，注册关键字很重要（单播映射）
# S2
int tunnel 0/0/0
nhrp entry 172.16.1.1 61.128.1.1 register

# 4. 配置动态路由协议
# Hub
int tunnel 0/0/0
nhrp entry multicast dynamic  # hub（组播）
ospf network-type broadcast
ospf dr-priority 255
ospf enable 1 area 0
int lo 0
ospf en 1 a 0
ospf 1
a 0
q
# S1
int tunnel 0/0/0
ospf network-type broadcast
ospf dr-priority 0
ospf enable 1 area 0
int lo 0
ospf en 1 a 0
ospf 1
a 0
q
# S2
int tunnel 0/0/0
ospf network-type broadcast
ospf dr-priority 0
ospf enable 1 area 0
int lo 0
ospf en 1 a 0
ospf 1
a 0
q

# 5. ipsec（可选配）
# Hub
ike proposal 1
ike peer DSVPN v1
pre-shared-key simple qytang666
ike-proposal 1
ipsec proposal QYT  
encapsulation-mode transport
q                
ipsec profile DSVPN
ike-peer DSVPN
proposal QYT
q
inter tunnel 0/0/0
shutdown        #  【此处注意：先关闭全部Spoke，再关闭Hub】
ipsec profile DSVPN
undo shutown    # 【此处注意：先启动Hub，再逐个启动Spoke】
# S1
ike proposal 1
ike peer DSVPN v1
pre-shared-key simple qytang666
ike-proposal 1
ipsec proposal QYT  
encapsulation-mode transport
q                
ipsec profile DSVPN
ike-peer DSVPN
proposal QYT
q
inter tunnel 0/0/0
shutdown 
ipsec profile DSVPN
undo shutown
# S2
ike proposal 1
ike peer DSVPN v1
pre-shared-key simple qytang666
ike-proposal 1
ipsec proposal QYT  
encapsulation-mode transport
q                
ipsec profile DSVPN
ike-peer DSVPN
proposal QYT
q
inter tunnel 0/0/0
shutdown 
ipsec profile DSVPN
undo shutown
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;短路shortcut模式层次化树状设计&#34;&gt;短路（shortcut）模式（层次化（树状）设计）&lt;/h3&gt;
&lt;p&gt;大型DSVPN使用shortcut方式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# Hub/S1/S2
int t0/0/0
ospf network-type p2mp  # 此时Spoke所有路由的下一跳均为Hub

# Hub
nhrp redirect
# S1/S2
nhrp shortcut    # 此时使用nhrp进行优化，动态触发路由，Spoke之间数据传递第一个包会经过Hub转发，之后的数据是Spoke之间直通
&lt;/code&gt;&lt;/pre&gt;
">HCIE-IPSec专题(2020.07.31，第2专题)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-bgp-zhuan-ti-20200713/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AC%AC%E4%B8%80%E5%A0%82%E8%AF%BE-%E8%AF%BE%E7%A8%8B%E4%BB%8B%E7%BB%8D&#34;&gt;第一堂课--课程介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp&#34;&gt;BGP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB&#34;&gt;分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%8B%E7%BB%8D&#34;&gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9F%A5%E8%AF%86%E7%82%B9&#34;&gt;知识点&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%87%AA%E6%B2%BB%E7%B3%BB%E7%BB%9Fas&#34;&gt;自治系统AS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%89%B9%E5%BE%81&#34;&gt;BGP特征&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%82%BB%E5%B1%85%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%8F%91%E7%8E%B0&#34;&gt;邻居建立和发现&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E6%8A%A5%E6%96%87%E7%A7%8D%E7%B1%BB&#34;&gt;BGP报文种类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#open&#34;&gt;Open&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#keepalive&#34;&gt;KeepAlive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#update&#34;&gt;Update&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#notification&#34;&gt;Notification&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#route-refresh&#34;&gt;Route-refresh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B6%88%E6%81%AF%E7%9A%84%E5%BA%94%E7%94%A8&#34;&gt;消息的应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E4%BA%A7%E7%94%9F&#34;&gt;路由产生&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E6%8A%A5%E6%96%87ttl%E5%80%BC&#34;&gt;BGP报文TTL值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E9%BB%91%E6%B4%9E&#34;&gt;路由黑洞&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88&#34;&gt;解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%9A%84%E4%B8%8B%E4%B8%80%E8%B7%B3%E8%A7%84%E5%88%99&#34;&gt;BGP的下一跳规则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ebgp%E9%98%B2%E7%8E%AF&#34;&gt;eBGP防环&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6&#34;&gt;工作机制&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92&#34;&gt;BGP路由传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E5%8F%AF%E9%9D%A0%E7%9A%84%E8%B7%AF%E7%94%B1%E6%9B%B4%E6%96%B0&#34;&gt;BGP可靠的路由更新&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%8A%B6%E6%80%81%E6%9C%BA&#34;&gt;BGP状态机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93&#34;&gt;BGP的数据库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E7%AD%96%E7%95%A5%E5%BC%95%E6%93%8E%E5%92%8C%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9&#34;&gt;BGP策略引擎和路径选择&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%BB%E5%8A%A8%E4%B8%8E%E8%A2%AB%E5%8A%A8%E8%BF%9E%E6%8E%A5tcp&#34;&gt;主动与被动连接TCP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E8%B7%AF%E7%94%B1%E9%80%9A%E5%91%8A%E4%BC%A0%E9%80%92%E5%8E%9F%E5%88%99&#34;&gt;BGP路由（通告）传递原则&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7&#34;&gt;BGP路径属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#as%E5%8F%B7%E7%A0%81%E6%AC%BA%E9%AA%97&#34;&gt;AS号码欺骗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%A7%BB%E9%99%A4%E7%A7%81%E6%9C%89as%E5%8F%B7%E7%A0%81&#34;&gt;移除私有AS号码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E8%81%9A%E5%90%88%E6%B1%87%E6%80%BB&#34;&gt;路由聚合（汇总）&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB-2&#34;&gt;分类&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BF%87%E6%BB%A4%E7%AD%96%E7%95%A5&#34;&gt;过滤策略&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8E%9F%E5%AD%90%E8%81%9A%E5%90%88%E5%92%8C%E8%81%9A%E5%90%88%E8%80%85&#34;&gt;原子聚合和聚合者&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%9B%E5%A4%A7%E7%B1%BB%E5%B1%9E%E6%80%A7&#34;&gt;四大类属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E5%8F%8D%E5%B0%84%E5%92%8C%E8%81%94%E7%9B%9F&#34;&gt;BGP反射和联盟&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84-rfc2796&#34;&gt;路由反射 (RFC2796)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E7%A7%8D%E8%A7%92%E8%89%B2%E5%92%8C%E5%85%B3%E7%B3%BB&#34;&gt;三种角色和关系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E5%AE%A3%E5%91%8A%E5%8E%9F%E5%88%99&#34;&gt;路由反射宣告原则&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E7%B0%87-cluster&#34;&gt;路由反射簇 (Cluster)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%8F%8D%E5%B0%84%E7%8E%AF%E8%B7%AF%E9%98%B2%E6%AD%A2%E6%9C%BA%E5%88%B6&#34;&gt;路由反射环路防止机制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%81%94%E9%82%A6-rfc3065&#34;&gt;联邦 (RFC3065)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%81%94%E9%82%A6%E5%86%85as_path%E5%8F%98%E5%8C%96&#34;&gt;联邦内AS_Path变化&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%81%94%E7%9B%9F%E4%B8%8E%E5%8F%8D%E5%B0%84%E7%9A%84%E6%AF%94%E8%BE%83&#34;&gt;联盟与反射的比较&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E8%B7%AF%E5%BE%84%E5%B1%9E%E6%80%A7-2&#34;&gt;BGP路径属性&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E7%B1%BB-3&#34;&gt;分类&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AC%E8%AE%A4%E5%BF%85%E9%81%B5well-known-mondatory%E5%91%A8%E7%9F%A5%E5%BC%BA%E5%88%B6&#34;&gt;公认必遵Well-known mondatory（周知强制）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%AC%E8%AE%A4%E4%BB%BB%E6%84%8Fwell-known-discretionary%E5%91%A8%E7%9F%A5%E5%8F%AF%E9%80%89&#34;&gt;公认任意Well-known discretionary（周知可选）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E9%80%89%E5%8F%AF%E4%BC%A0%E9%80%92optional-transitive%E8%BF%87%E6%B8%A1&#34;&gt;可选可传递Optional transitive（过渡）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%AF%E9%80%89%E9%9D%9E%E5%8F%AF%E4%BC%A0%E9%80%92optional-non-transitive%E9%9D%9E%E8%BF%87%E6%B8%A1&#34;&gt;可选非可传递Optional non-transitive（非过渡）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E9%80%89%E8%B7%AF%E5%8E%9F%E5%88%99&#34;&gt;BGP选路原则&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%8E%E4%B8%BA&#34;&gt;华为&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%9D%E7%A7%91&#34;&gt;思科&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E5%BE%84%E9%80%89%E6%8B%A9%E8%BF%87%E7%A8%8Bcost-community&#34;&gt;自定义路径选择过程cost-community&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A4%9A%E5%AE%BF%E4%B8%BB%E7%BD%91%E7%BB%9C&#34;&gt;多宿主网络&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E4%BA%A7%E7%94%9F%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E7%9A%84%E6%96%B9%E6%A1%88&#34;&gt;BGP产生默认路由的方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B1%BB%E5%9E%8B&#34;&gt;类型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AD%96%E7%95%A5%E5%B7%A5%E5%85%B7as-path-access-list&#34;&gt;策略工具as-path access-list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%8C%96%E5%89%8D%E7%BC%80%E6%9B%B4%E6%96%B0&#34;&gt;优化前缀更新&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E9%98%BB%E5%B0%BCdampeningrfc2439&#34;&gt;路由阻尼dampening（RFC2439）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E6%B8%A9%E5%92%8C%E9%87%8D%E9%85%8D%E7%BD%AEkeep-all-routes&#34;&gt;BGP温和重配置(keep all routes)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%AF%E7%94%B1%E5%88%B7%E6%96%B0route-refresh&#34;&gt;路由刷新（route refresh）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%BA%E7%AB%99%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4orf&#34;&gt;出站路由过滤ORF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp%E9%99%84%E5%8A%A0%E8%B7%AF%E5%BE%84&#34;&gt;BGP附加路径&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#hot-potato-roouting&#34;&gt;hot-potato roouting&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#bgp-additional-path%E7%9A%84%E5%8A%9F%E8%83%BD&#34;&gt;BGP Additional Path的功能&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%83%A8%E7%BD%B2additional-path&#34;&gt;部署Additional Path&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9D%A2%E8%AF%95%E4%B8%8E%E6%80%BB%E7%BB%93&#34;&gt;面试与总结&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#3%E4%B8%AA%E9%80%89%E8%B7%AFweight-local-med&#34;&gt;3个选路（weight、local、med）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#3%E4%B8%AA%E9%98%B2%E7%8E%AForigin-as_path-next_hop&#34;&gt;3个防环（origin、as_path、next_hop）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E4%B8%AA%E5%8F%8D%E5%B0%84%E9%98%B2%E7%8E%AForiginator-id-cluster-list&#34;&gt;2个反射防环（originator-id、cluster-list）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#2%E4%B8%AA%E6%B1%87%E6%80%BBatomic-aggregate-aggregator&#34;&gt;2个汇总（Atomic-aggregate、aggregator）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#1%E4%B8%AA%E5%9B%A2%E4%BD%93community&#34;&gt;1个团体（community）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C&#34;&gt;实验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%80%E9%80%9A%E8%BF%87%E7%9B%B4%E8%BF%9E%E8%B7%AF%E7%94%B1%E6%96%B9%E5%BC%8F%E5%BB%BA%E7%AB%8Bebgp%E5%AF%B9%E7%AD%89%E4%BD%93&#34;&gt;实验一：通过直连路由方式建立eBGP对等体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E9%80%9A%E8%BF%87%E7%8E%AF%E5%9B%9E%E5%8F%A3%E6%96%B9%E5%BC%8F%E5%BB%BA%E7%AB%8Bebgp%E5%AF%B9%E7%AD%89%E4%BD%93&#34;&gt;实验二：通过环回口方式建立eBGP对等体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%89ibgp%E9%82%BB%E5%B1%85%E9%85%8D%E7%BD%AE%E5%AE%9E%E9%AA%8C%E5%90%8C%E6%97%B6%E6%9F%A5%E7%9C%8B%E8%B7%AF%E7%94%B1%E9%BB%91%E6%B4%9E&#34;&gt;实验三：iBGP邻居配置实验（同时查看路由黑洞）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%85%A8%E4%BA%92%E8%81%94%E7%9A%84%E6%96%B9%E5%BC%8F%E8%A7%A3%E5%86%B3%E8%B7%AF%E7%94%B1%E9%BB%91%E6%B4%9E&#34;&gt;实验四：使用全互联的方式解决路由黑洞&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%94%E4%BF%AE%E6%94%B9%E4%B8%8B%E4%B8%80%E8%B7%B3%E5%B1%9E%E6%80%A7&#34;&gt;实验五：修改下一跳属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%85%ADbgp%E7%9A%84%E4%B8%8B%E4%B8%80%E8%B7%B3%E4%B8%8D%E6%94%B9%E5%8F%98%E5%9C%BA%E6%99%AF&#34;&gt;实验六：BGP的下一跳不改变场景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%83bgp-asbr%E4%B8%8B%E4%B8%80%E8%B7%B3%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94&#34;&gt;实验七：BGP ASBR下一跳方案对比&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%85%AB%E5%A4%9A%E7%82%B9%E6%8E%A5%E5%85%A5%E7%9A%84%E4%B8%8B%E4%B8%80%E8%B7%B3&#34;&gt;实验八：多点接入的下一跳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B9%9D%E9%83%A8%E7%BD%B2bgp%E5%AF%B9%E7%AD%89%E4%BD%93%E7%BB%84&#34;&gt;实验九：部署BGP对等体组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E9%83%A8%E7%BD%B2%E5%9F%BA%E4%BA%8E%E5%AF%B9%E7%AD%89%E4%BD%93%E7%BB%84%E7%9A%84%E5%8A%A8%E6%80%81%E9%82%BB%E5%B1%85%E6%80%9D%E7%A7%91&#34;&gt;实验十：部署基于对等体组的动态邻居（思科）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%80as%E6%AC%BA%E9%AA%97&#34;&gt;实验十一：AS欺骗&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%8C%E7%A7%BB%E9%99%A4%E7%A7%81%E6%9C%89as%E5%8F%B7%E7%A0%81&#34;&gt;实验十二：移除私有AS号码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%89%E8%B7%AF%E7%94%B1%E8%87%AA%E5%8A%A8%E8%81%9A%E5%90%88&#34;&gt;实验十三：路由自动聚合&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E5%85%85%E6%80%9D%E7%A7%91%E8%AE%BE%E5%A4%87%E4%B8%80%E8%88%AC%E4%B8%8D%E5%81%9A%E8%87%AA%E5%8A%A8%E8%81%9A%E5%90%88%E8%80%8C%E4%BD%BF%E7%94%A8%E6%B5%81%E9%87%8F%E6%B8%85%E6%B4%97&#34;&gt;补充：思科设备一般不做自动聚合，而使用流量清洗&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%9B%9B%E6%89%8B%E5%8A%A8%E8%81%9A%E5%90%88%E9%AA%8C%E8%AF%81%E8%B5%B7%E6%BA%90%E4%BB%A3%E7%A0%81%E7%9A%84%E7%BB%A7%E6%89%BF&#34;&gt;实验十四：手动聚合，验证起源代码的继承&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%BA%94%E4%B8%BA%E8%81%9A%E5%90%88%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE%E5%B1%9E%E6%80%A7&#34;&gt;实验十五：为聚合路由设置属性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%AD%E9%AA%8C%E8%AF%81rr%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84ibgp%E8%B7%AF%E7%94%B1%E4%BC%A0%E9%80%92&#34;&gt;实验十六：验证RR环境下的iBGP路由传递&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B8%83%E7%90%86%E8%A7%A3%E8%B5%B7%E6%BA%90%E8%80%85id%E5%92%8Ccluster-id%E7%9A%84%E4%BD%9C%E7%94%A8&#34;&gt;实验十七：理解起源者ID和Cluster-id的作用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E5%85%ABbgp%E8%81%94%E9%82%A6&#34;&gt;实验十八：BGP联邦&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E5%8D%81%E4%B9%9D%E5%9B%A2%E4%BD%93%E5%B1%9E%E6%80%A7no-export&#34;&gt;实验十九：团体属性no-export&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E5%9B%A2%E4%BD%93%E5%B1%9E%E6%80%A7no-export-subconfedlocal-as&#34;&gt;实验二十：团体属性no-export-subconfed(local-as)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E4%B8%80%E5%9B%A2%E4%BD%93%E5%B1%9E%E6%80%A7no-advertise&#34;&gt;实验二十一：团体属性no-advertise&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E4%BA%8C%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9B%A2%E4%BD%93%E5%B1%9E%E6%80%A7%E5%92%8Cmed&#34;&gt;实验二十二：设置自定义团体属性和MED&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%A1%88a&#34;&gt;方案A&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%A1%88b&#34;&gt;方案B&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E4%B8%89%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E6%AF%94%E8%BE%83%E6%9D%83%E9%87%8D%E5%80%BC&#34;&gt;实验二十三：路由选择-比较权重值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E5%9B%9B%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E6%AF%94%E8%BE%83%E6%9C%AC%E5%9C%B0%E4%BC%98%E5%85%88%E7%BA%A7&#34;&gt;实验二十四：路由选择-比较本地优先级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E4%BA%94%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E8%B5%B7%E6%BA%90&#34;&gt;实验二十五：路由选择-起源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E5%85%AD%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-as-path&#34;&gt;实验二十六：路由选择-as-path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E4%B8%83%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E5%88%B0bgp%E6%9B%B4%E6%96%B0%E6%BA%90igp%E5%BC%80%E9%94%80%E5%B0%8F%E7%9A%84%E8%A2%AB%E4%BC%98%E9%80%89&#34;&gt;实验二十七：路由选择-到BGP更新源IGP开销小的被优选&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E5%85%AB%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9-%E5%BC%80%E5%90%AF%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&#34;&gt;实验二十八：路由选择-开启负载均衡&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%BA%8C%E5%8D%81%E4%B9%9D%E4%BA%A7%E7%94%9F%E9%BB%98%E8%AE%A4%E8%B7%AF%E7%94%B1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F&#34;&gt;实验二十九：产生默认路由的三种方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%89%E5%8D%81%E4%B8%80as-path%E6%8E%A7%E5%88%B6%E5%88%97%E8%A1%A8&#34;&gt;实验三十一：as-path控制列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%89%E5%8D%81%E4%BA%8C%E5%BA%94%E7%94%A8%E6%B8%A9%E5%92%8C%E9%87%8D%E9%85%8D%E7%BD%AE&#34;&gt;实验三十二：应用温和重配置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%89%E5%8D%81%E4%B8%89%E5%87%BA%E7%AB%99%E8%B7%AF%E7%94%B1%E8%BF%87%E6%BB%A4orf&#34;&gt;实验三十三：出站路由过滤ORF&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;第一堂课-课程介绍&#34;&gt;第一堂课--课程介绍&lt;/h1&gt;
&lt;p&gt;QCIE：思科和华为设备操作和特性一起讲的&lt;br&gt;
课程包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一堂课：BGP&lt;/li&gt;
&lt;li&gt;第二堂课：DNA Center（SD-Access）（思科专属）&lt;/li&gt;
&lt;li&gt;第三堂课：IPSec
&lt;ul&gt;
&lt;li&gt;DM VPN（思科）&lt;/li&gt;
&lt;li&gt;DS VPN（华为）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第四堂课：组播Multicast&lt;/li&gt;
&lt;li&gt;第五堂课：SD-WAN（思科专属）&lt;/li&gt;
&lt;li&gt;第六堂课：MPLS VPN&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;bgp&#34;&gt;BGP&lt;/h1&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;p&gt;按照工作范围划分，动态路由协议，分为 IGP、EGP&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IGP：OSPF、EIGRP、ISIS&lt;/li&gt;
&lt;li&gt;EGP：EGP、BGP。 当然现在EGP已经完成了历史使命，BGP是目前唯一一个在网运行的EGP。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;BGP：边界网关协议，主要工作在AS和AS之间，AS内部也可以运行，但通常都是在网络AS出口设备之间运行，主要功能是在AS之间交换路由信息，执行基于策略的选路。&lt;br&gt;
其度量办法和IGP有本质上的不同，BGP还拥有强大的路由承载能力，能够在互联网上传递数百万条路由。&lt;/p&gt;
&lt;h2 id=&#34;知识点&#34;&gt;知识点&lt;/h2&gt;
&lt;h3 id=&#34;自治系统as&#34;&gt;自治系统AS&lt;/h3&gt;
&lt;p&gt;由同一个技术管理机构管理、使用统一选路策略的一些路由器的集合。&lt;br&gt;
自治系统内部的路由协议——IGP，自治系统之间的路由协议——EGP。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IGP和BGP的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IGP主要解决数据的转发，BGP主要解决路由的传递和控制&lt;br&gt;
IGP，运行于AS内部的路由协议，主要有: RIP, OSPF及ISIS。IGP着重于发现和计算路由&lt;br&gt;
EGP，运行于AS之间的路由协议，现通常都是指BGP。BGP着重于控制路由的传播和选择最优的路由。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;AS编号，两字节，1-65535 ，其中&lt;strong&gt;64512-65535是私有AS号码&lt;/strong&gt;。目前的BGP实现已经可以支持四字节的AS号码。&lt;br&gt;
AS号码在设备上有&lt;strong&gt;两种显示方式&lt;/strong&gt;：十进制数字、点分十进制&lt;/p&gt;
&lt;h3 id=&#34;bgp特征&#34;&gt;BGP特征&lt;/h3&gt;
&lt;p&gt;BGP通过在路由上面附加多种路由属性（路径属性），以这些属性达到对路由更新传递、路径决策方面的操控目的。灵活性，可靠性（TCP），稳定性和收敛速度可调节，BGP是增量更新的、没有周期更新（通过BGP协议传递网络信息的路径通常比较远），支持VLSM、CIDR，通过一些规则来实现路由传递的环路预防。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BGP是外部路由协议，用来在AS之间传递路由信息&lt;/li&gt;
&lt;li&gt;是一种增强的距离矢量路由协议
&lt;ul&gt;
&lt;li&gt;可靠的路由更新机制&lt;/li&gt;
&lt;li&gt;丰富的Metric度量方法&lt;/li&gt;
&lt;li&gt;从设计上避免了环路的发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为路由附带属性信息&lt;/li&gt;
&lt;li&gt;支持CIDR（无类别域间选路）&lt;/li&gt;
&lt;li&gt;丰富的路由过滤和路由策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;邻居建立和发现&#34;&gt;邻居建立和发现&lt;/h3&gt;
&lt;p&gt;BGP使用TCP的179号端口，侦听179端口，源端口为随机的高位端口&lt;br&gt;
建立邻居的&lt;strong&gt;基本条件&lt;/strong&gt;：IP可达，TCP端口可达。&lt;br&gt;
BGP单播建立邻居，也就意味着，大多数情况下，需要管理员手工的指定好邻居（peer，对等体）是谁。&lt;br&gt;
&lt;strong&gt;路由更新&lt;/strong&gt;：只发送增量路由（增加、修改、删除的路由信息），大大减少了传播路由时所占用的带宽，适用于Internet上传播大量的路由信息&lt;/p&gt;
&lt;h3 id=&#34;bgp报文种类&#34;&gt;BGP报文种类&lt;/h3&gt;
&lt;p&gt;运行BGP的路由器称之为BGP Speaker，它们之间将会交换五种类型的报文，其中Open，Keeplive以及Notification报文用于邻居关系的建立和维护。&lt;br&gt;
&lt;code&gt;前4种消息是在RFC4271中定义的，而Refresh的消息则是在RFC2918中定义的&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594954867397.png&#34; alt=&#34;BGP报文头&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Marker（标记）：16字节，固定为1&lt;/li&gt;
&lt;li&gt;Length（长度）：两字节无符号整数。指定了消息的全长，包括头部&lt;/li&gt;
&lt;li&gt;Type（类型）：1 字节，指示报文类型，如OPEN、UPDATE报文等
&lt;ul&gt;
&lt;li&gt;1 – OPEN&lt;/li&gt;
&lt;li&gt;2 – UPDATE&lt;/li&gt;
&lt;li&gt;3 – NOTIFICATION&lt;/li&gt;
&lt;li&gt;4 – KEEPALIVE&lt;/li&gt;
&lt;li&gt;5 – REFRESH&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;open&#34;&gt;Open&lt;/h4&gt;
&lt;p&gt;负责和对等体建立邻居关系。&lt;br&gt;
主要包括BGP版本，AS号等信息。试图建立BGP邻居关系的两个路由器在建立了TCP会话之后开始交换OPEN信息以确认能否形成邻居关系。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594954990823.png&#34; alt=&#34;Open&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Version：BGP的版本号。对于BGPv4来说，其值为4&lt;/li&gt;
&lt;li&gt;My Autonomous System：本地AS编号。通过比较两端的AS编号可以确定是EBGP连接还是IBGP连接&lt;/li&gt;
&lt;li&gt;Hold Time：在建立对等体关系时两端要协商Hold time，并保持一致。如果两端所配置的Hold time时间不同，则BGP会&lt;strong&gt;选择较小的值&lt;/strong&gt;作为协商的结果。如果在这个时间内未收到对端发来的Keepalive消息，则认为BGP连接中断&lt;/li&gt;
&lt;li&gt;BGP Identifier：BGP路由器的Router ID，以IP地址的形式表示，用来识别BGP路由器。在VRP5.30系统中，如果没有通过命令router id进行配置，则按照如下规则进行选择：优选Loopback接口地址中&lt;strong&gt;最大的地址&lt;/strong&gt;作为Router ID，如果没有Loopback接口配置了IP地址，则从其它配置了IP地址的物理接口中选择一个最大IP地址的作为Router ID&lt;/li&gt;
&lt;li&gt;Opt Parm Len（Optional Parameters Length）：可选参数的长度。如果为0则没有可选参数&lt;/li&gt;
&lt;li&gt;Optional Parameters：是一个可选参数用于BGP验证或多协议扩展（Multiprotocol Extensions）等功能。每一个参数为一个（Parameter Type-Parameter Length-Parameter Value）三元组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;keepalive&#34;&gt;KeepAlive&lt;/h4&gt;
&lt;p&gt;该消息在对等体之间周期性（60s）地发送，检测TCP的连通性，用以维护连接。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594955204497.png&#34; alt=&#34;KeepAlive&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
KeepAlive报文主要用于对等体路由器间的运行状态以及链路的可用性确认。KeepAlive 报文的组成&lt;strong&gt;只包括一个BGP数据报头&lt;/strong&gt;。 KeepAlive 消息在对等体之间的&lt;strong&gt;交换频率以保证对方保持定时器不超时为限&lt;/strong&gt;。&lt;br&gt;
缺省情况下，发送&lt;strong&gt;KeepAlive的时间间隔为60秒&lt;/strong&gt;，&lt;strong&gt;Hold Time是180秒&lt;/strong&gt;。每次从邻居处接收到KeepAlive 报文将重置Hold Time定时器，如果Hold Time定时器超时，就认为对等体Down掉。&lt;br&gt;
对等体在接收到Open消息后，将发送Keepalive消息确认并保持连接的有效性。确认后，对等体间可以进行Update、Notification、Keepalive和Route-refresh消息的交换。&lt;/p&gt;
&lt;h4 id=&#34;update&#34;&gt;Update&lt;/h4&gt;
&lt;p&gt;该消息被用来在BGP对等体之间传递路由信息（更新、撤销）。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594955311891.png&#34; alt=&#34;Update&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;撤销路由部分：
&lt;ul&gt;
&lt;li&gt;Withdrawn Routes Length ：（2字节无符号整数） &lt;strong&gt;不可达路由长度&lt;/strong&gt;，表示Withdrawn Routes字段的数据长度。如果Withdrawn Routes Length字段数值为0，则表示Withdrawn Routes字段没有任何数据，在UPDATE消息中不会被显示&lt;/li&gt;
&lt;li&gt;Withdrawn Routes ：（变长） 撤销路由。该字段包括一系列的IP地址前缀信息，以&amp;lt;length, prefix&amp;gt;的格式来表示，比如&amp;lt;19,198.18.160.0&amp;gt;表示一个&lt;code&gt;198.18.160.0 255.255.224.0&lt;/code&gt;的网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;更新路由部分：
&lt;ul&gt;
&lt;li&gt;Path Attribute Length ：（2字节无符号整数）&lt;strong&gt;路由属性长度&lt;/strong&gt;，表示Path Attribute字段的数据长度。如果Path Attribute Length数值为0，则表示Path Attribute字段没有任何数据，在UPDATE消息中不会被显示&lt;/li&gt;
&lt;li&gt;Path Attributes ：（变长） 路径属性。每个路径属性都是由三元组所组成：&amp;lt;attribute type, attribute length, attribute value&amp;gt;&lt;/li&gt;
&lt;li&gt;Network Layer Reachability Information ：（变长） 网络可达信息。包括一系列的IP地址前缀。格式与撤消路由字段一样&amp;lt;length, prefix&amp;gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;最小UPDATE消息&lt;/strong&gt;的长度为23个字节(19字节的报文头+2字节的撤消路由长度+2字节的路径属性长度)。这样的UPDATE消息被称之为&lt;strong&gt;End-of-RIB，用于BGP GR&lt;/strong&gt;。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一条UPDATE消息可以&lt;strong&gt;发布多条具有相同路由属性的可达路由&lt;/strong&gt;，这些路由可共享一组路由属性。所有包含在一个给定的Update消息里的路由属性适用于该Update消息中的NLRI(网络层可达性信息)字段里的所有目的地（用IP前缀表示）。&lt;/li&gt;
&lt;li&gt;一条UPDATE消息可以&lt;strong&gt;撤销多条不可达路由&lt;/strong&gt;。每一个路由通过目的地（用IP前缀表示），清楚的定义了BGP Speaker之间先前通告过的路由。&lt;/li&gt;
&lt;li&gt;一条UPDATE消息可以&lt;strong&gt;只用于撤销路由&lt;/strong&gt;，这样就不需要包括路径属性或者网络可达信息。相反，也可以&lt;strong&gt;只用于通告可达路由&lt;/strong&gt;，就不需要携带Withdrawn Routes了。&lt;strong&gt;不可即更新又撤销路由&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;notification&#34;&gt;Notification&lt;/h4&gt;
&lt;p&gt;当BGP Speaker检测到错误的时候，就发送该消息给对等体（报错，用于拆除连接，释放资源）。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594962555808.png&#34; alt=&#34;Notification&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Errorcode：错误码。1字节长的字段。每个不同的错误都使用唯一的代码表示，而每一个错误码都可以拥有一个或多个错误子码，但如果某些错误码并不存在错误子码的话，则该错误子码字段以全0表示。&lt;/li&gt;
&lt;li&gt;Errsubcode：错误子码&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594964879096.png&#34; alt=&#34;错误码和错误子码&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;route-refresh&#34;&gt;Route-refresh&lt;/h4&gt;
&lt;p&gt;用来通知对等体自己支持路由刷新能力。&lt;code&gt;对等体一端不支持路由刷新的能力，如果强制刷新，则会重新建立邻居&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594962609077.png&#34; alt=&#34;Route-refresh&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AFI（Address Family Identifier）：地址族标识符（2字节）&lt;/li&gt;
&lt;li&gt;Res.（Reserved field）：保留区域（1字节），发送方应将其设置为0，接收方应当忽略该区域的信息&lt;/li&gt;
&lt;li&gt;SAFI（Subsequent Address Family Identifier）：子地址族标识符（8字节）。&lt;br&gt;
在所有BGP路由器使能Route-refresh能力的情况下，如果BGP的入口路由策略发生了变化，本地BGP路由器会向对等体发布Route-refresh消息，&lt;strong&gt;收到此消息的对等体会将其路由信息重新发给本地BGP路由器&lt;/strong&gt;。这样，可以在不中断BGP连接的情况下，对BGP路由表进行动态刷新，并应用新的路由策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息的应用&#34;&gt;消息的应用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;BGP使用TCP建立连接，本地监听端口为179。和TCP连接建立相同，BGP连接的建立也要经过一系列的对话和握手。TCP通过握手协商通告其端口等参数，BGP的握手协商的参数有：BGP版本、BGP连接保持时间、本地的路由器标识（Router ID）、授权信息等。这些信息都在Open消息中携带。&lt;/li&gt;
&lt;li&gt;BGP连接建立后，如果有路由需要发送则发送Update消息通告对端。Update消息发布路由时，还要携带此路由的路由属性，用以帮助对端BGP协议选择最优路由。&lt;/li&gt;
&lt;li&gt;在本地BGP路由变化时，要通过Update消息来通知BGP对等体。&lt;/li&gt;
&lt;li&gt;经过一段时间的路由信息交换后，本地BGP和对端BGP都无新路由通告，趋于稳定状态。此时要定时发送KEEPALIVE消息以保持BGP连接的有效性。对于本地BGP，如果在保持时间内，未收到任何对端发来的BGP消息，就认为此BGP连接已经中断，将断开此BGP连接，并删除所有从该对等体学来的BGP路由。&lt;/li&gt;
&lt;li&gt;当本地BGP在运行中发现错误时，要发送NOTIFICATION消息通告BGP对等体&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由产生&#34;&gt;路由产生&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IGP
&lt;ul&gt;
&lt;li&gt;汇总，但需要有明细&lt;/li&gt;
&lt;li&gt;network既能激活接口又能产生接口所在网络的路由&lt;/li&gt;
&lt;li&gt;重分布&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BGP
&lt;ul&gt;
&lt;li&gt;network（精确的将一条IGP路由放入BGP table）&lt;/li&gt;
&lt;li&gt;原子聚合（汇总，需要至少一条明细的存在）&lt;/li&gt;
&lt;li&gt;路由注入（路由拆分，需要聚合路由的存在）&lt;/li&gt;
&lt;li&gt;重分布&lt;br&gt;
&lt;code&gt;注意，BGP的条目，下一跳IP地址在IGP路由表中可查询到，并且可达（但其实BGP并不检测到底能不能通），该条目才能被BGP的选路算法优选（路由计算）&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bgp报文ttl值&#34;&gt;BGP报文TTL值&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;eBGP&lt;/strong&gt;报文的TTL &lt;strong&gt;默认是1&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;iBGP&lt;/strong&gt;报文的TTL &lt;strong&gt;默认是255&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;路由黑洞&#34;&gt;路由黑洞&lt;/h3&gt;
&lt;p&gt;简单的说，它会默默的将数据包丢弃，使所有数据包有去无回，主要原因是&lt;strong&gt;没有相应的路由&lt;/strong&gt;，本质是&lt;strong&gt;IP逐跳转发导致数据包丢失&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://fqj.myds.me:4433/post/05-bgp20200518/&#34;&gt;路由黑洞&lt;/a&gt;&lt;br&gt;
在本课程拓扑中，R1和R4建立iBGP对等体，R4上&lt;code&gt;ping -a 4.4.4.4 1.1.1.1&lt;/code&gt;不通&lt;br&gt;
【R4上bgp路由表中1.1.1.1的优选路由的下一跳为11.1.1.1，但是&lt;code&gt;show ip cef&lt;/code&gt;的结果为1.1.1.1的下一跳为10.1.34.3，出口为g0/0/2，主要原因是OSPF选择路由的方式是基于带宽的，导致R4最终路由选择下一跳为R3，但是R3上没有11.1.1.1的路由】&lt;/p&gt;
&lt;h4 id=&#34;解决方案&#34;&gt;解决方案&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;将BGP引入IGP中
&lt;ul&gt;
&lt;li&gt;使用情景：AS之间通过BGP传递&lt;strong&gt;少量经过聚合&lt;/strong&gt;的前缀。如果是把来自IBGP的路由引入到IGP，则需要开关。&lt;br&gt;
&lt;code&gt;iBGP对等体之间的转发路径上出现路由黑洞，可以使用全互联、MPLS、路由反射器RR解决&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全互联
&lt;ul&gt;
&lt;li&gt;使用情景：适用于对等体数量较少的网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MPLS
&lt;ul&gt;
&lt;li&gt;更加适用于新的网络&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路由反射器RR
&lt;ul&gt;
&lt;li&gt;本质是一种针对与iBGP全互联的优化方案&lt;br&gt;
&lt;code&gt;iBGP的水平分割规则：来自iBGP对等体的路由，不能传递给iBGP对等体 。路由反射器是专门破坏这个规则的&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bgp的下一跳规则&#34;&gt;BGP的下一跳规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BGP speaker在向外更新路由的时候，如果对方是&lt;strong&gt;iBGP对等体&lt;/strong&gt;，默认&lt;strong&gt;不修改&lt;/strong&gt;下一跳属性&lt;/li&gt;
&lt;li&gt;BGP speaker在向外更新路由的时候，如果对方是&lt;strong&gt;eBGP对等体&lt;/strong&gt;，默认将会&lt;strong&gt;修改下一跳&lt;/strong&gt;属性为自身更新源地址&lt;br&gt;
&lt;code&gt;修正下一跳，解决下一跳不可达的问题&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;操作系统预定义了两个BGP下一跳属性的修改行为&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;code&gt;下一跳自我&lt;/code&gt;【通常，会在ASBR上针对内部的iBGP对等体应用下一跳自我】&lt;/li&gt;
&lt;li&gt;&lt;code&gt;下一跳不改变&lt;/code&gt;【多用于域间 MPLS VPN】&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ebgp防环&#34;&gt;eBGP防环&lt;/h3&gt;
&lt;p&gt;eBGP防环靠自治系统&lt;strong&gt;路径列表&lt;/strong&gt;属性。BGP会在将路由传递给eBGP邻居的时候，在列表的最前面加上自身的AS号码，当收到一个来自eBGP邻居的路由时，将会检测这个属性，如果包含本地AS号码，则拒收该路径上来的路由。&lt;/p&gt;
&lt;h3 id=&#34;工作机制&#34;&gt;工作机制&lt;/h3&gt;
&lt;h4 id=&#34;bgp路由传递&#34;&gt;BGP路由传递&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;BGP通过单播方式构建TCP会话以建立BGP邻居，并保持该会话&lt;/li&gt;
&lt;li&gt;建立连接的两台设备互为对等体，为了确保两边设备的BGP进程都正在运行，要求两端的设备通过该TCP连接周期性的发送KeepAlive消息，以向对端确认自己还存活&lt;/li&gt;
&lt;li&gt;BGP通过定义策略或者规则来穿越AS，所以BGP是as-by-as的而非IGP的基于路由器&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;bgp可靠的路由更新&#34;&gt;BGP可靠的路由更新&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;传输协议：TCP，端口号179&lt;/li&gt;
&lt;li&gt;无需周期性更新&lt;/li&gt;
&lt;li&gt;路由更新：只发送增量路由（增加、修改、删除的路由信息），大大减少了传播路由时所占用的带宽，适用于在Internet上传播大量的路由信息&lt;/li&gt;
&lt;li&gt;周期性（60s）发送keepAlive报文检测TCP的连通性&lt;br&gt;
&lt;code&gt;TCP路由传递，基于高层的路由服务，不必依赖IP支持。增量更新减少资源占用，keepalive保持TCP会话&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bgp状态机&#34;&gt;BGP状态机&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1594965930073.png&#34; alt=&#34;BGP状态机&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Idle：&lt;br&gt;
BGP连接的&lt;strong&gt;第一个状态&lt;/strong&gt;。在空闲状态，BGP在等待一个启动事件。启动事件出现以后，BGP初始化资源，复位连接重试计时器（Connect-Retry），
&lt;ul&gt;
&lt;li&gt;发起一条TCP连接，同时转入Connect（连接）状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Connect：&lt;br&gt;
在此状态，BGP&lt;strong&gt;发起第一个TCP连接&lt;/strong&gt;，
&lt;ul&gt;
&lt;li&gt;如果连接重试计时器超时，就重新发起TCP连接，并继续保持在Connect状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接成功，就转入OpenSent状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接失败，就转入Active状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Active：&lt;br&gt;
在此状态，BGP总是在&lt;strong&gt;试图建立TCP连接&lt;/strong&gt;，
&lt;ul&gt;
&lt;li&gt;如果连接重试计时器（Connect-Retry）超时，就退回到Connect状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接成功，就转入OpenSent状态，&lt;/li&gt;
&lt;li&gt;如果TCP连接失败，就继续保持在Active状态，并继续发起TCP连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenSent：&lt;br&gt;
在此状态，&lt;strong&gt;TCP连接已经建立&lt;/strong&gt;，BGP也&lt;strong&gt;已经发送了第一个Open报文&lt;/strong&gt;，剩下的工作，BGP就在&lt;strong&gt;等待其对等体发送Open报文&lt;/strong&gt;。并对收到的Open报文进行正确性检查，
&lt;ul&gt;
&lt;li&gt;如果有错误，系统就会发送一条出错通知消息并退回到Idle状态，&lt;/li&gt;
&lt;li&gt;如果没有错误，BGP就开始发送Keepalive报文，并复位Keepalive计时器，开始计时。&lt;strong&gt;同时转入OpenConfirm状态。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OpenConfirm：&lt;br&gt;
在OpenConfirm状态，BGP&lt;strong&gt;等待一个Keepalive报文，同时复位保持计时器&lt;/strong&gt;，
&lt;ul&gt;
&lt;li&gt;如果收到了一个Keepalive报文，就转入Established阶段，BGP邻居关系就建立起来了。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Established：&lt;br&gt;
在Established状态，BGP邻居关系&lt;strong&gt;已经建立&lt;/strong&gt;，这时，BGP将和它的邻居们交换Update报文，同时复位保持计时器。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;除Idle状态以外的其它五个状态&lt;strong&gt;出现任何Error的时候，BGP状态机就会退回到Idle状态&lt;/strong&gt;。&lt;br&gt;
在BGP对等体建立的过程中，&lt;strong&gt;通常可见的三个状态是：Idle、Active、Established&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Idle状态下，BGP拒绝任何进入的连接请求，是BGP初始状态。&lt;br&gt;
Active状态下，BGP将尝试进行TCP连接的建立，是BGP的中间状态。&lt;br&gt;
Established状态下，BGP对等体间可以交换Update报文、Route-refresh报文、Keepalive报文和Notification报文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;BGP对等体双方的状态必须都为Established，BGP邻居关系才能成立，双方通过Update报文交换路由信息&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;bgp的数据库&#34;&gt;BGP的数据库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IP路由表 (IP-RIB)：全局路由信息库，包括所有IP路由信息&lt;code&gt;dis ip rou&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;邻居表：对等体邻居清单列表&lt;code&gt;dis bgp peer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BGP路由表 (Loc-RIB)：BGP路由信息库，包括本地BGP Speaker选择的路由信息&lt;code&gt;dis bgp rou&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Adj-RIB-In：对等体宣告给本地Speaker的未处理的路由信息库&lt;/li&gt;
&lt;li&gt;Adj-RIB-Out：本地Speaker宣告给指定对等体的路由信息库&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bgp策略引擎和路径选择&#34;&gt;BGP策略引擎和路径选择&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1594967902505.png&#34; alt=&#34;BGP路由信息处理&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;本地被优选的路由，才允许更新给对等体&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;主动与被动连接tcp&#34;&gt;主动与被动连接TCP&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;neighbor 11.1.1.1 transport connection-mode [active|passive] # 思科&lt;/code&gt;&lt;br&gt;
执行&lt;code&gt;peer 11.1.1.1 lister-only&lt;/code&gt;命令之后，则对等体不会主动发起连接，会导致已经建立的邻居会话中断，本端等待对端发起连接请求之后，重新建立邻居会话。&lt;/p&gt;
&lt;h3 id=&#34;bgp路由通告传递原则&#34;&gt;BGP路由（通告）传递原则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;连接建立时，BGP Speaker只能把本身用的&lt;strong&gt;最优路由&lt;/strong&gt;通告给对等体；多条路径时，BGP Speaker只选择&lt;strong&gt;最优路由&lt;/strong&gt;放入路由表&lt;/li&gt;
&lt;li&gt;BGP Speaker从&lt;strong&gt;eBGP&lt;/strong&gt;获得的路由会向它&lt;strong&gt;所有的BGP对等体&lt;/strong&gt;（包括eBGP和iBGP）通告&lt;br&gt;
&lt;code&gt;通告给eBGP对等体时首先要保证的是AS号码不能出环，否则即使通告也会被过滤掉&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BGP Speaker从&lt;strong&gt;iBGP&lt;/strong&gt;获得的路由&lt;strong&gt;不会通告给它的iBGP&lt;/strong&gt;邻居&lt;/li&gt;
&lt;li&gt;BGP Speaker从&lt;strong&gt;iBGP&lt;/strong&gt;获得的路由是否通告给它的&lt;strong&gt;eBGP对等体要依IGP和BGP同步的情况&lt;/strong&gt;来&lt;br&gt;
决定&lt;br&gt;
【BGP与IGP同步的概念：BGP Speaker不将从iBGP对等体获得的路由信息通告给它的eBGP对等体，&lt;strong&gt;除非该路由信息也能通过IGP获得&lt;/strong&gt;】&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bgp路径属性&#34;&gt;BGP路径属性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下一跳：决定如何转发、路由优选的前提&lt;/li&gt;
&lt;li&gt;起源代码：标识路由出身的，有优劣之分&lt;/li&gt;
&lt;li&gt;as-path（AS路径）：eBGP防环的关键、路由的传递路径&lt;br&gt;
以上三个属性，是BGP的&lt;strong&gt;公认强制属性&lt;/strong&gt;，即&lt;strong&gt;所有的BGP前缀，必须拥有这三个属性&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;as号码欺骗&#34;&gt;AS号码欺骗&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对等体采用伪AS号与本端建立连接，常用于运营商修改网络部署的场景，即&lt;strong&gt;用于网络变更、DM VPN（动态VPN）部署&lt;/strong&gt;等&lt;/li&gt;
&lt;li&gt;如果本端使用伪AS号码与对端建立eBGP邻居，那么发送给邻居的AS_Path列表就只携带伪AS号码（华为，即华为只有完全欺骗模式）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 思科
neighbor 55.1.1.1 local-as 65535  # 欺骗邻居，伪装自己是 as 65535
no-prepend # 从eBGP邻居收到的路由不增加虚假AS号码
replace-as   # 在向eBGP更新路由的时候，将本地真实AS号码替换为虚假AS号码
dual-as   # 接收来自eBGP对等体的连接，真实AS、虚假AS均可
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;移除私有as号码&#34;&gt;移除私有AS号码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;运营商&lt;strong&gt;为没有公网AS号码但是又想用BGP协议的用户提供服务&lt;/strong&gt;。通常来讲，为了保障BGP的路径决策正确，或者其它因素，应当维持AS路径列表长度。常见的做法，就是&lt;strong&gt;将用户的AS号码替换为SP边界的AS号码&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;公有AS号可以直接在Internet上使用，私有AS号不能直接发布到Internet上，否则造成环路现象，因此&lt;strong&gt;私有AS号仅在内部路由域中使用&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;配置命令后，如果BGP路由信息的as_path属性中&lt;strong&gt;只包含私有AS号，BGP就会删除这些私有AS号&lt;/strong&gt;，然后再将路由信息发不出去。
&lt;ul&gt;
&lt;li&gt;以下两种情况，配置命令后，BGP不会删除私有AS号：
&lt;ul&gt;
&lt;li&gt;路由的as_path属性中&lt;strong&gt;含有对端的AS号时&lt;/strong&gt;，这种情况下删除私有AS号可能会造成路由环路&lt;/li&gt;
&lt;li&gt;as_path列表中同时&lt;strong&gt;含有公有AS号和私有AS号&lt;/strong&gt;，该列表表明路由已经经过公网，如果删除私有AS号，可能会造成转发错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;路由聚合汇总&#34;&gt;路由聚合（汇总）&lt;/h3&gt;
&lt;p&gt;路由聚合是将&lt;strong&gt;多条路由合并的机制&lt;/strong&gt;，它通过只向对等体发送聚合后的路由而不发送所有的具体路由的方法，&lt;strong&gt;减小路由表的规模&lt;/strong&gt;，并且被聚合的路由如果发生路由震荡，也不会对网络造成影响，从而提高网络的&lt;strong&gt;稳定性&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;聚合路由属性继承&lt;/strong&gt;：as-path（as-set）、origin code、团体&lt;/p&gt;
&lt;h4 id=&#34;分类-2&#34;&gt;分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;自动聚合&lt;br&gt;
对BGP引入的子网路由进行自然掩码聚合。配置自动聚合后，生成聚合后的自然网段路由，而&lt;strong&gt;原引入的子网路由被抑制&lt;/strong&gt;，不会被优选和发布给BGP邻居。&lt;br&gt;
&lt;code&gt;仅对**重分布的路由**（import-route）生效（对network的路由无效），组件路由抑制生成，但没有产生指向null0的聚合路由&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;手动聚合&lt;br&gt;
对BGP本地路由进行聚合。通常情况下，&lt;strong&gt;手动聚合的优先级高于自动聚合的优先级&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;可以对本地的任何路由进行聚合，包活import、network等等&lt;/code&gt;&lt;br&gt;
如果聚合路由中所包含的具体路由各Origin属性不相同，那么聚合路由的Origin属性按照优先级IGP&amp;gt;EGP&amp;gt;incomplete为准。聚合路由会携带原来所有具体路由中的团体属性。&lt;br&gt;
&lt;strong&gt;默认情况下&lt;/strong&gt;，组件路由（聚合路由）和明细路由一起发布，即不抑制明细
&lt;ol&gt;
&lt;li&gt;不带AS_SET的路由聚合&lt;br&gt;
as_path属性按一定次序记录了某条路由从本地到目的地址所要经过的所有AS编号。&lt;br&gt;
SET和SEQUENCE的不同之处在于，SET选项下的AS列表通常用于路由聚合，将来自不同AS的AS号无序排列在AS列表里；而SEQUENCE选项下的AS列表是有序的，每经过一个AS都会将其AS号排列在列表的前端。&lt;br&gt;
&lt;code&gt;默认情况下，聚合路由会由本设备产生，并且不携带原本的任何AS号码，即AS-Path属性为空&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;带AS_SET的路由聚合&lt;br&gt;
用于预防环路，不加as-set参数，将存在&lt;strong&gt;路由传递环路&lt;/strong&gt;的可能。&lt;br&gt;
as-path这个属性，在BGP中有四种存在格式：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AS_SET&lt;/strong&gt;： 一个去往特定目的地所经路径上的&lt;strong&gt;无序AS号列表&lt;/strong&gt;，用于聚合路由，在新的聚合路由上，将包含原本的所有组件路由的as号码，&lt;code&gt;包含在UPDATE消息里&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AS_SEQENCE&lt;/strong&gt;： 一个&lt;strong&gt;有序的AS号列表&lt;/strong&gt;，&lt;code&gt;包含在UPDATE消息里&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AS_CONFED_SEQUENCE&lt;/strong&gt;：一个去往特定目的地所经路径上的&lt;strong&gt;有序AS 号列表&lt;/strong&gt;，其用法与AS_SEQUENCE完全一样，区别在于该列表中的AS号&lt;strong&gt;属于本地联邦中的AS&lt;/strong&gt;，&lt;code&gt;包含在UPDATE消息中，只能在本地联盟内传递&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AS_CONFED_SET&lt;/strong&gt;：一个去往特定目的地所经路径上的&lt;strong&gt;无序AS号列表&lt;/strong&gt;，去用方法与AS_SET完全一样，区别在于列表中的AS号属于本地联邦中的AS，&lt;code&gt;包含在UPDATE消息中，只能在本地联盟内传递&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;过滤策略&#34;&gt;过滤策略&lt;/h3&gt;
&lt;p&gt;关键字&lt;code&gt;suppress-policy&lt;/code&gt;能产生聚合路由，但&lt;strong&gt;抑制指定路由的通告&lt;/strong&gt;。可以用route-policy的if-match字句有选择的抑制一些具体路由，其他具体路由仍被通告。&lt;/p&gt;
&lt;h3 id=&#34;原子聚合和聚合者&#34;&gt;原子聚合和聚合者&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;原子聚合&lt;/strong&gt;是公认自决属性，用来通知下游的邻居丢失了特定路由的路径信息。当更精确的路由被汇聚为不够精确的路由的时候会引起信息丢失，原子聚合属性只是UPDATE数据包中设置的一个标志位，它提醒下游路由器在聚合的过程中丢失了一些路径信息。当原子聚合属性被设置后，下游路由器不能删除这个属性或是发送到目的网段的更精确路由。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聚合者&lt;/strong&gt;属性是一个可选过渡属性，—般针对某个NLRI与原子聚合属性同时使用。聚合者属性包含了会聚路由的SPEAKER的相关信息，属性中包含了创建聚合路由并且标记原子聚合属性的路由器的BGP ID和自治系统号码。这些信息指明了非精确会聚合路由的来源，可以用来找到更精确路由的源头。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;四大类属性&#34;&gt;四大类属性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;公认强制/周知：所有BGP必须能理解，所有前缀必须带&lt;/li&gt;
&lt;li&gt;公认自决/自选：所有BGP必须能理解，但可以不携带&lt;/li&gt;
&lt;li&gt;可选可传递：不识别也可以传递属性&lt;/li&gt;
&lt;li&gt;可选非可传递：不识别则不可以传递属性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bgp反射和联盟&#34;&gt;BGP反射和联盟&lt;/h3&gt;
&lt;p&gt;由于BGP的通告原则，导致iBGP对等体都必须建立iBGP邻居，形成iBGP全互连，而iBGP全互连确实可以很好的解决BGP通告原则所引起的问题，但同时也带来另一个问题，BGP Speaker必须维护更多的iBGP会话数量，因此BGP引入反射和联盟。&lt;br&gt;
iBGP路由传递规则：只能传一跳。AS内部的iBGP全互联用于解决路由传递问题，但同时也给iBGP的扩展带来了很大问题（&lt;strong&gt;对等体数量众多导致资源消耗；配置量随着大量增长&lt;/strong&gt;）。BGP路由反射器（RR）以及BGP联邦（联盟）作为这些问题的扩展技术解决方案，重点在于解决路由传递。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BGP是怎样&lt;strong&gt;防止环路&lt;/strong&gt;的？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;eBGP：通过AS-Path属性，&lt;strong&gt;丢弃&lt;/strong&gt;从eBGP对等体接收到的在AS-Path属&lt;br&gt;
性里&lt;strong&gt;包含自身AS号&lt;/strong&gt;的任何更新信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;iBGP：BGP路由器&lt;strong&gt;不会将任何从iBGP对等体接收到的更新信息传给其&lt;br&gt;
它iBGP对等体&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;路由反射-rfc2796&#34;&gt;路由反射 (RFC2796)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;主动式解决方案&lt;/strong&gt;【放宽了iBGP路由传递规则】&lt;br&gt;
降低对指定路由器iBGP路由通告机制的限制，允许将从iBGP对等体接收到的更新信息传给某些&lt;br&gt;
iBGP对等体&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595512333093.png&#34; alt=&#34;路由反射&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
反射传递，路由反射器在反射iBGP路由的情况下，是&lt;strong&gt;不能修改属性的（但会增加属性，用于防环）&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;三种角色和关系&#34;&gt;三种角色和关系&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;路由反射器 (Route Reflector) ：被放宽了传递规则的设备，允许将来自iBGP对等体的路由传递给iBGP对等体&lt;/li&gt;
&lt;li&gt;客户机 (Client)：默认情况下，反射器将在反射器客户端之间反射传递路由，因此客户端之间不需要BGP对等体&lt;/li&gt;
&lt;li&gt;非客户机 (Non-Client) ：非客户端需要与RR以及其它非客户端建立全互联的iBGP对等体&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595513625768.png&#34; alt=&#34;三种角色&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Client只需维护与RR之间的IBGP会话&lt;/li&gt;
&lt;li&gt;RR与RR之间需要建立IBGP的全互连&lt;/li&gt;
&lt;li&gt;Non-Client与Non-Client之间需要建立IBGP全互连&lt;/li&gt;
&lt;li&gt;RR与Non-Client之间需要建立IBGP全互连&lt;br&gt;
&lt;code&gt;【总结】：RR与RR、RR和非客户机、RR和客户机、非客户机和非客户机全互连，客户机与客户机之间不能互连&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;路由反射宣告原则&#34;&gt;路由反射宣告原则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当RR收到BGP对等体发来的路由，首先使用BGP选路策略来选择最佳路由，RR在发布学习到的路由信息时，按照RFC2789中的规则发布路由&lt;/li&gt;
&lt;li&gt;从非客户机iBGP对等体Non-Client学到的路由，发布给此RR的所有客户机Client&lt;/li&gt;
&lt;li&gt;从客户机client学到的路由，发布给此RR的所有非客户机和客户机（发起此路由的客户机除外）&lt;/li&gt;
&lt;li&gt;从eBGP对等体学到的路由，发布给所有的非客户机和客户机&lt;br&gt;
&lt;code&gt;【总结】：非客户机--&amp;gt;所有客户机，客户机和eBGP--&amp;gt;所有客户机和非客户机&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;路由反射簇-cluster&#34;&gt;路由反射簇 (Cluster)&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;在AS内部，仅仅部署一台RR是不正确的，因为这样的话，RR可能会成为单点故障点&lt;/code&gt;&lt;br&gt;
当一个AS内存在多台RR为Client提供冗余时，RR间的路由更新很有可能会形成环路，为&lt;br&gt;
防止该现象，引入了Cluster的概念。&lt;br&gt;
通过4字节的Cluster_ID来标识Cluster，通常会使用Loopback地址作为Cluster_ID，一个Cluster里可以包括一个或多个RR，一个Client可以同时属于多个Cluster。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595515053253.png&#34; alt=&#34;路由反射簇&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
Cluster-id：簇列表成员，用于标识RR，每台RR在反射路由时会将自身的簇ID放入该路由属性的簇列表&lt;br&gt;
&lt;strong&gt;AS内多个簇&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595519535700.png&#34; alt=&#34;AS内多个簇&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;层次化路由反射&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595519580031.png&#34; alt=&#34;层次化路由反射&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
路由反射减少了域中iBGP会话的总数。然而，因为RR相互之间必须全互连，在大型网络中，存在一种可能性，即RR之间仍然需要大量的iBGP会话。为了进一步减少会话数量，引入层次化路由反射。层次化路由反射的层数按照需要逐步加深，但通常现网中两层或者三层就足够了。&lt;/p&gt;
&lt;h5 id=&#34;路由反射环路防止机制&#34;&gt;路由反射环路防止机制&lt;/h5&gt;
&lt;p&gt;当一条路由&lt;strong&gt;第一次被反射&lt;/strong&gt;时，反射器会将其router-id收集成Originator-ID，如果该路由由于配置适当或者其它反射簇或其它不明原因被反射到路由的起源者，则该设备将对比Originator-ID和本地router-id，以此拒收【这里说的router-id&lt;strong&gt;不一定是始发路由器的&lt;/strong&gt;】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Originator_ID【BGP路径属性，可选非可传递属性】
&lt;ul&gt;
&lt;li&gt;Originator ID属性用于&lt;strong&gt;防止在反射器和客户机/非客户机之间产生环路&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Originator_ID属性长4字节，可选非过渡属性，属性类型为9 ，是由路由反射器（RR）产生的，携带了本地AS内部路由发起者的Router ID&lt;/li&gt;
&lt;li&gt;当一条路由第一次被RR反射的时候，RR将Originator_ID属性加入到这条路由，标识这条路由的始发路由器。如果一条路由中已经存在了Originator_ID属性，则RR将不会创建新的Originator_ID&lt;/li&gt;
&lt;li&gt;当其它BGP Speaker接收到这条路由的时候，将比较收到的Originator_ID和本地的Router ID，如果两个ID相同，BGP Speaker会忽略掉这条路由，不做处理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cluster_List【BGP路径属性，可选非可传递属性】
&lt;ul&gt;
&lt;li&gt;Cluster_List属性用于&lt;strong&gt;防止AS内部的环路【RR之间防止环路】&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Cluster_List是可选非过渡属性，属性类型编码为10&lt;/li&gt;
&lt;li&gt;Cluster_List由一系列的Cluster_ID组成，描述了一条路由所经过的反射器路径，这和描述路由经过的As路径的AS_Path属性有相似之处，Cluster_List由路由反射器产生&lt;/li&gt;
&lt;li&gt;当RR在它的客户机之间或客户机与非客户机之间反射路由时，RR会把本地Cluster_ID添加到Cluster_List的前面。如果Cluster_List为空，RR就创建一个&lt;/li&gt;
&lt;li&gt;当RR接收到一条更新路由时，RR会检查Cluster_List。如果Cluster_List中已经有本地Cluster_ID，丢弃该路由；如果没有本地Cluster_ID，将其加入Cluster_List，然后反射该更新路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;联邦-rfc3065&#34;&gt;联邦 (RFC3065)&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;被动式解决方案&lt;/strong&gt;【将大的AS分成若干小的AS，而小AS之间建立eBGP对等体关系】&lt;br&gt;
将自治系统划分为多个子自治系统，子自治系统之间使用eBGP，子自治系统内部要求iBGP全互联&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595512408482.png&#34; alt=&#34;联盟&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;联邦不流行的原因&lt;/strong&gt;：配置复杂、拓扑不清晰、排错不便、割接风险较大【工程师嫌麻烦】&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;BGP联邦到底怎么麻烦的呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先说自治系统：子自治系统、联邦自治系统&lt;br&gt;
再说对等体关系：子AS iBGP（联邦内部iBGP）、子AS之间的eBGP（联邦内部eBGP），联邦外部eBGP（真实eBGP）&lt;br&gt;
联邦内部的eBGP路由传递过程中，一方面遵循iBGP默认规则，另一方面又遵循eBGP默认规则&lt;br&gt;
联邦内部eBGP传递路由时，NH、MED、Local-preference等被保留，但as-path被修改&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;联邦AS之间传递的&lt;strong&gt;联盟内&lt;/strong&gt;eBGP路由&lt;strong&gt;下一跳不改变&lt;/strong&gt;，意味着，在整个联邦内部，&lt;strong&gt;最好是部署一个IGP，并且保证所有设备的更新源互相可达&lt;/strong&gt;。&lt;br&gt;
当然，这些对于联邦外部eBGP对等体来说，都是不可见的。即当路由传递出联邦时，子AS的as-path是不携带的。联邦内部&lt;strong&gt;子AS内部的iBGP中也可以部署RR&lt;/strong&gt;。联邦内部可以不使用相同的IGP，但仍然需要保证下一跳可达性。&lt;/p&gt;
&lt;h5 id=&#34;联邦内as_path变化&#34;&gt;联邦内AS_Path变化&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;联邦内的eBGP会话&lt;/strong&gt;：子AS号被添加到as-path中的as-confed-sequence前面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;联盟内的iBGP会话&lt;/strong&gt;：不修改as-path&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;真实eBGP会话&lt;/strong&gt;：子AS号从as-path中清除，联邦as号被添加到as-path前面&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;联盟与反射的比较&#34;&gt;联盟与反射的比较&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;参考因素&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;比较&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多层次&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;两种方法都支持多层次来进一步增强扩展性。路由反射器支持多级路由反射结构；联盟允许在成员AS内部使用路由反射&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;策略控制&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;两者都提供路由选择策略控制，不过联盟可以提供更大的灵活性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;常规iBGP迁移的复杂性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由反射的迁移复杂性非常低，因为总体网络配置几乎很少发生改变；从iBGP到联盟的迁移需要对配置和网络架构做很大的改变&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;能力支持&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在路由反射的架构中，只需要路由反射器支持路由反射能力即可，但是在新的分簇设计中，客户端必须支持反射器属性；联盟内的所有路由器必须支持联盟配置能力，因为所有路由器需要支持联盟AS-PATH属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IGP扩展&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由反射在AS内需要单一的IGP，而联盟支持单一或者分开的IGP，这是联盟比路由反射所具有的最明显的优势。如果IGP达到了其扩展性限制，或者因为范围太大而难于处理管理任务，可以使用联盟来减小IGP路由表的大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;部署经验&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由于更多的服务提供商已经部署了路由反射而非联盟，因此从路由反射中已经获得更多的经验&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AS合并&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;实际上AS合并和iBGP扩展性是无关的，但在这里讨论是因为它是联盟的特点之一。一个AS可以和一个已存在的联盟合并，这是通过把新的AS作为联盟的一个子AS对待来完成的&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;bgp路径属性-2&#34;&gt;BGP路径属性&lt;/h3&gt;
&lt;p&gt;BGP路由拥有丰富的路径属性，用于对BGP路由进行更加详细的描述（除x.x.x.x/x之外）。因此BGP在执行路由操控和路径选择时，亦将拥有更多的筛选条件。&lt;/p&gt;
&lt;h4 id=&#34;分类-3&#34;&gt;分类&lt;/h4&gt;
&lt;h5 id=&#34;公认必遵well-known-mondatory周知强制&#34;&gt;公认必遵Well-known mondatory（周知强制）&lt;/h5&gt;
&lt;p&gt;所有BGP路由器&lt;strong&gt;都可以识别&lt;/strong&gt;，且&lt;strong&gt;必须&lt;/strong&gt;存在于Update消息中。如果缺少这种属性，路由信息就会出错。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Origin：起源&lt;br&gt;
一般的，具体的实现按如下方式决定一条路由的Origin属性
&lt;ul&gt;
&lt;li&gt;某条路由是&lt;strong&gt;直接而具体&lt;/strong&gt;的注入到BGP路由表中的，&lt;strong&gt;则origin属性为IGP(i)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;通过network命令注入BGP的路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过EGP(RFC904)学到的路由，&lt;strong&gt;则origin属性为EGP(e)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;其他情形下，&lt;strong&gt;Origin属性都为Incomplete(?)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;通过import命令注入BGP的路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Origin属性值默认情况下不被任何路由器修改&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AS_Path：AS路径&lt;br&gt;
描述到达目标网络所要经过的AS号序列。最重要的作用是防环，如果BGP Speaker发现自己的AS号位于接收自外部对等体的路由，则忽略该路由。仅当update消息被发送给其他的AS时，BGP 路由器才会将其AS号追加在AS_PATH中。这句话也隐含了另一个意思，那就是如果要修改AS_PATH属性，则必须在AS边界路由器上执行策略。有四种类型的AS_PATH：AS_SET、AS_SEQENCE、AS_CONFED_SEQUENCE、AS_CONFED_SET&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;了解eBGP防环规则的修改以及应用场景&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Hub-spoke架构网络&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用DM VPN模块&lt;br&gt;
使用相同的AS，中间点配置成路由反射器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;客户路由通过SP（运营商）更新&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;overraid，覆写，即左边AS300的路由传到AS200时，其属性as-path修改为200，然后在传递给右边的AS300（应用于MPLS VPN）&lt;/li&gt;
&lt;li&gt;允许接收相同AS的路由，可以设置次数，即右边的AS300可以接收左边AS300的路由&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595860627469.png&#34; alt=&#34;eBGP防环规则的修改&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以通过加长as_path的列表长度，从而影响路径选择。例如：从RTA向RTB更新时增加as-path长度，则使得路由选择2M链路，而不是64K的&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595861450538.png&#34; alt=&#34;加长as_path的列表长度&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3. Next_Hop：下一跳&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BGP Speaker在&lt;strong&gt;向eBGP对等体&lt;/strong&gt;发布某条路由时，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。&lt;/li&gt;
&lt;li&gt;BGP Speaker将&lt;strong&gt;本地始发路由发布给iBGP对等体时&lt;/strong&gt;，会把该路由信息的下一跳属性设置为本地与对端建立BGP邻居关系的接口地址。&lt;/li&gt;
&lt;li&gt;BGP Speaker在向iBGP对等体发布从eBGP对等体学来的路由时，并&lt;strong&gt;不改变该路由信息的下一跳属性&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;【总结】：传给iBGP对等体时默认不修改，传给eBGP对等体时默认修改，但这两个默认行为都是可以修改的。一般会在ASBR对内部对等体设置下一跳自我，eBGP对等体之间的下一条不改变一般用于域间MPLS VPN&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;公认任意well-known-discretionary周知可选&#34;&gt;公认任意Well-known discretionary（周知可选）&lt;/h5&gt;
&lt;p&gt;所有BGP路由器&lt;strong&gt;都可以识别&lt;/strong&gt;，但&lt;strong&gt;不要求必须&lt;/strong&gt;存在于Update消息中，可以根据具体情况来决定是否添加到Update消息中&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Local_Pref：本地优先级&lt;br&gt;
告诉AS中的路由器，哪条路径是离开AS的首选路径。优先级属性用来影响iBGP邻居，告诉自己的&lt;strong&gt;iBGP邻居如何离开本AS&lt;/strong&gt;，&lt;strong&gt;只能在本AS内传递（iBGP对等体或者联邦内部），不能传给EBGP邻居&lt;/strong&gt;。默认值为100，越大越好。&lt;br&gt;
&lt;code&gt;MED控制流量怎样进入AS，而本地优先级则控制流量怎样流出AS；路由器优选Local-preference值大的路由控制出流量，优选MED值小的路由控制入流量。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Atomic_Aggregate：原子聚合&lt;br&gt;
有时BGP发布者会收到两条重叠的路由，其中&lt;strong&gt;一条路由包含的地址是另一条路由的子集&lt;/strong&gt;。一般情况下BGP发布者会优选更精细的路由（前者），但是在对外发布时，如果它选择发布&lt;strong&gt;更粗略&lt;/strong&gt;的那条路由（后者），这时&lt;strong&gt;需要附加上ATOMIC-AGGREGATE属性&lt;/strong&gt;，以知会对等体。它实际上是&lt;strong&gt;一种警告&lt;/strong&gt;，因为发布更粗略的路由意味着更精细的路由信息在发布过程中丢失了。在进行&lt;strong&gt;路由聚合&lt;/strong&gt;时，&lt;strong&gt;对于聚合的路由信息会添加ATOMIC-AGGREGATE属性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;可选可传递optional-transitive过渡&#34;&gt;可选可传递Optional transitive（过渡）&lt;/h5&gt;
&lt;p&gt;BGP路由器可以&lt;strong&gt;选择是否在Update消息中携带这种属性&lt;/strong&gt;。&lt;strong&gt;接收的路由器如果不识别这种属性，可以转发给邻居路由器&lt;/strong&gt;，邻居路由器可能会识别并使用到这种属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Aggregator：聚合者&lt;br&gt;
聚合时也会自动出现该属性。它包括&lt;strong&gt;发动聚合路由器的AS号码还有它的router-id&lt;/strong&gt;，从而提供了执行聚合的地点信息。Atomic-aggregate属性指示出现了路径信息的丢失而aggregator属性指示聚合路由出现在哪里。&lt;/li&gt;
&lt;li&gt;Community：团体&lt;br&gt;
团体是一组有&lt;strong&gt;相同性质的目的地址路由&lt;/strong&gt;。&lt;strong&gt;目的&lt;/strong&gt;就是将路由信息编组，通过组的标识决定路由传递&lt;br&gt;
的策略。它被一组共享相同特性的前缀所定义，多个社团可以应用到一条前缀上。&lt;br&gt;
团体属性是&lt;strong&gt;BGP的私有属性&lt;/strong&gt;，在BGP对等体之间传播，且不受AS限制。利用团体属性可以使AS中的一组BGP设备共享相同的策略，从而简化路由策略的应用和降低维护管理难度。&lt;br&gt;
BGP设备可以在&lt;strong&gt;发布路由&lt;/strong&gt;时（或者针对邻居更新以及收取时、或者引入路由时），新增或者改变路由的团体属性。&lt;br&gt;
团体属性是在BGP中一种&lt;strong&gt;给路由条目打上标记&lt;/strong&gt;，用于确保路由过滤和选择的连续性，BGP路由器可以过滤进出路由更新或者优选某些路由。&lt;br&gt;
&lt;code&gt;默认不传递给对等体，要针对邻居做传递，即传递团体属性需要配置命令peer 22.1.1.1 advertise-community&lt;/code&gt;&lt;br&gt;
Community属性有&lt;strong&gt;4个字节(0x00000000—0xFFFFFFFF)&lt;/strong&gt;，RFC1997规定前&lt;strong&gt;两个字节代表AS号码&lt;/strong&gt;，&lt;strong&gt;后两个字节是管理上定义的标识符&lt;/strong&gt;。格式为AA:NN。
&lt;ul&gt;
&lt;li&gt;团体属性有以下&lt;strong&gt;3种类型&lt;/strong&gt;：保留的团体属性、公认的团体属性、私有团体属性
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保留团体属性&lt;/strong&gt;：&lt;br&gt;
0x00000000—0x0000FFFF、0xFFFF0000—0xFFFFFFFF&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公认团体属性&lt;/strong&gt;：&lt;br&gt;
NO_EXPORT (0xFFFFFF01)、NO_ADVERTISE (0xFFFFFF02) 、NO_EXPORT_SUBCONFED (0xFFFFFF03)&lt;br&gt;
当收到这些带有团体属性的前缀时，对等体会自动根据预定义（操作已经定义好了）的社团属性意义来采取操作，不需要额外的配置。公共团体属性的保留范围是（0xFFFF0000-0xFFFFFFFF）。下面是4种公共社团属性
&lt;ul&gt;
&lt;li&gt;Internet&lt;br&gt;
所有属于这个团体属性的路由都有一个缺省值，可以自由地公布属于这个团体的路由。换句话说&lt;strong&gt;这个团体的前缀通告没有任何限制&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;No-export&lt;br&gt;
有这个属性的前缀&lt;strong&gt;不会被通告给eBGP对等体&lt;/strong&gt;，但是&lt;strong&gt;可以发送给联邦的eBGP对等体&lt;/strong&gt;，也就是&lt;strong&gt;不能在联邦范围以外公布&lt;/strong&gt;。这个团体的值为0xFFFFFF01。&lt;/li&gt;
&lt;li&gt;No-advertise&lt;br&gt;
接收到带有此值的路由&lt;strong&gt;不能公布给任何对等体&lt;/strong&gt;，包括iBGP对等体和eBGP对等体。它的值为0xFFFFFF02。&lt;/li&gt;
&lt;li&gt;Local-AS（华为no-export-subconfed）&lt;br&gt;
有这个属性的路由条目&lt;strong&gt;不会被通告到本地AS之外&lt;/strong&gt;。在&lt;strong&gt;联邦&lt;/strong&gt;情况下，&lt;strong&gt;只有在同一个子AS中的对等体才会允许接受这些前缀&lt;/strong&gt;。它的值为0xFFFFFF03在RFC1997中这个团体也叫做&lt;code&gt;no-export-subconfed&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;私有社团属性&lt;/strong&gt;（自定义团体属性）：&lt;br&gt;
AS(2B):Number(2B)&lt;br&gt;
有网络管理员自己定义的社团属性，它的主要目的是为前缀附加管理标记，以便制定合适的策略。&lt;br&gt;
通过干预携带的团体属性的路由，影响数据报文的转发，也用于路由清洗。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;可选非可传递optional-non-transitive非过渡&#34;&gt;可选非可传递Optional non-transitive（非过渡）&lt;/h5&gt;
&lt;p&gt;BGP路由器可以选择是否在Update消息中携带这种属性。在整个路由发布的路径上，如果部分路由器不能识别这种属性，可能会导致该属性无法发挥效用。因此&lt;strong&gt;接收的路由器如果不识别这种属性，将丢弃这种属性&lt;/strong&gt;，不必再转发给邻居路由器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Multi_Exit_Disc(MED)：多出口分离器&lt;br&gt;
区别到达同一邻居AS的多条入口链路(MED的默认值为0，越小越优先)，&lt;strong&gt;通过eBGP发送MED值给对等体&lt;/strong&gt;。&lt;br&gt;
&lt;strong&gt;通告规则&lt;/strong&gt;：1. MED属性起源于iBGP对等体，在传递给eBGP对等体时会清除MED属性；2. MED起源于eBGP对等体，在传递给iBGP对等体时携带；3. MED起源于本地，可以通告给所有对等体&lt;br&gt;
例如：起源于RT1，RT1传递给RT2时携带MED值；起源于RT1，RT2在向RT3传递时不携带；起源于RT2，RT2在向RT3传递时携带。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1595864546574.png&#34; alt=&#34;通告规则&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;对比规则&lt;/strong&gt;：缺省情况下，不允许比较来自不同AS邻居的路由信息的MED值。但是，可以调整这个规则。&lt;/li&gt;
&lt;li&gt;Originator_ID：起源ID&lt;br&gt;
是本地AS中&lt;strong&gt;路由发起者的路由器ID&lt;/strong&gt;。如果路由发起者在接收到路由的originator-id中发现了自己的RID，就知道产生了环路，于是忽略该路由条目，它提供在&lt;strong&gt;AS内的防环作用&lt;/strong&gt;，它由第一个RR创建，并且不被后续的RR修改。&lt;br&gt;
它&lt;strong&gt;只应在iBGP对等体那里接收到&lt;/strong&gt;，在RR上originator-id用来替代路由选择过程中的router-ID。它应该是这些路由器的router-id；在本地AS始发路由的BGP宣告者的router-id；如果是从eBGP学到的就是最初学到那个条目的路由器(本AS内边界路由器)的router-id（它一定是本AS内路由器的router-id）&lt;/li&gt;
&lt;li&gt;Cluster_List&lt;br&gt;
是&lt;strong&gt;路由经过的路由反射器的簇ID&lt;/strong&gt;（默认RR的router-ID）的一个列表，如果路由反射器接收到的路由的cluster-List中发现了自己的本地簇ID，就知道产生了环路，于是忽略该路由条目，RR从而能够分别出路由选择信息是否又环回到同一个簇。可以配置bgp cluster-id。cluter-id默认为RR自己的router-id所以默认情况下所有的RR都不在同一个簇。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bgp选路原则&#34;&gt;BGP选路原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;前提&lt;/strong&gt;：如果此路由的下一跳不可达，忽略此路由&lt;/p&gt;
&lt;h4 id=&#34;华为&#34;&gt;华为&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Preferred-Value越&lt;strong&gt;大&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;Local-Preference越&lt;strong&gt;大&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;本地起源评估：&lt;strong&gt;手动&lt;/strong&gt;聚合&amp;gt;&lt;strong&gt;自动&lt;/strong&gt;聚合&amp;gt;&lt;strong&gt;network&lt;/strong&gt;&amp;gt;&lt;strong&gt;import-route&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;as-path长度越&lt;strong&gt;短&lt;/strong&gt;越优先【跳过本条使用命令&lt;code&gt;bestroute as-path-ignore&lt;/code&gt;】&lt;/li&gt;
&lt;li&gt;起源代码：&lt;strong&gt;i&amp;gt;e&amp;gt;?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MED值越&lt;strong&gt;小&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;eBGP&amp;gt;iBGP&lt;/li&gt;
&lt;li&gt;BGP下一跳的IGP度量越&lt;strong&gt;小&lt;/strong&gt;越优先&lt;br&gt;
当以上全部相同，则为等价路由，可以负载分担【AS_Path必须一致】。&lt;strong&gt;当负载分担时，以下原则无效&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;比较Cluster-List长度越&lt;strong&gt;短&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;Originator_ID/RouterID越&lt;strong&gt;小&lt;/strong&gt;越优先（没有起源者ID的情况下才使用RouterID进行比较）&lt;/li&gt;
&lt;li&gt;对等体的IP地址越&lt;strong&gt;小&lt;/strong&gt;越优先&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;思科&#34;&gt;思科&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Weight权重值越&lt;strong&gt;大&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;Local-Preference越&lt;strong&gt;大&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;本地起源评估：邻居默认&amp;gt;地址族默认&amp;gt;network&amp;gt;redistribute&amp;gt;手动聚合&amp;gt;自动聚合&lt;/li&gt;
&lt;li&gt;as-path长度越&lt;strong&gt;短&lt;/strong&gt;越优先【跳过本条使用命令&lt;code&gt;bgp bestpath as-path ignore&lt;/code&gt;】&lt;/li&gt;
&lt;li&gt;Origin起源代码：&lt;strong&gt;i&amp;gt;e&amp;gt;?&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;MED值越&lt;strong&gt;小&lt;/strong&gt;越优先（是否来自同一AS）&lt;/li&gt;
&lt;li&gt;eBGP&amp;gt;iBGP&lt;/li&gt;
&lt;li&gt;到达更新源的IGP metric越小越优先【跳过本条使用命令&lt;code&gt;bgp bestpath igp-metric ignore&lt;/code&gt;】&lt;/li&gt;
&lt;li&gt;load-balance i/eBGP负载均衡（默认关闭）【注意：最后一个AS号码必须一致】&lt;/li&gt;
&lt;li&gt;建立时间更&lt;strong&gt;久&lt;/strong&gt;的eBGP邻居【跳过本条使用命令&lt;code&gt;bgp bestpath compare-routerid&lt;/code&gt;】&lt;/li&gt;
&lt;li&gt;Originator_ID/Router_ID越&lt;strong&gt;小&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;Cluste-list越&lt;strong&gt;小&lt;/strong&gt;越优先&lt;/li&gt;
&lt;li&gt;对等体的IP地址越&lt;strong&gt;小&lt;/strong&gt;越优先&lt;br&gt;
&lt;code&gt;记忆口诀：世界（world-1）恋爱（love-2）组织（origanization-3）亚洲（asia-4）办公室（office-5），纪念碑（meml-6-7-8-9）下半兽人（orc-10-11-12）&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;自定义路径选择过程cost-community&#34;&gt;自定义路径选择过程cost-community&lt;/h5&gt;
&lt;p&gt;扩展团体属性，只能用于iBGP或者联邦内部，不能传递给eBGP&lt;br&gt;
为防止环路，要求所有设备能够识别，并且保证所有设备都传递扩展团体&lt;br&gt;
多宿主环境控制出站流量&lt;br&gt;
可以插入在第8条选路原则之后&lt;br&gt;
可以为路由附加多个cost-community，但ID不能相同&lt;br&gt;
先比同一组ID的cost，如果相等则比下一组ID，越小越优先&lt;br&gt;
如果设置了ID，没有设置cost，则cost=2147483647&lt;br&gt;
使用&lt;code&gt;bgp bestpath cost-community ignore&lt;/code&gt;忽略这条选路原则&lt;br&gt;
使用&lt;code&gt;pre-bestpath Compare before all other steps in bestpath calculation&lt;/code&gt;预置在所有选路原则之前&lt;/p&gt;
&lt;h3 id=&#34;多宿主网络&#34;&gt;多宿主网络&lt;/h3&gt;
&lt;h4 id=&#34;bgp产生默认路由的方案&#34;&gt;BGP产生默认路由的方案&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;将来自IGP的默认路由，使用&lt;code&gt;network&lt;/code&gt;命令注入BGP：&lt;code&gt;思科：network 0.0.0.0 mask 0.0.0.0；华为：network 0.0.0.0 0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;允许将默认路由引入BGP。在一些场景下，已经应用了重发布命令，如果此时有需要将默认路由注入BGP，即重分布时开启默认路由的允许开关，使用如下命令：&lt;code&gt;思科：default-information origination；华为：default-route imported&lt;/code&gt;【需要结合重发布一起使用】&lt;/li&gt;
&lt;li&gt;针对特定邻居下发默认路由：&lt;code&gt;思科：neighbor 33.1.1.1 default-originate；华为：peer 33.1.1.1 default-route-advertise&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;类型&#34;&gt;类型&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;单宿主单链路&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596168541530.png&#34; alt=&#34;单宿主单链路&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;单宿主多链路&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596168556146.png&#34; alt=&#34;单宿主多链路&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;多宿主
&lt;ol&gt;
&lt;li&gt;单节点多宿主&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596168570017.png&#34; alt=&#34;单节点多宿主&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;多节点多宿主&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596168582544.png&#34; alt=&#34;多节点多宿主&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;标准多宿主（需要注册公有ASN）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596169099742.png&#34; alt=&#34;标准多宿主&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596169428812.png&#34; alt=&#34;大型网络&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在SP上使用入境路由过滤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有网络信息&lt;/li&gt;
&lt;li&gt;127.0.0.0/8&lt;/li&gt;
&lt;li&gt;169.254.0.0/16&lt;/li&gt;
&lt;li&gt;0.0.0.0/8（注意：不是0.0.0.0/0）&lt;/li&gt;
&lt;li&gt;192.0.2.0/24（网络测试网络）&lt;/li&gt;
&lt;li&gt;D类、E类&lt;/li&gt;
&lt;li&gt;本AS内部的网络信息&lt;br&gt;
以上网络信息需要过滤掉，不能让其进入内部网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;策略工具as-path-access-list&#34;&gt;策略工具as-path access-list&lt;/h3&gt;
&lt;p&gt;用来匹配&lt;strong&gt;BGP前缀携带的as-path属性&lt;/strong&gt;（隐式拒绝一切）。&lt;br&gt;
由&lt;strong&gt;正则表达式字符串&lt;/strong&gt;定义，每个列表的行为可以是允许或者拒绝。&lt;br&gt;
as-path access-list一般由常规字符和原子字符组成。&lt;br&gt;
&lt;strong&gt;元字符&lt;/strong&gt;的作用是告诉正则表达式如何处理。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596183500837.png&#34; alt=&#34;字符&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596183513412.png&#34; alt=&#34;例子1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596183750339.png&#34; alt=&#34;例子2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;优化前缀更新&#34;&gt;优化前缀更新&lt;/h3&gt;
&lt;h4 id=&#34;路由阻尼dampeningrfc2439&#34;&gt;路由阻尼dampening（RFC2439）&lt;/h4&gt;
&lt;p&gt;减少由于不稳定路由引起的路由处理负载，防止持续的路由抖动，增强路由稳定性。&lt;br&gt;
&lt;strong&gt;涉及术语&lt;/strong&gt;：历史状态、惩罚、抑制门限、惩罚状态、半衰期、再使用门限、最大抑制门限等&lt;br&gt;
&lt;strong&gt;路由翻动&lt;/strong&gt;（route flaps）是internet不稳定的首要因素，当有效路由被重复宣告为无效、有效时就会产生路由翻动现象。&lt;br&gt;
【注意：路由震荡route oscillation≠路由翻动，路由震荡属于周期性行为，而route flaps则不是】&lt;br&gt;
路由阻尼是一种阻止不稳定路由传播到整个互联网络的方法，开启路由阻尼机制的路由器会为每条路由分配一个动态的特征值，用以反映该路由的稳定程度，当某条路由出现翻动时，将会给该路由分配一个惩罚值，翻动次数越多，累加的惩罚值就越大。&lt;br&gt;
路由阻尼中引入了半衰期（half-life）的时间周期概念，惩罚值以一定的速率衰减到每个半衰期初值的一半，当惩罚值超出了预设的阀值（suppress limit）之后，该路由就被抑制，不再对外宣告该路由。直到该路由的惩罚值降低至另一个阀值（reuse limit）之后，才会再次对外宣告该路由。&lt;br&gt;
【注意：可手工清除路由的惩罚值，这种方式对于矫正了网络中的不稳定性之后需要快速重用该路由时非常有用】&lt;br&gt;
如果路由翻动的次数足够多，以至于其惩罚值的增加速度大于半衰期的减小速度，那么将会超出抑制门限。尽管路由在被抑制期间，其惩罚值仍会继续累加，但是在该路由超出了最大抑制门限（maximum suppress  limit）周期之后将无法被抑制，这样就可以确保某路由在非常短的时间内翻动十几次之后，不会将惩罚值累加到一个很高的，使路由始终保持被抑制状态的值。&lt;/p&gt;
&lt;h4 id=&#34;bgp温和重配置keep-all-routes&#34;&gt;BGP温和重配置(keep all routes)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;出站&lt;/strong&gt;温和重配置不需要额外资源。通过针对特定对等体的出站更新策略来处理Adj-RIB-Loc，并创建一个新的Adj-RIB-Out&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;入站&lt;/strong&gt;温和重配置则&lt;strong&gt;需要更多的内存资源&lt;/strong&gt;，将维护所有学自远端对等体的前缀信息，即使被入站策略过滤影响&lt;/li&gt;
&lt;li&gt;配置了温和重配置之后，被入站策略拒绝的前缀信息将会保存在BGP表中，&lt;strong&gt;被标记为recevied-only&lt;/strong&gt;，这些前缀&lt;strong&gt;不参与BGP路径选择过程&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;路由刷新route-refresh&#34;&gt;路由刷新（route refresh）&lt;/h4&gt;
&lt;p&gt;在会话初始阶段协商的一种BGP能力，该特性允许BGP路由器请求远端对等体重新发送它的BGP Adj-RIB-Out，使得本地可以重新应用入站策略。&lt;br&gt;
如果不支持，如果入站策略变化，将重置对等体。&lt;/p&gt;
&lt;h4 id=&#34;出站路由过滤orf&#34;&gt;出站路由过滤ORF&lt;/h4&gt;
&lt;p&gt;专门针对于前缀列表的一种优化能力。&lt;br&gt;
分为发送能力、接收能力，表明具有发送或者接收前缀列表的能力。&lt;br&gt;
通过向对等体通告ORF能力可以激活这一特征。表示接受从对等体来的前缀列表，并把这个前缀列表应用到针对对等体的出站方向。&lt;br&gt;
通俗的讲，在本地&lt;strong&gt;针对邻居部署入站的前缀列表&lt;/strong&gt;，但通过ORF能力，将该列表发送到对等体上，&lt;strong&gt;由对等体在路由出站时进行过滤&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&#34;bgp附加路径&#34;&gt;BGP附加路径&lt;/h4&gt;
&lt;p&gt;提供了一种方法可以通告同一前缀的多个路径，实现了路径的多样性。即不仅仅通告best的路由，同时也通告其他路由。&lt;br&gt;
在现有前缀的基础上，增加一个NLRI的path ID （路径标识符）&lt;br&gt;
&lt;strong&gt;实现的要素&lt;/strong&gt;：优选多个；发送能力；接受能力&lt;/p&gt;
&lt;h5 id=&#34;hot-potato-roouting&#34;&gt;hot-potato roouting&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1596206786867.png&#34; alt=&#34;hot-potato roouting&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;bgp-additional-path的功能&#34;&gt;BGP Additional Path的功能&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;通过将路径标识符添加到NLRI中的每个路径来实现的&lt;/li&gt;
&lt;li&gt;路径标识符（ID）可以被视为类似于VPN中的路由标识符（RD）的东西，只是路径ID可以应用于任何地址族&lt;/li&gt;
&lt;li&gt;路径ID对于对等会话是唯一的，并且是为每个网络生成的&lt;/li&gt;
&lt;li&gt;除了最佳路径，Additional Path功能还允许发布更多的路径&lt;/li&gt;
&lt;li&gt;附加路径功能允许发布&lt;strong&gt;具有相同前缀&lt;/strong&gt;的多个路径&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1596207252955.png&#34; alt=&#34;路径标识符&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;部署additional-path&#34;&gt;部署Additional Path&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;指定设备是否可以发送/接收Additional Paths，地址族下或对邻居应用【注意：这是能力】&lt;/li&gt;
&lt;li&gt;指定选择标准，使用&lt;code&gt;bgp Additional-paths select&lt;/code&gt;命令来选择一组或者多组候选路径&lt;/li&gt;
&lt;li&gt;从标记的候选路径中向邻居通告一组或多组路径，使用&lt;code&gt;neighbor advertise Additional-paths&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全部部署完，需要重新建立会话，目的在于协商能力&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;面试与总结&#34;&gt;面试与总结&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&#34;https://blog.csdn.net/qq_45124553/java/article/details/99694087&#34;&gt;https://blog.csdn.net/qq_45124553/java/article/details/99694087&lt;/a&gt;&lt;br&gt;
首先，因为BGP管理的路由信息非常庞大，而且每个as情况不一致，其必然需要丰富的属性来灵活的进行选路，从而他创造出了11条属性（一条思科私有），来完成自己的使命。&lt;br&gt;
根据其主要作用，将其可大致分为5个方向：&lt;strong&gt;3个选路、3个防环、2个反射、2个汇总、1个团体&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;3个选路weight-local-med&#34;&gt;3个选路（weight、local、med）&lt;/h2&gt;
&lt;p&gt;首先为什么要有三个选路属性？因为三个属性各司其职，作用均不相同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;weight思科，华为preferred-value：&lt;br&gt;
只作用于自己，不可传递给其他人；适用于一个路由器在多条路径下的选路，无视邻居属性。&lt;br&gt;
思科的IOS系统默认在本地注入BGP的路由的weight=32768，即本设备产生的在本设备上是最优的；华为的默认情况下preferred-value=0。&lt;/li&gt;
&lt;li&gt;local：&lt;br&gt;
与weight相比，最大的优点为公有且可作用于AS内其他路由器，用于本AS选择离开AS的出口路由器&lt;/li&gt;
&lt;li&gt;med：&lt;br&gt;
与weight和local相比，最大的区别在于，可以作用于出口、影响其他AS，如果在本AS使用，和local差别不大；值得注意的是，med属性只能在两个as之间传递，不能传递给第三个as。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3个防环origin-as_path-next_hop&#34;&gt;3个防环（origin、as_path、next_hop）&lt;/h2&gt;
&lt;p&gt;作为一个路由协议，能广泛使用的前提必然是自身不会出环，如果路由协议本身都会出环，那么该协议也就没有存在的必要。所以BGP协议利用3个公认必遵属性，牢牢守护住这一命脉。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;origin：&lt;br&gt;
起源属性，标识该路由的来源方式，i表示自己产生的、E表示EGP学到的、？表示其他手段得到的（重发布）；优先顺序为i&amp;gt;E&amp;gt;?。&lt;br&gt;
这一属性，实为路由协议之间的较量，在自己内部传递是不会改变属性的；通过这一属性，来保证从自己发出的路由，经过其他协议处理之后，不会再流传给自己，从而防环。&lt;/li&gt;
&lt;li&gt;as_path：&lt;br&gt;
将经过的AS统统记下来，写进货日记，最近进货的排前面，而拒绝再购买自己进货日记里已经记载的货物（一个AS的路由器拒绝接受携带自己AS号的路由）；当然该属性也可以用来选路，as_path短的优先。&lt;/li&gt;
&lt;li&gt;next_hop：&lt;br&gt;
iBGP之间传递路由不会更新next_hop（只有next_hop为0.0.0.0的情况才会更新）；eBGP之间传递路由会更新next_hop为自己的更新源地址。&lt;code&gt;自己为0，保证从自己发出去的不再回来&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2个反射防环originator-id-cluster-list&#34;&gt;2个反射防环（originator-id、cluster-list）&lt;/h2&gt;
&lt;p&gt;因为BGP自己的原因，在ibgp之内传递路由时，不能中转；所以若想全网互通，则必须做全互联，而全互联工程量太大且复杂，所以有了反射器，使得路由可以中转。应注意，非客户端之间不能相互反射。但在反射之后，就违背了BGP设计之初防环的作用，所以又诞生了两个反射防环属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;originator-id：&lt;br&gt;
反射路由器收到路由后，将起源者的rid标记，后面的路由器看到自己的rid，不收，从而起到防环的作用。&lt;br&gt;
originator-id只能标记一个路由器，若途经多个反射器，则无能为力，可能导致反射器之间出环。所以出现了cluster-list。&lt;/li&gt;
&lt;li&gt;cluster-list：&lt;br&gt;
反射路由器反射出去的路由，会生成列表，加入自己的rid，沿途反射的均加入自己的rid，等收到后，若列表中有自己的rid，则忽略，达到防环的目的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2个汇总atomic-aggregate-aggregator&#34;&gt;2个汇总（Atomic-aggregate、aggregator）&lt;/h2&gt;
&lt;p&gt;由于路由协议庞大且复杂，那么避免不了需要对一些路由进行汇总，汇总本身就是消灭一些路由、产生一些路由，而在这个过程中必然会丢失很多属性。那么BGP就产生了2个汇总属性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Atomic-aggregate：&lt;br&gt;
通过添加某些选项，来达到弥补丢失一些属性的作用。&lt;br&gt;
加&lt;code&gt;As-set&lt;/code&gt;，继承明细as属性，防环；加&lt;code&gt;summary only&lt;/code&gt; 只显示汇总；加&lt;code&gt;advertise-map&lt;/code&gt; 显示某些属性；加&lt;code&gt;attribute-map&lt;/code&gt; 为聚合后的添加某些属性。而在其他路由器得到汇总路由之后，有可能需要知道是谁产生的汇总，产生了寻找的需求，那么就产生了aggregator属性。&lt;/li&gt;
&lt;li&gt;aggregator：&lt;br&gt;
通告汇总路由的汇聚路由器BGP-ID ，寻找汇总者方便&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;1个团体community&#34;&gt;1个团体（community）&lt;/h2&gt;
&lt;p&gt;团体属性主要有两大作用：1. 为了可读性好； 2. 规定和谁玩&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可读性好：&lt;br&gt;
利用正则表达式&lt;code&gt;X：Y&lt;/code&gt; 形式来标识，使得可读性大大提高。&lt;/li&gt;
&lt;li&gt;规定和谁玩：&lt;br&gt;
利用四条子属性来规定和谁玩的问题。
&lt;ol&gt;
&lt;li&gt;Internet：默认属性，可以给任何bgp发送，不对携带团体值的路由做任何限制&lt;/li&gt;
&lt;li&gt;no-export：只能在一个as之内传递，可以在联盟内传递，该属性就是限制携带团体值的路由传递给ebgp邻居，联盟ebgp除外&lt;/li&gt;
&lt;li&gt;no-advertise：不在ibgp，ebgp邻居间传递，禁止传递给其他邻居&lt;/li&gt;
&lt;li&gt;local-as（no-export-subconfed）：不向任何ebgp邻居发送，包括联盟的ebgp邻居&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1594648641791.png&#34; alt=&#34;本课程使用拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
本课程使用拓扑&lt;strong&gt;约定&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如有必要，每个设备的环回接口xx.1.1.1/32作为路由协议的源地址&lt;/li&gt;
&lt;li&gt;如有必要，业务网段采用x.x.x.x/32，比如2.2.2.2&lt;/li&gt;
&lt;li&gt;直连网络采用10.1.xy.x/24，比如10.1.13.3&lt;/li&gt;
&lt;li&gt;初始化配置：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置IP
# R1
sys
sys R1
int lo 0
ip addr 11.1.1.1 32
int lo 1
ip addr 1.1.1.1 32
int g0/0/0
ip addr 10.1.15.1 24
int g0/0/1
ip addr 10.1.13.1 24
int g0/0/2
ip addr 10.1.12.1 24
int s1/0/0
ip addr 10.1.14.1 24
return
sa
# R2
sys
sys R2
int lo 0
ip addr 22.1.1.1 32
int lo 1
ip addr 2.2.2.2 32
int g0/0/0
ip addr 10.1.23.2 24
int g0/0/2
ip addr 10.1.12.2 24
int s1/0/1
ip addr 10.1.24.2 24
int s1/0/0
ip addr 10.1.26.2 24
return
sa
# R3
sys
sys R3
int lo 0
ip addr 33.1.1.1 32
int lo 1
ip addr 3.3.3.3 32
int g0/0/0
ip addr 10.1.23.3 24
int g0/0/1
ip addr 10.1.13.3 24
int g0/0/2
ip addr 10.1.34.3 24
return
sa
# R4
sys
sys R4
int lo 0
ip addr 44.1.1.1 32
int lo 1
ip addr 4.4.4.4 32
int s1/0/0
ip addr 10.1.14.4 24
int s1/0/1
ip addr 10.1.24.4 24
int g0/0/2
ip addr 10.1.34.4 24
return
sa
# R5
sys
sys R5
int lo 0
ip addr 55.1.1.1 32
int lo 1
ip addr 5.5.5.5 32
int g0/0/0
ip addr 10.1.15.5 24
int g0/0/1
ip addr 10.1.57.5 24
return
sa
# R6
sys
sys R6
int lo 0
ip addr 66.1.1.1 32
int lo 1
ip addr 6.6.6.6 32
int s1/0/0
ip addr 10.1.26.6 24
int s1/0/1
ip addr 10.1.67.6 24
return
sa
# R7
sys
sys R7
int lo 0
ip addr 77.1.1.1 32
int lo 1
ip addr 7.7.7.7 32
int g0/0/1
ip addr 10.1.57.7 24
int s1/0/1
ip addr 10.1.67.7 24
return
sa
# 通过ping来测试网络的连通性

# ---------------------------------------------

# 配置OSPF
# R1
ospf 1
area 0
int lo 0
ospf enable 1 area 0
int g0/0/1
ospf enable 1 area 0
ospf network-type p2p
int g0/0/2
ospf enable 1 area 0
ospf network-type p2p
int s1/0/0
ospf enable 1 area 0
ospf network-type p2p
return
sa
# R2
ospf 1
area 0
int lo 0
ospf enable 1 area 0
int g0/0/0
ospf enable 1 area 0
ospf network-type p2p
int g0/0/2
ospf enable 1 area 0
ospf network-type p2p
int s1/0/1
ospf enable 1 area 0
ospf network-type p2p
return
sa
# R3
ospf 1
area 0
int lo 0
ospf enable 1 area 0
int g0/0/0
ospf enable 1 area 0
ospf network-type p2p
int g0/0/1
ospf enable 1 area 0
ospf network-type p2p
int g0/0/2
ospf enable 1 area 0
ospf network-type p2p
return
sa
# R4
ospf 1
area 0
int lo 0
ospf enable 1 area 0
int g0/0/2
ospf enable 1 area 0
ospf network-type p2p
int s1/0/0
ospf enable 1 area 0
ospf network-type p2p
int s1/0/1
ospf enable 1 area 0
ospf network-type p2p
return
sa
# R5
ospf 1
area 0
int lo 0
ospf enable 1 area 0
int g0/0/1
ospf enable 1 area 0
ospf network-type p2p
return
sa
# R6
ospf 1
area 0
int lo 0
ospf enable 1 area 0
int s1/0/1
ospf enable 1 area 0
ospf network-type p2p
return
sa
# R7
ospf 1
area 0
int lo 0
ospf enable 1 area 0
int g0/0/1
ospf enable 1 area 0
ospf network-type p2p
int s1/0/1
ospf enable 1 area 0
ospf network-type p2p
return
sa
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验一通过直连路由方式建立ebgp对等体&#34;&gt;实验一：通过直连路由方式建立eBGP对等体&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
peer 10.1.15.5 as-number 200
network 1.1.1.1 32
# R5
bgp 200
peer 10.1.15.1 as-number 100
network 5.5.5.5 32
# 检查R1/5
# 查看对等体
dis bgp peer
# 查看路由表
dis bgp routing-table  
# R1上测试连通性
ping -a 1.1.1.1 5.5.5.5
# 查看被选入路由表的bgp路由
dis ip rou pro bgp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二通过环回口方式建立ebgp对等体&#34;&gt;实验二：通过环回口方式建立eBGP对等体&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;此实验更能说明&lt;/strong&gt;：BGP peer是基于TCP连接之上建立的，BGP协议允许跨越多个节点建立BGP对等体，也就是说，即使不相邻的两台设备也可以建立BGP对等体。&lt;br&gt;
应用环回口建立BGP对等体，是比较常见的一种可靠性的做法。环回口建立BGP对等体适用于&lt;strong&gt;不仅仅存在一条通信链路的两台BGP设备之间&lt;/strong&gt;，提供了对等体的稳定（链路冗余）和高可用性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 保证环回口之间的IP连通性
# R1
ip route-static 55.1.1.1 32 10.1.15.5    
# R5
ip route-static 11.1.1.1 32 10.1.15.1
# 使用ping进行检测

# 配置eBGP对等体
# R1
bgp 100
peer 55.1.1.1 as-number 200
# R5
bgp 200
peer 11.1.1.1 as-number 100

# 配置eBGP多跳或者关闭直连检测功能
# 【关闭直连检测，这个方案，仅仅适用于直连设备使用环回口建立eBGP对等体；设置eBGP多跳，这个方案同时也适用于域间MPLS VVV等需要跨越多个节点的两台eBGP设备建立对等体】
# 【华为设备只支持配置eBGP多跳】
# 否则停留在Idle状态，即TCP报文无法到达对等体
# 默认的情况下，绝大多数的BGP实现，应当保证eBGP对等体之间发送的报文 TTL = 1（直连）
# R1
bgp 100
peer 55.1.1.1 ebgp-max-hop 2  # 修改最大的跳数，即修改TTL的值
# R5
bgp 200
peer 11.1.1.1 ebgp-max-hop 2

# 指定更新源地址
# 否则停留在Active状态，即对等体之间找到了物理接口以及其上的IP，但是未找到环回口
# 指定了建立BGP对等体关系时使用的IP源地址，通常还会把这个地址做为下一跳地址附加在路径属性中，更新给邻居（简而言之，对等体之间默认物理接口和其上的IP作为peer的连接方式）
# R1
bgp 100
peer 55.1.1.1 connect-interface LoopBack 0
# R5
bgp 200
peer 11.1.1.1 connect-interface LoopBack 0

# 此时查看路由表
[R1] dis bgp rou
# 去往5.5.5.5/32的有两个下一跳，默认10.1.15.5为优选
# 如果想要让55.1.1.1成为下一跳，则需要在R1上执行以下命令：
bgp 100
peer 55.1.1.1 preferred-value 1 # 修改优先级
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三ibgp邻居配置实验同时查看路由黑洞&#34;&gt;实验三：iBGP邻居配置实验（同时查看路由黑洞）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;构建R1和R4、R5和R7的iBGP邻居&lt;/li&gt;
&lt;li&gt;内部IGP使得更新源地址可达&lt;/li&gt;
&lt;li&gt;非常重要的几个点：
&lt;ul&gt;
&lt;li&gt;IGP保证更新源（对等体IP地址）可达&lt;/li&gt;
&lt;li&gt;配置更新源&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 思科
neighbor 44.1.1.1 remote-as 100
neighbor 44.1.1.1 update-source Loopback0
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
peer 44.1.1.1 as 100
peer 44.1.1.1 connect-interface lo 0
return
sa
# R4
bgp 100
peer 11.1.1.1 as 100
peer 11.1.1.1 connect-interface lo 0
network 4.4.4.4 32
return
sa

# R5
bgp 200
peer 77.1.1.1 as 200
peer 77.1.1.1 connect-interface lo 0
return
sa
# R7
bgp 200
peer 55.1.1.1 as 200
peer 55.1.1.1 connect-interface lo 0
return
sa
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验四使用全互联的方式解决路由黑洞&#34;&gt;实验四：使用全互联的方式解决路由黑洞&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在R3上分别建立R1和R4的iBGP邻居&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R3
bgp 100
peer 11.1.1.1 as 100
peer 11.1.1.1 connect-interface lo 0
peer 44.1.1.1 as 100
peer 44.1.1.1 connect-interface lo 0
return
sa
# R1和R4
bgp 100
peer 33.1.1.1 as 100
peer 33.1.1.1 connect-interface lo 0
return
sa
# 测试
# R4
ping -a 4.4.4.4 1.1.1.1
tracert -a 4.4.4.4 1.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验五修改下一跳属性&#34;&gt;实验五：修改下一跳属性&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
peer 33.1.1.1 next-hop-local
ret
sa
# R5
bgp 200
peer 77.1.1.1 next-hop-local
ret
sa
# 测试
# R7
refresh bgp all import  # 刷新bgp路由列表
dis bgp rou
# R5
ping -a 5.5.5.5 4.4.4.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验六bgp的下一跳不改变场景&#34;&gt;实验六：BGP的下一跳不改变场景&lt;/h2&gt;
&lt;p&gt;在R1向R5&lt;strong&gt;传递路由&lt;/strong&gt;时，尝试做下一跳不改变并观察现象【从R3\R4传递给R1（iBGP对等体）的BGP路由，再传递给R5（eBGP对等体）】&lt;br&gt;
应用于域间MPLS VPN环境&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
peer 55.1.1.1 next-hop-invariable
return
reset bgp all
# R5
return
refresh bgp all import
dis bgp rou  # 查看路由情况
# 此实验最后无现象，与ENSP模拟器有关系
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验七bgp-asbr下一跳方案对比&#34;&gt;实验七：BGP ASBR下一跳方案对比&lt;/h2&gt;
&lt;p&gt;取消R5对R7的下一跳自我，尝试将直连路由引入IGP并观察现象&lt;br&gt;
对比下一跳自我和重发布直连，从路由收敛的角度分析不同之处&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R5
bgp 200
undo peer 77.1.1.1 next-hop-local
# R7
return
refresh bgp all import
dis bgp rou # 此时来自as100的路由无法优先，原因是下一跳不可达

# R5：重发布静态路由
ospf 1
import-route static
q
dis bgp rou # 此时来自as100的路由可以进行优选了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验八多点接入的下一跳&#34;&gt;实验八：多点接入的下一跳&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1595076243431.png&#34; alt=&#34;多点接入的下一跳&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
多点接入的下一跳（第三方下一跳）&lt;br&gt;
R5、R6通过以太网建立iBGP对等体&lt;br&gt;
R2、R6通过以太网建立eBGP对等体&lt;br&gt;
观察R2和R5上的路由下一跳地址&lt;code&gt;dis bgp rou 5.5.5.5&lt;/code&gt;&lt;br&gt;
这种情况下，似乎R6向R2传递路由时，NH并未改为自己&lt;br&gt;
此时尝试针对R2做下一跳自我并观察效果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R2
int g0/0/1
ip addr 10.1.1.2 24
# R5
int g0/0/2
ip addr 10.1.1.5 24
# R6
int g0/0/2
ip addr 10.1.1.6 24

# R6
bgp 200
peer 10.1.1.5 as 200
peer 10.1.1.2 as 100
# R5
bgp 200
peer 10.1.1.6 as 200
# R2
bgp 100
peer 10.1.1.6 as 200

# 此时R2访问5.5.5.5的下一跳为10.1.1.5
# R6 
bgp 200
peer 10.1.1.2 next-hop-local
# 此时R2访问5.5.5.5的下一跳为10.1.1.6（第三方下一跳）
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验九部署bgp对等体组&#34;&gt;实验九：部署BGP对等体组&lt;/h2&gt;
&lt;p&gt;通过对等体组模板简化配置&lt;br&gt;
适用于针对多个对等体需要部署相同策略的环境&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
group PEER_GROUP internal  # 创建一个针对IBGP的对等体组
peer PEER_GROUP connect-interface LoopBack0
peer PEER_GROUP next-hop-local
peer 44.1.1.1 group PEER_GROUP # 针对邻居来使用
peer 22.1.1.1 group PEER_GROUP 
peer 33.1.1.1 group PEER_GROUP 
# R2
bgp 100
group PEER_GROUP internal
peer PEER_GROUP connect-interface LoopBack0
peer PEER_GROUP next-hop-local
peer 11.1.1.1 group PEER_GROUP
peer 44.1.1.1 group PEER_GROUP 
peer 33.1.1.1 group PEER_GROUP 
# R3
bgp 100
group PEER_GROUP internal
peer PEER_GROUP connect-interface LoopBack0
peer PEER_GROUP next-hop-local
peer 11.1.1.1 group PEER_GROUP
peer 22.1.1.1 group PEER_GROUP 
peer 44.1.1.1 group PEER_GROUP 
# R4
bgp 100
group PEER_GROUP internal
peer PEER_GROUP connect-interface LoopBack0
peer PEER_GROUP next-hop-local
peer 11.1.1.1 group PEER_GROUP
peer 22.1.1.1 group PEER_GROUP 
peer 33.1.1.1 group PEER_GROUP 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十部署基于对等体组的动态邻居思科&#34;&gt;实验十：部署基于对等体组的动态邻居（思科）&lt;/h2&gt;
&lt;p&gt;R3 做为动态邻居的侦听者，R1、R2、R4 主动找R3建立动态邻居&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置一个对等体组，用于部署侦听策略&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;neighbor Dynamic peer-group
neighbor Dynamic remote-as 100
neighbor Dynamic update-source Loopback2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;规划一个子网范围用于动态邻居   &lt;code&gt;172.16.1.0/24&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;每个设备配置一个子网范围内的 32 位的环回口，并使得其IP可达（宣高进IGP即可）&lt;/li&gt;
&lt;li&gt;配置侦听&lt;code&gt;R3(config-router)#bgp listen range 172.16.1.0/24 peer-group Dynamic&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实验十一as欺骗&#34;&gt;实验十一：AS欺骗&lt;/h2&gt;
&lt;p&gt;在R1上欺骗R5&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R5
bgp 200
undo peer 11.1.1.1
peer 11.1.1.1 as 6535
peer 11.1.1.1 connect-interface lo 0

# R1
bgp 100
peer 55.1.1.1 fake-as 65535
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十二移除私有as号码&#34;&gt;实验十二：移除私有AS号码&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;思科：neighbor 10.1.1.10 remove-private-as all [replace-as]&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 暂时关闭在R2上的邻居
# R2
int g0/0/1
shutdown

# 配置邻居
# R5
bgp 200
peer 10.1.1.10 as 300

# SW
sys
sys SW
int vlanif 1
ip addr 10.1.1.10 24
q
bgp 300
peer 10.1.1.5 as 200
dis bgp rou

# 移除私有AS
# R5
bgp 200
peer 10.1.1.10 public-as-only

# 查看
# SW
refresh bgp all import
dis bgp rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十三路由自动聚合&#34;&gt;实验十三：路由自动聚合&lt;/h2&gt;
&lt;p&gt;R1创建额外环回口并通告，开启自动聚合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 仅仅对重分布的路由（import-route）生效，组件路由抑制生成，但没有产生指向 null0的聚合路由
# R1
int l2
ip addr 1.1.1.2 32
int l3
ip addr 1.1.1.3 32
q
acl 2000
rule permit source 1.1.1.0 0.0.0.255
q
route-policy 1 permit node 10
if-match acl 2000
q
bgp 100
import-route direct route-policy 1
summary automatic
q
dis bgp rou
# 查看
# R5
dis bgp rou
dis bgp rou 1.0.0.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;补充思科设备一般不做自动聚合而使用流量清洗&#34;&gt;补充：思科设备一般不做自动聚合，而使用流量清洗&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 思科
R1(config-router)#auto-summary 
R1(config-router)#bgp aggregate-timer 0   // 默认 30秒
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;其实不是聚合的一种办法（通告指向空接口的静态）。不做重分布，将手工书写的聚合范围的静态路由network到BGP中。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;R1(config)#ip route 1.1.1.0 255.255.255.0 null 0
R1(config-router)#network 1.1.1.0 mask 255.255.255.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十四手动聚合验证起源代码的继承&#34;&gt;实验十四：手动聚合，验证起源代码的继承&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
undo summary automatic
aggregate 1.1.1.0 24
# aggregate 1.1.1.0 24 detail-suppressed    # 抑制明细路由，抑制明细后生成的聚合携带原子聚合Atomic-aggregate属性，且不携带原明细路由的团体属性
q
dis bgp rou
dis bgp rou 1.1.1.0
# 查看
# R5
dis bgp rou 
dis bgp rou 1.1.1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十五为聚合路由设置属性&#34;&gt;实验十五：为聚合路由设置属性&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
route-policy 2 permit node 10
apply origin igp
apply cost 666
bgp 100
aggregate 1.1.1.0 24 as-set detail-suppressed attribute-policy 2
# R5
dis bgp rou
dis bgp rou 1.1.1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十六验证rr环境下的ibgp路由传递&#34;&gt;实验十六：验证RR环境下的iBGP路由传递&lt;/h2&gt;
&lt;p&gt;R1部署为RR指定R3、R4为客户端（AS100内，所有设备只跟R1建立对等体）&lt;br&gt;
客户端之间反射&lt;br&gt;
客户端和非客户端之间反射&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
undo peer 22.1.1.1 group PEER_GROUP
peer 22.1.1.1 as 100
peer 22.1.1.1 con lo 0
peer 22.1.1.1 next-hop-local
peer 33.1.1.1 reflect-client
peer 44.1.1.1 reflect-client
# undo reflect between-clients    # 关闭客户端之间的反射
# R2
bgp 100
peer 33.1.1.1 ignore
peer 44.1.1.1 ignore
network 2.2.2.2 32
# R3
bgp 100
peer 22.1.1.1 ignore
peer 44.1.1.1 ignore
# R4
bgp 100
peer 22.1.1.1 ignore
peer 33.1.1.1 ignore

# 查看路由
# R2\3
dis bgp rou
dis bgp rou 4.4.4.4
# R4
dis bgp rou
dis bgp rou 2.2.2.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十七理解起源者id和cluster-id的作用&#34;&gt;实验十七：理解起源者ID和Cluster-id的作用&lt;/h2&gt;
&lt;p&gt;R1、R2部署为RR，R3、R4部署为RR客户端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
peer 22.1.1.1 reflect-client
# R2
bgp 100
peer PEER_GROUP route-client
undo peer 33.1.1.1 ignore
undo peer 44.1.1.1 ignore
# R3
bgp 100
undo peer 22.1.1.1 ignore
# R4
bgp 100
undo peer 22.1.1.1 ignore
# 查看
# R2
dis bgp rou
dis bgp rou 4.4.4.4

# 起源者ID防环
# R3
bgp 100
router-id 10.1.34.4 # 将起源者ID改成和R4相同

# Cluster-id防环
# R3
bgp 100
router-id 33.1.1.1 # 恢复起源者ID防环实验环境
# R1
bgp 100
reflector cluster-id 10.1.23.2 # 改成和R2相同的
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十八bgp联邦&#34;&gt;实验十八：BGP联邦&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;实验内容：R5为AS2005，R6和R7为AS2067，同属于AS200&lt;/li&gt;
&lt;li&gt;部署要点：
&lt;ul&gt;
&lt;li&gt;联邦边界对联邦内部的对等体做下一跳自我&lt;/li&gt;
&lt;li&gt;所有的子AS都应该写到列表上&lt;/li&gt;
&lt;li&gt;如果使用环回口建立，联邦内部的eBGP对等体应当配置eBGP多跳&lt;br&gt;
配置国家AS：&lt;code&gt;confederation id 200&lt;/code&gt;&lt;br&gt;
配置国家内部城邦eBGP的AS列表（将所有的AS成员都写入）：&lt;code&gt;confederation peer-as 2067&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R5
undo bgp
bgp 2005
confederation id 200
confederation peer-as 2067
peer 11.1.1.1 as 100
peer 11.1.1.1 ebgp-max-hop 2
peer 11.1.1.1 connect-interface lo 0
peer 77.1.1.1 as 2067
peer 77.1.1.1 ebgp-max-hop 2
peer 77.1.1.1 connect-interface lo 0
network 5.5.5.5 32

# R6
undo bgp
bgp 2067
confederation id 200
confederation peer-as 2005
peer 77.1.1.1 as 2067
peer 77.1.1.1 connect-interface lo 0
network 6.6.6.6 32

# R7
undo bgp
bgp 2067
confederation id 200
confederation peer-as 2005
peer 66.1.1.1 as 2067
peer 66.1.1.1 connect-interface lo 0
peer 55.1.1.1 as 2005
peer 55.1.1.1 ebgp-max-hop 2
peer 55.1.1.1 connect-interface lo 0

# 删除之前配置环境
#  R1
bgp 100
undo peer 55.1.1.1 next-hop-invariable
undo peer 55.1.1.1 fake-as 65535
# R5
ospf
undo import-route static  # 此时R7收到的来自AS100的路由无法优选，因为下一跳不可达因此在这里需要设置下一跳自我
q
bgp 2005
peer 77.1.1.1 next-hop-local
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验十九团体属性no-export&#34;&gt;实验十九：团体属性no-export&lt;/h2&gt;
&lt;p&gt;在R3上产生路由，应用策略，使其携带no-export属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;针对对等体应用通告团体的命令&lt;/li&gt;
&lt;li&gt;设置团体策略&lt;/li&gt;
&lt;li&gt;产生路由时应用团体策略&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
peer PEER_GROUP advertise-community
peer 22.1.1.1 advertise-community
# R2
bgp 100
peer PEER_GROUP advertise-community
# R4
bgp 100
peer PEER_GROUP advertise-community
# R3
route-policy COMM permit node 10
apply community no-export 100:333
q
bgp 100
network 3.3.3.3 32 route-policy COMM
peer PEER_GROUP advertise-community

# 查看
# R1/2/4/5
dis bgp rou 3.3.3.3
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十团体属性no-export-subconfedlocal-as&#34;&gt;实验二十：团体属性no-export-subconfed(local-as)&lt;/h2&gt;
&lt;p&gt;在R7上产生路由，使其携带no-export-subconfed属性&lt;br&gt;
实验2.1：在联邦内部应用 no-export 属性&lt;br&gt;
no-export 在联邦环境下，不影响子AS之间的传递，但路由不能传出联邦&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
bgp 100
peer 55.1.1.1 advertise-community
# R5
bgp 2005
peer 77.1.1.1 advertise-community
peer 11.1.1.1 advertise-community
# R6
bgp 2067
peer 77.1.1.1 advertise-community
peer 10.1.26.2 as 100
peer 10.1.26.2 advertise-community
# R2
bgp 100
peer 10.1.26.6 as-number 200
peer 10.1.26.6 advertise-community
# R7
bgp 2067
peer 55.1.1.1 advertise-community
peer 66.1.1.1 advertise-community
q
route-policy COMM permit node 10
apply community no-export-subconfed 200:2067
q
bgp 2067
network 7.7.7.7 32 route-policy COMM

# 查看
# R7/6/5/2
dis bgp rou 7.7.7.7  # 此时只有在R6上有相应的路由且带有属性

# ---------------------------------
# 对比在通告时加入属性和传递给邻居时加入属性的区别
# 即直接在出方向上设置属性，不在通告上设置属性了 
# R7
bgp 2067
undo network 7.7.7.7 32
network 7.7.7.7 32
peer 55.1.1.1 route-policy COMM export
peer 66.1.1.1 route-policy COMM export
# R7/6/5
dis bgp rou 7.7.7.7  # 此时R7本身不带团体属性，只有在R6和R5上有相应的路由且带有属性

# ---------------------------------
# 在联邦内部使用no-export属性
# R7
bgp 2067
undo peer 66.1.1.1 route-policy COMM export
undo peer 55.1.1.1 route-policy COMM export
network 7.7.7.7 32 route-policy COMM
q
route-policy COMM permit node 10
apply community no-export 200:2067
# R5/6/1
dis bgp rou 7.7.7.7  # 在R6和R5上有相应的路由且带有属性，但R1没有相应的路由
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十一团体属性no-advertise&#34;&gt;实验二十一：团体属性no-advertise&lt;/h2&gt;
&lt;p&gt;对比在通告时加入属性和传递给邻居时加入属性的区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通告时携带，将不能传递出去&lt;/li&gt;
&lt;li&gt;传递给邻居时携带，邻居将不能通告出去&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 通告时携带
# R7
int lo 2
ip addr 77.77.77.77 32
q
ip ip-prefix 7 permit 7.7.7.7 32
route-policy COMM permit node 10
undo apply community
if-match ip-prefix 7
apply community no-advertise     # 7.7.7.7通告时携带属性，所有其无法通告给对等体
q
route-policy COMM1 permit node 10
apply community no-advertise     # 77.77.77.77传递给邻居时携带属性，本路由可以通告给邻居，但是邻居收到后无法再向邻居的对等体进行通告
q
bgp 2067
network 77.77.77.77 32
peer 55.1.1.1 route-policy COMM1 export
peer 66.1.1.1 route-policy COMM1 export
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十二设置自定义团体属性和med&#34;&gt;实验二十二：设置自定义团体属性和MED&lt;/h2&gt;
&lt;p&gt;需求效果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R3产生的路由携带团体 100:333，并且数据转发路径为 7513&lt;/li&gt;
&lt;li&gt;R4产生的路由携带团体 100:444，并且数据转发路径为 7624 （调整AS100 IGP）&lt;br&gt;
方案：&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方案a&#34;&gt;方案A&lt;/h3&gt;
&lt;p&gt;在R1和R2上根据团体对eBGP应用MED（MED越小越优）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R3
route-policy COMM permit node 10
undo apply community
apply community 100:333

# R4
route-policy COMM permit node 10
apply community 100:444
bgp 100
network 4.4.4.4 32 route-policy COMM

# R1
ip community-filter 13 permit 100:333
ip community-filter 14 permit 100:444
route-policy MED permit node 10
if-match community-filter 13
apply cost 100
route-policy MED permit node 20 
if-match community-filter 14 
apply cost 200
route-policy MED permit node 30 # 放行其他所有的路由
bgp 100
peer 55.1.1.1 route-policy MED export

# R2
ip community-filter 13 permit 100:333
ip community-filter 14 permit 100:444
route-policy MED permit node 10
if-match community-filter 13
apply cost 200
route-policy MED permit node 20 
if-match community-filter 14 
apply cost 100
route-policy MED permit node 30 
bgp 100
peer 10.1.26.6 route-policy MED export

# R6
bgp 2067
peer 77.1.1.1 next-hop-local

# 查看
# R7
bgp 2067
undo netowork 7.7.7.7 32
netowork 7.7.7.7 32
undo peer 55.1.1.1 route-policy COMM1 export
undo peer 66.1.1.1 route-policy COMM1 export
q
dis bgp rou
ping -a 7.7.7.7 3.3.3.3
tracert -a 7.7.7.7 3.3.3.3  # 10.1.57.5--10.1.15.1--10.1.13.3
ping -a 7.7.7.7 4.4.4.4
tracert -a 7.7.7.7 4.4.4.4  # 10.1.67.6--10.1.26.2--10.1.23.3--10.1.34.4：R2转发给R3再转发给R4，而不是直接转发给R4的原因是IGP（R2直连R4的接口带宽低，OSPF不选择此）
# 在此处不建议调整，因为修改IGP会导致AS100内部路由调整，所有最终的走向为 76234
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;方案b&#34;&gt;方案B&lt;/h3&gt;
&lt;p&gt;在R5和R6上根据团体对eBGP进来的路由应用本地优先级（Local_Pref越大越优）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 删除之前配置的MED
# R1
bgp 100
undo peer 55.1.1.1 route-policy MED export
# R2
bgp 100
undo peer 10.1.26.2 route-policy MED export

# 配置本地优先级
# R5
ip community-filter 23 permit 100:333
ip community-filter 24 permit 100:444
route-policy LP permit node 10
if-match community-filter 23
apply local-preference 200
route-policy LP permit node 20 
if-match community-filter 24 
apply local-preference 150
route-policy MED permit node 30 
bgp 2005
peer 11.1.1.1 route-policy LP import

# R6
ip community-filter 23 permit 100:333
ip community-filter 24 permit 100:444
route-policy LP permit node 10
if-match community-filter 23
apply local-preference 150
route-policy LP permit node 20 
if-match community-filter 24 
apply local-preference 200
route-policy MED permit node 30 
bgp 2067
peer  10.1.26.2 route-policy LP import

# 查看
# R7/5/6
refresh bgp all import
dis bgp rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十三路由选择-比较权重值&#34;&gt;实验二十三：路由选择-比较权重值&lt;/h2&gt;
&lt;p&gt;仅仅本设备有意义，越大越优先&lt;br&gt;
实验内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R3针对R2入站的路由全部指定权重值为100&lt;/li&gt;
&lt;li&gt;R3针对R1进来的6.6.6.6路由指定权重值为200&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R3
ip ip-prefix 6 permit 6.6.6.6 32
route-policy WEIGHT permit node 10
if-match ip-prefix 6
apply preferred-value 200
route-policy WEIGHT permit node 20 # 放行其他所有的路由
q
bgp 100
peer 22.1.1.1 preferred-value 100
peer 11.1.1.1 route-policy WEIGHT import

# 查看
# R3
dis bgp rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十四路由选择-比较本地优先级&#34;&gt;实验二十四：路由选择-比较本地优先级&lt;/h2&gt;
&lt;p&gt;本地优先级属性仅在iBGP对等体和联邦内部传递，不传递给eBGP对等体&lt;br&gt;
该数值越大则优先级越高&lt;br&gt;
缺省情况下，BGP本地优先级值为100&lt;code&gt;设置本地优先级：default local-preferrence 250&lt;/code&gt;&lt;br&gt;
实验内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R6入站策略设置2.2.2.2的本地优先级为222&lt;/li&gt;
&lt;li&gt;R5设置默认本地优先级200&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R6
ip ip-prefix 2 permit 2.2.2.2 32
undo route-policy LP
route-policy LP permit node 10
if-match ip-prefix 2
apply local-preference 222
route-policy LP permit node 20

# R5
bgp 2005
undo peer 11.1.1.1 route-policy LP import
default local-preference 200

# 查看
# R7
dis bgp rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十五路由选择-起源&#34;&gt;实验二十五：路由选择-起源&lt;/h2&gt;
&lt;p&gt;使用route-policy修改起源代码&lt;br&gt;
实验内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将R4优选的来自RR1的路由通过入站策略修改起源代码为“？”&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R4
route-policy ORIGIN permit node 10
apply origin incomplete
bgp 100
peer 11.1.1.1 route-policy ORIGIN import

# 查看
# R4
dis bgp rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十六路由选择-as-path&#34;&gt;实验二十六：路由选择-as-path&lt;/h2&gt;
&lt;p&gt;跳过as-path选路规则命令&lt;code&gt;bestroute as-path-ignore&lt;/code&gt;&lt;br&gt;
实验内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;R1出站策略：为3.3.3.3设置前置AS号码100 100 100&lt;/li&gt;
&lt;li&gt;R2出站策略：为4.4.4.4设置前置AS号码100 100 100&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 下面设置是为了防止之前实验设置的本地优先级对本实验的影响
# R7
# route-policy NONE permit node 10
# apply local-preference 300
# R6
bgp 2067
undo peer 10.1.26.2 route-policy LP import
# R5 
bgp 2005
undo defaut local-preference 

# 配置
#Ｒ1
ip ip-prefix 3 permit 3.3.3.3 32
route-policy AS permit node 10
if-match ip-prefix 3
apply as-path 100 100 100 additive
route-policy AS permit node 20
bgp 100
peer 55.1.1.1 route-policy AS export
#Ｒ2
ip ip-prefix 4 permit 4.4.4.4 32
route-policy AS permit node 10
if-match ip-prefix 4
apply as-path 100 100 100 additive
route-policy AS permit node 20
bgp 100
peer 10.1.26.6 route-policy AS export

# 查看
# R5/6
dis bgp rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十七路由选择-到bgp更新源igp开销小的被优选&#34;&gt;实验二十七：路由选择-到BGP更新源IGP开销小的被优选&lt;/h2&gt;
&lt;p&gt;实验内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改OSPF（IGP）的cost&lt;/li&gt;
&lt;li&gt;将R4到R2的路径修改为经过R2比较小（即目前是R4-R3-R2，修改后为R4-R2）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R4
bgp 100
undo peer 11.1.1.1 route-policy ORIGIN import

# R3
int g0/0/1
ospf cost 3

# 查看
# R4
dis bgp rou 7.7.7.7
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十八路由选择-开启负载均衡&#34;&gt;实验二十八：路由选择-开启负载均衡&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R3
int g0/0/1
undo ospf cost

# R4
bgp 100
maximum load-balancing ibgp  2    # 可以开启iBGP或者eBGP的负载均衡，默认情况下只开启eBGP的负载均衡，如果eBGP有备份路径的话，可以开启iBGP的负载均衡。2代表负载均衡时使用两条链路。
# 负载均衡之后，路由前面（Status codes状态码那一列）会显示一个“m”，代表多路径multipath。
# 负载均衡虽然会有两条路径被优选，但是也只能向外更新一个，即best那条路由
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二十九产生默认路由的三种方式&#34;&gt;实验二十九：产生默认路由的三种方式&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 方案一：使用network命令引入IGP路由
# R1
ip route-static 0.0.0.0 0 10.1.15.1
bgp 100
network 0.0.0.0
dis bgp rou # 起源代码为i
undo network 0.0.0.0  # 查看完毕之后直接删除

# 方案二：重发布
# R1
bgp 100
import-route static
default-route imported
dis bgp rou  # 起源代码为？
undo import-route static
undo default-route imported

# 方案三：针对特定邻居下发默认路由
# R5
bgp 2005
peer 77.1.1.1 default-route-advertise
dis bgp rou  # 在R5上看不见，需要在R7上查看，所以此命令需要在R7和R5上执行
undo peer 77.1.1.1 default-route-advertise
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三十一as-path控制列表&#34;&gt;实验三十一：as-path控制列表&lt;/h2&gt;
&lt;p&gt;实验内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设 R7 是我们的企业网&lt;/li&gt;
&lt;li&gt;R5、R6是两个SP，背后的AS100是大型SP&lt;/li&gt;
&lt;li&gt;应用列表，阻止R7成为SP的流量载体&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 删除之前的环境
# R5
undo bgp 2005
# R6/7
undo bgp 2067
# R7
undo bgp 2067
# R1
bgp 100
undo peer 55.1.1.1 
peer 10.1.15.5 as-number 500
# R2
bgp 100
undo peer 10.1.26.6
peer 10.1.26.6 as-number 600

# 重新配置环境
# R5
bgp 500
peer 10.1.15.1 as-number 100
peer 10.1.57.7 as-number 700
network 5.5.5.5 32
# R7
bgp 700
peer 10.1.67.6 as-number 600
peer 10.1.57.5 as-number 500
network 7.7.7.7 32
# R6
bgp 600
peer 10.1.67.7 as-number 700
peer 10.1.26.2 as-number 100
network 6.6.6.6 32

# 配置as-path访问控制列表
# R7
ip as-path-filter 1 permit ^$  # 匹配本地AS始发的更新路由
bgp 700
peer 10.1.57.5 as-path-filter 1 export
peer 10.1.67.6 as-path-filter 1 export  #即仅仅通告本地始发的路由给对等体
# 此时，R6上去往R5(5.5.5.5)的路由的下一跳为10.1.26.2；R5上去往R6(6.6.6.6)的路由的下一跳为10.1.15.1。此时R5和R6上只有7.7.7.7的路由的下一跳为R7，即阻止了非R7流量经过R7的情况。
# 查看R7上通告路由情况
# R7
dis bgp peer 10.1.67.6 verbose
dis bgp peer 10.1.57.5 verbose
# 可以看到仅有一条路由更新出去，即本地AS始发的路由7.7.7.7
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三十二应用温和重配置&#34;&gt;实验三十二：应用温和重配置&lt;/h2&gt;
&lt;p&gt;实验内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在R5上针对R1应用入站方向的前缀列表，过滤路由&lt;/li&gt;
&lt;li&gt;应用入站方向的温和重配置&lt;br&gt;
[R5-bgp]&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R5
ip ip-prefix 1234 permit 2.2.2.2 32
bgp 500
peer 10.1.15.1 ip-prefix 1234 import
dis bgp rou
peer 10.1.15.1 keep-all-routes
dis bgp rou
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三十三出站路由过滤orf&#34;&gt;实验三十三：出站路由过滤ORF&lt;/h2&gt;
&lt;p&gt;在R5上设置入站策略，然后将策略通过ORF传至R1，编程R1的出站策略，对路由进行过滤&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R5
bgp 500
peer 10.1.15.1 capability-advertise orf ip-prefix  send  # 前缀列表是上一个实验写的：ip ip-prefix 1234 permit 2.2.2.2 32
# R1
bgp 100
peer 10.1.15.5 capability-advertise orf ip-prefix receive

# 查看
# R5
dis bgp rou
# R1
dis bgp peer 10.1.15.5 orf ip-prefix
&lt;/code&gt;&lt;/pre&gt;
">HCIE-BGP专题(2020.07.13，第1专题)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/jin-yong-tshark-yong-hu-gao-jing/"" data-c="
          &lt;p&gt;&lt;strong&gt;告警信息如下：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;Running as user &amp;quot;root&amp;quot; and group &amp;quot;root&amp;quot;. This could be dangerous. tshark: Lua: Error during loading:&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;yum -y install wireshark-devel&lt;/code&gt;&lt;br&gt;
编辑/usr/share/wireshark/init.lua文件，修改dofile(DATA_DIR..&amp;quot;console.lua&amp;quot;)为--dofile(DATA_DIR..&amp;quot;console.lua&amp;quot;)，也就是直接注掉。&lt;br&gt;
&lt;code&gt;注销或重启之后有效&lt;/code&gt;&lt;/p&gt;
">禁用tshark用户告警</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/hcie-mpls-zhuan-ti-20200706/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E4%B8%93%E9%A2%98%E6%8B%93%E6%89%91%E4%BB%A5%E5%8F%8Aensp%E6%8B%93%E6%89%91%E4%BD%BF%E7%94%A8&#34;&gt;MPLS专题拓扑以及ENSP拓扑使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%80%E5%8D%95%E5%9B%9E%E9%A1%BE&#34;&gt;简单回顾&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&#34;&gt;MPLS基本原理&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%9C%AF%E8%AF%AD%E7%AD%89&#34;&gt;MPLS术语等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84&#34;&gt;MPLS基本结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%A0%87%E7%AD%BE%E6%A0%BC%E5%BC%8F&#34;&gt;MPLS标签格式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%B8%A7%E6%A0%BC%E5%BC%8F&#34;&gt;MPLS帧格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF&#34;&gt;MPLS头部信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E6%A0%87%E7%AD%BE%E5%B5%8C%E5%A5%97&#34;&gt;MPLS标签嵌套&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mpls%E8%BD%AC%E5%8F%91%E6%B5%81%E7%A8%8B&#34;&gt;MPLS转发流程&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%A0%87%E7%AD%BE%E8%A1%8C%E4%B8%BA%E6%80%BB%E7%BB%93&#34;&gt;标签行为总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ldp%E5%8D%8F%E8%AE%AE%E5%8E%9F%E7%90%86&#34;&gt;LDP协议原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C&#34;&gt;实验&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%9E%E9%AA%8C%E4%B8%80%E5%AE%9E%E6%96%BDldp&#34;&gt;实验一：实施LDP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%80%9D%E7%A7%91&#34;&gt;思科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%8E%E4%B8%BA&#34;&gt;华为&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;mpls专题拓扑以及ensp拓扑使用&#34;&gt;MPLS专题拓扑以及ENSP拓扑使用&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1594043153855.png&#34; alt=&#34;MPLS专题拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
上课之前开启以下设备&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594219215690.png&#34; alt=&#34;ENSP拓扑使用&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;简单回顾&#34;&gt;简单回顾&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;TCP/IP端到端通信模型，IP转发的特点、依据：逐跳转发（路由黑洞）、依据目标地址和路由表（策略）转发&lt;/li&gt;
&lt;li&gt;BGP路由黑洞解决方案：全互联、路由反射器、同步IGP（即路由引入）、联盟&lt;/li&gt;
&lt;li&gt;MPLS多协议标签交换，高速转发，这是一种增加了能源消耗的转发技术，但是效率提高了。MPLS转发类似大型超市，需要扫码枪和很多收银员；传统IP转发类似小卖部，不需要这么多辅助工具与员工。&lt;/li&gt;
&lt;li&gt;依据数据库完成设备的数据处理或者转发角色，路由协议：邻居表、路由表、数据库（LSDB、BGP table、topology base（EIGRP））&lt;/li&gt;
&lt;li&gt;MPLS提供了一种相对比较简单的转发决策方法，在帧模式当中，将一个或者多个标签插入在二层头部后面，MPLS域的路由器依据标签做转发决策，标签是32bit固定长度的数值&lt;/li&gt;
&lt;li&gt;MPLS进阶路线：MPLS --&amp;gt; MPLS-VPN ---&amp;gt; MPLS-TE（流量工程） ---&amp;gt; SegmentRouting（分段路由，靠源决定路由往哪发）&lt;/li&gt;
&lt;li&gt;转控分离：控制层面----负责形成转发表项，比如路由协议等；数据层面----负责转发数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;mpls基本原理&#34;&gt;MPLS基本原理&lt;/h1&gt;
&lt;h2 id=&#34;mpls术语等&#34;&gt;MPLS术语等&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在IP网络与MPLS网络的交界处，边界的设备通常称为&lt;strong&gt;入站LSR&lt;/strong&gt;（标签交换路由器）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由器做IP转发&lt;/strong&gt;，需要哪些基础内容：配置IP地址、产生直连路由、配置路由协议、产生路由表、路由原理、IP报文。&lt;br&gt;
&lt;strong&gt;MPLS路由器LSR转发&lt;/strong&gt;报文又需要些什么呢？标签（标签协议）、具备标签转发表（标签分发协议+路由协议）、标签报文（IP报文+标签）&lt;/li&gt;
&lt;li&gt;术语：
&lt;ol&gt;
&lt;li&gt;CE：客户边界设备。CE(Customer Edge)，用户边缘设备，服务提供商所连接的用户端路由器。CE路由器通过连接一个或多个PE路由器，为用户提供服务接入。CE路由器通常是一台IP路由器，它与连接的PE路由器建立邻接关系&lt;/li&gt;
&lt;li&gt;PE：运营商边界设备。PE(Provider Edge)，即Provide的边缘设备，服务提供商骨干网的边缘路由器，它相当于标签边缘路由器（LER）。PE路由器连接CE路由器和P路由器，是最重要的网络节点。用户的流量通过PE路由器流入用户网络，或者通过PE路由器流到MPLS骨干网&lt;/li&gt;
&lt;li&gt;P：运营商内部的设备，仅仅负责帮助转发数据。P(Provider)，是核心层设备，提供商路由器，服务提供商是不连接任何CE路由器的骨干网路由设备，它相当于标签交换路由器（LSR）&lt;/li&gt;
&lt;li&gt;LSR：标签交换路由器&lt;/li&gt;
&lt;li&gt;LER：标签边缘路由器（PE）&lt;/li&gt;
&lt;li&gt;CPE：三巨头中两个互联，为同一个客户服务&lt;/li&gt;
&lt;li&gt;MCE：MCE功能是Multi-CE的简称，具有MCE功能的交换机可以在BGP/MPLS VPN组网应用中承担多个VPN实例的CE功能，减少用户网络设备的投入&lt;/li&gt;
&lt;li&gt;vrf（思科称vpn instance）：&lt;strong&gt;在PE设备上起到隔离作用&lt;/strong&gt;，每一个vrf提供一个独立的路由表，同时甚至能够提供独立的路由协议进程&lt;/li&gt;
&lt;li&gt;LSP：标签交换通道，LSP是一个单向通道，与数据流的方向一致&lt;/li&gt;
&lt;li&gt;FIB：转发信息库，来自路由表拷贝&lt;/li&gt;
&lt;li&gt;LIB：标签信息库，由标签协议根据路由产生的&lt;strong&gt;标签和路由的对应关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;LFIB：标签转发信息库，把FIB和LIB两者结合在一起&lt;/li&gt;
&lt;li&gt;FEC：转发等价类。MPLS将具有相同特征的报文归为一类，称为转发等价类FEC，属于相同FEC的报文在转发过程中被LSR以相同方式处理。FEC可以根据源地址、目的地址、源端口、目的端口、VPN等要素进行划分。例如，在传统的采用最长匹配算法的IP转发中，到同一条路由的所有报文就是一个转发等价类&lt;/li&gt;
&lt;li&gt;NHLFE：下一跳标签转发表项，用于指导MPLS报文的转发，包括Tunnel ID、出接口、下一跳、出标签、标签操作类型等信息。FEC到一组NHLFE的映射称为FTN（FEC-to-NHLFE），通过查看FIB表中Tunnel ID值不为0x0的表项，能够获得FTN的详细信息，FTN只在Ingress存在&lt;/li&gt;
&lt;li&gt;Tunnel ID：为了给使用隧道的上层应用（如VPN、路由管理）提供统一的接口，系统自动为隧道分配了一个ID，也称为Tunnel ID。该Tunnel ID的长度为32比特，只是本地有效&lt;/li&gt;
&lt;li&gt;ILM：入标签到一组下一跳标签转发表项的映射称为入标签映射ILM，ILM包括Tunnel ID、入标签、入接口、标签操作类型等信息。ILM在Transit节点的作用是将标签和NHLFE绑定。通过标签索引ILM表，就相当于使用目的IP地址查询FIB，能够得到所有的标签转发信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;BGP路由与IGP路由的一个区别：跨越设备传递，BGP路由都带有下一跳&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mpls基本结构&#34;&gt;MPLS基本结构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;MPLS\VPN报文转发流程&lt;/strong&gt;：
&lt;ol&gt;
&lt;li&gt;CE --&amp;gt; IngressPE&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594130873094.png&#34; alt=&#34;CE --&amp;gt; IngressPE&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;CE将报文发给与其相连的VRF接口，PE在本&lt;strong&gt;VRF的路由表&lt;/strong&gt;中进行查找，得到了该路由的公网下一跳地址（为下一步查找公网标签准备）和私网标签（此时数据头部已经含有私网标签）&lt;/li&gt;
&lt;li&gt;在把该报文封装一层私网标签后，在公网的标签转发表中查找下一跳地址，再封装一层公网标签后，交予MPLS转发&lt;br&gt;
&lt;code&gt;一共两次查找，两层标签，公网标签在外。入站IP报文，先查LFIB ，命中则压入标签转发，否则再查FIB，IP转发&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;IngressPE --&amp;gt; EgressPE --&amp;gt; CE&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594131971567.png&#34; alt=&#34;IngressPE --&amp;gt; EgressPE --&amp;gt; CE&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;该报文在公网上沿着LSP转发，并根据途径的每一台设备的标签转发表进行标签交换&lt;/li&gt;
&lt;li&gt;在倒数第2跳处，将外层的公网标签弹出(Pop Label)，交给目的PE设备（隐式(标签值为3)/显示空标签，用于QoS）&lt;/li&gt;
&lt;li&gt;PE设备根据内网的私网标签判断该报文属于哪个VRF&lt;/li&gt;
&lt;li&gt;弹出内网的私网标签，在目的VRF中查找路由表，根据下一跳发给相应的CE&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MPLS和MPLS\VPN的最大区别&lt;/strong&gt;：MPLS\VPN解决方案能够帮助运营商为用户提供服务，可以用一个MPLS网给多个用户提供服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;华为设备开启MPLS&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[R1]mpls lsr-id 11.1.1.1
[R1]mpls
[R1]route recursive-lookup tunnel  // 非标签路由可以迭代到LSP隧道
Info: Mpls starting, please wait... OK!
[R1-mpls]mpls ldp
[R1-mpls-ldp]inter g0/0/1
[R1-GigabitEthernet0/0/1]mpls 
[R1-GigabitEthernet0/0/1]mpls ldp
[R1-GigabitEthernet0/0/1]q
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;中国LT承载A网组网方式（现网真实案例）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594134875492.png&#34; alt=&#34;中国LT承载A网组网方式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
中国LT路由型MPLS VPN业务由中国LT综合IP承载网进行承载。&lt;br&gt;
综合IP承载网可承载全国性的MPLS-VPN业务（即省际、国际MPLS-VPN业务），也可承载省内MPLS-VPN业务，即省分公司所辖范围内的MPLS-VPN业务。&lt;br&gt;
综合IP承载网全网设备（包括海外POP点设备）都运行在同一个AS（9929）域内。&lt;br&gt;
综合IP承载网全网分为三层结构：核心层（CR）、汇聚层（BR）和接入层（AR）；其中，接入层AR设备即我们所说的PE设备，用以接入MPLS-VPN业务。&lt;/li&gt;
&lt;li&gt;MPLS结构&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594135005312.png&#34; alt=&#34;MPLS结构&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IP报文入站&lt;/strong&gt;：查找IP转发表，出去可能是IP报文，也可能是标签报文&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标签报文入站&lt;/strong&gt;：查找标签转发表，出去可能是IP报文，也可能是标签报文&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594135758323.png&#34; alt=&#34;MPLS体系结构&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;控制平面：负责产生和维护路由信息以及标签信息
&lt;ul&gt;
&lt;li&gt;路由信息表RIB：由IP路由协议生成，用于选择路由&lt;/li&gt;
&lt;li&gt;标签分发协议：负责标签的分配、标签转发信息表的建立、标签交换路径的建立、拆除等工作&lt;/li&gt;
&lt;li&gt;标签信息表LIB（Label Information Base）：由标签分发协议生成，用于管理标签信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转发平面：即数据平面，负责普通IP报文的转发以及带MPLS标签报文的转发
&lt;ul&gt;
&lt;li&gt;转发信息表FIB：从RIB提取必要的路由信息生成，负责普通IP报文的转发&lt;/li&gt;
&lt;li&gt;标签转发信息表LFIB：简称标签转发表，由标签分发协议&lt;strong&gt;在LSR上建立LFIB&lt;/strong&gt;，&lt;strong&gt;负责带MPLS标签报文的转发&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;mpls标签格式&#34;&gt;MPLS标签格式&lt;/h2&gt;
&lt;h3 id=&#34;mpls帧格式&#34;&gt;MPLS帧格式&lt;/h3&gt;
&lt;p&gt;MPLS帧模式封装在2、3层之间，信元模式的MPLS已经淘汰&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1594137031591.png&#34; alt=&#34;帧模式MPLS&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;mpls头部信息&#34;&gt;MPLS头部信息&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1594137083215.png&#34; alt=&#34;MPLS头部信息&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;MPLS头部总长度为4bytes (32bits)&lt;/li&gt;
&lt;li&gt;标签Label长度20bits&lt;/li&gt;
&lt;li&gt;EXP（Experimental Use）长度3bits：用作QoS&lt;/li&gt;
&lt;li&gt;S（Bottom of Stack）长度1bit：栈底位，如果置位则表示最后一层标签&lt;/li&gt;
&lt;li&gt;TTL长度8bits&lt;br&gt;
&lt;strong&gt;标签空间&lt;/strong&gt;：指标签的取值范围。标签空间划分如下：&lt;/li&gt;
&lt;li&gt;0～15：特殊标签
&lt;ul&gt;
&lt;li&gt;0：IPv4 Explicit NULL Label（显示空标签），表示该标签必须被弹出（即标签被剥掉），且报文的转发必须基于IPv4。如果出节点分配给倒数第二跳节点的标签值为0，则倒数第二跳LSR需要将值为0的标签正常压入报文标签值顶部，转发给最后一跳。最后一跳发现报文携带的标签值为0，则将标签弹出。&lt;/li&gt;
&lt;li&gt;1：Router Alert Label（警告标签），只有出现在非栈底时才有效。类似于IP报文的“Router Alert Option”字段，节点收到Router Alert Label时，需要将其送往本地软件模块进一步处理。实际报文转发由下一层标签决定。如果报文需要继续转发，则节点需要将Router Alert Label压回标签栈顶。&lt;/li&gt;
&lt;li&gt;2：IPv6 Explicit NULL Label（显示空标签），表示该标签必须被弹出，且报文的转发必须基于IPv6。如果出节点分配给倒数第二跳节点的标签值为2，则倒数第二跳节点需要将值为2的标签正常压入报文标签值顶部，转发给最后一跳。最后一跳发现报文携带的标签值为2，则直接将标签弹出。&lt;/li&gt;
&lt;li&gt;3：Implicit NULL Label（隐式空标签），倒数第二跳LSR进行标签交换时，如果发现交换后的标签值为3，则将标签弹出，并将报文发给最后一跳。最后一跳收到该报文直接进行IP转发或下一层标签转发。&lt;/li&gt;
&lt;li&gt;4～13：保留&lt;/li&gt;
&lt;li&gt;14：OAM Router Alert Label（MPLS的操作管理），MPLS OAM通过发送OAM报文检测和通告LSP故障。OAM报文使用MPLS承载。OAM报文对于Transit LSR和倒数第二跳LSR是透明的。&lt;/li&gt;
&lt;li&gt;15：保留&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;16～1023：静态LSP和静态CR-LSP共享的标签空间&lt;/li&gt;
&lt;li&gt;1024及以上：LDP、RSVP-TE、MP-BGP等动态信令协议的标签空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mpls标签嵌套&#34;&gt;MPLS标签嵌套&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1594137842455.png&#34; alt=&#34;MPLS标签嵌套&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;PID：标识二层头部后面的报文类型
&lt;ul&gt;
&lt;li&gt;Ethernet：
&lt;ul&gt;
&lt;li&gt;0x0800 IPv4&lt;/li&gt;
&lt;li&gt;0x8847 MPLS 单播报文&lt;/li&gt;
&lt;li&gt;0x8848 MPLS组播报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PPP：
&lt;ul&gt;
&lt;li&gt;0x8021 IPv4&lt;/li&gt;
&lt;li&gt;0x8281 MPLS 单播报文&lt;/li&gt;
&lt;li&gt;0x8283 MPLS组播报文&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;标签嵌套应用
&lt;ul&gt;
&lt;li&gt;MPLS VPN&lt;/li&gt;
&lt;li&gt;MPLS TE&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;mpls转发流程&#34;&gt;MPLS转发流程&lt;/h2&gt;
&lt;h3 id=&#34;标签行为总结&#34;&gt;标签行为总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;压入标签，PUSH&lt;/li&gt;
&lt;li&gt;交换标签，SWAP&lt;/li&gt;
&lt;li&gt;弹出标签，Pop（remove，隐式空标签）&lt;/li&gt;
&lt;li&gt;UNTAG/No label(没有标签) 出现问题，在MPLS\VPN的环境下只能丢弃报文&lt;/li&gt;
&lt;li&gt;Aggregate（聚合），把报文拿掉MPLS之后转发给 一个VPN-INSTANCE接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ldp协议原理&#34;&gt;LDP协议原理&lt;/h1&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;实验一实施ldp&#34;&gt;实验一：实施LDP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;域内IGP&lt;/li&gt;
&lt;li&gt;域内LDP
&lt;ul&gt;
&lt;li&gt;配置 ldp router-id&lt;/li&gt;
&lt;li&gt;开启mpls以及ldp&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;PE之间MP-BGP、VPNv4&lt;/li&gt;
&lt;li&gt;PE vrf/VPN-instance&lt;/li&gt;
&lt;li&gt;PE-CE路由交互&lt;/li&gt;
&lt;li&gt;规划：
&lt;ul&gt;
&lt;li&gt;R1和R10通过以太网接口G2/0/0互联&lt;/li&gt;
&lt;li&gt;R1\R3为PE设备&lt;/li&gt;
&lt;li&gt;R8\R10为CE设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;思科&#34;&gt;思科&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 域内IDP：配置 ldp router-id；开启mpls以及ldp
R1(config)#ip cef
R1(config)#mpls ip
R1(config)#mpls label protocol ldp   
R1(config)#mpls ldp router-id loopback 0 force   // mpls 排错组合拳
R1(config)#interface e0/1
R1(config-if)#mpls ip
R1(config-if)#inter e0/2
R1(config-if)#mpls ip   
R1(config-if)#int s1/0
R1(config-if)#mpls ip 

# PE之间 MP-BGP、VPNv4
R1(config-router)#no bgp default ipv4-unicast   // 关闭默认的IPv4能力，切换到 MP-BGP 工作模式
R1(config-router)#address-family vpnv4 unicast   // 进入VPNv4 地址族  
R1(config-router-af)#neighbor 33.1.1.1 activate   // 在地址族下激活邻居

R3(config)#router bgp 100  // 从头配一个
R3(config-router)#no bgp default ipv4-unicast 
R3(config-router)#neighbor 11.1.1.1 remote-as 100
R3(config-router)#neighbor 11.1.1.1 up lo0 
R3(config-router)#address-family vpnv4 unicast 
R3(config-router-af)#neighbor 11.1.1.1 activate 

# PE vrf/VPN-instance
R3(config)#ip vrf cisco   // 创建 vrf ，这种配置方式仅仅支持 ipv4 【PE本地隔离】
R3(config-vrf)#rd 1:1  // 定义路由区分器的值  【64bit的一个值，全局区分】96bit 的 VPNv4路由=32bit用户路由+64bit的路由区分器
R3(config-vrf)#route-target 1:1  // 定义路由标记的值  【收发控制，实际上是一个扩展团体属性】
R3(config)#int e0/3
R3(config-if)#ip vrf forwarding cisco  // 将接口划分入vrf，与全局和其它vrf隔离开
R3(config-if)#ip address 83.1.1.3 255.255.255.0  // 注意，如果先配置了ip地址，后划分vrf，则划分vrf的操作将会移除所有ip地址
R3#show ip route vrf cisco
R3#show ip vrf 
R3#show ip vrf detail  

# vrf的另外一种配置方式：
R1(config)#vrf definition cisco
R1(config-vrf)#rd 1:1
R1(config-vrf)#address-family ipv4 
R1(config-vrf-af)#route-target 1:1
R1(config-vrf)#inter e0/3
R1(config-if)#vrf forwarding cisco  
R1(config-if)#ip address 110.1.1.1 255.255.255.0            

# PE-CE路由交互
R8
interface Loopback0
 ip address 88.1.1.1 255.255.255.0
R8(config)#ip route 10.1.1.0 255.255.255.0 83.1.1.3

R10
interface Loopback0
ip address 10.1.1.1 255.255.255.0
R10(config)#ip route 88.1.1.0 255.255.255.0 110.1.1.1

R1(config)#ip route vrf cisco 10.1.1.0 255.255.255.0 110.1.1.10  // vrf 指向CE背后网络的静态路由
R3(config)#ip route vrf cisco 88.1.1.0 255.255.255.0 83.1.1.8

# 在PE设备上对客户路由进行重分布
R3(config)#router bgp 100
R3(config-router)#address-family ipv4 vrf cisco  // 一个专属于特定客户的地址族
R3(config-router-af)#redistribute static 

# 验证：
R1#show ip route vrf cisco
R1#show bgp vpnv4 unicast all   // R1#show bgp vpnv4 unicast vrf cisco
R1#show bgp vpnv4 unicast vrf cisco 88.1.1.0/24

R3#show bgp vpnv4 unicast vrf cisco labels 
   Network          Next Hop      In label/Out label
Route Distinguisher: 1:1 (cisco)
   10.1.1.0/24      11.1.1.1        nolabel/17
   88.1.1.0/24      83.1.1.8        16/nolabel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;华为&#34;&gt;华为&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 实现域内 IGP
# 实现域内 LDP(R1和R3)
[R1]mpls lsr-id 11.1.1.1
[R1]mpls
[R1-mpls]mpls ldp
[R1]inter g0/0/1
[R1-GigabitEthernet0/0/1]mpls
[R1-GigabitEthernet0/0/1]mpls ldp

# 实现PE之间 MP-BGP、vpnv4(R1和R3)
[R3]bgp 100
[R3-bgp]ipv4-family vpnv4
[R3-bgp-af-vpnv4]peer 11.1.1.1 enable 

#实现 vpn-instance(R1和R3)
R1
ip vpn-instance qytang
ipv4-family
route-distinguisher 1:1
vpn-target 2:2 export-extcommunity
vpn-target 2:2 import-extcommunity

interface GigabitEthernet2/0/0
ip binding vpn-instance qytang
ip address 110.1.1.1 255.255.255.0 

# 实现PE-CE路由交互
[R1]ip route-static *PN-instance qytang 10.1.1.0 24 110.1.1.10
[R10]ip route-static 88.1.1.0 24 110.1.1.1
[R3]ip route-static *PN-instance qytang 88.1.1.0 24 83.1.1.8
[R8]ip route-static 10.1.1.0 24 83.1.1.3
bgp 100
ipv4-family vpn-instance qytang 
import-route static
&lt;/code&gt;&lt;/pre&gt;
">HCIE-MPLS专题(2020.07.06不完整)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/vmware-xu-ni-ji-an-zhuang-hei-qun-hui-dsm62/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9C%80%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7&#34;&gt;需要用到的工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4&#34;&gt;安装步骤&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;需要用到的工具&#34;&gt;需要用到的工具&lt;/h1&gt;
&lt;p&gt;写镜像工具：Roadkils Disk Image&lt;br&gt;
DMS镜像文件：DSM_DS3617xs_23739.pat&lt;br&gt;
引导镜像：synoboot.img&lt;br&gt;
群晖助手：Synology assistant.exe&lt;/p&gt;
&lt;h1 id=&#34;安装步骤&#34;&gt;安装步骤&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;虚拟磁盘创建并进行镜像写入&lt;br&gt;
创建虚拟磁盘并将引导镜像写入虚拟磁盘&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;diskpart
create vdisk file=F:\synoboot.vhd maximum=50 type=expandable  # 根据具体情况进行修改
attach vdisk  
create partition primary
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593613751509.png&#34; alt=&#34;创建虚拟磁盘&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
创建好虚拟磁盘后我们打开Roadkils Disk Image，将synoboot.img写入我们创建的50MB的虚拟磁盘中，&lt;strong&gt;记住图中的Physical Disk 1&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615335834.png&#34; alt=&#34;开始写入镜像&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615344441.png&#34; alt=&#34;成功写入镜像&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2. 创建虚拟机&lt;br&gt;
虚拟机名称、CPU核心数、内存、硬盘大小根据自己的电脑和需要设置&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615629310.png&#34; alt=&#34;自定义虚拟机&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615635558.png&#34; alt=&#34;兼容性&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615640173.png&#34; alt=&#34;稍后安装操作系统&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615648333.png&#34; alt=&#34;Linux2.6&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615652651.png&#34; alt=&#34;虚拟机命名&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615657461.png&#34; alt=&#34;CPU&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615661620.png&#34; alt=&#34;内存&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615665854.png&#34; alt=&#34;网络类型&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615670449.png&#34; alt=&#34;IO类型&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615676507.png&#34; alt=&#34;磁盘类型&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;磁盘类型最好选择SATA，主要是为了跟后面添加的数据存储磁盘的类型区分开，进入固件后方便根据类型选择&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615685517.png&#34; alt=&#34;物理磁盘&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615692005.png&#34; alt=&#34;上一步创建的虚拟磁盘&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615695710.png&#34; alt=&#34;指定磁盘文件&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593615699438.png&#34; alt=&#34;完成&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
3. 配置虚拟机&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616585456.png&#34; alt=&#34;编辑虚拟机&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616589991.png&#34; alt=&#34;添加硬盘&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616593301.png&#34; alt=&#34;磁盘类型&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616597182.png&#34; alt=&#34;创建新虚拟磁盘&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616601833.png&#34; alt=&#34;存储为单个文件&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616605908.png&#34; alt=&#34;指定磁盘文件&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616615452.png&#34; alt=&#34;完成&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616619122.png&#34; alt=&#34;进入固件&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593649767258.png&#34; alt=&#34;删除非必须设备&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;必须删除光驱、声卡、打印机等设备&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593616622524.png&#34; alt=&#34;调整开机启动顺序&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593617875318.png&#34; alt=&#34;开机启动引导镜像&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4. 安装群晖DMS6.2&lt;br&gt;
安装群晖助手Synology assistant.exe之后打开，进行设备搜索（用户名等根据自己需求设置）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593649912563.png&#34; alt=&#34;查找IP&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593617578331.png&#34; alt=&#34;手动安装&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593617581995.png&#34; alt=&#34;选择pat文件开始安装&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593649924751.png&#34; alt=&#34;安装完成&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5. 使用虚拟机的快照功能建立还原点&lt;/p&gt;
">VMware虚拟机安装黑群晖DSM6.2</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/windows-xi-tong-jie-chu-kuan-dai-xian-zhi/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%96%E6%B6%88%E4%BF%9D%E7%95%99%E5%B8%A6%E5%AE%BD&#34;&gt;取消保留带宽&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8F%90%E9%AB%98%E5%90%9E%E5%90%90%E7%BA%A7%E5%88%AB&#34;&gt;提高吞吐级别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;取消保留带宽&#34;&gt;取消保留带宽&lt;/h1&gt;
&lt;p&gt;win+R ---&amp;gt; 计算机配置 ---&amp;gt; 管理模板 ---&amp;gt; 网络 ---&amp;gt; QoS数据包计划程序 ---&amp;gt; 限制可保留的带宽 ---&amp;gt; 已启用 ---&amp;gt; 带宽限制设置为0 ---&amp;gt; 应用 ---&amp;gt; 确定&lt;/p&gt;
&lt;h1 id=&#34;提高吞吐级别&#34;&gt;提高吞吐级别&lt;/h1&gt;
&lt;p&gt;win+R ---&amp;gt; 计算机配置 ---&amp;gt; Windows设置 ---&amp;gt; 基于策略的QoS ---&amp;gt; 右键选择高级QoS设置 ---&amp;gt; 入站TCP流量 ---&amp;gt; 勾选指定入站TCP吞吐量级别 ---&amp;gt; 选择级别3 ---&amp;gt; 确定&lt;/p&gt;
">Windows系统解除宽带限制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/vmware-ru-he-kuai-su-jie-jue-sheng-cheng-duo-jie-dian/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%94%9F%E6%88%90%E5%8E%9F%E5%A7%8B%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6&#34;&gt;生成原始镜像文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#lnmp&#34;&gt;LNMP&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#yum%E6%BA%90%E9%85%8D%E7%BD%AE&#34;&gt;yum源配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#developmentrepo&#34;&gt;development.repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#phprepo&#34;&gt;php.repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginxrepo&#34;&gt;nginx.repo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mariadbrepo&#34;&gt;mariadb.repo&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#php71%E5%AE%89%E8%A3%85&#34;&gt;php71安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mariadb105%E5%AE%89%E8%A3%85&#34;&gt;mariadb10.5安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#nginx1192%E5%AE%89%E8%A3%85&#34;&gt;nginx1.19.2安装&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;生成原始镜像文件&#34;&gt;生成原始镜像文件&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;使用centos7的mini镜像（例如：CentOS-7-x86_64-Minimal-1908.iso）安装系统，网络设置成**&amp;quot;桥接模式&amp;quot;&lt;strong&gt;，不勾选&lt;/strong&gt;&amp;quot;复制物理网络连接状态&amp;quot;**，其他配置可根据实际情况配置。&lt;/li&gt;
&lt;li&gt;系统安装时，关闭&amp;quot;KDUMP&amp;quot;，关闭&amp;quot;SECURITY POLICY&amp;quot;，安装位置中的磁盘配置可根据自己需求（例如：biosboot大小默认为2048K，/boot大小为1G，其余的全部给/），网络配置中勾选&amp;quot;常规--可用时自动连接到这个网络&amp;quot;。&lt;/li&gt;
&lt;li&gt;配置yum源&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rm -rf /etc/yum.repos.d/*
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo
yum makecache
yum -y install epel-*
yum makecache
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;安装常用软件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install wget vim 
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;关闭在测试环境中不需要的功能&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#关闭防火墙
systemctl disable firewalld
# 关闭网络管理
systemctl disable NetworkManager
# 关闭SeLinux
sed -i &#39;s/SELINUX=enforcing/SELINUX=disabled/g&#39; /etc/selinux/config
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;配置网络&lt;br&gt;
如果忽略此不，克隆的虚拟机会出现IP或MAC冲突等问题&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 编辑网卡配置文件，仅保留以下5行即可
vim /etc/sysconfig/network-scripts/ifcfg-ens32
    TYPE=Ethernet
    BOOTPROTO=dhcp
    NAME=ens32
    DEVICE=ens32
    ONBOOT=yes
# /etc/udev/rules.d/70-persistent-net.rules  # 如果有此文件则删除，没有直接进行下一步
reboot -h
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;镜像制作（快照）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;shutdown -h now
# 虚拟机--快照--拍摄快照--根据自己喜好起一个霸气侧漏的名字，例如Source
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;克隆&lt;br&gt;
选中虚拟机Source --&amp;gt; 右键 --&amp;gt; 管理 --&amp;gt; 克隆 --&amp;gt; 下一步 --&amp;gt; 现有快照 --&amp;gt; 选择上一步拍着的快照 --&amp;gt; 创建完整克隆 --&amp;gt; 下一步 --&amp;gt; 起一个不一样的名字(比如Master) --&amp;gt; 编辑虚拟机配置 --&amp;gt; 网络适配器 --&amp;gt; 高级 --&amp;gt; MAC地址 --&amp;gt; 生成 --&amp;gt; 确定 --&amp;gt; 然后按照上面的步骤，分别克隆机器inode1、inode2、inode3&lt;br&gt;
&lt;code&gt;修改MAC地址的方式二（推荐使用此方法）：找到虚拟机文件夹中的.vmx文件（例如Master.vmx），用文本工具打开，修改选项ethernet0.generatedAddress的值&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;开机测试&lt;br&gt;
将Master、inode1、inode2、inode3全部开启后登陆，输入命令&lt;code&gt;ip a&lt;/code&gt;查看IP是否正常获取，输入&lt;code&gt;ping www.baidu.com&lt;/code&gt;查看是否能够正常上网&lt;/li&gt;
&lt;li&gt;使用xshell连接之后开始批量操作&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;lnmp&#34;&gt;LNMP&lt;/h1&gt;
&lt;p&gt;如果需要安装nginx、php、mariadb(mysql)，则需要继续进行下面的步骤。&lt;br&gt;
关于php和nginx的配置可根据需求进行定制。&lt;br&gt;
关于mariadb只配置了数据和错误日志目录，因为这两块内容是最大的，也是最容易导致爆盘的数据，如果开启慢查询，则需要将慢查询的日志路径也进行相应的修改，至于连接数、缓存等等可根据需求进行定制。&lt;/p&gt;
&lt;h2 id=&#34;yum源配置&#34;&gt;yum源配置&lt;/h2&gt;
&lt;h3 id=&#34;developmentrepo&#34;&gt;development.repo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[base]
name=CentOS-$releasever - Base
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/
enabled=1
gpgcheck=0

[updates]
name=CentOS-$releasever - Updates
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/
enabled=1
gpgcheck=0

[extras]
name=CentOS-$releasever - Extras
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/
enabled=1
gpgcheck=0

[centosplus]
name=CentOS-$releasever - Plus
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/
gpgcheck=0
enabled=1
 
[epel]
name=Extra Packages for Enterprise Linux 7 - $basearch
baseurl=http://download.fedoraproject.org/pub/epel/$releasever/$basearch
enabled=1
gpgcheck=0

[epel-debuginfo]
name=Extra Packages for Enterprise Linux 7 - $basearch - Debug
baseurl=http://download.fedoraproject.org/pub/epel/$releasever/$basearch/debug
enabled=1
gpgcheck=0

[epel-source]
name=Extra Packages for Enterprise Linux 7 - $basearch - Source
baseurl=http://download.fedoraproject.org/pub/epel/$releasever/SRPMS
enabled=1
gpgcheck=0

[epel-testing]
name=Extra Packages for Enterprise Linux 7 - Testing - $basearch
baseurl=http://download.fedoraproject.org/pub/epel/testing/$releasever/$basearch
enabled=1
gpgcheck=0

[epel-testing-debuginfo]
name=Extra Packages for Enterprise Linux 7 - Testing - $basearch - Debug
baseurl=http://download.fedoraproject.org/pub/epel/testing/$releasever/$basearch/debug
enabled=1
gpgcheck=0

[epel-testing-source]
name=Extra Packages for Enterprise Linux 7 - Testing - $basearch - Source
baseurl=http://download.fedoraproject.org/pub/epel/testing/$releasever/SRPMS
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;phprepo&#34;&gt;php.repo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[webtatic]
name=Webtatic Repository EL7 - $basearch
baseurl=https://repo.webtatic.com/yum/el7/$basearch/
enabled=1
gpgcheck=0

[webtatic-debuginfo]
name=Webtatic Repository EL7 - $basearch - Debug
baseurl=https://repo.webtatic.com/yum/el7/$basearch/debug/
enabled=1
gpgcheck=0

[webtatic-source]
name=Webtatic Repository EL7 - $basearch - Source
baseurl=https://repo.webtatic.com/yum/el7/SRPMS/
enabled=1
gpgcheck=0

[webtatic-archive]
name=Webtatic Repository EL7 - $basearch - Archive
baseurl=https://repo.webtatic.com/yum/el7-archive/$basearch/
enabled=1
gpgcheck=0

[webtatic-archive-debuginfo]
name=Webtatic Repository EL7 - $basearch - Archive Debug
baseurl=https://repo.webtatic.com/yum/el7-archive/$basearch/debug/
enabled=1
gpgcheck=0

[webtatic-archive-source]
name=Webtatic Repository EL7 - $basearch - Archive Source
baseurl=https://repo.webtatic.com/yum/el7-archive/SRPMS/
enabled=1
gpgcheck=0

[webtatic-testing]
name=Webtatic Repository EL7 - $basearch - Testing
baseurl=https://repo.webtatic.com/yum/el7-testing/$basearch/
enabled=1
gpgcheck=0

[webtatic-testing-debuginfo]
name=Webtatic Repository EL7 - $basearch - Testing Debug
baseurl=https://repo.webtatic.com/yum/el7-testing/$basearch/debug/
enabled=1
gpgcheck=0

[webtatic-testing-source]
name=Webtatic Repository EL7 - $basearch - Testing Source
baseurl=https://repo.webtatic.com/yum/el7-testing/SRPMS/
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nginxrepo&#34;&gt;nginx.repo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mariadbrepo&#34;&gt;mariadb.repo&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[mariadb]
name = MariaDB
baseurl = https://mirrors.ustc.edu.cn/mariadb/yum/10.5/centos74-amd64/
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;php71安装&#34;&gt;php71安装&lt;/h2&gt;
&lt;p&gt;只安装一些常用扩展，后期如果需要其他扩展，请自行使用yum进行安装。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install mod_php71w php71w-devel php71w-cli php71w-common \
php71w-fpm  php71w-gd php71w-embedded \
php71w-ldap php71w-mbstring  php71w-mcrypt \
php71w-mysqlnd php71w-opcache php71w-pdo php71w-pdo_dblib \
php71w-soap php71w-xml
systemctl enable php-fpm
systemctl start php-fpm
# 其他常用扩展可以使用yum list *php71*命令来查看
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mariadb105安装&#34;&gt;mariadb10.5安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install mariadb-server mariadb
mkdir -p /mariadb/{db,log}
chown -R mysql:mysql /mariadb
# 移除默认数据文件
rm -rf /var/lib/mysql  
# 编辑总配置文件（这一步不能少）
vim /etc/my.cnf
    [client-server]
    socket=/mariadb/mysql.sock
# 编辑客户端配置文件
vim /etc/my.cnf.d/mysql-clients.cnf
    [client]
    default-character-set=utf8
# 编辑服务端配置文件
vim /etc/my.cnf.d/server.cnf 
    [mysqld]
    datadir = /mariadb/db
    log_error = /mariadb/log/error.log
    init_connect=&#39;SET NAMES utf8&#39;
    character-set-server=utf8
# 初始化数据后启动
mysql_install_db --defaults-file=/etc/my.cnf --datadir=/mariadb/db
systemctl enable mariadb
systemctl start mariadb
# 设置root密码后登陆
vim /usr/bin/mysql_secure_installation
    # 在make_config()函数中的  echo &amp;quot;password=&#39;$esc_pass&#39;&amp;quot; &amp;gt;&amp;gt;$config  这行下面添加如下一行
    echo &amp;quot;socket=/mariadb/mysql.sock&amp;quot; &amp;gt;&amp;gt;$config
mysql_secure_installation
    n #是否切换到unix套接字身份验证
    Y #是否设置root密码
    123456  # mariadb中root用户的密码
    123456
    Y #是否删除匿名用户?(就是空用户)，建议删除
    Y #是否不允许远程root登录
    Y #是否删除test数据库
    Y #是否加载权限使之生效
mysql -uroot -p
    show databases;
    exit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nginx1192安装&#34;&gt;nginx1.19.2安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install nginx
systemctl enable nginx
systemctl start nginx
&lt;/code&gt;&lt;/pre&gt;
">VMware快速部署集群</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/ansible-xue-xi-yu-shi-jian/"" data-c="
          &lt;h1 id=&#34;ansible简介工作中能使用到的层次&#34;&gt;ansible简介(工作中能使用到的层次)&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/&#34;&gt;参考文档&lt;/a&gt;&lt;br&gt;
ansible是新出现的自动化运维工具，ansible是一个配置管理和应用部署工具，&lt;strong&gt;基于Python开发&lt;/strong&gt;，集合了众多运维工具（puppet、cfengine、chef、func、fabric.SaltStack ）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。&lt;br&gt;
ansible是基于模块工作的，本身没有批量部署的能力。&lt;strong&gt;真正具有批量部署的是ansible所运行的模块&lt;/strong&gt;，ansible只是提供一种框架，根据官方提供的信息，当前使用ansible的用户有：美国国家航空航天局NASA、evernote(印象笔记)、rackspace(全球三大云计算中心之一)、atlassian、twitter(全球互联网上访问量最大的十个网站之一)等&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;ansible在生产环境当中的应用&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;自动化部署应用&lt;/li&gt;
&lt;li&gt;自动化管理配置&lt;/li&gt;
&lt;li&gt;自动化持续交付&lt;/li&gt;
&lt;li&gt;自动化(aws)云服务器管理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ansible的优点&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;ansible糅合了众多老牌运维工具的优点，基本上pubbet和saltstack能实现的功能全部能实现&lt;/li&gt;
&lt;li&gt;轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可&lt;/li&gt;
&lt;li&gt;ansible是一个工具，ansible&lt;strong&gt;不需要启动服务&lt;/strong&gt;，仅仅只是一个工具，可以轻松的实现分布式扩展&lt;/li&gt;
&lt;li&gt;批量任务执行可以写成脚本，而且不用分发到远程就可以执行&lt;/li&gt;
&lt;li&gt;ansible是一致性，高可靠性，安全性设计的轻量级自动化工具&lt;/li&gt;
&lt;li&gt;使用python编写，维护更简单，ruby语法过于复杂&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;no agents：不需要在被管控主机上安装任何客户端&lt;/li&gt;
&lt;li&gt;no server：无服务器端，使用时直接运行命令即可&lt;/li&gt;
&lt;li&gt;modules in any languages：基于模块工作，可使用任意语言开发模块&lt;/li&gt;
&lt;li&gt;yaml，not code：使用yaml语言定制剧本playbook&lt;/li&gt;
&lt;li&gt;ssh by default：基于SSH工作&lt;/li&gt;
&lt;li&gt;strong multi-tier solution：可实现多级指挥（分布式）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible架构以及执行流程&#34;&gt;ansible架构以及执行流程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;连接插件&lt;/strong&gt;(connectior plugins)： 用于连接主机（用来连接被管理端）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;核心模块&lt;/strong&gt;(core modules) ：连接主机实现操作，它依赖于具体的模块来做具体的事情&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;自定义模块&lt;/strong&gt;(custom modules)： 根据自己的需求编写具体的模块&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;插件&lt;/strong&gt;(plugins) ：完成模块功能的补充&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;剧本&lt;/strong&gt;(playbooks) ：ansible的配置文件，&lt;strong&gt;将多个任务定义在剧本中，由ansible自动执行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;主机清单&lt;/strong&gt;(host inventory)：定义ansible需要操作主机的范围&lt;br&gt;
&lt;code&gt;最重要的一点是ansible是模块化的它所有的操作都依赖于模块&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592813979693.png&#34; alt=&#34;基本架构&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
比如需要创建一个文件，那么我就需要调用file模块；需要copy文件，那么我就需要copy模块；需要测试机器的存活率，那么就需要ping模块&lt;code&gt;ansible all -m ping&lt;/code&gt;。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592829408722.png&#34; alt=&#34;执行流程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible安装与配置&#34;&gt;ansible安装与配置&lt;/h1&gt;
&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ansible只是一个进程&lt;/strong&gt;，不需要添加数据库也不需要启动和运行守护进程，它只是一个进程，你可以轻松使用它安装在任何一台主机上面（除了windows），ansible管理机不能安装到windows上面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;版本的选择&lt;/strong&gt;，因为2.0有非常大的改进，一般都会使用2.0以上的版本&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制机的要求&lt;/strong&gt;，因为ansible是python写的，所以需要在安装了python2.6或者2.7以上的python版本才可以安装&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理节点的要求&lt;/strong&gt;，需要安装ssh，python版本在2.5以上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;安装有3个方式&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;yum源安装：&lt;code&gt;yum -y install ansible&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;python模块安装：&lt;code&gt;pip install ansible&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从github下载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;    $ git clone git：//github.com/ansible/ansible.git --recursive
    $ cd ./ansible
    $ make rpm
    $ sudo rpm -Uvh ./rpm-build/ansible-*.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;任务执行模式&#34;&gt;任务执行模式&lt;/h2&gt;
&lt;p&gt;ansible系统由控制主机对被管节点的操作方式有两种&lt;strong&gt;ad_hoc和playbook&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ad_hoc单命令模式：可以对多台主机执行&lt;strong&gt;单个命令&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -a &amp;quot;/bin/echo hello&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;playbook通过&lt;strong&gt;多个tasks的集合&lt;/strong&gt;完成一类功能如web的安装部署，数据库服务器的批量备份等&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;- hosts: webservers
  vars:
    http_port: 80
    max_clients: 200
  remote_user: root
  tasks:
  - name: ensure apache is at the latest version
    yum: name=httpd state=latest
  - name: write the apache config file
    template: src=/srv/httpd.j2 dest=/etc/httpd.conf
    notify:
    - restart apache
  - name: ensure apache is running (and enable it at boot)
    service: name=httpd state=started enabled=yes
  handlers:
    - name: restart apache
      service: name=httpd state=restarted
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ansible七个命令&#34;&gt;ansible(七个命令)&lt;/h2&gt;
&lt;p&gt;安装完ansible后，发现ansible一共为我们提供了七个指令：&lt;code&gt;ansible&lt;/code&gt;、&lt;code&gt;ansible-doc&lt;/code&gt;、&lt;code&gt;ansible-galaxy&lt;/code&gt;、&lt;code&gt;ansible-lint&lt;/code&gt;、&lt;code&gt;ansible-playbook&lt;/code&gt;、&lt;code&gt;ansible-pull&lt;/code&gt;、&lt;code&gt;ansible-vault&lt;/code&gt; 。这里只查看usage部分，详细部分可以通过 “指令 -h” 的方式获取。&lt;/p&gt;
&lt;h3 id=&#34;ansible&#34;&gt;ansible&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;格式&lt;/strong&gt;：&lt;code&gt;ansible &amp;lt;host-pattern&amp;gt; [options]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;说明&lt;/strong&gt;：ansible是指令核心部分，其主要用于执行ad-hoc命令，即单条命令。默认后面需要跟主机和选项部分，默认不指定模块时，使用的是command模块。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例&lt;/strong&gt;：&lt;code&gt;ansible 127.0.0.1 -a &#39;date&#39;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;常用参数&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;-m：执行模块的名字，默认使用command模块，所以如果是只执行单一命令可以不用-m参数 
-a：命令行参数
-u：ssh连接的用户名，默认用root，ansible.cfg中可以配置
-k：提示输入ssh登录密码。当使用密码验证的时候用
-s：sudo运行
-U：sudo到那个用户，默认为root
-K：提示输入sudo密码，当不是NOPASSWD模式时使用
-C：只是测试一下会改变什么内容，不会真正去执行
-c：连接类型（default=smart）
-f：fork多少个进程并发处理，默认为5个
-i：指定hosts文件路径（可以是文件，也可以是目录，也可以动态主机列表获取脚本），默认default=/etc/ansible/hosts
-I： 指定pattern，对&amp;lt;host_pattern&amp;gt;已匹配的主机中再过滤一次
--list-hosts：只打印有哪些主机会执行这个playbook文件，不是实际执行 #ansible --list-hosts all
-M：要执行的模块路径，默认为/usr/share/ansible
-o：压缩输出，摘要输出
--private-key：私钥路径
-T：ssh连接超时时间，默认10秒
-t：日志输出到该目录，日志文件名以主机名命名
-v：详细信息
-vvv： 查看详细信息，调试的时候使用
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主机清单文件&lt;/strong&gt;：/etc/ansible/host&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592899775322.png&#34; alt=&#34;主机清单文件&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ansible-doc&#34;&gt;ansible-doc&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;格式&lt;/strong&gt;：&lt;code&gt;ansible-doc [options] [module...]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;说明&lt;/strong&gt;：该指令用于查看模块信息，常用参数有两个-l 和 -s ，具体如下：
&lt;ul&gt;
&lt;li&gt;列出所有已安装的模块&lt;code&gt;ansible-doc -l&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;查看具体某模块的用法，这里如查看command模块&lt;code&gt;ansible-doc -s command&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ansible-galaxy&#34;&gt;ansible-galaxy&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;格式&lt;/strong&gt;：&lt;code&gt;ansible-galaxy [-h] [--version] [-v] TYPE ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;说明&lt;/strong&gt;：用于方便的从&amp;lt;https://galaxy.ansible.com/ &amp;gt;站点下载第三方扩展模块，可以形象的理解其类似于centos下的yum、python下的pip或easy_install。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;举例&lt;/strong&gt;：安装了一个aeriscloud.docker组件，前面aeriscloud是galaxy上创建该模块的用户名，后面对应的是其模块。在实际应用中也可以指定txt或yml文件进行多个组件的下载安装。这部分可以参看官方文档。&lt;code&gt;ansible-galaxy install aeriscloud.docker&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ansible-lint&#34;&gt;ansible-lint&lt;/h3&gt;
&lt;p&gt;对playbook的语法进行检查的一个工具。用法是&lt;code&gt;ansible-lint playbook.yml&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;ansible-playbook&#34;&gt;ansible-playbook&lt;/h3&gt;
&lt;p&gt;该指令是&lt;strong&gt;使用最多的指令&lt;/strong&gt;，其通过读取playbook 文件后，执行相应的动作&lt;/p&gt;
&lt;h3 id=&#34;ansible-pull&#34;&gt;ansible-pull&lt;/h3&gt;
&lt;p&gt;该指令使用需要谈到ansible的另一种模式---&lt;strong&gt;pull模式&lt;/strong&gt;，这和平常经常用的push模式刚好相反，其适用于以下&lt;strong&gt;场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;你有数量巨大的机器需要配置，即使使用非常高的线程还是要花费很多时间；&lt;/li&gt;
&lt;li&gt;你要在一个没有网络连接的机器上运行Anisble，比如在启动之后安装。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ansible-vault&#34;&gt;ansible-vault&lt;/h3&gt;
&lt;p&gt;ansible-vault主要应用于配置文件中含有敏感信息，又不希望他能被人看到，vault可以帮你&lt;strong&gt;加密/解密这个配置文件&lt;/strong&gt;，属高级用法。主要对于playbooks里比如涉及到配置密码或其他变量时，可以通过该指令加密，这样我们通过cat看到的会是一个密码串类的文件，&lt;strong&gt;编辑的时候需要输入事先设定的密码才能打开&lt;/strong&gt;。这种playbook文件在执行时，&lt;strong&gt;需要加上 –ask-vault-pass参数&lt;/strong&gt;，同样需要输入密码后才能正常执行。&lt;/p&gt;
&lt;h2 id=&#34;ansible配置文件&#34;&gt;ansible(配置文件)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;位置：&lt;code&gt;/etc/ansible/ansible.cfg&lt;/code&gt;&lt;br&gt;
用户可以修改一下配置文件来修改设置,他们的被读取的顺序如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;* ANSIBLE_CONFIG (一个环境变量)
* ansible.cfg (位于当前目录中)
* .ansible.cfg (位于家目录中)
* /etc/ansible/ansible.cfg
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ansible 将会按以上顺序逐个查询这些文件,直到找到一个为止,并且&lt;strong&gt;使用第一个寻找到个配置文件的配置,这些配置将不会被叠加.&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;获取最新配置文件&#34;&gt;获取最新配置文件&lt;/h3&gt;
&lt;p&gt;如果使用程序包管理器安装ansible,最新的 ansible.cfg 配置文件有可能出现在 /etc/ansible 下并且命名为 ”.rpmnew”, 也可能根据不同的更新命名为其它名称。&lt;br&gt;
如果你是通过 pip 或者其他方式安装,则可能需要自行创建这个文件,以免原配置文件被覆盖。&lt;/p&gt;
&lt;h3 id=&#34;配置文件不同段详解&#34;&gt;配置文件不同段详解&lt;/h3&gt;
&lt;h4 id=&#34;通用默认段&#34;&gt;通用默认段&lt;/h4&gt;
&lt;p&gt;在 [defaults] 段中,以下选项是可以调节的:&lt;/p&gt;
&lt;h5 id=&#34;action_plugins&#34;&gt;action_plugins&lt;/h5&gt;
&lt;p&gt;“行为”是 ansible中的一段代码，用来激活一些事件，例如执行一个模块等。这是一个以开发者为中心的特性,使得一些底层模块可以从外部不同地方加载：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;action_plugins = ~/.ansible/plugins/action_plugins/:/usr/share/ansible_plugins/action_plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;ansible_managed&#34;&gt;ansible_managed&lt;/h5&gt;
&lt;p&gt;Ansible-managed 是一个字符串，可以插入到Ansible配置模版系统生成的文件中，如果你使用以下的自字符：&lt;code&gt;{{ ansible_managed }}&lt;/code&gt;&lt;br&gt;
例如：默认设置可以哪个用户修改和修改时间：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible_managed = Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个设置可以告知用户，Ansible修改了一个文件，并且手动写入的内容可能已经被覆盖.需要注意的是，如果使用这一特性，这个字符串中将包含一个日期注释，如果日期更新，模版系统将会在每一次报告文件修改。&lt;/p&gt;
&lt;h5 id=&#34;ask_pass&#34;&gt;ask_pass*&lt;/h5&gt;
&lt;p&gt;控制Ansible剧本playbook是否会自动弹出输入密码，默认为no。如果使用SSH 密钥匙做身份认证，可能需要修改这一参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ask_pass=True
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;ask_sudo_pass&#34;&gt;ask_sudo_pass*&lt;/h5&gt;
&lt;p&gt;类似 ask_pass，用来控制Ansible playbook 在执行sudo之前是否询问sudo密码。默认为no。如果用户使用的系统平台开启了sudo 密码的话,应该修改这一参数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ask_sudo_pass=True
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;bin_ansible_callbacks&#34;&gt;bin_ansible_callbacks&lt;/h5&gt;
&lt;p&gt;用来控制callback插件是否在运行 /usr/bin/ansible 的时候被加载。这个模块将用于命令行的日志系统，发出通知等特性。Callback插件如果存在将会永久性的被 /usr/bin/ansible-playbook 加载，不能被禁用:&lt;code&gt;1.8 版本之前,callbacks 插件不可以被 /usr/bin/ansible加载。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;bin_ansible_callbacks=False
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;callback_plugins&#34;&gt;callback_plugins&lt;/h5&gt;
&lt;p&gt;Callbacks 在ansible中是一段代码，在特殊事件时将被调用，并且允许出发通知。这是一个以开发者为中心的特性，可以实现对Ansible的底层拓展,并且拓展模块可以位于任何位置:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;callback_plugins = ~/.ansible/plugins/callback_plugins/:/usr/share/ansible_plugins/callback_plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;deprecation_warnings&#34;&gt;deprecation_warnings&lt;/h5&gt;
&lt;p&gt;允许在ansible-playbook输出结果中禁用“不建议使用”的警告:&lt;br&gt;
“不建议警告”指的是使用一些在新版本中可能会被淘汰的遗留特性。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;deprecation_warnings = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;display_skipped_hosts&#34;&gt;display_skipped_hosts&lt;/h5&gt;
&lt;p&gt;如果设置为&lt;code&gt;False&lt;/code&gt;，ansible将不会显示任何跳过任务的状态。默认选项是跳过任务的状态：&lt;br&gt;
注意Ansible总是会显示任何任务的头文件, 不管这个任务被跳过与否。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;display_skipped_hosts=True
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;error_on_undefined_vars&#34;&gt;error_on_undefined_vars&lt;/h5&gt;
&lt;p&gt;这个选项为默认，如果所引用的变量名称错误的话, 将会导致ansible在执行步骤上失败：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;error_on_undefined_vars=True
# If set to False, any ‘{{ template_expression }}’ that contains undefined variables will be rendered in a template or ansible action line exactly as written.
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;executable&#34;&gt;executable&lt;/h5&gt;
&lt;p&gt;这个选项可以在sudo环境下产生一个shell交互接口。用户只在/bin/bash的或者sudo限制的一些场景中需要修改。大部分情况下不需要修改::&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;executable = /bin/bash
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;filter_plugins&#34;&gt;filter_plugins&lt;/h5&gt;
&lt;p&gt;过滤器是一种特殊的函数，用来拓展模版系统。这是一个开发者核心的特性，允许Ansible从任何地方载入底层拓展模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;filter_plugins = ~/.ansible/plugins/filter_plugins/:/usr/share/ansible_plugins/filter_plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;force_color&#34;&gt;force_color&lt;/h5&gt;
&lt;p&gt;当没有使用TTY终端的时候，这个选项当用来强制颜色模式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;force_color = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;force_handlers&#34;&gt;force_handlers&lt;/h5&gt;
&lt;p&gt;即便这个用户崩溃，这个选项仍可以继续运行这个用户:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;force_handlers = True
# The default is False, meaning that handlers will not run if a failure has occurred on a host. This can also be set per play or on the command line. See _handlers_and_failure for more details. 
# 如果这个选项是False. 如果一个主机崩溃了,handlers将不会再运行这个主机。这个选项也可以通过命令行临时使用。详见:doc:_handlers_and_failure.
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;forks&#34;&gt;forks*&lt;/h5&gt;
&lt;p&gt;这个选项设置在与主机通信时的默认并行进程数。很多用户把这个设置为50,有些设置为500或者更多，如果你有很多的主机, 高数值将会使得跨主机行为变快。默认值比较保守：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;forks=5
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;hash_behaviour&#34;&gt;hash_behaviour&lt;/h5&gt;
&lt;p&gt;Ansible默认将会以一种特定的优先级覆盖变量，详见&lt;code&gt;:doc:playbooks_variables&lt;/code&gt;。拥有更高优先级的参数将会覆盖掉其他参数。&lt;br&gt;
有些用户希望被hashed的参数（python 中的数据结构dictionaries）被合并.。这个设置叫做&lt;code&gt;merge&lt;/code&gt;。这不是一个默认设置，而且不影响数组类型的数组。我不建议使用这个设置除非你觉得一定需要这个设置。&lt;strong&gt;官方实例中不使用这个选项&lt;/strong&gt;：&lt;br&gt;
合法的值为&lt;code&gt;replace&lt;/code&gt;(默认值)或者&lt;code&gt;merge&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;hash_behaviour=replace
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;host_key_checking&#34;&gt;host_key_checking*&lt;/h5&gt;
&lt;p&gt;这个特性详见：&lt;code&gt;doc:intro_getting_started&lt;/code&gt;，在Ansible 1.3或更新版本中将会检测主机密钥。如果你了解怎么使用并且希望禁用这个功能,你可以将这个值设置为False:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;host_key_checking=True
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;inventory&#34;&gt;inventory*&lt;/h5&gt;
&lt;p&gt;这个是默认库文件位置，脚本或者存放可通信主机的目录：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;inventory = /etc/ansible/hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;jinja2_extensions&#34;&gt;jinja2_extensions&lt;/h5&gt;
&lt;p&gt;这是一个开发者中心特性，允许开启Jinja2拓展模块：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;jinja2_extensions = jinja2.ext.do,jinja2.ext.i18n
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;library&#34;&gt;library*&lt;/h5&gt;
&lt;p&gt;这个是Ansible默认搜寻模块的位置：&lt;br&gt;
&lt;code&gt;Ansible会多个用冒号隔开的路径，同时也会搜索在playbook中的“./library”&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;library = /usr/share/ansible
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;log_path&#34;&gt;log_path*&lt;/h5&gt;
&lt;p&gt;如果出现在ansible.cfg文件中，Ansible将会在选定的位置登陆执行信息。请留意用户运行的Ansible对于logfile有无权限:&lt;br&gt;
这个特性不是默认开启的。如果不设置，ansible将会把模块加载记录在系统日志系统中。不包含用户密码.&lt;br&gt;
对于需要了解更多日志系统的企业及用户,你也许对**:doc:tower**感兴趣。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;log_path=/var/log/ansible.log
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;lookup_plugins&#34;&gt;lookup_plugins&lt;/h5&gt;
&lt;p&gt;这是一个开发者中心选项，允许模块插件在不同区域被加载：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;lookup_plugins = ~/.ansible/plugins/lookup_plugins/:/usr/share/ansible_plugins/lookup_plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;module_lang&#34;&gt;module_lang&lt;/h5&gt;
&lt;p&gt;这是默认模块和系统之间通信的计算机语言,默认为&lt;code&gt;C语言&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;module_lang = C
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在解决推送日志乱码的时候需要配置
module_lang = C 
    ==&amp;gt; module_lang = zh_CN.UTF-8
module_set_locale = False  
    ==&amp;gt; module_set_locale = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;module_name&#34;&gt;module_name&lt;/h5&gt;
&lt;p&gt;这个是/usr/bin/ansible的默认模块名（-m）。默认是&lt;code&gt;command&lt;/code&gt;模块。之前提到过，command模块不支持shell变量、管道、配额，所以也许你希望把这个参数改为&lt;code&gt;shell&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;module_name = command
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;nocolor&#34;&gt;nocolor&lt;/h5&gt;
&lt;p&gt;默认ansible会为输出结果加上颜色，用来更好的区分状态信息和失败信息。如果你想关闭这一功能,可以把&lt;code&gt;nocolor&lt;/code&gt;设置为&lt;code&gt;1&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nocolor=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;nocows&#34;&gt;nocows&lt;/h5&gt;
&lt;p&gt;默认ansible可以调用一些cowsay的特性，使得/usr/bin/ansible-playbook运行起来更加愉快。如果你不喜欢cows，你可以通通过将&lt;code&gt;nocows&lt;/code&gt;设置为&lt;code&gt;1&lt;/code&gt;来禁用这一选项：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nocows=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;pattern&#34;&gt;pattern&lt;/h5&gt;
&lt;p&gt;如果没有提供“hosts”节点，这是playbook要通信的默认主机组。默认值是对所有主机通信：&lt;br&gt;
&lt;code&gt;注意/usr/bin/ansible 一直需要一个host pattern，并且不使用这个选项。这个选项只作用于/usr/bin/ansible-playbook。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pattern = * 
#　hosts=*
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;poll_interval&#34;&gt;poll_interval*&lt;/h5&gt;
&lt;p&gt;对于Ansible中的异步任务，当具体的poll interval 没有定义时，多少时间回查一下这些任务的状态，默认值（15秒）是一个折中选择。这个时间是回查频率、任务完成叫回频率、当任务完成时的回转频率的折中:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;poll_interval=15
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;private_key_file&#34;&gt;private_key_file&lt;/h5&gt;
&lt;p&gt;如果你是用pem密钥文件而不是SSH客户端或密码认证的话，你可以设置这里的默认值，来避免每一次提醒设置密钥文件位置&lt;code&gt;–ansible-private-keyfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;private_key_file=/path/to/file.pem
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;remote_port&#34;&gt;remote_port*&lt;/h5&gt;
&lt;p&gt;这个设置是你系统默认的远程SSH端口，如果不指定,默认为22号端口：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;remote_port = 22
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;remote_tmp&#34;&gt;remote_tmp*&lt;/h5&gt;
&lt;p&gt;Ansible 通过远程传输模块到远程主机，然后远程执行，执行后再清理现场。在有些场景下，你也许想使用默认路径，希望像更换补丁一样使用, 这时候你可以使用这个选项：&lt;br&gt;
&lt;code&gt;默认路径是在用户家目录下的目录.Ansible，会在这个目录中使用一个随机的文件夹名称&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;remote_tmp = $HOME/.ansible/tmp
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;remote_user&#34;&gt;remote_user&lt;/h5&gt;
&lt;p&gt;这是个ansible使用&lt;code&gt;/usr/bin/ansible-playbook&lt;/code&gt;链接的默认用户名。如果不指定，&lt;code&gt;/usr/bin/ansible&lt;/code&gt;默认使用&lt;strong&gt;当前用户名称&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;remote_user = root
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;roles_path&#34;&gt;roles_path&lt;/h5&gt;
&lt;p&gt;roles路径指的是&lt;code&gt;roles/&lt;/code&gt;下的额外目录，用于playbook搜索Ansible roles。比如， 如果我们有个用于common roles源代码控制仓库和一个不同的playbooks仓库，你也许会在 /opt/mysite/roles里面查找roles：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;roles_path = /opt/mysite/roles
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多余的路径可以用冒号分隔，类似于其他path字符串：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;roles_path = /opt/mysite/roles:/opt/othersite/roles
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;sudo_exe&#34;&gt;sudo_exe&lt;/h5&gt;
&lt;p&gt;如果在其他远程主机上使用另一种方式执行sudo操纵， sudo程序的路径可以用这个参数更换，使用命令行标签来拟合标准sudo：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo_exe=sudo
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;sudo_flags&#34;&gt;sudo_flags&lt;/h5&gt;
&lt;p&gt;当使用sudo支持的时候,传递给sudo以外的标签. 默认值为&lt;code&gt;-H&lt;/code&gt;， 意思是保留原用户的环境。在有些场景下也许需要添加或者删除标签，大多数用户不需要修改这个选项:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo_flags=-H
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;sudo_user&#34;&gt;sudo_user*&lt;/h5&gt;
&lt;p&gt;这个是sudo使用的默认用户,如果&lt;code&gt;–sudo-user&lt;/code&gt;没有特指或者&lt;code&gt;sudo_user&lt;/code&gt;在Ansible playbooks中没有特指,在大多数的逻辑中 默认为&lt;code&gt;root&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo_user=root
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;system_warnings&#34;&gt;system_warnings&lt;/h5&gt;
&lt;p&gt;允许禁用系统运行ansible相关的潜在问题警告（不包括操作主机）:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;system_warnings = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;timeout&#34;&gt;timeout*&lt;/h5&gt;
&lt;p&gt;这个是默认SSH链接尝试超市时间：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;timeout = 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;transport&#34;&gt;transport*&lt;/h5&gt;
&lt;p&gt;如果&lt;code&gt;-c &amp;lt;transport_name&amp;gt;&lt;/code&gt;选项没有在使用&lt;code&gt;/usr/bin/ansible&lt;/code&gt;或者 &lt;code&gt;/usr/bin/ansible-playbook&lt;/code&gt;特指的话，这个参数提供了默认通信机制。默认 值为&lt;code&gt;smart&lt;/code&gt;, 如果本地系统支持 ControlPersist技术的话，将会使用(基于OpenSSH)&lt;code&gt;ssh&lt;/code&gt;，如果不支持讲使用&lt;code&gt;paramiko&lt;/code&gt;。其他传输选项包括&lt;code&gt;local&lt;/code&gt;，&lt;code&gt;chroot&lt;/code&gt;，&lt;code&gt;jail&lt;/code&gt;等等。&lt;br&gt;
用户通常可以设置为&lt;code&gt;smart&lt;/code&gt;,让playbook在根据通信条件自己选择&lt;code&gt;connectin:&lt;/code&gt;参数.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;transport=smart
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;vars_plugins&#34;&gt;vars_plugins&lt;/h5&gt;
&lt;p&gt;这是一个开发者中心选项，允许底层拓展模块从任何地方加载：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vars_plugins = ~/.ansible/plugins/vars_plugins/:/usr/share/ansible_plugins/vars_plugins
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;vault_password_file&#34;&gt;vault_password_file&lt;/h5&gt;
&lt;p&gt;这个用来设置密码文件，也可以通过命令行指定&lt;code&gt;–vault-password-file&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vault_password_file = /path/to/vault_password_file
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;paramiko-specific-settings&#34;&gt;Paramiko Specific Settings&lt;/h4&gt;
&lt;p&gt;Paramiko是商业版linux 6 的默认SSH链接。但在其他平台上不是默认使用的。请在&lt;code&gt;[paramiko]&lt;/code&gt;头文件下激活它&lt;/p&gt;
&lt;h5 id=&#34;record_host_keys&#34;&gt;record_host_keys&lt;/h5&gt;
&lt;p&gt;默认设置会记录并验证通过在用户hostfile中新发现的的主机（如果host key checking 被激活的话）。这个选项在有很多主机的时候将会性能很差。在这种情况下,建议使用SSH传输代替。当设置为False时, 性能将会提升，在hostkey checking被禁用时候，建议使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;record_host_keys=True
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;openssh-specific-settings&#34;&gt;OpenSSH Specific Settings&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;[ssh_connection]&lt;/code&gt;头文件之下，用来调整SSH的通信连接。OpenSSH是Ansible在操作系统上默认的通讯连接。&lt;/p&gt;
&lt;h5 id=&#34;ssh_args&#34;&gt;ssh_args&lt;/h5&gt;
&lt;p&gt;如果设置了的话，这个选项将会传递一组选项给Ansible，而使用以前的默认值:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ssh_args = -o ControlMaster=auto -o ControlPersist=60s
# 用户可以提高ControlPersist值来提高性能。30分钟通常比较合适.
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;control_path&#34;&gt;control_path&lt;/h5&gt;
&lt;p&gt;这个是保存ControlPath套接字的位置。默认值是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;control_path=%(directory)s/ansible-ssh-%%h-%%p-%%r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在有些系统上面,会遇到很长的主机名或者很长的路径名称（也许因为很长的用户名,或者比较深的家目录）,这些都会超出套接字文件名字符上限（对于大多数平台上限为108个字符）。在这种情况下,你也许希望按照以下方式缩短字符串:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;control_path = %(directory)s/%%h-%%r
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;scp_if_ssh&#34;&gt;scp_if_ssh&lt;/h5&gt;
&lt;p&gt;用户操控一个没有开启SFTP协议的远程系统，如果这个设置为True，scp将代替用来为远程主机传输文件:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;scp_if_ssh=False
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果没有遇到这样的问题没有必要来修改这个设置。当然修改这个设置也没有什么明显的弊端。大部分的系统环境都默认支持SFTP, 通常情况下不需要修改。&lt;/p&gt;
&lt;h5 id=&#34;pipelining&#34;&gt;pipelining&lt;/h5&gt;
&lt;p&gt;在不通过实际文件传输的情况下执行ansible模块来使用管道特性，从而减少执行远程模块SSH操作次数。如果开启这个设置，将显著提高性能.。然而当使用&lt;code&gt;sudo&lt;/code&gt;操作的时候,，你必须在所有管理的主机的&lt;code&gt;/etc/sudoers&lt;/code&gt;中禁用&lt;code&gt;requiretty&lt;/code&gt;。默认这个选项为了保证与sudoers requiretty的设置的兼容性是禁用的.，但是为了提高性能强烈建议开启这个设置。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;pipelining=False
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;accelerated-mode-settings&#34;&gt;Accelerated Mode Settings&lt;/h4&gt;
&lt;p&gt;在&lt;code&gt;[accelerate]&lt;/code&gt;首部下, 以下设置可以调整。如果你不能在你的环境中开启&lt;code&gt;:ref:pipelining&lt;/code&gt; , Accelertation 是一个很有用的性能特性. 但是如果你可以开启管道，这个选项也许对你无用。&lt;/p&gt;
&lt;h5 id=&#34;accelerate_port&#34;&gt;accelerate_port&lt;/h5&gt;
&lt;p&gt;在急速模式下使用的端口:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;accelerate_port = 5099
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;accelerate_timeout&#34;&gt;accelerate_timeout&lt;/h5&gt;
&lt;p&gt;这个设置时用来控制从客户机获取数据的超时时间。如果在这段时间内没有数据传输，套接字连接会被关闭。一个保持连接（keepalive）数据包通常每15秒回发回给控制台，所以这个超时时间不应该低于15秒（默认值为30秒）:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;accelerate_timeout = 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;accelerate_connect_timeout&#34;&gt;accelerate_connect_timeout&lt;/h5&gt;
&lt;p&gt;这个设置连接套接字调用的超时时间。这个应该设置相对比较短.这个和&lt;code&gt;accelerate_port&lt;/code&gt;连接在回滚到ssh或者paramiko（受限于你默认的连接设置）连接方式之前会尝试三次开始远程加速daemon守护进程。默认设置为1.0秒：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;accelerate_connect_timeout = 1.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，这个选项值可以设置为小于1秒钟，但是除非你拥有一个速度很快而且很可靠的网络，否则也许这样并不是一个很好的选择。如果你使用英特网访问你的系统，最好提高这个值。&lt;/p&gt;
&lt;h5 id=&#34;accelerate_daemon_timeout&#34;&gt;accelerate_daemon_timeout&lt;/h5&gt;
&lt;p&gt;这个控制加速daemon守护进程的超时时间，用分钟来衡量。默认为30分钟：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;accelerate_daemon_timeout = 30
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;accelerate_multi_key&#34;&gt;accelerate_multi_key&lt;/h5&gt;
&lt;p&gt;如果这个选项开启，这个设置将允许多个私钥被加载到daemon。任何客户端要想连接daemon都需要开启这个选项:&lt;br&gt;
通过本地套接字文件连接的通过SSH上传密钥文件到目标节点的新客户端，必须在登陆daemon时使用原始的登陆密钥登陆。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;accelerate_multi_key = yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ansible免密码登录以及排错&#34;&gt;ansible(免密码登录以及排错)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;生成密钥&lt;br&gt;
&lt;code&gt;ssh-keygen -t rsa&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;【常用ssh-keygen参数】&lt;br&gt;
-b bits ：指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)&lt;br&gt;
-t type ：指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)&lt;br&gt;
-f filename ：指定密钥文件名&lt;br&gt;
-C comment ：提供一个新注释&lt;br&gt;
-q ：安静模式。用于在 /etc/rc 中创建新密钥的时候&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;将密钥拷贝到预管理的节点(root@192.168.1.203)上&lt;br&gt;
&lt;code&gt;ssh-copy-id -i /root/.ssh/id_rsa.pub root@192.168.1.203&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;测试&lt;br&gt;
&lt;code&gt;ansible all -a &amp;quot;date&amp;quot;&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ansible all -a &amp;quot;ping -c 4 192.168.3.1&amp;quot; -vvv&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ansible插件ansible-cmdb实现cmdb功能&#34;&gt;ansible插件ansible-cmdb（实现cmdb功能）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装 ansible-cmdb 插件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://github.com/fboender/ansible-cmdb/releases/download/1.30/ansible-cmdb-1.30.tar.gz
tar -xvf ansible-cmdb-1.30.tar.gz -C /usr/share/ansible/plugins
cd /usr/share/ansible/plugins/ansible-cmdb-1.30/ &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;添加环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/profile
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;生成所有主机的facts信息&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m setup --tree out/
# 会在当前目录下生成 out 目录，out目录下都是以主机域名或ip命名的文件。
# 比如，在/usr/local/ 下执行 ansible all -m setup --tree out/ ，则会在 /usr/local/下生成out目录
# 或者，
# 直接指明在哪生成 out目录
ansible all -m setup --tree /usr/local/out
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;通过第3步生成的facts信息生成web页面&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd ~
ansible-cmdb /usr/local/out/ &amp;gt; overview.html
将 ~/overview.html 文件导出可用浏览器直接访问：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible组件&#34;&gt;ansible组件&lt;/h1&gt;
&lt;h2 id=&#34;inventory主机清单静态&#34;&gt;inventory(主机清单静态)&lt;/h2&gt;
&lt;p&gt;所有的机器信息都存放到ansible的inventory组件里面，默认ansible的inventory是一个静态的ini格式的文件/etc/ansible/hosts，当然还可以通过ANSIBLE_HOSTS环境变量指定或者运行ansible和ansible-playbook的时候用-i参数临时设置。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593414433591.png&#34; alt=&#34;inventory&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;中括号中的名字代表组名&lt;/strong&gt;，你可以根据你自己的需求将庞大的主机分成具有标识的组，如上面我分了两个组webservers和dbservers组；&lt;br&gt;
&lt;strong&gt;主机(hosts)部分可以使用域名、主机名、IP地址表示&lt;/strong&gt;；当然使用前两者时，也需要主机能反解析到相应的IP地址，一般此类配置中多使用IP地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;定义主机和主机组&#34;&gt;定义主机和主机组&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[docker] #定义了一组叫docker
172.16.1.11 #组下面的主机
172.11.11.11 # ansible_ssh_pass=&#39;123456&#39;

[docker:vars] #针对docker组使用inventroy内置变量定义了ssh登陆密码
ansible_ssh_pass=&#39;123456&#39;
aaa=&#39;my name is aaa&#39; # 传入自定义变量

[ansible:children] #定义了ansible组下面包含docker组，即docker组为ansible的子组
docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;多个inventory列表&#34;&gt;多个inventory列表&lt;/h3&gt;
&lt;p&gt;配置支持多个inventory，首先需要修改ansible.cfg中hosts的定义改成一个目录比如&lt;code&gt;hostfile = /data/inventory&lt;/code&gt;，然后我们在目录里面放入多个hosts文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@ceshi2 data]# tree inventory
inventory
├── docker
└── hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不同的文件可以存放不同的主机：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@ceshi2 data] cat hosts
172.16.4.11 ansible_ssh_pass=&#39;123456&#39;

[root@ceshi2 data]cat docker
[docker]
172.16.1.11 #组下面的主机
172.11.11.11 # ansible_ssh_pass=&#39;123456&#39;

[docker:vars] #针对docker组使用inventroy内置变量定义了ssh登陆密码
ansible_ssh_pass=&#39;123456&#39;

[ansible:children]#定义了一个ansible组 下面包含一个docker组
docker
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;inventory内置参数&#34;&gt;inventory内置参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ansible_ssh_host：要连接的主机名&lt;/li&gt;
&lt;li&gt;ansible_ssh_port：端口号默认是22&lt;/li&gt;
&lt;li&gt;ansible_ssh_user：ssh连接时默认使用的用户名&lt;/li&gt;
&lt;li&gt;ansible_ssh_pass：ssh连接时的密码&lt;/li&gt;
&lt;li&gt;ansible_sudo_pass：使用sudo连接用户是的密码&lt;/li&gt;
&lt;li&gt;ansible_ssh_private_key_file：秘钥文件如果不想使用ssh-agent管理时可以使用此选项&lt;/li&gt;
&lt;li&gt;ansible_shell_type：shell的类型默认sh&lt;/li&gt;
&lt;li&gt;ansible_connection：SSH 连接的类型： local , ssh , paramiko。在ansible 1.2之前默认是paramiko，后来智能选择，优先使用基于ControlPersist的ssh&lt;/li&gt;
&lt;li&gt;ansible_python _ interpreter：用来指定 python 解释器的路径，同样可以指定ruby 、perl 的路径&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;inventory动态获取主机清单&#34;&gt;inventory(动态获取主机清单)&lt;/h2&gt;
&lt;p&gt;动态inventory的意思是所有的变量可以从外部获取，也就是说我们可以从CMDB以及zabbix系统拉取所有的主机信息然后使用ansible进行管理。引用inventory只需要把ansible.cfg文件中的inventory定义值改成一个执行脚本即可。&lt;br&gt;
脚本举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/env python
# coding=utf-8
# inverti.py
import json
host1ip = [&#39;192.168.1.15&#39;]
host2ip = [&#39;192.168.1.110&#39;]
group = &#39;test11&#39;
group2 = &#39;test22&#39;
hostdata = {group:{&amp;quot;hosts&amp;quot;:host1ip},group2:{&amp;quot;hosts&amp;quot;:host2ip}} # ansible识别的是json格式，且格式固定为{&amp;quot;组名&amp;quot;:{&amp;quot;hosts&amp;quot;:ip1}}
print json.dumps(hostdata,indent=4)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[root@vagrant-centos65 opt]# ansible -i inverti.py all  -a &#39;uptime&#39; -k
SSH password: 
192.168.1.15 | SUCCESS | rc=0 &amp;gt;&amp;gt;
 07:25:27 up  3:56,  3 users,  load average: 0.00, 0.00, 0.00
192.168.1.110 | SUCCESS | rc=0 &amp;gt;&amp;gt;
 07:25:27 up 7 min,  3 users,  load average: 0.00, 0.02, 0.00
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible单命令模式&#34;&gt;ansible(单命令模式)&lt;/h1&gt;
&lt;p&gt;ad-hoc是&lt;strong&gt;点对点的执行ansible命令&lt;/strong&gt;，介绍一下日常的Ad-Hoc命令&lt;br&gt;
例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 后台执行(返回ansible_job_id(即jid)等信息)
# -B的意思是异步执行，-o的意思是压缩输出，-P设置轮询间隔
ansible docker -B 120 -P 0 -m shell -a &#39;sleep 10;hostname&#39; -o #加了-P 0 之后会返回一个job_id 可以通过jobID去查看执行的结果。当-P 大于0的时候会轮询去查询执行结果
# 根据jid查询后台任务状态
# -m要执行的模块，-a模块参数
ansible all -m async_status -a &#39;jid=&#39;5265654654&#39;&#39; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其他的命令&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;可选参数：
  --ask-vault-pass      
	要求提供保管库密码
  --list-hosts          
	输出匹配主机列表；不执行其他任何操作
  --playbook-dir BASEDIR
	由于此工具不使用剧本，因此可以将其用作替代剧本目录，从而为许多功能（包括role / group_vars /等）设置相对路径。
  --syntax-check
	在剧本上执行语法检查，但不执行
  --vault-id VAULT_IDS
	要使用的库身份
  --vault-password-file VAULT_PASSWORD_FILES
	保险库密码文件
  --version             
	显示程序的版本号，配置文件位置，配置的模块搜索路径，模块位置，可执行位置和退出
  -B SECONDS, --background SECONDS
	异步运行，在X秒后失败。（默认值= N / A）
  -C, --check           
	不要做任何改变；相反，尝试预测可能发生的某些变化
  -D, --diff            
	更改（小的）文件和模板时，请显示这些文件中的差异；与--check一起使用效果很好
  -M MODULE_PATH, --module-path MODULE_PATH
	在模块库前添加用冒号分隔的路径。（默认值=〜/ .ansible / plugins / modules：/ usr / share / ansible / plugins / modules）
  -P POLL_INTERVAL, --poll POLL_INTERVAL
	如果使用-B，则设置轮询间隔（默认值= 15）
  -a MODULE_ARGS, --args MODULE_ARGS
	模块参数
  -e EXTRA_VARS, --extra-vars EXTRA_VARS
	如果文件名以@开头，则将其他变量设置为key = value或YAML / JSON
  -f FORKS, --forks FORKS
	指定要使用的并行进程数。（默认值= 5）
  -h, --help            
	显示此帮助消息并退出
  -i INVENTORY, --inventory INVENTORY, --inventory-file INVENTORY
	指定清单主机路径或逗号分隔的主机列表。 --inventory-file已弃用。
  -l SUBSET, --limit SUBSET
	将所选主机进一步限制为其他模式
  -m MODULE_NAME, --module-name MODULE_NAME
	要执行的模块名称。（默认=commond）
  -o, --one-line        
	压缩输出
  -t TREE, --tree TREE  
	日志输出到该目录
  -v, --verbose         
	详细模式（-vvv用于更多，-vvvv用于启用连接调试）
--------------------------------------------------------------
--------------------------------------------------------------
特权升级选项：控制您如何以及在目标主机上成为哪个用户
  --become-method BECOME_METHOD
    要使用的特权升级方法（默认= sudo），请使用“ ansible-doc -t become -l”列出有效的选择。
  --become-user BECOME_USER
	以该用户身份运行操作（默认= root）
  -K, --ask-become-pass
	要求特权升级密码
  -b, --become          
	使用变为运行操作（不表示提示输入密码）
--------------------------------------------------------------
--------------------------------------------------------------
连接选项：控制谁以及如何连接到主机
  --private-key PRIVATE_KEY_FILE, --key-file PRIVATE_KEY_FILE
	使用此文件来验证连接
  --scp-extra-args SCP_EXTRA_ARGS
	指定额外的参数以仅传递给scp（例如-l）
  --sftp-extra-args SFTP_EXTRA_ARGS
	指定额外的参数以仅传递给sftp（例如-f，-l）
  --ssh-common-args SSH_COMMON_ARGS
	指定要传递给sftp / scp / ssh的通用参数（例如ProxyCommand）
  --ssh-extra-args SSH_EXTRA_ARGS
	指定额外的参数以仅传递给ssh（例如-R）
  -T TIMEOUT, --timeout TIMEOUT
	覆盖连接超时（以秒为单位）。（默认值为10）
  -c CONNECTION, --connection CONNECTION
	要使用的连接类型。（默认=智能）
  -k, --ask-pass        
	询问连接密码
  -u REMOTE_USER, --user REMOTE_USER
	以该用户身份连接。（默认=无）
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible常用模块&#34;&gt;ansible常用模块&lt;/h1&gt;
&lt;p&gt;根据官方的分类，将模块按功能分类为：云模块、命令模块、数据库模块、文件模块、资产模块、消息模块、监控模块、网络模块、通知模块、包管理模块、源码控制模块、系统模块、单元模块、web设施模块、window模块等&lt;/p&gt;
&lt;h2 id=&#34;command&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/command_module.html&#34;&gt;command&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;命令模块，适合使用简单的命令 无法支持&amp;quot;&amp;lt;&amp;quot;，&amp;quot;&amp;gt;&amp;quot;，&amp;quot;|&amp;quot;，&amp;quot;;&amp;quot;，&amp;quot;&amp;amp;&amp;quot;等符号&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chdir：在执行命令前，进入到指定目录中&lt;/li&gt;
&lt;li&gt;creates：判断指定文件是否存在，如果存在，&lt;strong&gt;不执行后面的操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;removes：判断指定文件是否存在，如果存在，&lt;strong&gt;执行后面的操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;free_form：必须要输入一个合理的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible webservers -m command -a &amp;quot;hostname&amp;quot;
ansible webservers -m command -a &amp;quot;chdir=/data ls -l&amp;quot;
ansible webservers -m command -a &amp;quot;touch /data/lol.txt creates=/data/lol.txt&amp;quot;
ansible webservers -m command -a &amp;quot;rm -f /data/hosts removes=/data/hosts&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;shell&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/shell_module.html&#34;&gt;shell&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;类似command模块升级版—万能模块，可以使用&amp;quot;&amp;lt;&amp;quot;，&amp;quot;&amp;gt;&amp;quot;，&amp;quot;|&amp;quot;，&amp;quot;;&amp;quot;，&amp;quot;&amp;amp;&amp;quot;等符号特殊符号，其它参数参考command模块，使用方法一致&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chdir：在执行命令前，进入到指定目录中&lt;/li&gt;
&lt;li&gt;creates：判断指定文件是否存在，如果存在，&lt;strong&gt;不执行后面的操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;removes：判断指定文件是否存在，如果存在，&lt;strong&gt;执行后面的操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;free_form：必须要输入一个合理的命令&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible dkaiyun -m shell -a &amp;quot;ps -ef |grep /[s]sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;ping&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/ping_module.html&#34;&gt;ping&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;主要用于判断远程客户端是否在线，用于ping本身服务器，用法很简单，不涉及参数，返回值是changed、ping&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m ping
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593440346134.png&#34; alt=&#34;ping&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;setup&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/setup_module.html&#34;&gt;setup&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;主要用于获取主机信息，不用option的情况会输出所有相关的对象机器的facts，在playbooks里经常会用到的一个参数&lt;code&gt;gather_facts&lt;/code&gt;就与该模块有关。还有一个经常使用的参数是&lt;code&gt;filter&lt;/code&gt;，使用方法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; # 查看所有的信息：CPU、内存、IP等，所有的主机信息都会被收集
ansible all -m setup

# filter ：过滤关键字
# 查看主机的内存信息
ansible all -m setup -a &#39;filter=&amp;quot;ansible_*_mb&amp;quot;&#39; 
# 查看主机eth0-eth2的网卡信息
ansible all -m setup -a &#39;filter=ansible_eth[0-2]&#39;
# 收集对象机器的环境变量信息
ansible all -m setup -a &amp;quot;filter=ansible_env&amp;quot;

# --tree :将所有主机的输出信息保存到/tmp/目录下，以/etc/ansible/hosts里的主机名为文件名
ansible all -m setup -a &#39;filter=ansible_distribution_version&#39; --tree /tmp/
# 把所有的主机信息输入到/tmp/inode目录下，每台主机的信息输入到主机文件名的文件中
ansible all -m setup --tree /tmp/inode

# gather_subset：按子集收集信息，值有all, min, hardware, network, virtual, ohai, facter。不包含请使用!号，如，!network

# 其他常用参数如下：
# ansible_all_ipv4_addresses：仅显示ipv4的信息
# ansible_devices：仅显示磁盘设备信息
# ansible_distribution：显示是什么系统，例：centos,suse等
# ansible_distribution_major_version：显示是系统主版本
# ansible_distribution_version：仅显示系统版本
# ansible_machine：显示系统类型，例：32位，还是64位
# ansible_eth0：仅显示eth0的信息
# ansible_hostname：仅显示主机名
# ansible_kernel：仅显示内核版本
# ansible_lvm：显示lvm相关信息
# ansible_memtotal_mb：显示系统总内存
# ansible_memfree_mb：显示可用系统内存
# ansible_memory_mb：详细显示内存情况
# ansible_swaptotal_mb：显示总的swap内存
# ansible_swapfree_mb：显示swap内存的可用内存
# ansible_mounts：显示系统磁盘挂载情况
# ansible_processor：显示cpu个数(具体显示每个cpu的型号)
# ansible_processor_vcpus：显示cpu个数(只显示总的个数)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593480124097.png&#34; alt=&#34;setup&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;file&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/file_module.html&#34;&gt;file&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;file模块主要用于远程主机上的文件操作，file模块包含如下选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;force：需要在两种情况下强制创建软连接，一是源文件不存在但之后会建立的情况下，二是目标软连接已存在，需要先取消之前的软连接，然后再创建软连接，两个选项：yes|no&lt;/li&gt;
&lt;li&gt;group/mode/owner：定义文件或目录的属组/权限/属主&lt;/li&gt;
&lt;li&gt;path：必选项，定义文件/目录的路径&lt;/li&gt;
&lt;li&gt;recurse：递归的设置文件的属性，只对目录有效&lt;/li&gt;
&lt;li&gt;scr：要被链接的源文件的路径，只应用于state=link的情况&lt;/li&gt;
&lt;li&gt;dest：被链接到的路径，只应用于state=link的情况&lt;/li&gt;
&lt;li&gt;state=
&lt;ul&gt;
&lt;li&gt;directory：如果目录不存在，创建目录&lt;/li&gt;
&lt;li&gt;link：创建软连接&lt;/li&gt;
&lt;li&gt;hard：创建硬链接&lt;/li&gt;
&lt;li&gt;touch：如果文件不存在，则创建文件；如果文件或目录已经存在，则更新其最后修改时间&lt;/li&gt;
&lt;li&gt;absent：删除目录、文件、链接文件&lt;/li&gt;
&lt;li&gt;file：查看指定目录信息是否存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m file -a &amp;quot;src=/etc/fstab dest=/tmp/fstab state=link&amp;quot;
ansible all -m file -a &amp;quot;path=/tmp/fstab state=absent&amp;quot;
ansible all -m file -a &amp;quot;path=/tmp/fstab state=touch&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593480249631.png&#34; alt=&#34;file&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;copy&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/copy_module.html&#34;&gt;copy&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;复制文件到远程主机，copy模块包含如下选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;backup：在覆盖之前将原文件备份，备份文件包含时间信息。有两个选项：yes|no。&lt;strong&gt;只有当两个文件的内容不同时才生效&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;content：用于替代src，可以直接设定指定文件的值&lt;/li&gt;
&lt;li&gt;dest：必选项。要将源文件复制到远程主机的绝对路径，如果源文件是一个目录，那么该路径必须是一个目录&lt;/li&gt;
&lt;li&gt;directory_mode：递归的设定目录的权限，默认为系统默认权限&lt;/li&gt;
&lt;li&gt;force：如果目标主机包含该文件，但内容不同，如果设置为yes（默认值），则强制覆盖；如果为no，则只有当目标主机的目标位置不存在该文件时才复制&lt;/li&gt;
&lt;li&gt;others：所有的file模块里的选项都可以在这里使用&lt;/li&gt;
&lt;li&gt;src：要复制到远程主机的文件在本地的地址，可以是绝对路径也可以是相对路径。如果路径是一个目录，它将递归复制。在这种情况下，如果路径使用&amp;quot;/&amp;quot;结尾，则只复制目录中的内容，否则，包含整个目录在内的全部内容均被复制，类似rsync&lt;/li&gt;
&lt;li&gt;validate：验证命令在复制到位之前运行。 要验证的文件的路径通过“％s”传递，该路径必须如下面的visudo示例中所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m copy -a &amp;quot;src=/etc/fstab dest=/data owner=foo group=foo mode=0644&amp;quot; # mode权限之前需要添加一位0。如果想要在user对应的权限位上添加执行权限，则可以使用mode=u+x表示
ansible all -m copy -a &amp;quot;src=/root/anaconda-ks.cfg  dest=/data&amp;quot;
echo ansible &amp;gt;&amp;gt;/root/anaconda-ks.cfg
ansible all -m copy -a &amp;quot;src=/root/anaconda-ks.cfg  dest=/data backup=yes&amp;quot;
ansible all -m copy -a &amp;quot;src=/etc/sudoers dest=/data validate=&#39;visudo -cf %s&#39;&amp;quot; # -cf的意思是检查配置文件是否正常
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593482702444.png&#34; alt=&#34;copy&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593482706146.png&#34; alt=&#34;backup&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593482711694.png&#34; alt=&#34;backup2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;fetch&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/fetch_module.html&#34;&gt;fetch&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;抓取文件到管理机上&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;src：要获取的远程系统上的文件，必须是文件，而不是目录&lt;/li&gt;
&lt;li&gt;dest：用于保存文件的目录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m fetch -a &amp;quot;src=/root/lol.txt dest=/root&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;service&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/service_module.html&#34;&gt;service&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用于管理服务，该模块包含如下选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;arguments：给命令行提供一些选项&lt;/li&gt;
&lt;li&gt;enabled：是否开机启动yes|no&lt;/li&gt;
&lt;li&gt;name：必选项，服务名称&lt;/li&gt;
&lt;li&gt;pattern：定义一个模式，如果通过status指令来查看服务的状态时，没有响应，就会通过ps指令在进程中根据该模式进行查找，如果匹配到，则认为该服务依然在运行&lt;/li&gt;
&lt;li&gt;runlevel：运行级别&lt;/li&gt;
&lt;li&gt;sleep：如果执行了restarted，则在stop和start之间沉睡几秒钟&lt;/li&gt;
&lt;li&gt;status=：对当前服务执行
&lt;ul&gt;
&lt;li&gt;started：启动&lt;/li&gt;
&lt;li&gt;stopped：停止&lt;/li&gt;
&lt;li&gt;restarted：重启&lt;/li&gt;
&lt;li&gt;reloaded：重新加载&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m service -a &amp;quot;name=crond state=started enabled=yes&amp;quot;
ansible all -m service -a &amp;quot;name=nginx state=restarted sleep=10&amp;quot;
ansible all -m service -a &amp;quot;name=foo pattern=/usr/bin/foo state=started&amp;quot;
ansible all -m service -a &amp;quot;name=network state=restarted args=ens32&amp;quot; # centos6
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;cron&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/cron_module.html&#34;&gt;cron&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用于管理计划任务，包含如下选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;backup：对远程主机上的原任务计划内容修改之前做备份&lt;/li&gt;
&lt;li&gt;cron_file：如果指定该选项，则用该文件替换远程主机上的cron.d目录下的用户的任务计划&lt;/li&gt;
&lt;li&gt;day/hour/minute/month/weekday：日/小时/分钟/月/周&lt;/li&gt;
&lt;li&gt;job：要这行的任务，依赖于state=present&lt;/li&gt;
&lt;li&gt;name：该任务的描述&lt;/li&gt;
&lt;li&gt;special_time：指定什么时候执行，参数reboot/yearly/annually/monthly/weekly/daily/hourly&lt;/li&gt;
&lt;li&gt;state：确认该任务计划是创建还是删除&lt;/li&gt;
&lt;li&gt;user：以哪个用户的身份执行&lt;/li&gt;
&lt;li&gt;diasbled=yes：将指定的任务注释掉，取消注释使用no。&lt;strong&gt;注释和取消注释时必须填写 job和时间参数&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 添加任务计划
ansible all -m cron -a &#39;name=&amp;quot;a job for reboot&amp;quot; special_time=reboot job=&amp;quot;/some/job.sh&amp;quot;&#39;
ansible all -m cron -a &amp;quot;name=&#39;testx&#39; weekday=&#39;2&#39; minute=&#39;0&#39; hour=12 user=&#39;root&#39; job=&#39;cat /etc/passwd &amp;gt;/root/111&#39; cron_file=&#39;test ansible&#39;&amp;quot;
ansible all -m cron -a &#39;backup=&amp;quot;True&amp;quot; name=&amp;quot;test&amp;quot; minute=0 hour=2 job=&amp;quot;ls -alh &amp;gt;/dev/null&amp;quot;&#39;
ansible all -m cron -a &amp;quot;name=&#39;ntpdate time&#39; minute=*/5 job=&#39;/usr/sbin/ntpdate ntp1.aliyun.com &amp;amp;&amp;gt;/dev/null&#39; &amp;quot;
# 删除任务计划
ansible all -m cron -a &amp;quot;name=&#39;a job for reboot&#39; state=absent&amp;quot; 
ansible all -m cron -a &amp;quot;name=&#39;test&#39; state=absent&amp;quot; 
ansible all -m cron -a &amp;quot;name=&#39;testx&#39; state=absent&amp;quot; 
ansible all -m cron -a &#39;cron_file=ansible_yum-autoupdate state=absent&#39;
# 注释和取消注释任务
ansible all -m cron -a &amp;quot;name=&#39;ntpdate time&#39; minute=*/5 job=&#39;/usr/sbin/ntpdate ntp1.aliyun.com &amp;amp;&amp;gt;/dev/null&#39; disabled=yes&amp;quot;
ansible all -m cron -a &amp;quot;name=&#39;ntpdate time&#39; minute=*/5 job=&#39;/usr/sbin/ntpdate ntp1.aliyun.com &amp;amp;&amp;gt;/dev/null&#39; disabled=no&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593501015011.png&#34; alt=&#34;1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593501020264.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593501025590.png&#34; alt=&#34;3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593501030852.png&#34; alt=&#34;result&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;yum&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/yum_repository_module.html&#34;&gt;yum&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;使用yum包管理器来管理软件包，其选项有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;config_file：yum的配置文件&lt;/li&gt;
&lt;li&gt;diasble_gpg_check：关闭gpg_check校验&lt;/li&gt;
&lt;li&gt;disablerepo/enablerepo：启用/关闭某个源&lt;/li&gt;
&lt;li&gt;name：要进行操作的软件包的名字，也可以传递一个url或者笨的的rpm包的路径&lt;/li&gt;
&lt;li&gt;state=
&lt;ul&gt;
&lt;li&gt;absent：卸载软件(常用)&lt;/li&gt;
&lt;li&gt;removed：卸载软件&lt;/li&gt;
&lt;li&gt;present：安装软件(常用)&lt;/li&gt;
&lt;li&gt;installed：安装软件&lt;/li&gt;
&lt;li&gt;latest：安装最新版本软件，更新软件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m yum -a &amp;quot;name=httpd state=latest&amp;quot;
ansible all -m yum -a &amp;quot;name=&#39;@Development tools&#39; state=present&amp;quot;
ansible all-m yum -a &#39;name=nginx state=installed disable_gpg_check=yes&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;get_url&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/get_url_module.html&#34;&gt;get_url&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;该模块主要用于从http\ftp\https服务器上下载文件，类似于wget。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sha256sum：下载完成后进行sha 256校验&lt;/li&gt;
&lt;li&gt;timeout：下载超时时间，默认10秒&lt;/li&gt;
&lt;li&gt;url：下载的url&lt;/li&gt;
&lt;li&gt;url_password\url_username：主要用于需要用户名和密码进行验证的情况&lt;/li&gt;
&lt;li&gt;use_proxy：使用代理，代理需要先在环境变量中定义&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m get_url -a &amp;quot;url=https://www.baidu.com dest=/tmp/baidu.html&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mount&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/mount_module.html&#34;&gt;mount&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;用于批量管理主机进行挂载卸载操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fstype：指定挂载的文件系统类型&lt;/li&gt;
&lt;li&gt;opts：指定挂载的参数信息&lt;/li&gt;
&lt;li&gt;path：定义一个挂载点信息&lt;/li&gt;
&lt;li&gt;src：定义设备文件信息&lt;/li&gt;
&lt;li&gt;state=
&lt;ul&gt;
&lt;li&gt;absent：会进行卸载，也会修改fstab文件信息&lt;/li&gt;
&lt;li&gt;unmounted：会进行卸载，不会修改fstab文件&lt;/li&gt;
&lt;li&gt;present：不会挂载，只会修改fstab文件&lt;/li&gt;
&lt;li&gt;mounted：会进行挂载，会修改fstab文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 只是在/etc/fstab文件中添加了配置信息，不会真正进行挂载（mount -a）
ansible all -m mount -a &amp;quot;src=172.16.1.31:/data/  path=/mnt fstype=nfs state=present&amp;quot;
# 在/etc/fstab文件中添加了配置信息，并且也会真正进行挂载
ansible web01 -m mount -a &amp;quot;src=172.16.1.31:/data/  path=/mnt fstype=nfs state=mounted&amp;quot;
# 在进行挂载的时候，使用state=mounted
# 在进行卸载的时候，使用state=absent
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;group&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/group_module.html&#34;&gt;group&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;远程批量创建用户组信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;gid：指创建的组ID信息&lt;/li&gt;
&lt;li&gt;name：指创建组名称信息&lt;/li&gt;
&lt;li&gt;state=
&lt;ul&gt;
&lt;li&gt;absent：删除指定的用户组&lt;/li&gt;
&lt;li&gt;present：创建指定的用户组&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible all -m group -a &amp;quot;name=test gid=1055&amp;quot;
ansible all -m group -a &amp;quot;name=test gid=1055 state=absent&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;user&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/user_module.html&#34;&gt;user&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;远程批量创建用户信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;password：请输入密码信息。password设置密码时不能使用明文方式，只能使用密文方式，可以给用户设置密码，还可以给用户修改密码&lt;/li&gt;
&lt;li&gt;name：指定用户名信息&lt;/li&gt;
&lt;li&gt;uid：指定用户uid信息&lt;/li&gt;
&lt;li&gt;group：指定用户主要属于哪个组&lt;/li&gt;
&lt;li&gt;groups：指定用户属于哪个附加组信息&lt;/li&gt;
&lt;li&gt;shell	/bin/bash或/sbin/nologin：指定是否能够登录&lt;/li&gt;
&lt;li&gt;create_home：yes/no，是否创建家目录信息&lt;/li&gt;
&lt;li&gt;home：指定家目录创建在什么路径 默认/home&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;template&#34;&gt;&lt;a href=&#34;https://docs.ansible.com/ansible/latest/modules/template_module.html&#34;&gt;template&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;可以将带有参数的配置文件传递到目标地址，可以对文件进行属组属主的修改以及备份（类似copy模块）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;backup：建立个包括timestamp在内的文件备份，以备不时之需.&lt;/li&gt;
&lt;li&gt;dest：远程节点上的绝对路径，用于放置template文件。&lt;/li&gt;
&lt;li&gt;group：设置远程节点上的的template文件的所属用户组&lt;/li&gt;
&lt;li&gt;mode：设置远程节点上的template文件权限。类似Linux中chmod的用法&lt;/li&gt;
&lt;li&gt;owner：设置远程节点上的template文件所属用户&lt;/li&gt;
&lt;li&gt;src：本地Jinjia2模版的template文件位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在playbook中的使用方法
# 把/mytemplates/foo.j2文件经过填写参数后，复制到远程节点的/etc/file.conf，文件权限相关略过
- template: src=/mytemplates/foo.j2 dest=/etc/file.conf owner=bin group=wheel mode=0644
# 跟上面一样的效果，不一样的文件权限设置方式
- template: src=/mytemplates/foo.j2 dest=/etc/file.conf owner=bin group=wheel mode=&amp;quot;u=rw,g=r,o=r&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible-playbook-2&#34;&gt;ansible-playbook&lt;/h1&gt;
&lt;h2 id=&#34;playbook基本语法&#34;&gt;playbook基本语法&lt;/h2&gt;
&lt;p&gt;playbook使用yaml语法，yaml语法可以通过&lt;a href=&#34;https://yaml.org/spec/1.2/spec.html&#34;&gt;https://yaml.org/spec/1.2/spec.html&lt;/a&gt;或&lt;a href=&#34;https://www.runoob.com/w3cnote/yaml-intro.html&#34;&gt;https://www.runoob.com/w3cnote/yaml-intro.html&lt;/a&gt;进行详细的学习。&lt;br&gt;
下面是简单的例子：&lt;/p&gt;
&lt;h3 id=&#34;例子1简单说明playbook的书写方式&#34;&gt;例子1：简单说明playbook的书写方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;playbook文件-nginx.yml&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  tasks:
  - name: Install nginx
    yum: name=nginx state=present
  - name: template nginx.conf
    template: src=./nginxbak.conf dest=/etc/nginx/nginx.conf owner=root group=root mode=0644 validate=&#39;nginx -t -c %s&#39;
    notify:
      - Restart Nginx Service
  handlers:
  - name: Restart Nginx Service # name的值必须与notify的值相同，否则无法触发handle
    service: name=nginx state=restarted
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第1行：表示该文件是YAML文件，非必须&lt;/li&gt;
&lt;li&gt;第2行：定义了该playbook针对的目标主机，all表示针对所有主机，这个参数支持ansible Ad-Hoc模式的所有参数，也就是可以定义组&lt;/li&gt;
&lt;li&gt;第3行：定义了该playbook所有的tasks集合，比如下面的3个tasks&lt;/li&gt;
&lt;li&gt;第4行：定义了一个task的名称，非必须，建议根据task实际任务命名&lt;/li&gt;
&lt;li&gt;第5行：定义了一个状态的action，这里使用的是yum模块安装nginx软件包&lt;/li&gt;
&lt;li&gt;第6-9行：使用template模板去管理/etc/nginx/nginx.conf文件；owner和group定义改文件的属主和属组；使用validate参数指定文件产生后使用&lt;code&gt;nginx -t -c %s&lt;/code&gt;命令去做nginx文件的语法验证；notify是触发handle，如果同步后，文件的MD5值有变化会触发&lt;code&gt;Restart Nginx Service&lt;/code&gt;这个handle&lt;/li&gt;
&lt;li&gt;第10-12行：定义一个handle状态让nginx服务重启，handle的名称是&lt;code&gt;Restart Nginx Service&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;hosts文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[nginx]
192.168.1.201
192.168.1.203
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;进行语法检查&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible-playbook nginx.yml --syntax-check
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;查看运行的主机和任务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible-playbook nginx.yml --list-task
ansible-playbook nginx.yml --list-hosts
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;执行&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible-playbook nginx.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593587235256.png&#34; alt=&#34;执行&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;例子2任务形式&#34;&gt;例子2：任务形式&lt;/h3&gt;
&lt;h4 id=&#34;任务目标&#34;&gt;任务目标&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;服务器&lt;/strong&gt;：3台&lt;br&gt;
&lt;strong&gt;任务1&lt;/strong&gt;：安装redis&lt;br&gt;
&lt;strong&gt;任务2&lt;/strong&gt;：修改redis.conf配置文件,指定bind绑定各自的局域网ip(用到template模板)&lt;br&gt;
&lt;strong&gt;任务3&lt;/strong&gt;：启动redis服务&lt;br&gt;
####目录结构&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593572113534.png&#34; alt=&#34;目录结构&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;pyml文件内容&#34;&gt;p.yml文件内容&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: web  #web组三台服务器,hosts文件配置
  remote_user: root  #远端服务器以root权限执行
  tasks:
  - name: install_redis  #任务1,下载redis
    yum: name=redis
    tags: install  #指定标签,暂时不用
  - name: copy_file  #任务2,将本地的redis.conf文件复制到远端服务器
    template: dest=/etc/redis.conf src=redis.conf.j2  #这个j2文件内下一步再看
    tags: copy
  - name: start_redis  #任务3,启动redis
    service: name=redis state=started
    tags: start  #指定标签,暂时不用
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;redisconfj2文件内容&#34;&gt;redis.conf.j2文件内容&lt;/h4&gt;
&lt;p&gt;首先复制/etc/redis.conf文件到当前文件夹下的templates目录下且命名为 redis.conf.j2。然后编辑改文件内容，文件部分内容看截图。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir templates  #新建一个templates文件夹
copy /etc/redis.conf ./templates/redis.conf.j2  #复制配置文件
vim ./templates/redis.conf.j2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593572356724.png&#34; alt=&#34;redis.conf.j2文件内容&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;ansible_default_ipv4.address 获取每个远程服务器的ipv4内网ip（使用setup模块）&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;执行文件&#34;&gt;执行文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible-plyabook p.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;常用的一些复杂变量&#34;&gt;常用的一些复杂变量&lt;/h2&gt;
&lt;p&gt;playbook中的一些复杂变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;---
# 目标主机支持所有的ad-hoc模式的所有的patterns
- hosts: 172.16.102.109:172.16.102.119
  # 远程ssh认证用户
  remote_user: root
  # 设置playbook的sudo操作
  sudo: yes
  # 设置playbook的sudo操作
  sudo_user: admin
  # 设置facts信息收集
  gather_facts: no
  # 设置accelerate模式(守护进程)
  accelarate: no
  # 设置accelerate端口
  accelerate_port: 5099
  # 设置playbook的tasks失败的百分比
  max_fail_percentage: 30
  # 远程连接的方式
  connection: local
  # 设置并发数目
  serial: 15
  # 设置额外的变量
  vars:
    nginx_port: 80
  # 引入变量文件
  vars_files:
    - &amp;quot;vars.yml&amp;quot;
    - [&amp;quot;one.yml&amp;quot;,&amp;quot;two.yml&amp;quot;]
  # 设置引入角色
  roles:
    - docker
  # 设置引入tasks
  tasks:
    - include: tasks.yml
  # 设置运行之后的tasks
  post_tasks:
    - name: post_tasks
  # 设置playbook的handlers
  handlers:
    - include: handlers.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;角色roles&#34;&gt;角色roles&lt;/h2&gt;
&lt;p&gt;ansible_playbook是ansible进行配置管理的组件，由于ad-hoc命令无法支撑复杂的配置管理工作，在我们实际使用ansible的工作中，大部分时间都是在编写playbook。&lt;br&gt;
简单的安装nginx的脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# mkdir -p /data/nginx_install/roles/nginx/tasks
# vim /data/nginx_install/site.yml
---
- hosts: all
  gather_facts: no
  roles:
    - nginx # 与文件同级的目录roles下面的目录
    # - mysql
    # - php
    # - java
# vim /data/nginx_install/roles/nginx/tasks/main.yml
---
- name: install nginx
  yum: name=nginx state=present
- name: start service nginx
  service: name=nginx state=started
# vim /data/nginx_install/hosts
[nginx]
192.168.1.201
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目录架构：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;roles/
-- nginx  # 角色目录
-- files # 角色的file目录
    -- index.html # 你的file资源
-- handler
    -- main.yml
-- tasks
    -- main.yml #nginx这个角色的入口文件
-- templates
    -- nginx.conf.j2
site.yml  # playbook统一入口文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;引入自定义变量&#34;&gt;引入自定义变量&lt;/h2&gt;
&lt;p&gt;通过inventory文件来定义变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# vim hosts
[nginx]
192.168.1.201
192.168.1.203
[nginx:vars]
key1= &amp;quot;i am key1&amp;quot; 

# vim var.yml
---
key3: &amp;quot;i am key3&amp;quot;
value3: &amp;quot;i am value&amp;quot;

# vim vars.yml
---
- hosts: all
  gather_facts: no
  vars:    
    key2: &amp;quot;i am key2&amp;quot;
  vars_files:
    - var.yml
  tasks:
    # 方式一：在hosts文件中引入自定义变量
    - name: display key1    
      debug: msg=&amp;quot;{{key1}}&amp;quot;
    # 方式二：在playbook文件中引入自定义变量
    - name: display key2
      debug: msg=&amp;quot;{{key2}}&amp;quot;
    # 方式三：通过yml文件引入自定义变量
    - name: display keys
      debug: msg=&amp;quot;{{key3}}-----&amp;gt;{value3{}}&amp;quot;

# 执行
ansible-playbook -i hosts vars.yml

# 通过命令传入需要加参数-e，这种方法很少用
# 在playbook文件里面使用var_files来传变量
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;变量传递&#34;&gt;变量传递&lt;/h2&gt;
&lt;p&gt;使用register变量，在playbook中的task之间进行变量的传递，比如两个tasks，第二个task需要第一个task运行后的结果&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: no
  tasks:
    # 第一个task：将命令hostname运行结果赋值给变量info
    - name: register var 
      shell: hostname
      register: info
    # 第二个task：将变量info的内容打印出来，同时打印字典中的key=stdout的值
    - name: display var
      debug: msg=&amp;quot;{{info}}&amp;quot;
    - name: display hostname
      debug: msg=&amp;quot;{{info.stdout}}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本的循环loops&#34;&gt;基本的循环loops&lt;/h2&gt;
&lt;p&gt;使用with_items这个关键字就可以完成迭代一个列表，列表中的每个变量都叫做item&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 标准的loops（循环列表）
---
- hosts: all
  gather_facts: no
  tasks:
    - name: debug loops
      debug: msg=&amp;quot;{{item}}&amp;quot;   # 等同于&amp;quot;for item in with_items:&amp;quot;，其中item、with_items是固定写法
      with_items:
        - one
        - two
        - three
        - four
# 批量安装软件
---
- hosts: all
  gather_facts: no
  tasks:
    - name: debug loops
      yum: name=&amp;quot;{{item}}&amp;quot; state=present
      with_items:
        - nginx
        - php
        - mariadb
        - zabbix

# 循环字典
---
- hosts: all
  gather_facts: no
  tasks:
    - name: debug dic
      debug: msg=&amp;quot;name--&amp;gt;{{item.key}}    val--&amp;gt;{{item.value}}&amp;quot;
      with_items:
        - {key: &amp;quot;one&amp;quot;,value: &amp;quot;value_one&amp;quot;}
        - {key: &amp;quot;two&amp;quot;,value: &amp;quot;value_two&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;嵌套循环&#34;&gt;嵌套循环&lt;/h2&gt;
&lt;p&gt;嵌套loops主要用于一对多或者多对多的合并&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: no
  tasks:
    - name: loops in loops
      debug: msg=&amp;quot;List1--&amp;gt;{{item[0]}}    List2--&amp;gt;{{item[1]}}&amp;quot;
      with_nested:
        - [&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;]
        - [1,2,3,4,5]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;文件循环和散列循环&#34;&gt;文件循环和散列循环&lt;/h2&gt;
&lt;p&gt;散列loops相比标准的loops，变量支持的数据结构更丰富，例如标准的最外层数据必须是python的list数据类型，而散列loops直接支持yaml格式的数据变量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: False
  vars:
    user:
      shan:
        name: shan
        shell: bash
      ceshi:
        name: ceshi
        shell: ssh
  tasks:
    - name: debug loops
      debug: msg=&amp;quot;{{item.key}}:{{item.value}}&amp;quot;
      with_dict: &amp;quot;{{user}}&amp;quot;
# 而python实现的方法
# user={&#39;shan&#39;:{&#39;name&#39;:&#39;shan&#39;,&#39;shell&#39;:bash&#39;},&#39;ceshi&#39;:{&#39;name&#39;:&#39;ceshi&#39;,&#39;shell&#39;:&#39;ssh&#39;}}
# for i,x in user.items():
#     print i,x[name],x[shell]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件匹配循环&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: False
  tasks:
    - name: debug loops
      debug: msg=&amp;quot;{{item}}&amp;quot;
      with_fileglob:
        - /etc/*.conf   # 输出/etc目录下的所有conf文件
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;条件判断循环以及组合使用&#34;&gt;条件判断循环以及组合使用&lt;/h2&gt;
&lt;p&gt;有时候执行一个tasks之后，我们需要检测这个tasks的结果是否达到了预想状态，如果没有达到我们预想的状态时，就需要退出整个playbook执行，这时候需要对这个task结果一直循环检测。&lt;br&gt;
&lt;strong&gt;例如&lt;/strong&gt;：5秒执行一次&lt;code&gt;cat /root/ansible&lt;/code&gt;，将结果赋值给变量hosts，然后判断&lt;code&gt;hosts.stdout.startswitch&lt;/code&gt;的内容是否以Master字符串开头，如果条件成立，此task运行完成，否则5秒后重试，5次后还不成立，此task运行失败。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: False
  tasks:
    - name: debug IF
      shell: cat /root/ansible
      register: hosts
      until: hosts.stdout.startswith(&amp;quot;Master&amp;quot;)
      retries: 5
      delay: 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;例如&lt;/strong&gt;：要么循环5次，要么5次循环还没跑完间隔10s， 但是result.stdout中找到 “all systems go”这几个字母，然后这个task就不跑了（默认的retries=3, delay=5）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: False
  tasks:
  - action: shell /usr/bin/foo
    register: result
    until: result.stdout.find(&amp;quot;all systems go&amp;quot;) != -1
    retries: 5
    delay: 10
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;For循环的使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: no
  tasks:
    - name: debug loops
      shell: &amp;quot;{{item}}&amp;quot;
      with_items:
        - hostname
        - uname
      register: ret
    - name: display ret
      debug: msg=&amp;quot;{% for i in ret.results %} {{ i.stdout }} {% endfor %}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;when语句逻辑判断&#34;&gt;when语句逻辑判断&lt;/h2&gt;
&lt;p&gt;ansible支持从外部拉取信息，比如可以从数据库里面读取信息然后定义给一个变量的形式，这就是ansible的lookups插件。ansible中所有的conditionals都是使用when来判断的，when值是一个条件表达式，如果天剑判断成立，这个task就执行某个操作，否则不执行或者跳过。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  tasks:
    # 判断IP是否为192.168.1.201
    - name: IP192.168.1.201 run this task
      debug: msg=&amp;quot;{{ansible_default_ipv4.address}}&amp;quot;
      when: ansible_default_ipv4.address==&amp;quot;192.168.1.201&amp;quot;
    # 判断主机名是否为inode203
    - name: all host run this task
      shell: hostname
      register: info
    - name: Hostname is inode203 run this task
      debug: msg=&amp;quot;{{ansible_fqdn}}&amp;quot;
      when: info[&#39;stdout&#39;]==&amp;quot;inode203&amp;quot;
    # 判断主机名中是否包含特定字符207
    - name: Hostname is startswith M run this task
      debug: msg=&amp;quot;{{ansible_fqdn}}&amp;quot;
      when: info[&#39;stdout&#39;].find(&amp;quot;207&amp;quot;) != -1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Centos系统，版本号为7，满足这两个条件会在 /home/创建123.test 文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- name: touch centos
  command: touch /home/123.test
  when:
    - ansible_distribution == &amp;quot;CentOS&amp;quot;
    - ansible_distribution_major_version == &amp;quot;7&amp;quot;
  tags:
  - touch_Cent
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;组条件判断：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 使用括号对条件进行分组
---
- hosts: localhost
  gather_facts: yes

  tasks:
    - name: &amp;quot;shut down CentOS 6 and Debian 7 systems&amp;quot;
      command: ls -a
      when: (ansible_facts[&#39;distribution&#39;] == &amp;quot;CentOS&amp;quot; and ansible_facts[&#39;distribution_major_version&#39;] == &amp;quot;6&amp;quot;) or
            (ansible_facts[&#39;distribution&#39;] == &amp;quot;Debian&amp;quot; and ansible_facts[&#39;distribution_major_version&#39;] == &amp;quot;7&amp;quot;)
# 所有需要为true的多条件判读（逻辑“and”） 也可以指定为列表
---
- hosts: localhost
  gather_facts: yes

  tasks:
    - name: &amp;quot;shut down CentOS 7 systems&amp;quot;
      command: ls -a
      when:
        - ansible_facts[&#39;distribution&#39;] == &amp;quot;CentOS&amp;quot;
        - ansible_facts[&#39;distribution_major_version&#39;] == &amp;quot;7&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;when判断是centos还是Ubuntu系统后在安装http&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;- hosts: all
  tasks:
    - name: &amp;quot;update apache version - yum&amp;quot;
      yum: name=httpd state=present
      when:
        - ansible_pkg_mgr == &#39;yum&#39;
      notify: restart httpd

    - name: &amp;quot;Update apache version - apt&amp;quot;
      apt: name=apache2 state=present update_cache=yes
      when:
        - ansible_pkg_mgr == &#39;apt&#39;
      notify: restart apache2
 handlers:
    - name: restart apache2
      service: name=apache2 state=restarted
    - name: restart httpd
      service: name=httpd state=restarted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;when&lt;/code&gt;语句中也可以使用过滤器。如，我们想跳过一个语句执行中的错误，但是后续的任务的执行需要由该任务是否成功执行决定：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;    tasks:
      - command: /bin/false
        register: result
        ignore_errors: True
      - command: /bin/something
        when: result|failed
      - command: /bin/something_else
        when: result|success
      - command: /bin/still/something_else
        when: result|skipped
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;更多内容参考httpswwwcnblogscomgzxbkkp7608055html&#34;&gt;更多内容参考&lt;a href=&#34;https://www.cnblogs.com/gzxbkk/p/7608055.html&#34;&gt;https://www.cnblogs.com/gzxbkk/p/7608055.html&lt;/a&gt;&lt;/h2&gt;
&lt;h1 id=&#34;ansible自动部署lnmphdwiki&#34;&gt;ansible(自动部署lnmp+hdwiki)&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;架构与流程&lt;br&gt;
在做一个比较复杂的事情的时候，需要理清思路，通过画图将思路理清楚，可以使用思维导图&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1593706156916.png&#34; alt=&#34;架构与流程&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;写代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /data
mkdir hdwiki
cd hdwiki
vim site.yml #编辑site.yml
mkdir roles
cd roles
mkdir nginx mysql hdwiki base -p

# 角色base：配置yum源
cd /data/roles/base
mkdir tasks files
cd /data/roles/base/files  # 将yum源的配置文件development.repo放在此目录下
cd /data/roles/base/tasks
vim main.yml

# 设置主机清单
cd /data/roles/hdwiki
vim hosts
    [hdwiki]
    192.168.1.201
    192.168.1.203
    [hdwiki:vars]
    nginx=nginx-1.4.4-1.x86_64.rpm
    php=php-5.3.10-1.x86_64.rpm
    user=hdwiki
    password=wiki123456
    database=wiki

# 角色nginx
cd /data/roles/nginx
mkdir tasks files
cd /data/roles/nginx/tasks
vim main.yml

# 角色mysql
cd /data/roles/mysql
mkdir tasks files
cd /data/roles/mysql/tasks
vim main.yml

# 角色hdwiki
cd /data/roles/hdwiki
mkdir tasks files
cd /data/roles/hdwiki/tasks
vim main.yml

# 执行
cd /data/roles/hdwiki
ansible-playbook -i hosts site.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;playbook文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# 总入口文件site.yml
---
- hosts: all
  roles:
    - base
    - nginx
    - mysql
    - hdwiki

# base的入口文件main.yml
---
- copy: scr=development.repo dest=/etc/yum.repos.d/development.repo
- shell: yum makecache

# nginx的入口
---
- yum: name={{item}} state=present
  with_items:
    - libtool-libs
    - libXpm-devel
    - fontconfig-devel
    - libpng
    - libjpeg-turbo
- shell: mkdir -p /usr/local/services
- name: copy nginx rpm
  copy: src={{nginx}} dest=opt/{{nginx}}
- shell: rpm-qa| grep nginx || rpm -ivh /opt/{{nginx}}  # 已经安装了的机器不需要再安装
- service: name=nginx state=restarted
- copy: src={{php}} dest=opt/{{php}}
- shell: rpm-qa| grep php || rpm -ivh /opt/{{php}}
- service: name=php-fpm state=restarted

# mysql的入口
---
- yum: name={{item}} state=present
  with_items:
    - mysql-server
    - mysql-python
- service: name=mysqld state=started
- mysql_db: name={{database}} state=present
- mysql_user: name={{user}} password={{password}} priv=*.*:ALL host=&amp;quot;%&amp;quot; state=present
 - mysql_user: name={{user}} password={{password}} priv=*.*:ALL host=&amp;quot;localhost&amp;quot; state=present

# hdwiki的入口
---
- unarchive: src=wiki.tar.gz dest=/data/htdocs/www
- shell: chown -R www:www /data/htdocs/www
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible-jinja2&#34;&gt;ansible-jinja2&lt;/h1&gt;
&lt;p&gt;jinja2是ansible的默认的模板语音，jinjia2是目前比较流行的一款模板语音，ansible默认支持jinja2语言内的filter，jinja2也提供了很多filter。&lt;br&gt;
&lt;strong&gt;字符串过滤器&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;safe：禁止转义，渲染时不会转义特殊字符&lt;/li&gt;
&lt;li&gt;capitallize：把首字母转大写，其他的字母转小写&lt;/li&gt;
&lt;li&gt;lower：把所有的字母转小写&lt;/li&gt;
&lt;li&gt;upper：把所有字母转大写&lt;/li&gt;
&lt;li&gt;title：把每个单词的首字母转大写&lt;/li&gt;
&lt;li&gt;trim：去掉首尾空格&lt;/li&gt;
&lt;li&gt;striptags：去掉所有的HTML标签&lt;/li&gt;
&lt;li&gt;replace：替换字符串的值&lt;/li&gt;
&lt;li&gt;round：对数字四舍五入&lt;/li&gt;
&lt;li&gt;int：转换成int类型&lt;/li&gt;
&lt;li&gt;default：定义变量的默认值&lt;/li&gt;
&lt;li&gt;reverse：字符串反转&lt;/li&gt;
&lt;li&gt;format：格式化输出，例如{{ &#39;%s is %d&#39; | format(&amp;quot;Number&amp;quot;, 2) }}，返回值&amp;quot;Number is 2&amp;quot;&lt;/li&gt;
&lt;li&gt;abs：绝对值&lt;br&gt;
&lt;strong&gt;列表过滤器&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;first：获取列表的第一个元素&lt;/li&gt;
&lt;li&gt;last：获取列表的最后一个&lt;/li&gt;
&lt;li&gt;sort：排序&lt;/li&gt;
&lt;li&gt;sum：列表求和&lt;/li&gt;
&lt;li&gt;length：求列表长度&lt;/li&gt;
&lt;li&gt;join：将多个值拼接成字符串，类似python的join()函数&lt;/li&gt;
&lt;li&gt;max：最大值&lt;/li&gt;
&lt;li&gt;min：最小值&lt;/li&gt;
&lt;li&gt;random：获取随机值&lt;br&gt;
&lt;code&gt;列表中所有元素都全大写。这里可以用upper,lower，但capitalize无效&lt;/code&gt;&lt;br&gt;
更多内容参考&lt;br&gt;
&lt;a href=&#34;https://jinja.palletsprojects.com/en/2.10.x/&#34;&gt;https://jinja.palletsprojects.com/en/2.10.x/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/mauricewei/p/10056379.html&#34;&gt;https://www.cnblogs.com/mauricewei/p/10056379.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: False
  vars:
    list: [1,2,3,4,5]
    one: &amp;quot;1&amp;quot;
    str: &amp;quot;string&amp;quot;
  tasks:
    # 执行命令，并将结果赋值给变量info
    - name: run commands
      shell: df -h
      register: info
    # 对变量info使用pprint进行格式化，debug时使用可以打印变量的详细信息
    - name: debug pprint filter
      debug: msg=&amp;quot;{{info.stdout|pprint}}&amp;quot; 
    - name: debug info
      debug: msg=&amp;quot;{{info}}&amp;quot; 
    # 判断info[changed]值，如果为true，则执行debug
    - name: debug conditionals filter
      debug: msg=&amp;quot;the run commands status is changed&amp;quot;
      when: info.changed
    # 对变量one的值进行int转变，对变量str的值进行首字母大写操作
    - name: debug int capitalize filter
      debug: msg=&amp;quot;The int value {{one|int}}. The lower value is {{str|capitalize}}&amp;quot;
    # 如果ansible变量定义了就引用其值，否则就定义其默认值为&amp;quot;ansible is not define&amp;quot;
    - name: debug default filter
      debug: msg=&amp;quot;The variable value is {{ansible|default(&#39;ansible is not define&#39;)}}&amp;quot;
    # 获取变量列表list中的最大值和最小值
    - name: debug list max and min filter
      debug: msg=&amp;quot;The list max value is {{list|max}} and min value is {{list|min}}&amp;quot;
      # 随意选取一个list内的值，然后随机生成一个1000以内的数据，以1开始且步长为10
    - name: debug random filter
      debug: msg=&amp;quot;The list random value is {{list|random}} and generate a random value is {{1000|random(1,10)}}&amp;quot;
    # 将list内的值连接在一起形成字符串
    - name: debug join filter
      debug: msg=&amp;quot;The join filter value is {{list| join(&amp;quot;+&amp;quot;)}}&amp;quot;
    # 将变量str中的字母t替换为T
    - name: debug replace  filter
      debug: msg=&amp;quot;The replace value is {{str|replace(&#39;t&#39;,&#39;T&#39;)}}&amp;quot;
    # string==&amp;gt;strawen，将string变量ri以及之后的所有字符替换为awen
    - name: debug regex_replace filter
      debug: msg=&amp;quot;The regex_replace value is {{str|regex_replace((&#39;ri(.*)$&#39;),&#39;awen&#39;)}}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;循环与判断&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- hosts: all
  gather_facts: no
  tasks:
    # 解析之后执行，执行结果写入被控端/tmp/f2
    - template: src=f2.j2  dest=/tmp/f2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;f2.j2文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;{% set list=[&#39;one&#39;,&#39;two&#39;,&#39;three&#39;] %}
{% set dict={&#39;1&#39;:&#39;one&#39;,&#39;2&#39;:&#39;two&#39;,&#39;3&#39;:&#39;three&#39;} %}
{% set dict1={&#39;1&#39;:{&#39;1.1&#39;:{&#39;1.2&#39;:&#39;one point two&#39;}} %}
# 循环
{% for i in list %}
    {{i}}
{% endfor %}
{% for key,value in dict.iteritems() %}
    {{key}}---&amp;gt;{{value}}
{% endfor %}
# 判断
{% for i in list %}
    {% if i==&#39;one&#39; %} # 值为one则打印
        ---&amp;gt;{{i}}   
    {% elif loop.index==2 %}  # 索引为2（two）则打印
         ---&amp;gt;&amp;gt;{{i}}
    {% else %}
        ---&amp;gt;&amp;gt;&amp;gt;{{i}}
    {% endif %}
{% endfor %}

# 多层嵌套字典取值
{{dict1[&#39;1&#39;][&#39;1.1&#39;][&#39;1.2&#39;]}}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;jinja2中可以使用set定义临时变量也可以直接使用ansible其他地方定义的变量关于jinja2变量的引用都是采用变量名的方式当然里面还可以根据变量名数据类型选择你想要的信息比如dictkeyvalue直接dict会返回一个python的字典数据如果只需要key对应的值则需要dictkey或dictgetkey&#34;&gt;jinja2中可以使用set定义临时变量也可以直接使用ansible其他地方定义的变量，关于jinja2变量的引用都是采用&lt;code&gt;{{变量名}}&lt;/code&gt;的方式，当然里面还可以根据变量名数据类型选择你想要的信息，比如&lt;code&gt;dict={&#39;key&#39;:&#39;value&#39;}&lt;/code&gt;，直接&lt;code&gt;{{dict}}&lt;/code&gt;会返回一个python的字典数据，如果只需要key对应的值，则需要&lt;code&gt;{{dict[&#39;key&#39;]}}&lt;/code&gt;或&lt;code&gt;{{dict.get(&#39;key&#39;)}}&lt;/code&gt;。&lt;/h2&gt;
&lt;h1 id=&#34;ansible-一键部署haproxylnmp&#34;&gt;ansible-一键部署haproxy+lnmp&lt;/h1&gt;
&lt;p&gt;首先需要知道我们需要什么样的架构，然后我们了解整个架构每个组件之间是如何衔接和交互的，当然我们还要清除架构中每一个组件的原理和流程。&lt;br&gt;
haproxy是一款提供高可用、负载均衡以及基于TCP和HTTP应用的代理软件，目前很多大公司也在使用其做web集群和cache集群的负载均衡以及代理&lt;br&gt;
整个架构的数据流向：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;haproxy代理以及负载的nginx+php&lt;/li&gt;
&lt;li&gt;nginx+php的web功能&lt;/li&gt;
&lt;li&gt;mysql功能&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;架构&#34;&gt;架构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1593913779066.png&#34; alt=&#34;架构&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;目录结构及角色&#34;&gt;目录结构及角色&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;haproxy_lnmp
├── group_vars
│   ├── all
│   ├── haproxy
│   └── mysql
├── hosts
├── roles
│   ├── base
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       ├── CentOS-Base.repo
│   │       └── epel.repo
│   ├── haproxy
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       └── haproxy.cfg.j2
│   ├── mysql
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       └── my.cnf.j2
│   ├── nginx
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       ├── index.php.j2
│   │       └── nginx.conf.j2
│   └── php
│       └── tasks
│           └── main.yml
└── site.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;变量&#34;&gt;变量&lt;/h2&gt;
&lt;h3 id=&#34;全局变量&#34;&gt;全局变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat group_vars/all
---
ansible_ssh_pass: P@ssw0rd
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mysql变量&#34;&gt;mysql变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat group_vars/mysql 
---
user: ansible
password: ansible
database: ansible
mysql_port: 3306
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;haprxoy变量&#34;&gt;haprxoy变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat group_vars/haproxy 
---
mode: http
listenport: 80
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;hosts列表&#34;&gt;hosts列表&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# cat hosts
[nginx]
192.168.1.201
192.168.1.203
[php]
192.168.1.201
192.168.1.203
[mysql]
192.168.1.203
[haproxy]
192.168.1.207
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;入口文件siteyml&#34;&gt;入口文件site.yml&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- name: Modify the yum
  gather_facts: no
  hosts: all
  remote_user: root
  roles:
    - base

- name: Install the nginx
  hosts: nginx
  remote_user: root
  roles:
    - nginx

- name: Install the mysql 
  gather_facts: no
  hosts: mysql
  remote_user: root
  roles:
    - mysql

- name: Install the php
  gather_facts: no
  hosts: php
  remote_user: root
  roles:
    - php

- name: Install the haproxy
  gather_facts: no
  hosts: haproxy
  remote_user: root
  roles:
    - haproxy
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;角色&#34;&gt;角色&lt;/h2&gt;
&lt;h3 id=&#34;base&#34;&gt;base&lt;/h3&gt;
&lt;h4 id=&#34;入口文件&#34;&gt;入口文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat roles/base/tasks/main.yml 
---
- name: Copy the yum repo to the remote hosts
  template: src={{item}}  dest=/etc/yum.repos.d/{{item}}
  with_items:
      - CentOS-Base.repo
      - epel.repo
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;yum源文件&#34;&gt;yum源文件&lt;/h4&gt;
&lt;p&gt;yum源文件，可以使用阿里、163或清华大学等源&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ll roles/base/templates/
total 8
-rw-r--r-- 1 root root 1663 Jul 21 17:50 CentOS-Base.repo
-rw-r--r-- 1 root root  970 Jul 21 17:50 epel.repo

# more roles/base/templates/CentOS-Base.repo
[base]
name=CentOS-$releasever - Base - mirrors.aliyun.com
baseurl=http://mirrors.aliyun.com/centos/$releasever/os/$basearch/
enabled=1
gpgcheck=0
[updates]
name=CentOS-$releasever - Updates - mirrors.aliyun.com
baseurl=http://mirrors.aliyun.com/centos/$releasever/updates/$basearch/
enabled=1
gpgcheck=0
[extras]
name=CentOS-$releasever - Extras - mirrors.aliyun.com
baseurl=http://mirrors.aliyun.com/centos/$releasever/extras/$basearch/
enabled=1
gpgcheck=0
[centosplus]
name=CentOS-$releasever - Plus - mirrors.aliyun.com
baseurl=http://mirrors.aliyun.com/centos/$releasever/centosplus/$basearch/
enabled=1
gpgcheck=0
[contrib]
name=CentOS-$releasever - Contrib - mirrors.aliyun.com
baseurl=http://mirrors.aliyun.com/centos/$releasever/contrib/$basearch/
enabled=1
gpgcheck=0

# epel.repo
[epel]
name=Extra Packages for Enterprise Linux 7 - $basearch
metalink=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;amp;arch=$basearch
enabled=1
gpgcheck=0
[epel-debuginfo]
name=Extra Packages for Enterprise Linux 7 - $basearch - Debug
metalink=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;amp;arch=$basearch
enabled=1
gpgcheck=0
[epel-source]
name=Extra Packages for Enterprise Linux 7 - $basearch - Source
metalink=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;amp;arch=$basearch
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nginx&#34;&gt;nginx&lt;/h3&gt;
&lt;h4 id=&#34;入口文件-2&#34;&gt;入口文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat roles/nginx/tasks/main.yml 
---
- name: Install Nginx Package
  yum: name=nginx state=present

- name: Copy Nginx.conf
  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf owner=root group=root mode=0644 validate=&#39;nginx -t -c %s&#39;  

- name: restart nginx
  service: name=nginx state=restarted enabled=yes

- name: Copy php file to nginx web root
  template: src=index.php.j2 dest=/usr/share/nginx/html/index.php
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;配置文件&#34;&gt;配置文件&lt;/h4&gt;
&lt;p&gt;nginx配置文件是同版本的配置文件&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ll  roles/nginx/templates/
total 8
-rw-r--r-- 1 root root   34 Jul 21 19:21 index.php.j2
-rw-r--r-- 1 root root 2491 Jul 21 17:50 nginx.conf.j2

# cat roles/nginx/templates/index.php.j2 
# 网页文件，获取nginx主机的IP
{{ansible_default_ipv4.address}}

# cat roles/nginx/templates/nginx.conf.j2
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log;
pid /run/nginx.pid;
include /usr/share/nginx/modules/*.conf;
events {
    worker_connections 1024;
}
http {
    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;
                      &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;
                      &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;
    access_log  /var/log/nginx/access.log  main;
    sendfile            on;
    tcp_nopush          on;
    tcp_nodelay         on;
    keepalive_timeout   65;
    types_hash_max_size 2048;
    include             /etc/nginx/mime.types;
    default_type        application/octet-stream;
    include /etc/nginx/conf.d/*.conf;
    server {
        listen       80 default_server;
        listen       [::]:80 default_server;
        server_name  _;
        root         /usr/share/nginx/html;
        include /etc/nginx/default.d/*.conf;
        location / {
        }
        error_page 404 /404.html;
            location = /40x.html {
        }
        error_page 500 502 503 504 /50x.html;
            location = /50x.html {
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;php&#34;&gt;php&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat roles/php/tasks/main.yml 
---
- name: Install php
  yum: name={{item}} state=installed
  with_items:
    - php-fpm
    - php-mysql

- name: start php service 
  service: name=php-fpm state=started enabled=yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mysql&#34;&gt;mysql&lt;/h3&gt;
&lt;h4 id=&#34;入口文件-3&#34;&gt;入口文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat roles/mysql/tasks/main.yml 
---
- name: Install mysql
  yum: name={{item}} state=installed
  with_items:
    - mariadb-server
    - MySQL-python

- name: Configure the mysql cnf file with hosts
  template: src=my.cnf.j2 dest=/etc/my.cnf owner=root group=root mode=0644

- name: Start mariadb service 
  service: name=mariadb state=started enabled=yes

- name: Create database
  mysql_db: name={{database}} state=present
  
- name: Create user
  mysql_user: name={{user}} password={{password}} priv={{database}}.*:ALL host=&#39;%&#39; state=present
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;配置文件-2&#34;&gt;配置文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# cat roles/mysql/templates/my.cnf.j2 
[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
symbolic-links=0
port={{ mysql_port }}
[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mariadb/mysqld.pid
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;haproxy&#34;&gt;haproxy&lt;/h3&gt;
&lt;h4 id=&#34;入口文件-4&#34;&gt;入口文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat roles/haproxy/tasks/main.yml 
- name: Install haproxy
  yum: name=haproxy state=present
 
- name: Configure the haproxy cnf file with hosts
  template: src=haproxy.cfg.j2 dest=/etc/haproxy/haproxy.cfg

- name: restart haproxy
  service: name=haproxy state=restarted enabled=yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;配置文件-3&#34;&gt;配置文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;# cat roles/haproxy/templates/haproxy.cfg.j2 
global
    log         127.0.0.1 local2
    chroot      /var/lib/haproxy
    pidfile     /var/run/haproxy.pid
    maxconn     4000
    user        haproxy
    group       haproxy
    daemon
    stats socket /var/lib/haproxy/stats
defaults
    mode                    {{mode}} 
    log                     global
    option                  httplog
    option                  dontlognull
    option http-server-close
    option forwardfor       except 127.0.0.0/8
    option                  redispatch
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 3000
frontend  main *:{{listenport}}
    acl url_static       path_beg       -i /static /images /javascript /stylesheets
    acl url_static       path_end       -i .jpg .gif .png .css .js
    use_backend static          if url_static
    default_backend             app
backend static
    balance     roundrobin
    server      static 127.0.0.1:8080 check
backend app
    balance     roundrobin
    {% for host in groups[&#39;nginx&#39;] %}
    server {{hostvars[host][&#39;inventory_hostname&#39;]}} {{host}}:80}
    # server {{hostvars[host][&#39;ansible_hostname&#39;]}} {{hostvars[host][&#39;inventory_hostname&#39;]}}:80 check inter 3000 rise 3 fall 2
    {% endfor %}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;语法检查&#34;&gt;语法检查&lt;/h2&gt;
&lt;p&gt;只检查site.yml入口文件，不能检查各个角色下的main.yml&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible-playbook site.yml --syntax-check
    playbook: site.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;执行&#34;&gt;执行&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ansible-playbook -i hosts site.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;测试&#34;&gt;测试&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl 192.168.1.201
curl 192.168.1.203
curl 192.168.1.207
curl 192.168.1.207
curl 192.168.1.207
curl 192.168.1.207
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;排错&#34;&gt;排错&lt;/h2&gt;
&lt;h2 id=&#34;在入口文件siteyml中的nginx角色没有使用gather_facts-no选项是因为indexphp中要获取主机的信息得到ip地址&#34;&gt;在入口文件site.yml中的nginx角色没有使用gather_facts: no选项，是因为index.php中要获取主机的信息得到IP地址。&lt;/h2&gt;
&lt;h1 id=&#34;ansible优化执行速度&#34;&gt;ansible优化执行速度&lt;/h1&gt;
&lt;h2 id=&#34;开启ssh长连接&#34;&gt;开启ssh长连接&lt;/h2&gt;
&lt;p&gt;ansible模式是使用ssh和被管理机器进行通信的，所以ansible对ssh的依赖非常强。&lt;br&gt;
ansible在openssh5.6版本以后可以支持multiplexing，在&lt;code&gt;ansible.cfg&lt;/code&gt;文件中设置ssh长连接，设置参数如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/ansible/ansible.cfg
sh_args = -C -o ControlMaster=auto ControlPersist=5d  
# ControlPersist=5d ：设置整个长连接保持时间为5天，如果开启后通过ssh连接过的设备都会在当前ansible/cp目录下产生一个socket文件，也可以通过netstat命令查看，会发现有一个状态为ESTABLISHED的连接一直与被控端进行TCP连接
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;开启pipelining&#34;&gt;开启pipelining&lt;/h2&gt;
&lt;p&gt;pipelining也是openssh的一个特性，之前的流程是在本地产生一个py的文件，然后put到被控端上面再执行这个py脚本。如果开启pipelining，这个过程将会在ssh的会话中进行。&lt;br&gt;
如果需要开启pipelining，则需要在被控端/etc/sudoers文件编辑当前ansible ssh用户的配置为requirety。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/ansible/ansible.cfg
pipelining = True
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;开启accelerate&#34;&gt;开启accelerate&lt;/h2&gt;
&lt;p&gt;和前面的ssh的长连接有点类似，因为都依赖ansible控制端和被控端有一个长连接，但是accelerate是使用python在被控端运行一个守护进行，然后ansible会通过这个守护进行监听的端口进行通信，开启accelarate模式，则需要在ansible控制端和被控端都安装python-keyczar软件包&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/ansible/ansible.cfg
[accelerate]
accelerate_port=5099
accelerate_timeout=30
accelerate_connect_timeout=5.0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;设置facts缓存&#34;&gt;设置facts缓存&lt;/h2&gt;
&lt;p&gt;在playbook里面有一个&lt;code&gt;gather_facts:yes&lt;/code&gt;选项，用来收集远端机器的信息，比较浪费时间，执行一次之后，将结果保存一定时间可以节省后面执行playbook的时间，从而提高效率&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# vim /etc/ansible/ansible.cfg
gathering = smart
fact_caching_timeout = 86400
fact_caching = jsonfile
fact_cashing_connection = /dev/shm/ansible_fact_cache 
 # ansible支持将数据放到redis里面，读取速度会更快
gathering = smart
fact_caching_timeout = 86400
fact_caching = redis
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible目录标准化&#34;&gt;ansible目录标准化&lt;/h1&gt;
&lt;p&gt;参考&lt;a href=&#34;https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html&#34;&gt;https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.html&lt;/a&gt;&lt;br&gt;
官网最佳实践中推荐使用的ansible工作目录的结构，统一工作目录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;Project
├── hosts # 主机清单
├── site.yml # playbook统一入口文件
├── webservers.yml # 特殊任务playbook文件【一般不用】
├── java  # java环境的inventory文件
├── web # web环境的inventory文件
├── library # 自定义模块存放的目录
├── filter_plugins # 自定义filter插件存放的目录
├── group_vars  # 自定义变量存放文件夹
│   ├── all  # 全局变量
│   ├── role1 # role1使用的变量
│   └── role2
├── host_vars  # 自定义变量存放文件夹，功能同group_vars【一般不用】
│   ├── all  # 全局变量
│   ├── host1 # role1使用的变量
├── roles #角色存放的目录
│   ├── role1  # 角色1目录
│   │   ├── tasks # 存放playbook的目录，其中main.yml是主入口文件
│   │   │   └── main.yml # 在main.yml中导入其他yml文件，要采用import_tasks关键字
│   │    |   └── install.yml
│   │   ├── handles # 存放tasks中的notify指定的内容
│   │   │   └── main.yml
│   │   ├── files # unarchive、copy等模块会来这找文件，不必写绝对路径，只需写文件名
│   │    |    ├── mysql.tar.gz
│   │    |    └── nginx.tar.gz
│   │   └── templates # template模块需要用的文件存放目录，存放的是软件的配置文件
│   │         ├── index.php.j2 # 使用jinja2格式作为文件模板，进行文档内变量替换的模块
│   │         └── nginx.conf.j2

# 举例：
haproxy_lnmp
├── group_vars
│   ├── all
│   ├── haproxy
│   └── mysql
├── hosts
├── roles
│   ├── base
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       ├── CentOS-Base.repo
│   │       └── epel.repo
│   ├── haproxy
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       └── haproxy.cfg.j2
│   ├── mysql
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       └── my.cnf.j2
│   ├── nginx
│   │   ├── tasks
│   │   │   └── main.yml
│   │   └── templates
│   │       ├── index.php.j2
│   │       └── nginx.conf.j2
│   └── php
│       └── tasks
│           └── main.yml
└── site.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;ansible-项目实战-批量部署&#34;&gt;ansible-项目实战-批量部署&lt;/h1&gt;
&lt;h2 id=&#34;需求和目的&#34;&gt;需求和目的&lt;/h2&gt;
&lt;p&gt;通过ansible制作一个初始化脚本，采用标准化半自动化流程，可移植、可复用、步骤明确、操作简便、低故障、责任明确。&lt;/p&gt;
&lt;h2 id=&#34;初始化操作&#34;&gt;初始化操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置yum源&lt;/li&gt;
&lt;li&gt;安装常用软件和机器所需软件：wget、vim、unzip、net-tools、gcc、ntpdate等&lt;/li&gt;
&lt;li&gt;配置防火墙&lt;/li&gt;
&lt;li&gt;配置SeLinux（关闭）&lt;/li&gt;
&lt;li&gt;生成秘钥，发送公钥&lt;/li&gt;
&lt;li&gt;修改ssh配置文件，修改ssh连接的默认端口&lt;/li&gt;
&lt;li&gt;配置DNS、hostname、IP等&lt;/li&gt;
&lt;li&gt;配置时间同步服务器，添加到crontab&lt;/li&gt;
&lt;li&gt;调优，优化内核参数：提高打开文件数量、配置nginx最大连接数等等&lt;/li&gt;
&lt;li&gt;IO测试，磁盘性能&lt;/li&gt;
&lt;li&gt;......&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;创建所有的角色&#34;&gt;创建所有的角色&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;base，替换yum源&lt;/li&gt;
&lt;li&gt;public，秘钥&lt;/li&gt;
&lt;li&gt;yum，安装依赖&lt;/li&gt;
&lt;li&gt;crontab，配置时间服务器等&lt;/li&gt;
&lt;li&gt;iptables，关闭selinux、NetworkManager和iptables配置&lt;/li&gt;
&lt;li&gt;init，调优初始化&lt;/li&gt;
&lt;li&gt;install，安装软件&lt;/li&gt;
&lt;li&gt;ssh_config，修改ssh的配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p setup_init/roles/{base,public,yum,crontab,iptables,init,install,ssh_config}/{tasks,templates,files}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;开发&#34;&gt;开发&lt;/h2&gt;
&lt;h3 id=&#34;目录结构&#34;&gt;目录结构&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/root/
└── setup_init
    └── roles
        ├── base
        │   ├── files
        │   │   ├── CentOS-Base.repo
        │   │   └── epel.repo
        │   ├── tasks
        │   │   └── main.yml
        │   └── templates
        ├── crontab
        │   ├── files
        │   ├── tasks
        │   │   └── main.yml
        │   └── templates
        ├── init
        │   ├── files
        │   ├── tasks
        │   │   └── main.yml
        │   └── templates
        ├── install
        │   ├── files
        │   ├── tasks
        │   │   └── main.yml
        │   └── templates
        ├── iptables
        │   ├── files
        │   ├── tasks
        │   │   └── main.yml
        │   └── templates
        ├── public
        │   ├── files
        │   │   └── id_rsa.pub
        │   ├── tasks
        │   │   └── main.yml
        │   └── templates
        ├── ssh_config
        │   ├── files
        │   ├── tasks
        │   │   └── main.yml
        │   └── templates
        └── yum
            ├── files
            ├── tasks
            │   └── main.yml
            └── templates
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;入口文件-5&#34;&gt;入口文件&lt;/h3&gt;
&lt;h4 id=&#34;basetasksmainyml&#34;&gt;base/tasks/main.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- copy: src=CentOS-Base.repo dest=/etc/yum.repos.d/CentOS-Base.repo
- copy: src=epel.repo dest=/etc/yum.repos.d/epel.repo
- shell: yum makecache
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;publictasksmainyml&#34;&gt;public/tasks/main.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- shell: mkdir -p ~/.ssh
- copy: src=id_rsa.pub dest=&#39;~/.ssh/id_rsa.pub_tmp&#39; force=yes
- shell: cat &#39;~/.ssh/id_rsa.pub_tmp&#39; &amp;gt;&amp;gt;&#39;~/.ssh/zuthorized_keys&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;yumtasksmainyml&#34;&gt;yum/tasks/main.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- yum: name={{item}} state=present
  with_items:
    - vim
    - unzip
    - wget
    - gcc
    - net-tools
    - tree
    - ntpdate
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;crontabtasksmainyml&#34;&gt;crontab/tasks/main.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- cron: minute */2 hour=* day=* month=* name=uptime job=&#39;ntpdate time.windows.com &amp;gt;/dev/null&#39; state=present
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;iptablestasksmainyml&#34;&gt;iptables/tasks/main.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
- serivce: name=NetworkManager state=stopped enabled=no
- shell: setenforce 0
# 防火墙根据要求进行配置
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;inittasksmainyml&#34;&gt;init/tasks/main.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
# 根据实际情况进行优化
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;installtasksmainyml&#34;&gt;install/tasks/main.yml&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
# 根据实际情况进行安装
&lt;/code&gt;&lt;/pre&gt;
">Ansible学习与实践</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/mysql-zhu-cong-tong-bu/"" data-c="
          &lt;h1 id=&#34;环境及要求&#34;&gt;环境及要求&lt;/h1&gt;
&lt;p&gt;主：192.168.1.251&lt;br&gt;
从（主主复制中的主）：192.168.1.253&lt;/p&gt;
&lt;h1 id=&#34;主从复制&#34;&gt;主从复制&lt;/h1&gt;
&lt;h2 id=&#34;主服务器&#34;&gt;主服务器&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/my.cnf
	[mysqld]
	skip_name_resolve=0 #禁止域名解析
	server-id=251 #设置主服务的ID (id可以自己随便设置但是要保证和slave的id不一样)
	log-bin=master-bin #log-bin日志文件名
	sync_binlog=1 #【可选】开启binlog日志同步功能
	binlog-lgnore-db=mysql #【可选】设置不要复制的数据库
	binlog-do-db=需要复制的主数据库名字 #【可选】设置需要复制的数据
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;重启mysql,后生成日志文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl restart mariadb
cat /data/mysql/master-bin.000001 #把里面记录的日志文件名记录下来等一下从库要用到
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;授权后查看主服务器状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -p
    grant replication slave,replication client on *.* to &amp;quot;mariadbsync&amp;quot;@&amp;quot;192.168.1.253&amp;quot; identified by &amp;quot;123456&amp;quot;; 
    flush privileges;
    show master status; #记录下245（pos）等下配置从库要用
        +--------------------+----------+--------------+---------------+
        | File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
        +--------------------+----------+--------------+---------------+
        | master-bin.000001 | 245 | | |
        +--------------------+----------+--------------+---------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;从服务器&#34;&gt;从服务器&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/my.cnf
	[mysqld]
	skip_name_resolve=0 #禁止域名解析
	server-id=253	
	relay-log=slave-bin	#relay-log日志文件名
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;重启mysq后配置从库&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl restart mariadb
mysql -uroot -p
    change master to 
    MASTER_HOST=&#39;192.168.1.251&#39;,  #主库IP
    MASTER_USER=&#39;mariadbsync&#39;,   #账号
    MASTER_PASSWORD=&#39;123456&#39;, #密码  
    MASTER_LOG_FILE=&#39;master-bin.000001&#39;, #主库日志文件名  
    MASTER_LOG_POS=245; #主库的pos为245
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;开启从库与状态查看&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -p
    start slave; #启动
    stop slave; #关闭
    show slave status\G #查看状态
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;主主复制&#34;&gt;主主复制&lt;/h1&gt;
&lt;h2 id=&#34;主1&#34;&gt;主1&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/my.cnf
	[mysqld]
	skip_name_resolve=0
	server-id=251
	log-bin=master-bin-251
	relay-log=slave-bin-251
	auto_increment_offset=1 #【可选】自增值
    auto_increment_increment=2 #【可选】漂移值,也就是步长
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;授权后查看主服务器状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -p
    grant replication slave,replication client on *.* to &amp;quot;mariadbsync&amp;quot;@&amp;quot;192.168.1.253&amp;quot; identified by &amp;quot;123456&amp;quot;; 
    flush privileges;
    show master status; #记录下245（pos）等下配置从库要用
        +--------------------+----------+--------------+---------------+
        | File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
        +--------------------+----------+--------------+---------------+
        | master-bin-251.000001 | 245 | | |
        +--------------------+----------+--------------+---------------+
    # 以下命令需要主2配置玩之后才能执行
    change master to 
        master_host=&#39;192.168.1.253&#39;
        master_user=&#39;mariadbsync&#39;
        master_password=&#39;123456&#39;
        master_log_file=&#39;master-bin-253.000003&#39;
        master_log_pos=231; 
    start slave;
    SHOW SLAVE STATUS\G
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;主2&#34;&gt;主2&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/my.cnf
	[mysqld]
	skip_name_resolve=0
	server-id=253
	log-bin=master-bin-253
	relay-log=slave-bin-253
	auto_increment_offset=2 #【可选】自增值
    auto_increment_increment=2 #【可选】漂移值,也就是步长
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;授权后查看主服务器状态&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -p
    grant replication slave,replication client on *.* to &amp;quot;mariadbsync&amp;quot;@&amp;quot;192.168.1.251&amp;quot; identified by &amp;quot;123456&amp;quot;; 
    flush privileges;
    show master status; #记录下245（pos）等下配置从库要用
        +--------------------+----------+--------------+---------------+
        | File | Position | Binlog_Do_DB | Binlog_Ignore_DB |
        +--------------------+----------+--------------+---------------+
        | master-bin-253.000003 | 231 | | |
        +--------------------+----------+--------------+---------------+
    # 以下命令需要主2配置玩之后才能执行
    change master to 
        master_host=&#39;192.168.1.251&#39;
        master_user=&#39;mariadbsync&#39;
        master_password=&#39;123456&#39;
        master_log_file=&#39;master-bin-251.000001&#39;
        master_log_pos=245; 
    start slave;
    SHOW SLAVE STATUS\G
&lt;/code&gt;&lt;/pre&gt;
">mariadb的主从复制、主主复制配置</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/07-jiao-huan-20200601/"" data-c="
          &lt;h1 id=&#34;交换机&#34;&gt;交换机&lt;/h1&gt;
&lt;h2 id=&#34;工作原理&#34;&gt;工作原理&lt;/h2&gt;
&lt;p&gt;交换机根据数据帧的源MAC来学习，构建CAM表项（MAC地址和端口的映射关系），根据目的MAC地址来进行转发（根据CAM表项来进行转发）&lt;/p&gt;
&lt;h2 id=&#34;五种基本操作&#34;&gt;五种基本操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;学习MAC地址，根据源MAC构建CAM表项&lt;/li&gt;
&lt;li&gt;删除MAC，默认300秒（aging-time），300秒后如果没有收到更新，就会删除&lt;/li&gt;
&lt;li&gt;泛洪，如果MAC地址不在CAM表项中则会泛洪。广播只是泛洪 行为中的的其中 一种&lt;br&gt;
&lt;code&gt;BUM报文。B，Broadcast，ff-ff-ff-ff-ff-ff；U，未知单播帧， 第一组第八位为0是单播；M，组播 ，第一组第八位为1是组播，01－00－5e、01-80-c2、 33-33-33&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转发，根据目的MAC，查找CAM表项进行转发&lt;/li&gt;
&lt;li&gt;过滤，端口安全，交换机不会将数据帧从接收端口发送出去，如果数据帧中的CRC校验失败，也会丢弃&lt;br&gt;
##端口类型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;交换机三种端口模式access-hybrid和trunk的理解&#34;&gt;交换机三种端口模式Access、Hybrid和Trunk的理解&lt;/h3&gt;
&lt;p&gt;端口有三种模式：access，hybrid，trunk。&lt;/p&gt;
&lt;h4 id=&#34;access类型端口&#34;&gt;Access类型端口&lt;/h4&gt;
&lt;p&gt;只能属于1个VLAN，且该端口不打tag，一般连接主机，只用于接入链路&lt;br&gt;
只允许与该端口的PVID相同的VLAN通过，收到untagged的数据帧，强制打上本端口PVID的标签；&lt;/p&gt;
&lt;h4 id=&#34;trunk类型端口&#34;&gt;Trunk类型端口&lt;/h4&gt;
&lt;p&gt;可以允许多个VLAN通过，且该端口都是打tag的，这个端口是交换机之间或者交换机和上层设备之间的通信端口，用于干道链路。这种端口的存在就是为了多个vlan的跨越交换机进行传递。&lt;br&gt;
一个trunk端口可以拥有一个主vlan和多个副vlan。在交换机之间传递tagged frame。允许多个VLAN通过，可以与PVID不同；收到不带tagged frame的数据帧时，打上主PVID并转发；收到带tagged frame数据帧时，检查VLAN ID，如果允许并且VLAN ID与PVID相同，去掉tagged直接转发，如果允许并且VLAN ID与PVID不同，直接转发原数据帧。&lt;/p&gt;
&lt;h4 id=&#34;hybrid类型端口&#34;&gt;Hybrid类型端口&lt;/h4&gt;
&lt;p&gt;可以允许多个VLAN通过，至于该端口在vlan中是否打tag由用户根据具体情况而定，可以用于交换机之间的连接也可以用于交换机和用户计算机之间的连接。&lt;br&gt;
此端口的转发模式与trunk端口一样，允许多个VLAN通过，收到不带tagged frme，打上pvid标签并转发。收到带tagged frame时，如允许并且VLAN ID与PVID相同，除去标签转发，如允许并且VLAN ID与PVID不同，直接转发。hybrid允许多个VLAN报文不打标签发送，但是trunk端口只允许与自己PVID相同的VLAN报文发送时不打标签；当Hybrid端口没有tagged VLAN，untagged VLAN只有一个时，功能与access端口一样；当Hybrid端口没有untagged VLAN时，功能与trunk端口一样。&lt;br&gt;
&lt;code&gt;trunk和hybrid的区别主要是，hybrid端口可以允许多个vlan的报文不打标签，而 trunk端口只允许缺省vlan的报文不打标签，同一个交换机上不能hybrid和trunk并存&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Access类型的接口仅属于一个VLAN，只能接收、转发相应VLAN的帧；Trunk类型接口则默认属于所有VLAN，任何 Tagged 帧都能经过Trunk接收和转发；Hybrid类型接口则介于二者之间，可自主定义端口上能接收和转发哪些VLANTag 的帧，并可决定VLANTag 是否继续携带或者剥离。Access和 Trunk 类型接口是Hybrid 类型接口的两个特例，一个仅支持一个VLAN的传递，一个默认支持所有VLAN的传递，而Access类型和Trunk类型的接口能做到的，Hybrid 接口都能做到。&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;mux-vlan&#34;&gt;Mux Vlan&lt;/h2&gt;
&lt;p&gt;Mux Vlan提供了一种在VLAN的端口间进行二层流量隔离的机制。&lt;br&gt;
MUX VLAN 分为&lt;strong&gt;主VLAN&lt;/strong&gt;和&lt;strong&gt;从VLAN&lt;/strong&gt;，从VLAN又分为&lt;strong&gt;互通型从VLAN&lt;/strong&gt; 和&lt;strong&gt;隔离型从VLAN&lt;/strong&gt;。主VLAN与从VLAN之间可以相互通信；互通型从VLAN内的端口之间可以互相通信，隔离型从VLAN内的端口之间不能互相通信，不同从VLAN之间不能互相通信。&lt;/p&gt;
&lt;h2 id=&#34;arp代理&#34;&gt;ARP代理&lt;/h2&gt;
&lt;p&gt;ARP用于将一个IP地址映射到正确的MAC地址。一个物理网络的子网（Subnet）中的源主机向另一个物理网络的子网中的目的主机发ARP request，和源主机直连的网关用自己接口的MAC地址代替目的主机回ARP reply，这个过程称为ARP 代理。&lt;br&gt;
&lt;strong&gt;Proxy ARP有以下特点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有处理在ARP子网网关进行，所连网络中的主机不必做任何改动；&lt;/li&gt;
&lt;li&gt;在主机端看不到子网，只是一个标准IP网络；&lt;/li&gt;
&lt;li&gt;Proxy ARP只影响主机的ARP高速缓存，对网关的ARP高速缓存和路由表没有影响；&lt;/li&gt;
&lt;li&gt;使用Proxy ARP后，主机应该减小ARP老化时间，以尽快使无效ARP项失效，减少发给路由器而路由器却不能转发的报文&lt;br&gt;
&lt;code&gt;交换机开启arp代理：arp-proxy enable&lt;/code&gt;&lt;br&gt;
路由式的ARP代理， 实现在没有配置网关的情况下，进行代理实现互通&lt;br&gt;
&lt;code&gt;Inter-arp proxy&lt;/code&gt;实现Super-vlan互通&lt;br&gt;
&lt;code&gt;Inner-arp proxy&lt;/code&gt;实现端口隔离的互通&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;super-vlanvlan聚合&#34;&gt;Super Vlan（Vlan聚合）&lt;/h2&gt;
&lt;p&gt;VLAN聚合，只在super-VLAN接口上配置IP地址，而不必为每个sub-VLAN分配IP地址。所有sub-VLAN 共用IP网段，解决了IP地址资源浪费的问题。&lt;/p&gt;
&lt;h2 id=&#34;端口隔离&#34;&gt;端口隔离&lt;/h2&gt;
&lt;p&gt;端口隔离是交换机端口之间的一种访问控制安全控制机制。&lt;br&gt;
实现不同端口接入的PC之间不能互访（PC属于相同的vlan），而所有的PC都能通过上行的交换机访问网络。&lt;br&gt;
可以配置vlan内的用户间的相互隔离或者互通，端口隔离则是物理层次上的隔离，是基于端口。&lt;/p&gt;
&lt;h2 id=&#34;vlan-mappingvlan映射&#34;&gt;vlan mapping(VLAN映射)&lt;/h2&gt;
&lt;p&gt;将用户报文中的私网VLAN Tag替换为公网的VLAN Tag，使其按照公网的网络规划进行传输。在报文被发送到对端用户私网时，再按照同样的规则将VLAN Tag恢复为原有的用户私网VLAN Tag，使报文正确到达目的地。&lt;br&gt;
在交换机接收到带有用户私网报文的VLAN Tag后，首先根据配置的映射规则对用户私网报文的VLAN Tag进行匹配，如果匹配成功，则按照规则将私网VLAN Tag进行替换。&lt;/p&gt;
&lt;h3 id=&#34;映射方式&#34;&gt;映射方式&lt;/h3&gt;
&lt;h4 id=&#34;1-to-1的映射方式&#34;&gt;1 to 1的映射方式&lt;/h4&gt;
&lt;p&gt;当部署VLAN Mapping功能设备上的主接口收到带有单层VLAN Tag的报文时，将报文中携带的单层VLAN Tag映射为公网的VLAN Tag。包括1:1和N:1两种方式，其中1:1的方式是将指定的一个用户侧VLAN Tag标签映射到一个网络侧VLAN Tag标签，N:1的方式是将指定范围的多个用户侧VLAN Tag标签映射到一个网络侧VLAN Tag标签。&lt;/p&gt;
&lt;h4 id=&#34;2-to-1的映射方式&#34;&gt;2 to 1的映射方式&lt;/h4&gt;
&lt;p&gt;当部署VLAN Mapping功能设备上的主接口收到带有双层VLAN Tag的报文时，将报文中携带的外层Tag映射为公网的Tag，内层Tag作为数据透传。&lt;/p&gt;
&lt;h4 id=&#34;2-to-2的映射方式&#34;&gt;2 to 2的映射方式&lt;/h4&gt;
&lt;p&gt;当部署VLAN Mapping功能设备上的主接口收到带有双层VLAN Tag的报文时，将报文中携带的双层VLAN Tag映射为公网的双层VLAN Tag。&lt;br&gt;
基于MQC实现VLAN Mapping指的是通过MQC可以对分类后的报文实现VLAN Mapping。&lt;br&gt;
用户可以根据多种匹配规则对报文进行流分类，然后将流分类与VLAN Mapping的动作相关联，对匹配规则的报文重标记报文的VLAN ID值。基于MQC的VLAN Mapping能够针对业务类型提供差别服务。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置vlan mapping
int g0/0/2
qinq vlan-translation enable # 使能接口的vlan转换功能
port link-type trunk
port trunk allow-pass vlan 100
port vlan-mapping vlan 10 to 20 map-vlan 100 # 将vlan10到20全部转换成vlan100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;qinq&#34;&gt;QinQ&lt;/h2&gt;
&lt;p&gt;基于802.1 Q封装的隧道协议，报文封装双层VLAN Tag&lt;/p&gt;
&lt;h3 id=&#34;有点&#34;&gt;有点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;解决日益紧缺的公网VLAN ID资源问题&lt;/li&gt;
&lt;li&gt;用户可以规划自己的私网VLAN ID&lt;/li&gt;
&lt;li&gt;提供一种较为简单的二层VPN解决方案&lt;/li&gt;
&lt;li&gt;使用户网络具有较高的独立性&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分类按照实现方式&#34;&gt;分类（按照实现方式）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;基于端口的QinQ：基于端口的基本QinQ&lt;/li&gt;
&lt;li&gt;灵活QinQ：VLAN Stacking&lt;/li&gt;
&lt;li&gt;基于流的灵活QinQ：基于ACL的灵活QinQ&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tpid&#34;&gt;TPID&lt;/h3&gt;
&lt;p&gt;标签协议标识TPID是vlan tag中的一个字段，表示vlan tag的协议类型，IEEE 802.1Q协议规定该字段的取值为0x8100&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1591878623497.png&#34; alt=&#34;TPID&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
不同运营商的系统可能将QinQ帧外层VLAN标记的TPID设置为不同值。为实现与这些系统的兼容性，可以修改TPID值，使QinQ帧发送到公网时，承载与特定运营商相同的TPID值，从而实现与该运营商设备之间的互操作性。以太网帧的TPID与不带VLAN标记的帧的协议类型字段位置相同。为避免在网络中转发和处理数据包时出现问题，&lt;strong&gt;不可将TPID值设置为下表中的任意值&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1591878772202.png&#34; alt=&#34;协议类型及对应值描述表&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 基于端口的QinQ
interface GigabitEthernet0/0/2
port link-type dot1q-tunnel # 配置为QinQ模式
port default vlan 100 # 指定外层tag
# 灵活的QinQ
interface GigabitEthernet0/0/2
qinq vlan-translation enable # 开启vlan转换功能
port hybrid untagged vlan 100 200 # 收到vlan100和200的数据之后去掉vlan tag100和200
port vlan-stacking vlan 10 to 20 stack-vlan 100 # 收到vlan10-20的数据之后，加上vlan tag 100
port vlan-stacking vlan 30 to 40 stack-vlan 200
# 修改TPID配置
interface GigabitEthernet0/0/1
port link-type trunk
port trunk allow-pass vlan 100
qinq protocol 9100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;链路聚合&#34;&gt;链路聚合&lt;/h2&gt;
&lt;p&gt;链路聚合是将—组物理接口捆绑在一起作为一个逻辑接口来增加带宽的一种方法，又称为多接口负载均衡组或链路聚合组，相关的协议标准请参考IEEE802.3ad。&lt;/p&gt;
&lt;h3 id=&#34;配置手工负载分担模式链路聚合&#34;&gt;配置手工负载分担模式链路聚合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当需要增加两台设备之间的带宽或可靠性，而两台设备中有一台不支持LACP协议时，可在Switch设备上创建手工负载分担模式的Eth-Trunk，并加入多个成员接口增加设备间的带宽及可靠性。&lt;/li&gt;
&lt;li&gt;Eth-Trunk的创建、成员接口的加入都需要手工配置完成，没有LACP协议报文的参与。&lt;/li&gt;
&lt;li&gt;手工负载分担模式允许在聚合组中手工加入多个成员接口，所有的接口均处于转发状态，分担负载的流量。&lt;/li&gt;
&lt;li&gt;手工负载分担没有协议的交互&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;在物理成员接口下接入eth-trunk&#34;&gt;在物理成员接口下接入eth-trunk&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;每个Eth-Trunk接口下最多可以包含8个成员接口。&lt;/li&gt;
&lt;li&gt;成员接口不能配置任何业务和静态MAC地址，即成员接口加入Eth-Trunk时，必须为缺省的hybrid类型接口。&lt;/li&gt;
&lt;li&gt;Eth-Trunk接口不能嵌套，即成员接口不能是Eth-Trunk。&lt;/li&gt;
&lt;li&gt;一个以太网接口只能加入到一个Eth-Trunk接口，如果需要加入其它Eth-Trunk接口，必须先退出原来的Eth-Trunk接口。&lt;/li&gt;
&lt;li&gt;一个Eth-Trunk接口中的成员接口必须是同一类型，例如：FE口和GE口不能加入同一个Eth-Trunk接口。&lt;/li&gt;
&lt;li&gt;可以将不同接口板上的以太网接口加入到同一个Eth-Trunk。&lt;/li&gt;
&lt;li&gt;如果本地设备使用了Eth-Trunk，与成员接口直连的对端接口也必须捆绑为Eth-Trunk接口，两端才能正常通信。&lt;/li&gt;
&lt;li&gt;当成员接口的速率不一致时，实际使用中速率小的接口可能会出现拥塞，导致丢包。&lt;/li&gt;
&lt;li&gt;当成员接口加入Eth-Trunk后，学习MAC地址时是按照Eth-Trunk来学习的，而不是按照成员接口来学习&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;修改eth-trunk负载分担方式&#34;&gt;修改eth-trunk负载分担方式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;dst-ip（目的IP地址）模式：从目的IP地址、出端口的TCP/UDP端口号中分别选择指定位的3bit数值进行异或运算，根据运算结果选择Eth-Trunk表中对应的出接口。&lt;/li&gt;
&lt;li&gt;dst-mac（目的MAC地址）模式：从目的MAC地址、VLAN ID、以太网类型及入端口信息中分别选择指定位的3bit数值进行异或运算，根据运算结果选择Eth-Trunk表中对应的出接口。&lt;/li&gt;
&lt;li&gt;src-ip（源IP地址）模式：从源IP地址、入端口的TCP/UDP 端口号中分别选择指定位的3bit数值进行异或运算，根据运算结果选择Eth-Trunk表中对应的出接口。&lt;/li&gt;
&lt;li&gt;src-mac（源MAC地址）模式：从将源MAC地址、VLAN ID、以太网类型及入端口信息中分别选择指定位的3bit数值进行异或运算，根据运算结果选择Eth-Trunk表中对应的出接口。&lt;/li&gt;
&lt;li&gt;src-dst-ip（源IP地址与目的IP地址的异或）模式：从目的IP地址、源IP地址两种负载分担模式的运算结果进行异或运算，根据运算结果选择Eth-Trunk表中对应的出接口。&lt;/li&gt;
&lt;li&gt;src-dst-mac（源MAC地址与目的MAC地址的异或）模式：从目的MAC地址、源MAC地址、VLAN ID、以太网类型及入端口信息中分别选择指定位的3bit数值进行异或运算，根据运算结果选择Eth-Trunk表中对应的出接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#配置手工负载分担模式链路聚合
# sw1/2
# 方法一：配置聚合后加入端口
int Eth-Trunk 10
trunkport g0/0/1 to 0/0/4
# 方法二：在接口下加入eth-trunk
int Eth-Trunk 10
q
int g0/0/1
# port-group group-member g0/0/1 to g0/0/4
eth-trunk 10
int g0/0/2
eth-trunk 10
int g0/0/3
eth-trunk 10
int g0/0/4
eth-trunk 10
# 设置活动连接数
interface Eth-Trunk10
port link-type trunk
port trunk allow-pass vlan 2 to 4094
least active-linknumber 2      # 如果活动链接数低于该值，聚合组直接down 
max bandwidth-affected-linknumber  # 设置最大活动链接数
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置静态lacp模式链路聚合&#34;&gt;配置静态LACP模式链路聚合&lt;/h3&gt;
&lt;p&gt;静态LACP模式也称为M∶N模式。这种方式同时可以实现链路负载分担和链路冗余备份的双重功能。在链路聚合组中M条链路处于活动状态，这些链路负责转发数据并进行负载分担，另外N条链路处于非活动状态作为备份链路，不转发数据。当M条链路中有链路出现故障时，系统会从N条备份链路中选择优先级最高的接替出现故障的链路，同时这条替换故障链路的备份链路状态变为活动状态开始转发数据。&lt;br&gt;
&lt;strong&gt;静态LACP模式与手工负载分担模式的主要区别&lt;/strong&gt;：静态LACP模式有备份链路，而手工负载分担模式所有成员接口均处于转发状态，分担负载流量&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置静态LACP模式链路聚合
int Eth-Trunk 10
port link-type trunk
port trunk allow-pass vlan 2 to 4094
mode lacp-static
trunkport g0/0/1 to 0/0/4
least active-linknumber 2   # 最小活动连接数
max active-linknumber 3   # 最大活动连接数
lacp preempt enable  # 开启抢占，即接口恢复正常后按照优先级进行抢占
lacp preempt delay 10  # 配置抢占延时，接口UP后10秒钟后，进行抢占 （防止链路震荡）
q
lacp priority 100         # 修改设备的LACP优先级，优先级小的成为主动端 
int g0/0/1
lacp priority 40000   # 修改接口的LACP 优先级，优先级小的会被选择
# mixed-rate link enable：命令用来使能允许端口支持速率不同的接口加入同一Eth-Trunk接口的功能。
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;stp&#34;&gt;STP&lt;/h2&gt;
&lt;p&gt;生成树的工作原理：&lt;strong&gt;生成树的最终目的是用来破环的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;工作流程&#34;&gt;工作流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先要选举出一个根桥RB（皇帝），在整个交换网络中选举的，用来发送BPDU报文（圣旨）&lt;/li&gt;
&lt;li&gt;选举出根端口（RP）（在每一个非根交换机上选举出一个）（太守），用来接收BPDU报文的（圣旨）&lt;/li&gt;
&lt;li&gt;选举出指定端口（DP）（在每条链路上都要选举出一个指定端口）（钦差），用来发放或转发BDPU报文&lt;/li&gt;
&lt;li&gt;非根端口，非指定端口，会成为预备端口（AP），会被阻塞&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;根桥rb的选举&#34;&gt;根桥RB的选举&lt;/h4&gt;
&lt;p&gt;比较BridgeID，有三部分级成：优先级+扩展系统ID+MAC，&lt;strong&gt;华为的扩展系统ID是0&lt;/strong&gt;&lt;br&gt;
比较优先级，优先级低成为根桥；如果优先级相同，比较MAC地址，MAC地址小的成为根桥。&lt;br&gt;
优先级为0，仅是最大可能会成为根桥，不一定是根桥。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;stp root primary   # 思科做法是把最小的优先级减去8192，华为直接置为0
stp root secondary  # 思科做法是把最小的优先级减去4096，华为直接置为4096
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;根端口rp的选举用来接收bpdu&#34;&gt;根端口RP的选举(用来接收BPDU)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;通俗选法：选离RB距离最近的那个&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较到达根桥最小路径开销值（RPC）&lt;/li&gt;
&lt;li&gt;比较转发该BPDU的BridgeID，越小越优&lt;/li&gt;
&lt;li&gt;比较转发该BPDU报文的PortID：端口优先级+端口编号，即优先级越小越优，如果优先级相同；比较端口编号&lt;/li&gt;
&lt;li&gt;比较接收该BPDU报文的PortID：端口优先级+端口编号，即优先级越小越优，如果优先级相同；比较端口编号&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;指定端口dp的选举用来发送bpdu&#34;&gt;指定端口DP的选举(用来发送BPDU)&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;和RP选举规则相同，通俗选法：RP对面的端口一定是DP&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比较到达根桥最小路径开销值（RPC）&lt;/li&gt;
&lt;li&gt;比较转发该BPDU的bridge ID，越小越优&lt;/li&gt;
&lt;li&gt;比较转发该BPDU报文的PortID：端口优先级+端口编号，优先级越小越优，如果优先级相同，比较端口编号&lt;/li&gt;
&lt;li&gt;比较接收该BPDU报文的Port ID:端口优先级+端口编号，优先级越小越优，如果优先级相同，比较端口编号&lt;br&gt;
&lt;code&gt;根桥的接口默认都是DP，但根桥的接口不一定全部都是DP，有可能是AP（思科）或BP（华为）&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;ap的选举阻塞端口&#34;&gt;AP的选举(阻塞端口)&lt;/h4&gt;
&lt;p&gt;非DP，非RP就是AP，端口会被阻塞掉&lt;/p&gt;
&lt;h4 id=&#34;stp的两种报文&#34;&gt;STP的两种报文&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;配置BPDU（STP的BPDU发送(组播)地址：01-80-C2-00-00-00）&lt;/li&gt;
&lt;li&gt;TCN报文（拓扑变更通知）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592031903629.png&#34; alt=&#34;STP帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592031911277.png&#34; alt=&#34;字段解释&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;调整设备的rp端口&#34;&gt;调整设备的RP端口&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;调整转发端口的开销值&lt;code&gt;stp instance 0 cost 30000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调整接收端口的优先级&lt;code&gt;stp priority 8192&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;可能的临时环路&#34;&gt;可能的临时环路&lt;/h3&gt;
&lt;p&gt;在端口角色以及状态的变化过程中，可能会出现临时环路问题。&lt;br&gt;
&lt;strong&gt;解决临时环路的方法&lt;/strong&gt;： 在一个端口从不转发状态进入之前，需要等待一个足够长的时间 ，以使需要进入不转发状态的端口有足够时间完后才能生成树计算，并进入不转发状态&lt;/p&gt;
&lt;h3 id=&#34;端口状态转换&#34;&gt;端口状态转换&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592035787942.png&#34; alt=&#34;端口状态转换&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592036138271.png&#34; alt=&#34;端口状态描述&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;华为将disable、blocking和listening三种状态合并为discarding状态&lt;/code&gt;&lt;br&gt;
1：端口被选为指定DP或根端口RP；&lt;br&gt;
2：端口被选为预备端口AP；&lt;br&gt;
3：经过Forward Delay间隔，默认为 15 秒。&lt;br&gt;
端口被禁用之后进入Disable状态。&lt;br&gt;
当一个端口从不转发状态进入状态之前需要等待两次 Forward Delay间隔 ，以解决前文所述可能的临时环路问题。&lt;/p&gt;
&lt;h3 id=&#34;拓扑结构改变导致mac地址表错误&#34;&gt;拓扑结构改变导致MAC地址表错误&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592036621842.png&#34; alt=&#34;拓扑结构改变导致MAC地址表错误&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
默认情况下，MAC地址表中的动态表项生存期为300秒（5分钟）&lt;br&gt;
稳定拓扑下，在SWC上到达LAND某PC的目的端口应当为E1；&lt;br&gt;
当SWB的E1接口断开之后，E2接口成为新的根端口，从SWC到达该PC的目的地址应当修改为E2，但是交换机不能检测到拓扑改变，导致MAC地址表错误，最长可导致5分钟的数据转发错误。&lt;br&gt;
&lt;strong&gt;解决问题的办法&lt;/strong&gt;：当拓扑结构改变之后，通过一定的机制，使拓扑改变的信息在整网内泛洪，并修改MAC地址表的生存期为一个较短的数值，等拓扑结构稳定之后，再恢复MAC地址表的生存期。&lt;strong&gt;STP规定这个较短的MAC地址表生存期使用交换机的Forward Delay参数，默认为15秒&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;端口改变所在的交换机(RP端口)给上级发TCN报文（TC=1，表示拓扑改变），直到当RB收到该报文之后，全网泛洪配置BPDU（TCA=1，表示拓扑改变响应），进行重新选举&lt;/code&gt;&lt;br&gt;
&lt;code&gt;TC=1的BPDU会发送多长时间？37秒=MaxAge(20s)+ForwardDelay(15s)+Hello(2s)，共计18个报文&lt;/code&gt;&lt;br&gt;
&lt;code&gt;所有交换机在收到TC=1的报文之后会将MagAge时间由300秒调整为15秒&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;泛洪拓扑改变信息&#34;&gt;泛洪拓扑改变信息&lt;/h4&gt;
&lt;p&gt;在向整网泛洪拓扑改变信息的过程中，共涉及三 种BPDU：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;拓扑改变通知BPDU&lt;/strong&gt;：用于非根交换机在根端口上向上行交换机通告拓扑改变信息，并且每隔Hello Time（2秒）发送一次，直到收到上行交换机的拓扑改变确认配置BPDU或者拓扑改变配置BPDU。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拓扑改变确认配置BPDU&lt;/strong&gt;：配置BPDU的一种，和普通配置BPDU不同的是此配置BPDU设置了一个Flag位。用于非根交换机在接收到拓扑改变通知BPDU的指定接口上向下行交换机发送拓扑改变通知的确认信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拓扑改变配置BPDU&lt;/strong&gt;：此配置BPDU设置了另外 一个Flag位。用于从根交换机向整网泛洪拓扑改变信息，所有交换机都在自己所有的指定端口上泛洪此BPDU。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;stp的缺点&#34;&gt;STP的缺点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;收敛慢，至少需要30s&lt;/li&gt;
&lt;li&gt;发生了拓扑变更，至少需要30s才能收敛&lt;/li&gt;
&lt;li&gt;端口角色只有三种，端口状态却有五种&lt;/li&gt;
&lt;li&gt;STP需要一个max age时间（20s）才能感受到线路变化，端口状态变化需要30s，则恢复通信需要50s（非直连，直连只需要30s的端口状态变化时间）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;rstp&#34;&gt;RSTP&lt;/h2&gt;
&lt;h3 id=&#34;rstp对stp的改进&#34;&gt;RSTP对STP的改进&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;端口角色从三种变为五种&lt;br&gt;
STP：DP、RP 、AP&lt;br&gt;
RSTP：DP 、RP、AP（预备端口）、BP（指定端口的备份）、EP（边缘端口）&lt;br&gt;
&lt;code&gt;AP是RP的备份，BP是DP的备份&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;端口状态 五种变为三种&lt;br&gt;
Discarding、Learning、Forwarding&lt;/li&gt;
&lt;li&gt;BPDU格式的变化--flag位的变化&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592121929445.png&#34; alt=&#34;flag位的变化&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第0位&lt;/strong&gt;为TC标志位，和STP相同。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第1位为&lt;/strong&gt;Proposal标志位，该位置位表示该BPDU为快速收敛机制中的Proposal报文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第2位和第3位&lt;/strong&gt;为端口角色标志位，&lt;br&gt;
00表示端口角色为未知；&lt;br&gt;
01表示端口角色为Alternate或Backup端口（AP或BP）；&lt;br&gt;
10表示端口为根端口；&lt;br&gt;
11表示端口为指定端口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第4位&lt;/strong&gt;为Learning标志位，该位置位表示端口处于Learning状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第5位&lt;/strong&gt;为Forwarding标志位，该位置位表示端口处于Forwarding状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第6位&lt;/strong&gt;为Agreement标志位，该位置位表示该BPDU位快速收敛机制中的Agreement报文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第7位&lt;/strong&gt;为TCA标志位，和STP相同。&lt;br&gt;
&lt;code&gt;0和7是一组，1和6是一组，2和3是一组，4和5是一组&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;快速收敛&#34;&gt;快速收敛&lt;/h3&gt;
&lt;h4 id=&#34;proposalagreement机制&#34;&gt;Proposal/Agreement机制&lt;/h4&gt;
&lt;p&gt;当一个端口被选举成为指定端口DP之后，在STP中，该端口至少要等待一个Forward Delay（Learning）时间才会迁移到Forwarding状态。而在RSTP中，此端口会先进入Discarding状态，再通过Proposal/Agreement机制快速进入Forward状态。这种机制必须在&lt;strong&gt;点到点全双工链路上使用&lt;/strong&gt;。&lt;br&gt;
Proposal/Agreement机制，&lt;strong&gt;其目的是使一个指定端口尽快进入Forwarding状态&lt;/strong&gt;。如图所示，根桥S1和S2之间新添加了一条链路。在当前状态下，S2的另外几个端口p2是Alternate端口，p3是指定端口且处于Forwarding状态，p4是边缘端口。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592123671461.png&#34; alt=&#34; Proposal/Agreement机制&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
新链路连接成功后，P/A机制协商过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;p0和p1两个端口马上都先成为指定端口，发送RST BPDU。&lt;/li&gt;
&lt;li&gt;S2的p1口收到更优的RST BPDU，马上意识到自己将成为根端口，而不是指定端口，停止发送RST BPDU。&lt;/li&gt;
&lt;li&gt;S1的p0进入Discarding状态，于是发送的RST BPDU中把proposal置1。&lt;/li&gt;
&lt;li&gt;S2收到根桥发送来的携带proposal的RST BPDU，开始将自己的所有端口进入sync变量置位。&lt;/li&gt;
&lt;li&gt;p2已经阻塞，状态不变；p4是边缘端口，不参与运算；所以只需要阻塞非边缘指定端口p3。&lt;/li&gt;
&lt;li&gt;p2和p3都进入Discarding状态之后，端口的synced变量置位，根端口p1的synced也置位，于是便向S1返回Agreement位置位的回应RST BPDU。该RST BPDU携带和刚才根桥发过来的BPDU一样的信息，除了Agreement位置位之外（Proposal位清零）。&lt;/li&gt;
&lt;li&gt;当S1判断出这是对刚刚发出的Proposal的回应，于是端口p0马上进入Forwarding状态。&lt;br&gt;
下游设备继续执行P/A协商过程。&lt;br&gt;
事实上对于STP，指定端口的选择可以很快完成，主要的速度瓶颈在于：为了避免环路，必须等待足够长的时间，使全网的端口状态全部确定，也就是说必须要等待至少一个Forward Delay所有端口才能进行转发。而RSTP的主要目的就是消除这个瓶颈，通过阻塞自己的非根端口来保证不会出现环路。而使用P/A机制加快了上游端口转到Forwarding状态的速度。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;协商机制的前提－点到点链路&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用“Proposal－Agreement”的前提是泛洪这两种消息的链路均为点到点链路，点到点链路是指两个交换机直接相连的链路。之所以必须使用点到点链路是因为点到多点链路有环路风险。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 开启全局边缘端口
[Huawei]stp edged-port default 
# 开启端口下边缘端口
interface GigabitEthernet0/0/4
stp edged-port enable
# 如果全局开启边缘端口且开启了BPDU保护功能，需要将连接交换机的上连接口（trunk接口）关闭边缘端口功能
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;根端口快速切换机制&#34;&gt;根端口快速切换机制&lt;/h4&gt;
&lt;p&gt;如果网络中一个根端口RP失效，那么网络中最优的Alternate端口AP将成为根端口，进入Forwarding状态。因为通过这个Alternate端口连接的网段上必然有个指定端口可以通往根桥。这种产生新的根端口的过程会引发拓扑变化，详细描述请见RSTP技术细节中的RSTP拓扑变化处理。&lt;/p&gt;
&lt;h4 id=&#34;边缘端口的引入&#34;&gt;边缘端口的引入&lt;/h4&gt;
&lt;p&gt;在RSTP里面，如果某一个指定端口位于整个网络的边缘，即不再与其他交换设备连接，而是直接与终端设备直连，这种端口叫做边缘端口EP。边缘端口不接收处理配置BPDU，不参与RSTP运算，可以由Disable直接转到Forwarding状态，且不经历时延，就像在端口上将STP禁用。但是一旦边缘端口收到配置BPDU，就丧失了边缘端口属性，成为普通STP端口，并重新进行生成树计算，从而引起网络震荡。&lt;/p&gt;
&lt;h3 id=&#34;rstp拓扑变化处理&#34;&gt;RSTP拓扑变化处理&lt;/h3&gt;
&lt;p&gt;在RSTP中检测拓扑是否发生变化&lt;strong&gt;只有一个标准&lt;/strong&gt;：&lt;strong&gt;一个非边缘端口迁移到Forwarding状态&lt;/strong&gt;。&lt;br&gt;
一旦检测到拓扑发生变化，将进行如下处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先清空状态发生变化的端口上学习到的MAC地址。&lt;/li&gt;
&lt;li&gt;同时在2倍的hello time时间内不断向非边缘端口发送TC置位的RST BPDU。&lt;/li&gt;
&lt;li&gt;其他设备收到TC置位的RST BPDU后，清空其他所有端口学习到的MAC地址（&lt;strong&gt;除了收到RST BPDU的端口&lt;/strong&gt;）。同时也会从自己的非边缘端口和根端口向外泛洪TC置位的 RST BPDU。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rstp中配置bpud的处理&#34;&gt;RSTP中配置BPUD的处理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;非根桥设备每隔Hello Timer从指定端口主动发送配置BPDU&lt;/li&gt;
&lt;li&gt;BPDU超时计时器为3个Hello Timer&lt;/li&gt;
&lt;li&gt;阻塞端口可以立即对收到的次级BPDU进行回应&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;根端口快速切换机制-2&#34;&gt;根端口快速切换机制&lt;/h3&gt;
&lt;p&gt;网桥根端口失效，且对端网桥指定端口依然为转发状态，则该网桥Alternate端口直接进入转发状态&lt;/p&gt;
&lt;h3 id=&#34;rstp与stp互操作&#34;&gt;RSTP与STP互操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;RSTP端口在接收到STP BPDU的两个hello timer后，会切换到STP工作模式&lt;/li&gt;
&lt;li&gt;切换到STP协议的RSTP端口会丧失快速收敛等特性&lt;/li&gt;
&lt;li&gt;当运行STP的设备从网络撤离后，原运行RSTP的交换设备上的相应端口（连接STP设备的端口）可迁移回到RSTP工作模式&lt;br&gt;
&lt;code&gt;如果边缘端口收到BPDU报文，会失去边缘端口特性，变为普通接口&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bpdu保护和bpdu-filture&#34;&gt;BPDU保护和BPDU Filture&lt;/h3&gt;
&lt;p&gt;BPDU保护和BPDU Filture一般都是与边缘端口EP配合使用&lt;br&gt;
&lt;code&gt;边缘端口EP即发也收BPDU，EP+BPDU保护只发不收BPDU，EP+BPDU Filture不收也不发BPDU&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;什么情况配置BPDU保护
&lt;ol&gt;
&lt;li&gt;没有办法保证接入端一定是终端设备&lt;/li&gt;
&lt;li&gt;为了防止其他非法设备抢占根桥RB&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;什么情况配置BPDU Filture&lt;br&gt;
&lt;code&gt;stp bpdu-filter enable&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;不收也不发BPDU&lt;/li&gt;
&lt;li&gt;防止自己去抢别人根桥&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;根保护&#34;&gt;根保护&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stp root-protection&lt;/code&gt;&lt;br&gt;
防止自己的根桥被抢占，一般配置在DP接口&lt;br&gt;
一旦启用Root保护功能的指定端口收到优先级更高的RST BPDU时，端口状态将进入Discarding状态，不再转发报文。在经过一段时间（通常为两倍的Forward Delay），如果端口一直没有再收到优先级较高的RST BPDU，端口会自动恢复到正常的Forwarding状态。&lt;br&gt;
&lt;code&gt;Root保护功能只能在指定端口DP上配置生效&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;环路保护&#34;&gt;环路保护&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stp loop-protection&lt;/code&gt;&lt;br&gt;
在启动了环路保护功能后，如果根端口或Alternate端口长时间收不到来自上游设备的BPDU报文时，则向网管发出通知信息（此时根端口会进入Discarding状态，角色切换为指定端口），而Alternate端口则会一直保持在阻塞状态（角色也会切换为指定端口），不转发报文，从而不会在网络中形成环路。直到链路不再拥塞或单向链路故障恢复，端口重新收到BPDU报文进行协商，并恢复到链路拥塞或者单向链路故障前的角色和状态。&lt;br&gt;
&lt;code&gt;环路保护功能只能在根端口RP和预备端口AP上配置生效&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;防tc-bpdu报文攻击&#34;&gt;防TC-BPDU报文攻击&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stp tc-protection threshold 1 # 默认为1&lt;/code&gt;&lt;br&gt;
交换设备在接收到TC BPDU报文后，会执行MAC地址表项和ARP表项的删除操作。&lt;br&gt;
如果有人伪造TC BPDU报文恶意攻击交换设备时，交换设备短时间内会收到很多TC BPDU报文，频繁的删除操作会给设备造成很大的负担，给网络的稳定带来很大隐患。&lt;br&gt;
启用防TC-BPDU报文攻击功能后，在单位时间内，交换设备处理TC BPDU报文的次数可配置。&lt;br&gt;
如果在单位时间内，交换设备在收到TC BPDU报文数量大于配置的阈值，那么设备只会处理阈值指定的次数。对于其他超出阈值的TC BPDU报文，定时器到期后设备只对其统一处理一次。这样可以避免频繁的删除MAC地址表项和ARP表项，从而达到保护设备的目的。&lt;/p&gt;
&lt;h2 id=&#34;mstp&#34;&gt;MSTP&lt;/h2&gt;
&lt;p&gt;RSTP和STP还存在同一个缺陷：由于局域网内所有的VLAN共享一棵生成树，因此无法在VLAN间实现数据流量的负载均衡，链路被阻塞后将不承载任何流量，造成带宽浪费，还有可能造成部分VLAN的报文无法转发。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实例就是多个VLAN的一个集合。通过将多个VLAN捆绑到一个实例，可以节省通信开销和资源占用率。MSTP各个实例拓扑的计算相互独立，在这些实例上可以实现负载均衡。可以把多个相同拓扑结构的VLAN映射到一个实例里，这些VLAN在端口上的转发状态取决于端口在对应MSTP实例的状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;mst区域&#34;&gt;MST区域&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592232219673.png&#34; alt=&#34;MST区域&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MSTP允许一组相邻的交换机组成一个MST区域（MST Region）。同一个区域的交换机有着相同的VLAN到MST Instance的映射关系。除了Instance 0之外，每个区域的MST Instance都独立计算生成树，不管是否包含相同的VLAN，不管VLAN是否通过区域间链路，区域间的生成树计算互不影响。&lt;/p&gt;
&lt;h3 id=&#34;mstp域&#34;&gt;MSTP域&lt;/h3&gt;
&lt;p&gt;MSTP域，具有相同元素网桥的集合：使能MSTP，相同域名，相同VLAN映射，相同的修订级别&lt;/p&gt;
&lt;h3 id=&#34;cstistcist总根主桥mstimsti域根&#34;&gt;CST/IST/CIST/总根/主桥/MSTI/MSTI域根&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592232593691.png&#34; alt=&#34;CST/IST/CIST/总根/主桥&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592318351169.png&#34; alt=&#34;MSTI/MSTI域根&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CIST公共和内部生成树CIST是通过STP或RSTP协议计算生成的，连接一个交换网络内所有交换设备的单生成树。
&lt;ul&gt;
&lt;li&gt;总根是整个网络中优先级最高的网桥，即为CIST的根桥。&lt;/li&gt;
&lt;li&gt;拓扑中，MST域内的红线和MST域间的蓝线共同组成了CIST。CIST的根桥为MST Region1中的S1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CST公共生成树CST（Common Spanning Tree）是连接交换网络内所有MST域的一棵生成树。
&lt;ul&gt;
&lt;li&gt;CST就是这些节点通过STP或RSTP协议计算生成的一棵生成树。&lt;/li&gt;
&lt;li&gt;拓扑中，由蓝线组成CST。CST的根即为MST Region1。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内部生成树IST（Internal Spanning Tree）是各MST域内的一棵生成树。
&lt;ul&gt;
&lt;li&gt;MST域内每颗生成树都对应一个实例号，IST的实例号为0。实例0无论有没有配置都是存在的，没有映射到其他实例的VLAN默认都会映射到实例0，即IST上。&lt;/li&gt;
&lt;li&gt;IST是CIST在MST域中的一个片段。拓扑中，由红线组成IST。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主桥（Master Bridge）也就是IST Master，它是域内距离总根最近的交换设备。
&lt;ul&gt;
&lt;li&gt;如果总根在MST域中，则总根为该域的主桥。&lt;/li&gt;
&lt;li&gt;拓扑中，Master桥为黄色的网桥，即为S1/S4/S7。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;构成单生成树SST（Single Spanning Tree）有两种情况：
&lt;ul&gt;
&lt;li&gt;运行STP或RSTP的交换设备只能属于一个生成树。&lt;/li&gt;
&lt;li&gt;MST域中只有一个交换设备，这个交换设备构成单生成树。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSTI
&lt;ul&gt;
&lt;li&gt;一个MST域内可以生成多棵生成树，每棵生成树都称为一个MSTI。MSTI域根是每个多生成树实例的树根。域中不同的MSTI有各自的域根。&lt;/li&gt;
&lt;li&gt;MSTI之间彼此独立，MSTI可以与一个或者多个VLAN对应。但一个VLAN只能与一个MSTI对应。&lt;/li&gt;
&lt;li&gt;每一个MSTI对应一个实例号，实例号从1开始，以区分实例号为0的IST。&lt;/li&gt;
&lt;li&gt;拓扑中，VLAN2映射到实例2，即MSTI 2；VLAN4映射到实例4，即MSTI 4。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MSTI域根
&lt;ul&gt;
&lt;li&gt;MSTI域根是每个MSTI上优先级最高的网桥，MST域内每个MSTI可以指定不同的根。&lt;/li&gt;
&lt;li&gt;拓扑中，假设S9在MSTI 2中优先级最高，所以S9为MSTI 2中的域根；假设S8在MSTI 4中优先级最高，所以S8为MSTI 2中的域根。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mstp端口角色&#34;&gt;MSTP端口角色&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592320464460.png&#34; alt=&#34;MSTP端口角色&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
MSTP在RSTP的基础上新增了2种端口，MSTP的端口角色共有7种：根端口、指定端口、Alternate端口、Backup端口、边缘端口、Master端口和域边缘端口。&lt;/p&gt;
&lt;h4 id=&#34;master端口&#34;&gt;Master端口&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Master端口是MST域和总根相连的所有路径中最短路径上的端口，它是交换设备上连接MST域到总根的端口。&lt;/li&gt;
&lt;li&gt;Master端口是域中的报文去往总根的必经之路。&lt;/li&gt;
&lt;li&gt;Master端口是特殊域边缘端口，Master端口在CIST上的角色是Root Port，在其它各实例上的角色都是Master端口。&lt;/li&gt;
&lt;li&gt;拓扑中，S7面向Region 1的端口为Master口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;域边缘端口&#34;&gt;域边缘端口&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;MST域内网桥和其他MST域或者STP/RSTP网桥相连的端口为域边界端口。&lt;/li&gt;
&lt;li&gt;拓扑中，S8面向Region 2的端口为域边界端口。&lt;br&gt;
由于网桥在不同MSTI上可以具有不同的角色，所以网桥端口在MSTI上可能有不同的角色。&lt;strong&gt;唯一例外&lt;/strong&gt;的是Master端口，该端口在所有MSTI上的角色都相同，都为Master端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mstp和rstp交互&#34;&gt;MSTP和RSTP交互&lt;/h3&gt;
&lt;p&gt;RSTP/STP网桥将MSTP域看做一个桥ID为域根ID的RSTP桥。&lt;br&gt;
当RSTP/STP网桥收到MSTP的BPDU后，会提取BPDU中的总根、外部路径开销、域根ID、指定端口ID作为RSTP/STP的（RID、RPC、BID、PID）&lt;br&gt;
当MSTP网桥收到RSTP/STP的BPDU后，会将BPDU中的（RID、RPC、BID、PID）对应到MSTP中，其中BID作为MSTP中的域根ID，也作为指定交换机ID，内部路径开销为0.&lt;/p&gt;
&lt;h3 id=&#34;mstp拓扑计算-比较原则&#34;&gt;MSTP拓扑计算--比较原则&lt;/h3&gt;
&lt;p&gt;首先，比较根交换设备ID。&lt;br&gt;
如果根交换设备ID相同，再比较外部路径开销。&lt;br&gt;
如果外部路径开销相同，再比较域根ID。&lt;br&gt;
如果域根ID仍然相同，再比较内部路径开销。&lt;br&gt;
如果内部路径仍然相同，再比较指定交换设备ID。&lt;br&gt;
如果指定交换设备ID仍然相同，再比较指定端口ID。&lt;br&gt;
如果指定端口ID还相同，再比较接收端口ID。&lt;/p&gt;
&lt;h3 id=&#34;mstp快速收敛&#34;&gt;MSTP快速收敛&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592320585495.png&#34; alt=&#34;MSTP快速收敛&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在MSTP中，P/A机制工作过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上游设备发送Proposal报文，请求进行快速迁移。下游设备接收到后，把与上游设备相连的端口设置为根端口，并阻塞所有非边缘端口。&lt;/li&gt;
&lt;li&gt;上游设备继续发送Agreement报文。下游设备接收到后，根端口转为Forwarding状态。&lt;/li&gt;
&lt;li&gt;下游设备回应Agreement报文。上游设备接收到后，把与下游设备相连的端口设置为指定端口，指定端口进入Forwarding状态。&lt;br&gt;
缺省情况下，华为使用增强的快速迁移机制。如果华为设备与其他厂商的设备进行互通，而其他厂商的设备P/A机制使用普通的快速迁移机制，此时，可在华为设备上通过命令&lt;code&gt;stp no-agreement-check&lt;/code&gt;设置P/A机制为普通的快速迁移机制，从而实现华为设备和其他厂商的设备进行互通。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dhcp&#34;&gt;DHCP&lt;/h2&gt;
&lt;h3 id=&#34;dhcp-三种地址分配方式&#34;&gt;DHCP 三种地址分配方式&lt;/h3&gt;
&lt;p&gt;在这三种方式中，只有动态分配的方式可以对已经分配给主机但现在此主机已经不用的IP地址重新加以利用。这样，在给一台临时连入网络的主机分配地址或者在一组不需要永久的IP地址的主机中共享一组有限的IP地址时，动态分配就会显得特别有用。当一台新主机要永久的接入一个网络时，而网络的IP地址非常有限，为了将来这台主机被淘汰时能回。&lt;/p&gt;
&lt;h4 id=&#34;自动分配&#34;&gt;自动分配&lt;/h4&gt;
&lt;p&gt;在自动分配中，不需要进行任何的IP地址手工分配。当DHCP客户机第一次向DHCP服务器租用到IP地址后，这个地址就永久地分配给了该DHCP客户机，而不会再分配给其他客户机。&lt;/p&gt;
&lt;h4 id=&#34;动态分配&#34;&gt;动态分配&lt;/h4&gt;
&lt;p&gt;当DHCP客户机向DHCP服务器租用IP地址时，DHCP服务器只是暂时分配给客户机一个IP地址。只要租约到期，这个地址就会还给DHCP服务器，以供其他客户机使用。如果DHCP客户机仍需要一个IP地址来完成工作，则可以再要求另外一个IP地址。&lt;/p&gt;
&lt;h4 id=&#34;手动分配&#34;&gt;手动分配&lt;/h4&gt;
&lt;p&gt;在手动分配中，网络管理员在DHCP服务器上通过手工方法配置DHCP客户机的IP地址。当DHCP客户机要求网络服务时，DHCP服务器把手工配置的IP地址传递给DHCP客户机。&lt;/p&gt;
&lt;h3 id=&#34;dhcp报文类型共8个类型&#34;&gt;DHCP报文类型（共8个类型）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;DHCP  DISCOVER：由客户端广播来查找可用的服务器。&lt;/li&gt;
&lt;li&gt;DHCP OFFER：服务器用来响应客户端的DHCP DISCOVER报文，并指定相应的配置参数。&lt;code&gt;华为是单播，思科是广播&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DHCP  REQUEST：由客户端发送给服务器来请求配置参数或者请求配置确认或者续借租期。使用场景如下：
&lt;ol&gt;
&lt;li&gt;正常的请求消息（华为是单播）&lt;/li&gt;
&lt;li&gt;租约的期限到了50%（单播，进行续约）&lt;/li&gt;
&lt;li&gt;租约的期限到了87.5%（广播，在50%的时候续约不成功，重新进行续约）&lt;/li&gt;
&lt;li&gt;PC重启之后需要重新续约&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;DHCP ACK：由服务器到客户端，含有配置参数包括IP地址。&lt;/li&gt;
&lt;li&gt;DHCP  DECLINE：当客户端发现地址已经被使用时，用来通知服务器。&lt;/li&gt;
&lt;li&gt;DHCP  INFORM：客户端已经有IP地址时用它来向服务器请求其他的配置参数。&lt;/li&gt;
&lt;li&gt;DHCP NAK：由服务器发送给客户端来表明客户端的地址请求不正确或者租期已过期。&lt;/li&gt;
&lt;li&gt;DHCP  RELEASE：客户端要释放地址时用来通知服务器。&lt;code&gt;PC&amp;gt;ipconfig /release # 释放IP地址；PC&amp;gt;ipconfig /renew # 重新获取IP&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;报文格式&#34;&gt;报文格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592443026859.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
DHCP报文中的option字段，采用“CLV”方式构成。DHCP的选项字段可以应用到多种不同的场景，比如无线等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Code:标识号，唯一标识后面的信息内容，占1byte&lt;/li&gt;
&lt;li&gt;Length:长度，表示后面信息内容的长度，占1byte&lt;/li&gt;
&lt;li&gt;Value:信息内容，其长度为length所指定，以byte为单位&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工作流程-2&#34;&gt;工作流程&lt;/h3&gt;
&lt;h4 id=&#34;全局配置&#34;&gt;全局配置&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592448738953.png&#34; alt=&#34;全局配置&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送DHCP Discover 广播报文即目的地址为255.255.255.255，在网络上寻找DHCP Server。&lt;/li&gt;
&lt;li&gt;网络的的DHCP服务器响应客户端的请求，可能有多个DHCP Sever响应，以广播的方式进行。在网络中接收到DHCPdiscover发现信息的DHCP服务器都会做出响应，它从尚未出租的IP地址中挑选一个分配给DHCP客户机，向DHCP客户机发送一个包含出租的IP地址和其他设置的DHCPoffer信息。&lt;/li&gt;
&lt;li&gt;客户端收到了DHCP Server的DHCP Offer报文之后，则向DHCP Server发送所需要的IP地址请求，该信息中包含向它所选定的DHCP服务器请求IP地址的内容。&lt;/li&gt;
&lt;li&gt;因为有多个DHCP服务器，所以客户端是以广播方式发送DHCP Request报文，还因为要通知所有的DHCP服务器，他将选择某台DHCP服务器所提供的IP地址服务器收到请求之后，给客户端发送ACK响应报文。&lt;/li&gt;
&lt;li&gt;以后DHCP客户端每次重新登录网络时，就不需要再发送DHCPdiscover发现信息了，而是直接发送包含前一次所分配的IP地址的DHCPrequest请求信息。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#......................全局配置
dhcp enable  # 全局下开启dhcp
# 配置单臂路由
interface GigabitEthernet0/0/1.20
dot1q termination vid 20
ip address 192.168.20.1 255.255.255.0 
arp broadcast enable
# 配置DHCP
dhcp select interface # 配置接口模式
dhcp server static-bind ip-address 192.168.20.200 mac-address 5489-98f9-5a19 # mac地址绑定
dhcp server excluded-ip-address 192.168.20.201 192.168.20.253 # IP地址池中排除相应IP
dhcp server lease unlimited #配置租借期为无限期
dhcp server dns-list 8.8.8.8 # 配置DNS服务器
dhcp server domain-name qyt # 配置域名
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#..........................配置地址池
dhcp enable  # 全局下开启dhcp
# 配置地址池
ip pool VLAN10 
gateway-list 192.168.10.1 # 配置地址池必须配置网关
network 192.168.10.0 mask 255.255.255.0 
static-bind ip-address 192.168.10.100 mac-address 5489-9874-0143 
excluded-ip-address 192.168.10.201 192.168.10.254 
dns-list 8.8.8.8
# 借口下开启
interface GigabitEthernet0/0/1.10
dot1q termination vid 10
ip address 192.168.10.1 255.255.255.0
arp broadcast enable
dhcp select global 
# 查看地址池中已经使用的地址
dis ip pool name VLAN10 used 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;华为地址池分配顺序是从大到小，因此一般设置网关为x.x.x.254；思科地址池分配顺序为从小到大，因此一般设置网关为x.x.x.1&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;续租&#34;&gt;续租&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592448995259.png&#34; alt=&#34;续租&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;中继&#34;&gt;中继&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592449056530.png&#34; alt=&#34;中继&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 为实现DHCP服务器跨Vlan，则需要配置中继
interface GigabitEthernet0/0/1.10
dot1q termination vid 10
ip address 192.168.10.1 255.255.255.0 
arp broadcast enable
dhcp select relay  # 配置中继
dhcp relay server-ip 192.168.100.100 #配置中继的地址（此地址必须可以ping通）
# 中继也需要在相应接口下开启
dhcp select global
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;dhcp-snooping&#34;&gt;DHCP Snooping&lt;/h3&gt;
&lt;h4 id=&#34;原理&#34;&gt;原理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DHCP Snooping是一种DHCP 安全特性，通过截获DHCP Client和DHCP Relay之间的DHCP报文并进行分析处理，可以过滤不信任的DHCP报文并建立和维护一个DHCP Snooping绑定表。&lt;br&gt;
&lt;code&gt;绑定表包括MAC地址、IP地址、租约时间、VLAN ID、接口信息。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;DHCP Snooping通过对这个绑定表的维护，建立一道在DHCP Client和DHCP Server之间的防火墙。&lt;/li&gt;
&lt;li&gt;DHCP Snooping可以解决设备应用DHCP时遇到的DHCP DoS（Denial of Service）攻击、DHCP Server仿冒攻击、DHCP仿冒续租报文攻击等问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;关键技术&#34;&gt;关键技术&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;信任/非信任端口&lt;/strong&gt;：一般通向DHCP服务器 (运营商网络内部)的端口设成“信任(Trusted)”，其它端口(连接运营商网络外部的端口) 都设为“不信任(Untrusted)” 。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;绑定表&lt;/strong&gt;：建立&lt;code&gt;MAC + IP + VLAN + Port&lt;/code&gt;的绑定关系。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Option82&lt;/strong&gt;：是DHCP协议报文中选项部分之中的一项，用于记录报文入端口类型、端口号、VLAN信息以及桥MAC地址，是生成绑定表的重要部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dhcp-snooping绑定表&#34;&gt;DHCP Snooping绑定表&lt;/h4&gt;
&lt;p&gt;分为动态绑定表和静态绑定表&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态绑定表&lt;br&gt;
按照实际需求在报文入端口手工输入，没有租期限制&lt;br&gt;
&lt;strong&gt;用途&lt;/strong&gt;：一些重要设备（如服务器）和一些高端用户需采用静态方式，一是没有租期限制，二是安全性高且便 于管理。&lt;/li&gt;
&lt;li&gt;动态绑定表&lt;br&gt;
DHCP客户端在申请IP地址过程中，根据DHCP报文内容在报文入端口自动生成，存在老化时间，有租期限制。&lt;br&gt;
&lt;strong&gt;用途&lt;/strong&gt;：生成方便，常用于非重要设备。不过绑定表存在老化时间，且不便于管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 全局下开启DHCP嗅探
dhcp snooping enable
# vlan下开启DHCP嗅探并添加信任端口
vlan 10
dhcp snooping enable
dhcp snooping trusted int g0/0/3
arp anti-attack check user-bind enable  # 在vlan下开启动态arp检测
#在接口下配置该端口为DHCP信任端口
interface GigabitEthernet0/0/24
dhcp snooping trusted
arp anti-attack check user-bind enable # 在接口下开启动态arp检测
arp anti-attack check user-bind alarm enable
# 查看DHCP Snooping配置情况　
dis dhcp snooping configuration 
# 查看DHCP Snooping绑定表
dis dhcp snooping user-bind all
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;dhcp的option82原理&#34;&gt;DHCP的Option82原理&lt;/h4&gt;
&lt;p&gt;使能Option82功能，可以根据Option82信息&lt;strong&gt;建立精确到接口的绑定表&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DHCP Relay Agent插 入到用户的DHCP报 文，DHCP服务器通 过识别Option82来执 行IP地址分配策略或 其它策略。&lt;/li&gt;
&lt;li&gt;DHCP服务器的响应 报文也带Option82，  Relay Agent将Option82剥离后发给用户。&lt;/li&gt;
&lt;li&gt;Agent Information Field中包括多个子选项，每个子选项格式为SubOpt/Length/Value三元组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;dhcp-option82工作流程&#34;&gt;DHCP Option82工作流程&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466421789.png&#34; alt=&#34;DHCP Option82工作流程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;dhcp仿冒者攻击&#34;&gt;DHCP仿冒者攻击&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466460979.png&#34; alt=&#34;DHCP仿冒者攻击&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;DHCP仿冒者攻击解决方法&lt;/strong&gt;：一般把通向DHCP Server的接口（连接网络内部的网络侧接口）设成Trusted&lt;br&gt;
状态，其它接口（连接网络外部的用户侧接口）都设为Untrusted状态。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466544827.png&#34; alt=&#34;DHCP仿冒者攻击解决方法&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;中间人攻击和ipmac-spoofing攻击&#34;&gt;中间人攻击和IP/MAC Spoofing攻击&lt;/h5&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466733449.png&#34; alt=&#34;中间人攻击和IP/MAC Spoofing攻击&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;中间人攻击和IP/MAC Spoofing攻击解决方法&lt;/strong&gt;：为了防止中间人攻击或IP/MAC Spoofing攻击，可以在交换机上配置DHCP Snooping功能，使能DHCP Snooping绑定表功能后，只有接收到的报文的信息和绑定表中的内容一致才会被转发，否则报文将被丢弃。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592466826858.png&#34; alt=&#34;中间人攻击和IP/MAC Spoofing攻击解决方法&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;DAI（动态ARP检测）是用来检测arp报文的，是用来防止中间人攻击；IPSG（IP源防攻击）是用来检测IP报文的，用来防止盗用IP的&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#-------------------------DAI
# 在vlan下开启动态arp检测
vlan 10
dhcp snooping enable
dhcp snooping trusted interface GigabitEthernet0/0/1
arp anti-attack check user-bind enable
# 在接口下开启动态arp检测　　　　　　　　　　　　
interface GigabitEthernet0/0/5
port link-type access
port default vlan 10
arp anti-attack check user-bind enable
arp anti-attack check user-bind alarm enable
#------------------------------
# 配置静态绑定表
user-bind static ip-address 192.168.10.100 mac-address 5489-9832-2464 inter
face  g0/0/5 vlan 10
# 查看静态绑定表
dis dhcp static user-bind all 
#------------------------------IPSG
# 在VLAN下开启IP源防护
vlan 10
ip source check user-bind enable　　　　　　　　　　　　
# 在接口下开启IP源防护功能
interface GigabitEthernet0/0/5
ip source check user-bind enable　　　　　　　　　　　　　
ip source check user-bind alarm enable
# 查看IP源防护功能
[SW1]dis ip source check user-bind interface GigabitEthernet 0/0/5 
ip source check user-bind enable
ip source check user-bind alarm enable
# ------------------------------开启端口安全
int g0/0/2
port-security enable
port-security max-mac-num 1  # 最多允许一个max
port-security protect-action shutdown  # 触发之后关闭端口(protect丢弃；restrict丢弃后告警；shutdown关闭端口)
port-security mac-address sticky # 只允许这个mac地址(5489-982A-463D)通过
port-security mac-address sticky 5489-982A-463D vlan 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;饿死攻击&#34;&gt;饿死攻击&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;攻击原理&lt;/strong&gt;：在饿死攻击方式中，攻击者不断变换物理地址，尝试申请地址池中所有的IP 地址，直到耗尽DHCP Server地址池中的地址，导致其他正常用户无法获得地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：通过MAC地址限制功能可以防止饿死攻击。通过限制交换机接口上允许学习到的最多MAC 地址数目，防止用户通过变换MAC地址，大量发送DHCP请求，同时也限制了一个接口上的用户数目。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;改变chaddr值的饿死攻击&#34;&gt;改变CHADDR值的饿死攻击&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;攻击原理&lt;/strong&gt;：在这种攻击方式中，如果攻击者改变的不是数据帧头部的源MAC，而是改变DHCP报文中的CHADDR（Client Hardware Address）值来不断申请IP地址，而交换机仅根据数据帧头部的源MAC来判断该报文是否合法，那么MAC地址限制方案不能起作用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：可以使用DHCP Snooping检查DHCP REQUEST报文中CHADDR字段的功能。如果该字段跟数据帧头部的源MAC相匹配，便转发报文；否则，丢弃报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;arp攻击原理&#34;&gt;ARP攻击原理&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击方式&lt;/strong&gt;：有针对主机的，也有针对网关的；有地址欺骗型的， 也有野蛮攻击型的；有来自病毒的攻击，也有来自使用非法软件的人为攻击。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击根源&lt;/strong&gt;：ARP协议本身过于简单和开放，没有任何的安全手段。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击危害&lt;/strong&gt;：ARP地址欺骗攻击一般针对个别或一定范围内的主机 进行，危害相对较小。但针对网关设备的大流量ARP DDOS攻击，由 于其网络位置的特殊性，将造成大面积用户“掉线”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ARP攻击解决方法&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;在应用DHCP服务器的组网环境下， 建立可信端口（trust Port），通过监控可信端口的DHCP 报文获得IP/MAC地址绑定表，这是DHCP Check IP/ARP安全检查手段的重要依据。实际上也是一种安全焦点的转移，把ARP安全问题转换为别的安全问题。&lt;/li&gt;
&lt;li&gt;DHCP Snooping Chek IP/ARP依据可信端口上生成的绑定表，过滤掉所有不匹配的IP/ARP报文。大大的提高了防攻击的能力。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;istack堆叠&#34;&gt;iStack堆叠&lt;/h2&gt;
&lt;p&gt;CSS和iStack的区别：CSS是框式堆叠，iStack是盒式堆叠&lt;/p&gt;
&lt;h3 id=&#34;典型园区组网csseth-trunkistack&#34;&gt;典型园区组网（CSS+Eth-Trunk+iStack）&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592552003932.png&#34; alt=&#34;典型园区组网&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;设备堆叠istack&#34;&gt;设备堆叠iStack&lt;/h3&gt;
&lt;p&gt;智能堆叠iStack是指将多台支持堆叠特性的交换机设备组合在一起，从逻辑上组合成一台交换设备。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592552557293.png&#34; alt=&#34;设备堆叠iStack&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;基本概念&#34;&gt;基本概念&lt;/h3&gt;
&lt;h4 id=&#34;角色&#34;&gt;角色&lt;/h4&gt;
&lt;p&gt;堆叠中所有的单台交换机都称为成员交换机，按照功能不同，可以分为三种角色：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主交换机（Master）：负责管理整个堆叠。堆叠中只有一台主交换机。&lt;code&gt;不支持抢占&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;备交换机（Standby）：是主交换机的备份交换机。当主交换机故障时，备交换机会接替原主交换机的所有业务。堆叠中只有一台备交换机。&lt;/li&gt;
&lt;li&gt;从交换机（Slave）：主要用于业务转发，从交换机数量越多，堆叠系统的转发能力越强。除主交换机和备交换机外，堆叠中其他所有的成员交换机都是从交换机。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;堆叠id&#34;&gt;堆叠ID&lt;/h4&gt;
&lt;p&gt;即成员交换机的槽位号（Slot ID），用来标识和管理成员交换机，堆叠中所有成员交换机的堆叠ID都是唯一的。&lt;/p&gt;
&lt;h4 id=&#34;堆叠优先级&#34;&gt;堆叠优先级&lt;/h4&gt;
&lt;p&gt;堆叠优先级是成员交换机的一个属性，主要用于角色选举过程中确定成员交换机的角色，优先级值越大表示&lt;br&gt;
优先级越高，优先级越高当选为主交换机的可能性越大。&lt;/p&gt;
&lt;h3 id=&#34;堆叠建立&#34;&gt;堆叠建立&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592554662316.png&#34; alt=&#34;堆叠建立&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;堆叠连接方式&#34;&gt;堆叠连接方式&lt;/h4&gt;
&lt;p&gt;交换机组建堆叠根据堆叠口的不同，可以分为两种方式：&lt;strong&gt;堆叠卡堆叠和业务口堆叠&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;堆叠卡堆叠&lt;/strong&gt;又分为以下两种情况：
&lt;ul&gt;
&lt;li&gt;交换机之间通过专用的堆叠插卡及专用的堆叠线缆连接&lt;/li&gt;
&lt;li&gt;堆叠卡集成到了交换机后面板上，交换机通过集成的堆叠端口及专用的堆叠线缆连接&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务口堆叠&lt;/strong&gt;指的是交换机之间通过与逻辑堆叠端口绑定的物理成员端口相连，不需要专&lt;br&gt;
用的堆叠插卡&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;堆叠成员加入&#34;&gt;堆叠成员加入&lt;/h4&gt;
&lt;p&gt;堆叠成员加入是指向已经稳定运行的堆叠系统添加一台新的交换机。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592554993280.png&#34; alt=&#34;堆叠成员加入&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使能堆叠并配置好SWD的堆叠参数
&lt;ul&gt;
&lt;li&gt;如果是&lt;strong&gt;业务口堆叠&lt;/strong&gt;，新加入的交换机需要配置无力程远端口加入逻辑堆叠端口。链型连接时，当前堆叠系统链型两端（或一端）的成员交换机也需要配置物理成员端口加入逻辑堆叠口。&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;堆叠卡堆叠&lt;/strong&gt;，新加入的成员交换机需要使能堆叠功能。&lt;br&gt;
&lt;code&gt;为了便于管理，建议新加入的交换机配置堆叠ID，如果不配置，堆叠系统会为其分配一个堆叠ID&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;讲SWD连接到堆叠系统
&lt;ul&gt;
&lt;li&gt;如果是&lt;strong&gt;链型连接&lt;/strong&gt;，新加入的交换机建议添加到链型的两端，这样对现有的业务影响最小&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;环型连接&lt;/strong&gt;，需要把当前环型拆成链型，然后在链型的两端添加设备&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;系统完成堆叠
&lt;ol&gt;
&lt;li&gt;新加入的交换机连线上电启动后，进行角色选举，新加入的交换机会选举为从交换机，堆叠系统中原有的主备从角色不变&lt;/li&gt;
&lt;li&gt;角色选举结束后，主交换机更新堆叠拓扑信息，同步到其他成员交换机上，并向新加入的交换机分配堆叠ID（在新成员未配置或配置冲突时）&lt;/li&gt;
&lt;li&gt;新加入的交换机更新堆叠ID，并同步主交换机的配置文件和系统软件，之后进入稳定运行状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;堆叠合并&#34;&gt;堆叠合并&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592555929409.png&#34; alt=&#34;堆叠合并&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;堆叠成员退出&#34;&gt;堆叠成员退出&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592555967540.png&#34; alt=&#34;堆叠成员退出&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;堆叠分裂&#34;&gt;堆叠分裂&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592556004132.png&#34; alt=&#34;堆叠分裂&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;多主检测&#34;&gt;多主检测&lt;/h3&gt;
&lt;h4 id=&#34;直连检测方式&#34;&gt;直连检测方式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592556327590.png&#34; alt=&#34;直连检测方式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;代理检测方式&#34;&gt;代理检测方式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592556373097.png&#34; alt=&#34;代理检测方式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;连线方式&#34;&gt;连线方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;链型&lt;/li&gt;
&lt;li&gt;环型&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;配置&#34;&gt;配置&lt;/h3&gt;
&lt;h4 id=&#34;通过堆叠卡连接方式组建堆叠&#34;&gt;通过堆叠卡连接方式组建堆叠&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[SwitchA] stack slot 0 priority 200
\\配置成员交换机的堆叠优先级。缺省情况下，成员交换机的堆叠优先级为100
[SwitchB] stack slot 0 renumber 1
\\配置设备的堆叠ID
[SwitchC] stack slot 0 renumber 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;通过业务口连接方式组建堆叠&#34;&gt;通过业务口连接方式组建堆叠&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[SwitchA] interface stack-port 0/1
[SwitchA-stack-port0/1] port interface gigabitethernet 0/0/27 enable
\\配置业务口为物理成员端口并将其加入到逻辑堆叠端口中。交换机B、C同理。
[SwitchA] interface stack-port 0/2
[SwitchA-stack-port0/2] port interface gigabitethernet 0/0/28 enable
[SwitchA] stack slot 0 priority 200
\\ 配置SwitchA的堆叠优先级为200
[SwitchB] stack slot 0 renumber 1
\\配置SwitchB的堆叠ID为1
[SwitchC] stack slot 0 renumber 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;css堆叠&#34;&gt;CSS堆叠&lt;/h2&gt;
&lt;p&gt;集群交换系统CSS，又称集群，是指将两台支持集群特性的交换机设备组合在一起，从逻辑上组合成以太交换设备。&lt;/p&gt;
&lt;h3 id=&#34;特征&#34;&gt;特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;交换机多虚一：堆叠交换机对外表现为一台逻辑交换机，控制平面合一，统一管理&lt;/li&gt;
&lt;li&gt;转发平面合一：堆叠内物理设备转发平面合一，转发信息共享并实时同步&lt;/li&gt;
&lt;li&gt;跨设备链路聚合：跨堆叠内物理设备的链路被聚合成一个Eth-Trunk端口，和现有设备实现互联。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;基本概念-2&#34;&gt;基本概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主交换机：负责管理整个集群，集群中只有一台主交换机&lt;/li&gt;
&lt;li&gt;备交换机：主交换机的备份交换机。当主交换机故障时，备交换机会接替原主交换机的所有业务，集群中只有一台备交换机&lt;/li&gt;
&lt;li&gt;集群ID：即CSS ID，用来标识和管理成员交换机，交换机中成员交换机的集群ID是唯一的。&lt;/li&gt;
&lt;li&gt;集群优先级：即Priority，是成员交换机的一个属性，主要用于角色选举过程中确定成员交换机的角色，优先级值越大表示优先级越高，优先级越高当选为主交换机的可能性越大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集群建立&#34;&gt;集群建立&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592665040596.png&#34; alt=&#34;集群建立&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
集群建立时，成员交换机间相互发送集群竞争报文，通过竞争，一台成为主交换机，负责管理整个集群系统，另外一台则成为备用交换机。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;角色选举
&lt;ol&gt;
&lt;li&gt;运行状态比较，最先完成启动的交换机优先竞争为主交换机&lt;/li&gt;
&lt;li&gt;堆叠优先级比较，堆叠优先级高的交换机优先竞争为主交换机&lt;/li&gt;
&lt;li&gt;软件版本比较，软件版本高的交换机优先竞争为主交换机&lt;/li&gt;
&lt;li&gt;主控板数量比较，有2块主控板的交换机比只有1块主控板的交换机优先竞争为主交换机&lt;/li&gt;
&lt;li&gt;桥MAC地址比较，桥MAC地址小的交换机优先竞争为主交换机&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;版本同步
&lt;ul&gt;
&lt;li&gt;集群具有自动加载系统软件的功能，待组成集群的成员不需要具有相同的软件版本，只需要版本间兼容即可。&lt;/li&gt;
&lt;li&gt;当主交换机选举结束后，如果备交换机与主交换机的软件版本不一致，备交换机会自动从主交换机下载系统软件，然后使用新的系统软件重启，并重新加入集群&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置同步&lt;br&gt;
集群具有严格的配置文件同步机制，来保证集群中的多台交换机能够像一台设备一样在网络中工作。&lt;/li&gt;
&lt;li&gt;配置备份&lt;br&gt;
交换机从飞机群状态进入集群状态后，会自动将原有的非集群状态下的配置文件加上.bak的扩展名进行备份，以便关闭集群功能后，恢复原有配置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;css集群连接方式&#34;&gt;CSS集群连接方式&lt;/h3&gt;
&lt;p&gt;设备组建集群有两种连接方式 ，分别为集群卡和业务口集群&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;集群卡方式：成员交换机之间通过主控板上专用的集群卡及专用的集群线缆连接。&lt;/li&gt;
&lt;li&gt;业务口集群方式：成员交换机之间通过业务板上的普通业务口连接，不需要专用的集群卡。通iStack，业务口集群一样涉及两种端口的概念：物理成员端口和逻辑集群端口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;集群成员的加入与合并&#34;&gt;集群成员的加入与合并&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592666510567.png&#34; alt=&#34; 集群成员的加入与合并&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;集群分裂&#34;&gt;集群分裂&lt;/h3&gt;
&lt;p&gt;集群建立后，系统主用主控板和系统备用主控板定时发送心跳报文来维护集群系统的状态。集群线缆、&lt;br&gt;
集群卡、主控板等发生故障或者是其中一台交换机下电或重启将导致两台交换机之间失去通信。当两&lt;br&gt;
台交换机之间的心跳报文超时（&lt;strong&gt;超时时间为8秒&lt;/strong&gt;）时，集群系统将分裂为两个单框集群系统，如图所 示：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592666614258.png&#34; alt=&#34;集群分裂&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
集群分裂后，由于成员交换机运行着相同的配置文件，就会产生两个具有相同IP和MAC的集群系统。 为防止由此引起网络故障，必须进行IP地址和MAC地址的冲突检查。&lt;/p&gt;
&lt;h3 id=&#34;集群升级&#34;&gt;集群升级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;传统升级方式&lt;/strong&gt;。传统的升级即通过指定启动文件后整机重启的方式进行升级。这种升级方式业务中断时间比较长，不适用于对业务中断时间要求较高的场景。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快速升级方式&lt;/strong&gt;。堆叠快速升级提供了一种在堆叠系统的成员设备软件版本升级过程中尽量减少转发业务中断的机制，减少了升级设备对业务的影响。
&lt;ol&gt;
&lt;li&gt;升级前，堆叠与上下游设备之间使用Eth-Trunk双归连接方式。若不采用该连接方式，升级时流量中断时间会较长。&lt;/li&gt;
&lt;li&gt;升级时，备交换机先以新版本重新启动，完成升级，此时数据流量由主交换机转发。&lt;/li&gt;
&lt;li&gt;备交换机完成升级后，备交换机升级为主交换机，转发数据流量。原主交换机以新版本重新启动，完成升级后成为堆叠系统的备交换机。&lt;/li&gt;
&lt;li&gt;升级结束，数据流量转发恢复正常。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 模拟器不支持，需要使用真机配置
#CE1-A
lldp enable
stack
stack member 1 priority 200  # 配置槽位号（成员号）为1，优先级为200（默认为100）
stack member 1 domain 10
q
interface Stack-Port 1/1
port member-group interface 10GE 1/0/17 to 1/0/18
q
dis stack configuration
q
save
reboot
#CE1-B
lldp enable
stack
stack member 2 priority 120
stack member 2 domain 10
# stack member 2 rebunber 3 inherit-config  # 修改槽位号并继承之前的配置
q
interface Stack-Port 1/1
port member-group interface 10GE 1/0/17 to 1/0/18
q
dis stack configuration
q
save
reboot
# 查看拓扑
dis stack topology
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;双向转发检测bfd&#34;&gt;双向转发检测BFD&lt;/h2&gt;
&lt;p&gt;一个通用的标准化的介质无关和协议无关的快速故障检测机制，用于快速检测、监控网络中链路或者IP路由的转发连通状况。&lt;/p&gt;
&lt;h3 id=&#34;应用场景&#34;&gt;应用场景&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592717179304.png&#34; alt=&#34;1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
RTA和RTD建立了OSPF邻接关系，Hello包发送周期为10秒；当交换机SWB与SWC链路物理中断，路由器RTA和RTD无法感知，需要等待OSPF协议邻居失效计时器超时后才会中断邻接关系。（40秒之后才能感知到）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592717259063.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
SWA和SWB启用了VRRP协议，实现了主备网关的作用，SWB为主用网关。当出口路由器RTB与外网Router的链路中断，SWB虽然可以通过动态路由协议感知，但是无法联动连接下游的网关接口，且继续为主网关。用户的数据流还是发送到SWB，SWB再通过三层路由转发给SWA，最后由RTA出口。虽然结果不至于造成业务中断，但是会产生次优路径。&lt;/p&gt;
&lt;h3 id=&#34;简介&#34;&gt;简介&lt;/h3&gt;
&lt;p&gt;一种全网统一、检测迅速、监控网络中链路或者IP路由的双向转发连通状况，并为上层应用提供服务的技术。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592717444631.png&#34; alt=&#34;简介&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;bfd会话建立方式和检测机制&#34;&gt;BFD会话建立方式和检测机制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592717501255.png&#34; alt=&#34;BFD会话建立方式和检测机制&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;BFD的标识符：
&lt;ul&gt;
&lt;li&gt;BFD建立会话存在标识符的概念，类似于OSPF建立邻居需要一个路由器的Router ID。&lt;/li&gt;
&lt;li&gt;标识符分为本地标识符和远端标识符，本地标识符用于表示本端设备，远端标识符用于表示对端设备。&lt;/li&gt;
&lt;li&gt;静态建立BFD会话是指通过命令行手工配置BFD会话参数，包括配置本地标识符和远端标识符等，然后手工下发BFD会话建立请求。&lt;/li&gt;
&lt;li&gt;动态建立BFD会话是指由应用程序触发创建BFD会话，当应用程序动态触发创建BFD会话时，系统分配属于动态会话标识符区域的值作为BFD会话的本地标识符。然后向对端发送Remote Discriminator的值为0的BFD控制报文，进行会话协商。当BFD会话的一端收到Remote Discriminator的值为0的BFD控制报文时，判断该报文是否与本地BFD会话匹配，如果匹配，则学习接收到的BFD报文中Local Discriminator的值，获取远端标识符。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BFD的检测机制：
&lt;ul&gt;
&lt;li&gt;BFD的检测机制是两个系统建立BFD会话，并沿它们之间的路径周期性发送BFD控制报文，如果一方在既定的时间内没有收到BFD控制报文，则认为路径上发生了故障，&lt;strong&gt;BFD控制报文是UDP报文，端口号3784&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;BFD提供异步检测模式。在这种模式下，系统之间相互周期性地发送BFD控制报文，&lt;strong&gt;如果某个系统连续3个报文都没有接收到，就认为此BFD会话的状态是Down&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;bfd会话建立过程&#34;&gt;BFD会话建立过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592717639141.png&#34; alt=&#34;BFD会话建立过程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;RTA和RTB各自启动BFD状态机，初始状态为Down，发送状态为Down的BFD报文。对于静态配置BFD会话，报文中的Remote Discriminator的值是用户指定的；对于动态创建BFD会话，Remote Discriminator的值是0。&lt;/li&gt;
&lt;li&gt;RTB收到状态为Down的BFD报文后，状态切换至Init，并发送状态为Init的BFD报文。&lt;/li&gt;
&lt;li&gt;RTB本地BFD状态为Init后，不再处理接收到的状态为Down的报文。&lt;/li&gt;
&lt;li&gt;RTB收到状态为Init的BFD报文后，本地状态切换至Up。&lt;/li&gt;
&lt;li&gt;RTA的BFD状态变化同RTB。&lt;/li&gt;
&lt;li&gt;邻居会话建立成功后，RTA和RTB周期性的向对方发送状态为Up的控制报文。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;bfd工作流程&#34;&gt;BFD工作流程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592717751076.png&#34; alt=&#34;BFD工作流程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
OSPF邻居建立--&amp;gt;BFD会话建立。&lt;br&gt;
链路故障--&amp;gt;BFD会话Down--&amp;gt;OSPF邻居关系中断。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OSPF的BFD检测故障发现处理流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;OSPF通过自己的Hello机制发现邻居并建立连接。&lt;/li&gt;
&lt;li&gt;OSPF在建立了邻居关系后，将邻居信息（包括目的地址和源地址等）通告给BFD。&lt;/li&gt;
&lt;li&gt;BFD根据收到的邻居信息建立会话。&lt;/li&gt;
&lt;li&gt;被检测链路出现故障。&lt;/li&gt;
&lt;li&gt;BFD快速发送BFD探测报文检测到链路故障，如果在规定时间内无响应，BFD会话状态变为Down。&lt;/li&gt;
&lt;li&gt;BFD通知本地OSPF进程BFD邻居不可达。&lt;/li&gt;
&lt;li&gt;本地OSPF进程中断OSPF邻居关系。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;联动功能&#34;&gt;联动功能&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592717944048.png&#34; alt=&#34;联动功能&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;监测模块负责对链路状态、网络性能等进行监测，并将探测结果通知给Track模块 。&lt;/li&gt;
&lt;li&gt;Track模块收到监测模块的探测结果后，及时改变Track项的状态，并通知应用模块。&lt;/li&gt;
&lt;li&gt;应用模块根据Track项的状态，进行相应的处理，从而实现联动。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;镜像技术&#34;&gt;镜像技术&lt;/h2&gt;
&lt;p&gt;在网络维护的过程中会遇到需要对报文进行获取和分析的情况，比如怀疑有攻击报文，此时需要在不影响报文转发的情况下，对报文进行获取和分析。&lt;br&gt;
镜像技术可以在&lt;strong&gt;不影响报文正常处理流程&lt;/strong&gt;的情况下，&lt;strong&gt;将镜像端口的报文复制一份到观察端口&lt;/strong&gt;，用户利用数据监控设备来分析复制到观察端口的报文，进行网络监控和故障排除。&lt;/p&gt;
&lt;h3 id=&#34;数据采集的作用&#34;&gt;数据采集的作用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592725350067.png&#34; alt=&#34;数据采集的作用&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;数据采集的方法&#34;&gt;数据采集的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分光器物理采集&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592725410973.png&#34; alt=&#34;分光器物理采集&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;利用物理器件分光器插入连接的链路当中，复制出正常的数量流到采集器上面。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点是&lt;/strong&gt;采集的数据完整可靠，只在中间链路上操作，完全不影响被采集设备的性能，也不占用链路带宽。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点是&lt;/strong&gt;每次采集要做物理动作切入，相对繁琐且有风险。&lt;/li&gt;
&lt;li&gt;适合网络业务出入口大型设备的数据流采集，常用于连接IDS设备的网络环境。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NMS集中采集&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592725474265.png&#34; alt=&#34;NMS集中采集&#34; loading=&#34;lazy&#34;&gt;
&lt;ul&gt;
&lt;li&gt;利用通用标准协议SNMP协议传送标准的MIB数据，采集整网的配置信息和设备端口数据流信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优点是&lt;/strong&gt;可以采集整网设备节点信息。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺点是&lt;/strong&gt;针对接口的数据流信息采集不够精细和完整，大部分是统计信息。&lt;/li&gt;
&lt;li&gt;适合网管中心查看设备的参数和性能以及业务信息统计。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;镜像概述&#34;&gt;镜像概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;镜像定义&lt;br&gt;
将镜像端口（源端口）的报文复制一份到观察端口（目的端口）。&lt;/li&gt;
&lt;li&gt;镜像作用&lt;br&gt;
获取完整报文用于分析网络状况。&lt;/li&gt;
&lt;li&gt;镜像优点&lt;br&gt;
不影响原有网络，快捷方便。采集的是实时数据流，真实可靠。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;镜像的角色&#34;&gt;镜像的角色&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592725699675.png&#34; alt=&#34;镜像的角色&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;镜像端口：镜像端口是被监控的端口，从镜像端口流经的所有报文或匹配流分类规则的报文将被复制到观察端口。&lt;/li&gt;
&lt;li&gt;观察端口：观察端口是连接监控设备的端口，用于输出从镜像端口复制过来的报文。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;vxlan&#34;&gt;VXLAN&lt;/h2&gt;
&lt;p&gt;服务器虚拟化能够大幅降低IT建设运维成本，提高业务部署灵活性。虚拟机在传统数据中心网络中只能在二层网络中进行无缝迁移，一旦在跨三层网络中进行迁移，就会造成业务中断。于是VXLAN技术应运而生，大大提高了虚拟机迁移的灵活性，使海量租户不受网络IP地址变更和广播域限制的影响，同时也大大降低了网络管理的难度。&lt;/p&gt;
&lt;h3 id=&#34;数据中心&#34;&gt;数据中心&lt;/h3&gt;
&lt;h4 id=&#34;概念&#34;&gt;概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;数据中心（Data Center）是一套完整、复杂的集合系统，它不仅包括计算机系统和其它与之配套的设备（例如通信和存储系统），还包含数据通信系统、环境控制设备、监控设备以及各种安全装置。&lt;/li&gt;
&lt;li&gt;数据中心通常是指在一个物理空间内实现信息集中处理、存储、传输、交换、管理的场所。&lt;/li&gt;
&lt;li&gt;服务器、网络设备、存储设备等通常都是数据中心的关键设备。&lt;/li&gt;
&lt;li&gt;设备运行所需要的环境因素，如供电系统、制冷系统、机柜系统、消防系统、监控系统等通常都被认为是关键物理基础设施。&lt;/li&gt;
&lt;li&gt;互联网数据中心（Internet Data Center，IDC）是互联网中数据存储和处理的中心，是互联网中数据交互最为集中的地方。&lt;br&gt;
&lt;strong&gt;简而言之：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;DC (Data Center)。&lt;/li&gt;
&lt;li&gt;企业IT系统的核心。&lt;/li&gt;
&lt;li&gt;海量数据运算、交换、存储的中心。&lt;/li&gt;
&lt;li&gt;关键信息业务应用的计算环境。&lt;/li&gt;
&lt;li&gt;集中管控各种数据、应用程序、物理或 虚拟化设备的环境。&lt;/li&gt;
&lt;li&gt;数据中心四大焦点：可靠 、灵活 、绿色 、高效&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;传统数据中心网络结构&#34;&gt;传统数据中心网络结构&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592745554047.png&#34; alt=&#34;传统数据中心网络结构&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;数据中心按不同业务功能进行分区。传统数据中心的网络结构是按照经典的三层架构（接入、汇聚、核心）进行部署的。&lt;/li&gt;
&lt;li&gt;按照功能模块划分，传统数据中心可分为核心区、外网服务器区、内网服务器区、互联网服务器区、数据中心管理区、数据交换&amp;amp;测试服务器区、数据存储功能区、数据容灾功能区等。&lt;/li&gt;
&lt;li&gt;在服务器区，再根据不同的应用类型划分不同的层次，例如，数据库层、应用服务器层、WEB服务器层等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;面对的挑战&#34;&gt;面对的挑战&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;计算节点低延迟需求
&lt;ul&gt;
&lt;li&gt;同一物理服务器部署大量虚拟机，造成流量并发量大增。&lt;/li&gt;
&lt;li&gt;数据流量模型也从传统的南北向流量转变为东西向流量。&lt;/li&gt;
&lt;li&gt;网络中存在大量多对一、多对多的东西向流量。&lt;/li&gt;
&lt;li&gt;对接入层和汇聚层设备的处理能力提出了更高的要求。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592746576535.png&#34; alt=&#34;计算节点低延迟需求&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚拟化应用大量部署
&lt;ul&gt;
&lt;li&gt;传统的数据中心内，服务器主要用于对外提供服务，不同业务区域之间可通过划分为不同的安全分区或VLAN进行隔离。&lt;/li&gt;
&lt;li&gt;一个分区通常集中了该业务所需的计算、网络及存储资源，不同的分区之间或者禁止互访，或者经由三层网络进行互访，数据中心的网络流量大部分集中于南北向。在这种设计下，不同分区间计算资源无法共享，资源利用率低下的问题越来越突出。&lt;/li&gt;
&lt;li&gt;通过虚拟化技术、云计算管理技术等，将各个分区间的资源进行池化，实现数据中心资源的有效利用。&lt;/li&gt;
&lt;li&gt;随着这些新技术的兴起和应用，新的业务需求如虚拟机迁移、数据同步、数据备份、协同计算等在数据中心内开始实现部署，数据中心内部东西向流量开始大幅度增加。&lt;/li&gt;
&lt;li&gt;虚拟机动态迁移技术在实际应用中很常见，比如需要对一台服务器进行升级和维护时，可以通过VM迁移技术将这台服务器上的VM先迁移到另一台服务器上，其间所提供的服务不中断，然后等服务器升级和维护结束后再将VM迁移回来即可。&lt;/li&gt;
&lt;li&gt;虚拟机动态迁移技术还可以充分利用计算资源，比如某公司的网购平台在某段时间内在某片区域提供促销活动，其间业务量大大增加，这样可以将其他业务量小的区域内的VM动态迁移过来，这样不会中断其他区域服务的情况下，集中利用资源，活动结束后再将VM调整回原先的区域。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592747017901.png&#34; alt=&#34;虚拟化应用大量部署&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;多数据中心大二层互联 - VXLAN&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748145388.png&#34; alt=&#34;VXLAN&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;业务快速创新、自动发放需求&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748085984.png&#34; alt=&#34;业务快速创新、自动发放需求&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;云数据中心的网络解决方案&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748176793.png&#34; alt=&#34;云数据中心的网络解决方案&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;传统三层网络架构下虚拟机动态迁移带来的问题&#34;&gt;传统三层网络架构下虚拟机动态迁移带来的问题&lt;/h5&gt;
&lt;p&gt;虚拟机迁移要求二层可达，变更虚拟机IP地址业务造成业务中断，而且相关的服务器也要进行相应的配置变更。&lt;br&gt;
当前的一些&lt;strong&gt;解决方案&lt;/strong&gt;：拓扑简化思想。通过CSS、istack技术简化拓扑，服务器处于扁平网络架构，VM在同一个二层网络中，迁移过程无需修改IP，服务不受影响，可无障碍灵活迁移。&lt;br&gt;
该解决方案&lt;strong&gt;存在的问题&lt;/strong&gt;：MAC地址数量陡增，接入设备压力较大；多租户隔离环境中设备VLAN资源紧张；二层网络范围过大，影响网络通信效率；传统解决方案较适用于DC内部大二层互联应用&lt;/p&gt;
&lt;h3 id=&#34;vxlan部署的典型网络架构&#34;&gt;VXLAN部署的典型网络架构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748270768.png&#34; alt=&#34;VXLAN部署的典型网络架构&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;VXLAN/NVGRE/STT是三种典型的NVO3技术。&lt;/li&gt;
&lt;li&gt;是通过MAC In IP技术在IP网络之上构建逻辑二层网络。&lt;/li&gt;
&lt;li&gt;同一租户的VM彼此可以二层通信、跨三层物理网络进行迁移。&lt;/li&gt;
&lt;li&gt;相比传统L2 VPN等Overlay技术，NVO3的CE侧是虚拟或物理主机，而不是网络站点。&lt;/li&gt;
&lt;li&gt;此外主机具有可移动性。&lt;/li&gt;
&lt;li&gt;目前，一般是IT厂商主导，通过服务器的Hypervisor来构建Overlay网络。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vxlan组网逻辑架构&#34;&gt;VXLAN组网逻辑架构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748349641.png&#34; alt=&#34;VXLAN组网逻辑架构&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;VXLAN是IETF NVO3定义的NVO3标准技术之一，采用MAC in UDP封装方式，将二层报文用三层协议进行封装，可对二层网络在三层范围进行扩展，同时支持24bits的VNI ID（16M租户能力），满足数据中心大二层VM迁移和多租户的需求。&lt;/li&gt;
&lt;li&gt;在VXLAN NVO3网络模型中，部署在VXLAN网络边缘的设备称为 VXLAN NVE（Network Virtualization Edge，网络虚拟边缘），主要负责VLAN网络与VXLAN网络间的封装和解封装。经过NVE封装转换后，NVE间就可基于L3基础网络建立Overlay二层虚拟化网络。&lt;/li&gt;
&lt;li&gt;VXLAN技术特点：
&lt;ul&gt;
&lt;li&gt;位置无关性：业务可在任意位置灵活部署，缓解了服务器虚拟化后相关的网络扩展问题。&lt;/li&gt;
&lt;li&gt;可扩展性：在传统网络架构上规划新的Overlay网络，部署方便，同时避免了大二层的广播风暴问题，可扩展性极强。&lt;/li&gt;
&lt;li&gt;部署简单：由高可靠SDN Controller完成控制面的配置和管理，避免了大规模的分布式部署，同时集中部署模式可加速网络和安全基础架构的配置，提高可扩展性。&lt;/li&gt;
&lt;li&gt;适合云业务：可实现千万级别的租户间隔离，有力地支持了云业务的大规模部署。&lt;/li&gt;
&lt;li&gt;技术优势：VXLAN利用了现有通用的UDP进行传输，成熟性极高。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vxlan网关&#34;&gt;VXLAN网关&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748495817.png&#34; alt=&#34;VXLAN网关&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;NVE是服务器虚拟化层的一个功能模块，虚拟机通过虚拟化软件直接建立VTEP隧道。&lt;/li&gt;
&lt;li&gt;NVE也可以是一台支持VXLAN的接入交换机集中为多租户提供VXLAN网关服务。&lt;/li&gt;
&lt;li&gt;VXLAN网关可以实现不同VXLAN下租户间通信，也能实现VXLAN用户与非VXLAN用户间通信，这和VLANIF接口的功能是类似的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vxlan报文封装&#34;&gt;VXLAN报文封装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;VXLAN是IETF定义的NVO3（Network Virtualization over Layer3）标准技术之一。&lt;/li&gt;
&lt;li&gt;采用Mac in UDP封装方式将二层报文用三层协议进行封装。&lt;/li&gt;
&lt;li&gt;支持24bits的VNI ID ，满足数据中心大二层VM迁移和多租户的需求。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748576160.png&#34; alt=&#34;VXLAN报文封装&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;VXLAN头封装：
&lt;ul&gt;
&lt;li&gt;VNI：VXLAN网络标识，24比特，用于区分VXLAN段。&lt;/li&gt;
&lt;li&gt;Reserved：24比特和8比特，必须设置为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外层UDP头封装：
&lt;ul&gt;
&lt;li&gt;目的UDP端口号是4789。源端口号是内层以太报文头通过哈希算法计算后的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外层IP头封装：
&lt;ul&gt;
&lt;li&gt;源IP地址为发送报文的虚拟机所属VTEP的IP地址；目的IP地址是目的虚拟机所属VTEP的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外层Ethernet头封装：
&lt;ul&gt;
&lt;li&gt;SA：发送报文的虚拟机所属VTEP的MAC地址。&lt;/li&gt;
&lt;li&gt;DA：目的虚拟机所属VTEP上路由表中直连的下一跳MAC地址。&lt;/li&gt;
&lt;li&gt;VLAN Type：可选字段，当报文中携带VLAN Tag时，该字段取值为0x8100。&lt;/li&gt;
&lt;li&gt;Ethernet Type：以太报文类型，IP协议报文该字段取值为0x0800。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;vxlan数据封装过程&#34;&gt;VXLAN数据封装过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748794075.png&#34; alt=&#34;VXLAN数据封装过程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;基于sdn的vxlan基本组网&#34;&gt;基于SDN的VXLAN基本组网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592748847613.png&#34; alt=&#34;基于SDN的VXLAN基本组网&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;实验一&#34;&gt;实验一&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1591583151232.png&#34; alt=&#34;实验一&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;pc1、pc2和pc4、pc5实现通信（VLAN10），pc3和pc6通信（VLAN20）&lt;/li&gt;
&lt;li&gt;pc7和pc4、pc5通信，但是不能和pc1和pc2通信&lt;/li&gt;
&lt;li&gt;pc8和pc6通信，但是不能和pc3通信&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1
sys
sys sw1
vlan batch 10 20 100 200
int g0/0/1
port link tr
port trunk allow vlan 10 20 100 200
port-group group-member g0/0/2 to g0/0/3
port link access
port default vlan 10
q
int g0/0/4
port link access
port default vlan 20
# sw2
sys
sys sw2
vlan batch 10 20 100 200
int g0/0/1
port hybrid tagged vlan 10 20 100 200
int g0/0/2
port hybrid tagged vlan 10 20 100 200
port-group group-member g0/0/3 to g0/0/4
port hybrid untagged vlan 10 100
port hybrid pvid vlan 10
q
int g0/0/5
port hybrid untagged vlan 20 200
port hybrid pvid vlan 20
# sw3
sys
sys sw3
vlan batch 10 20 100 200
int g0/0/1
port link tr
port trunk allow vlan 10 20 100 200
int g0/0/2
port hybrid untagged vlan 10 100
port hybrid pvid vlan 100
int g0/0/3
port hybrid untagged vlan 20 200
port hybrid pvid vlan 200
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二mux-vlan&#34;&gt;实验二：Mux Vlan&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1591712174048.png&#34; alt=&#34;Mux Vlan&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;vlan50内的主机可以相互通信&lt;/li&gt;
&lt;li&gt;vlan60内的主机不能相互通信&lt;/li&gt;
&lt;li&gt;vlan50和vlan60内的所有主机均可以访问vlan100中的pc5&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# .............................配置Mux vlan
vlan batch 50 60 100 #创建vlan
vlan 100
mux-vlan # 配置主vlan
subordinate group 50 # 配置mux vlan 中的互通型从vlan
subordinate separate 60 # 配置mux vlan 中的隔离型从vlan
port-group group-member g0/0/1 to g0/0/2
port link access
port default vlan 50
port mux-vlan enable  # 使能端口下的mux vlan功能：互通型从vlan
port-group group-member g0/0/3 to g0/0/4
port link access
port default vlan 60
port mux-vlan enable  # 使能端口下的mux vlan功能：隔离型从vlan
int g0/0/5
port link access
port default vlan 100
port mux-vlan enable # 使能端口下的mux vlan功能：主vlan
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三vlan聚合和端口隔离&#34;&gt;实验三：Vlan聚合和端口隔离&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1591800550861.png&#34; alt=&#34;Vlan聚合&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Vlan聚合：所有vlan共享一个网段全网互通&lt;/li&gt;
&lt;li&gt;端口隔离：pc1和PC2不能互访，PC3和pc4可以互访且可以访问PC1和PC2&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.............................Vlan聚合
# SW1
sys
sys SW1
vlan batch 10 20 100 200
port -group group-member g0/0/2 to g0/0/3
port link acc
port default vlan 10
port -group group-member g0/0/4 to g0/0/5
port link acc
port default vlan 20
q
vlan 100
aggregate-vlan  # Super-VLAN由多个Sub-VLAN组成，不能加入物理端口，但可以创建VLANIF接口并配置IP地址
access-vlan 10  # 将多个Sub-VLAN批量加入到Super-VLAN中，必须保证这些Sub-VLAN没有创建对应的VLANIF接口
access-vlan 20 
int vlan 100
ip add 10.10.10.1 24
arp-proxy inter-sub-vlan-proxy enable # 开启vlan间的arp代理
int vlan 200
ip addr 10.10.200.1 24
int g0/0/1
port default vlan 200
# AR1
sys
sys AR1
int g0/0/0
ip addr 10.10.200.254 24
q
ip route-static 10.10.10.0 24 10.10.200.1
ip route-static 10.10.20.0 24 10.10.200.1
int lo 0
ip addr 8.8.8.8 32
q
ip route-static 0.0.0.0 0 10.10.200.254
#.............................端口隔离
# SW1
sys
sys SW1
vlan batch 100
port -group group-member g0/0/2 to g0/0/5
port link acc
port default vlan 100
# 方法一：接口下配置
int g0/0/2
port-isolate enable
int g0/0/3
port-isolate enable
# 方法二：配置隔离端口组
port-isolate mode all  # 全部隔离为all(即二层三层都隔离)，二层隔离为l2
int g0/0/2
port-isolate enable group 1
int g0/0/3
port-isolate enable group 1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验四mstp&#34;&gt;实验四：MSTP&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592231253786.png&#34; alt=&#34;MSTP&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1
sys 
sys SW1
vlan batch 1 to 20
port-group gr g0/0/1 to g0/0/3
port link trunk
port tr allow all
stp region-configuration
region-name hcie
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
stp instance 10 root primary
stp instance 11 root secondary
# SW2
sys 
sys SW2
vlan batch 1 to 20
port-group gr g0/0/1 to g0/0/3
port link trunk
port tr allow all
stp region-configuration
region-name hcie
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
stp instance 11 root primary
stp instance 10 root secondary
# SW3
sys 
sys SW3
vlan batch 1 to 20
port-group gr g0/0/1 to g0/0/3
port link trunk
port tr allow all
stp region-configuration
region-name hcie
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration

# SW4
sys 
sys SW4
vlan batch 1 to 20
port-group gr g0/0/1 to g0/0/3
port link trunk
port tr allow all
stp region-configuration
region-name hcie
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验五mstp域&#34;&gt;实验五：MSTP域&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592319405083.png&#34; alt=&#34;MSTP域&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# SW1
sys
sys SW1
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp root primary # 设置为总根
stp region-configuration
region-name qyt
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
# SW2
sys
sys SW2
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name qyt
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
# SW3
sys
sys SW3
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name qyt
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
# ---------------------------
# SW4
sys
sys SW4
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name huawei
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
stp instance 10 root primary
stp instance 11 root secondary
# SW5
sys
sys SW5
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name huawei
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
# SW6
sys
sys SW6
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name huawei
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
stp instance 11 root primary
stp instance 10 root secondary
# SW10
sys
sys SW10
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name huawei
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
# ------------------------------
# SW7
sys
sys SW7
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name cisco
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
# SW8
sys
sys SW8
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name cisco
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
# SW9
sys
sys SW9
vlan batch 1 to 20
port-group group-member g0/0/1 to g0/0/4
port link trunk
port tr allow vlan all
stp region-configuration
region-name cisco
revision-level 10
instance 10 vlan 1 to 10
instance 11 vlan 11 to 20
active region-configuration
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验六bfd&#34;&gt;实验六：BFD&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592719051176.png&#34; alt=&#34;BFD&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# BFD和静态联动
# AR1
bfd
bfd qyt bind peer-ip 12.1.1.2 interface GigabitEthernet0/0/0 source-ip 12.1.1.1 auto
commit
ip route-static 100.100.100.100 255.255.255.255 12.1.1.2 track bfd-session qyt
# AR2
bfd
bfd qyt bind peer-ip 12.1.1.1 interface GigabitEthernet0/0/0 source-ip 12.1.1.2 auto
commit

# BFD的单臂回声
# 即单向检测，应用于一端设备不支持BFD的情况下
# AR1
bfd
bfd qyt bind peer-ip 12.1.1.2 interface GigabitEthernet0/0/0 source-ip 12.1.1.1 one-arm-echo
discriminator local 1
commit
ip route-static 100.100.100.100 255.255.255.255 12.1.1.2 track bfd-session qyt

# BFD和OSPF联动
# AR1
bfd
q
ospf 10 router-id 1.1.1.1 
bfd all-interfaces enable
# AR2
bfd
q
ospf 10 router-id 2.2.2.2
bfd all-interfaces enable

# BFD和BGP联动
# AR1
bfd
q
bgp 100
router-id 1.1.1.1
peer 2.2.2.2 as-number 100
peer 2.2.2.2 connect-interface lo 0
peer 2.2.2.2 bfd enable
# AR2
bfd
q
bgp 100
router-id 2.2.2.2
peer 1.1.1.1 as-number 100
peer 1.1.1.1 connect-interface lo 0
peer 1.1.1.1 bfd enable
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592720892915.png&#34; alt=&#34;BFD和VRRP联动&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# BFD和VRRP联动
# 接口断掉之后优先级减30
# AR1
sys
sys AR1
int g0/0/1
ip addr 14.1.1.1 24
int g0/0/0
ip addr 192.168.10.1 24
vrrp vrid 10 virtual-ip 192.168.10.254
vrrp vrid 10 priority 120
vrrp vrid 10 preempt-mode timer delay 10
ospf 10 router 1.1.1.1
area 0
network 192.168.10.1 0
network 14.1.1.1 0
q
silent-interface g0/0/0
bfd qyt bind peer-ip 14.1.1.4 interface GigabitEthernet0/0/1 source-ip 14.1.1.1 auto
q
int g0/0/0
vrrp vrid 10 track bfd-session session-name qyt reduced 30

# AR2
sys
sys AR2
int g0/0/1
ip addr 24.1.1.2 24
int g0/0/0
ip addr 192.168.10.2 24
vrrp vrid 10 virtual-ip 192.168.10.254
vrrp vrid 10 preempt-mode timer delay 10
ospf 10 router 2.2.2.2
area 0
network 192.168.10.2 0
network 24.1.1.2 0
q
silent-interface g0/0/0

# AR4
int g0/0/0
ip addr 14.1.1.4 24
int g0/0/1
ip addr 24.1.1.4 24
int lo 0
ip addr 8.8.8.8 32
ospf 10 router 4.4.4.4
area 0
network 8.8.8.8
network 24.1.1.4 0
network 14.1.1.4 0
bfd qyt bind peer-ip 14.1.1.1 interface GigabitEthernet0/0/0 source-ip 14.1.1.4 auto
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验七端口镜像&#34;&gt;实验七：端口镜像&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1592727706876.png&#34; alt=&#34;端口镜像&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 初始化呢配置
# AR1
sys
sys AR1
int g0/0/0
ip addr 192.168.10.1 24
int g0/0/1
ip addr 12.1.1.1 24
int g0/0/2
ip addr 192.168.30.1 24
int g1/0/0
ip addr 192.168.20.1 24
ospf 10 route 1.1.1.1
a 0
network 192.168.0.0 0.0.255.255
q
silent-interface g0/0/0
silent-interface g1/0/0
silent-interface g0/0/2
# SW1/2
stp disable
# AR2
sys
sys AR2
int g0/0/0
ip addr 12.1.1.2 24
int lo 0
ip addr 8.8.8.8 32
ospf 10 route 2.2.2.2
a 0
network 8.8.8.8 0
# 镜像端口配置
# 将AR1的g0/0/0为镜像端口，g0/0/2为观察端口
# AR1
observe-port int g0/0/2　# 首先需要配置观察端口
# 跨路由器或交换机配置观察端口：observe-server destination-ip 2.2.2.2 source-ip 1.1.1.1
######## 监控g0/0/0上的全部流量
int g0/0/0  # 配置镜像端口
mirror to observe-port both  # [both/inbound/outbound]
######## 针对特定流量监控，只监控PC1的流量
acl 2001
rule permit source 192.168.10.10 0
q
traffic classifier C1
if-match acl 2001
q
traffic behavior B1
mirror to observe-port 
q
traffic policy P1
classifier C1 behavior B1
int g0/0/0
traffic-policy P1 inbound
&lt;/code&gt;&lt;/pre&gt;
">07 交换（2020.0601）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/chang-yong-yum-yuan-zheng-li/"" data-c="
          &lt;h1 id=&#34;rpm包常用下载地址&#34;&gt;rpm包常用下载地址&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://centos.pkgs.org/&#34;&gt;https://centos.pkgs.org/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://rpmfind.net/&#34;&gt;https://rpmfind.net/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://dl.fedoraproject.org/pub/&#34;&gt;https://dl.fedoraproject.org/pub/&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/apache/&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/apache/&lt;/a&gt;：tomcat、hadoop、kafka等&lt;/p&gt;
&lt;h1 id=&#34;yum配置文件&#34;&gt;yum配置文件&lt;/h1&gt;
&lt;h2 id=&#34;developmentrepo&#34;&gt;development.repo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[base]
name=CentOS-$releasever - Base
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/
enabled=1
gpgcheck=0

[updates]
name=CentOS-$releasever - Updates
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/updates/$basearch/
enabled=1
gpgcheck=0

[extras]
name=CentOS-$releasever - Extras
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/extras/$basearch/
enabled=1
gpgcheck=0

[centosplus]
name=CentOS-$releasever - Plus
baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/centosplus/$basearch/
gpgcheck=0
enabled=1
 
[epel]
name=Extra Packages for Enterprise Linux 7 - $basearch
baseurl=http://download.fedoraproject.org/pub/epel/$releasever/$basearch
enabled=1
gpgcheck=0

[epel-debuginfo]
name=Extra Packages for Enterprise Linux 7 - $basearch - Debug
baseurl=http://download.fedoraproject.org/pub/epel/$releasever/$basearch/debug
enabled=1
gpgcheck=0

[epel-source]
name=Extra Packages for Enterprise Linux 7 - $basearch - Source
baseurl=http://download.fedoraproject.org/pub/epel/$releasever/SRPMS
enabled=1
gpgcheck=0

[epel-testing]
name=Extra Packages for Enterprise Linux 7 - Testing - $basearch
baseurl=http://download.fedoraproject.org/pub/epel/testing/$releasever/$basearch
enabled=1
gpgcheck=0

[epel-testing-debuginfo]
name=Extra Packages for Enterprise Linux 7 - Testing - $basearch - Debug
baseurl=http://download.fedoraproject.org/pub/epel/testing/$releasever/$basearch/debug
enabled=1
gpgcheck=0

[epel-testing-source]
name=Extra Packages for Enterprise Linux 7 - Testing - $basearch - Source
baseurl=http://download.fedoraproject.org/pub/epel/testing/$releasever/SRPMS
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;phprepo&#34;&gt;php.repo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[webtatic]
name=Webtatic Repository EL7 - $basearch
baseurl=https://repo.webtatic.com/yum/el7/$basearch/
enabled=1
gpgcheck=0

[webtatic-debuginfo]
name=Webtatic Repository EL7 - $basearch - Debug
baseurl=https://repo.webtatic.com/yum/el7/$basearch/debug/
enabled=1
gpgcheck=0

[webtatic-source]
name=Webtatic Repository EL7 - $basearch - Source
baseurl=https://repo.webtatic.com/yum/el7/SRPMS/
enabled=1
gpgcheck=0

[webtatic-archive]
name=Webtatic Repository EL7 - $basearch - Archive
baseurl=https://repo.webtatic.com/yum/el7-archive/$basearch/
enabled=1
gpgcheck=0

[webtatic-archive-debuginfo]
name=Webtatic Repository EL7 - $basearch - Archive Debug
baseurl=https://repo.webtatic.com/yum/el7-archive/$basearch/debug/
enabled=1
gpgcheck=0

[webtatic-archive-source]
name=Webtatic Repository EL7 - $basearch - Archive Source
baseurl=https://repo.webtatic.com/yum/el7-archive/SRPMS/
enabled=1
gpgcheck=0

[webtatic-testing]
name=Webtatic Repository EL7 - $basearch - Testing
baseurl=https://repo.webtatic.com/yum/el7-testing/$basearch/
enabled=1
gpgcheck=0

[webtatic-testing-debuginfo]
name=Webtatic Repository EL7 - $basearch - Testing Debug
baseurl=https://repo.webtatic.com/yum/el7-testing/$basearch/debug/
enabled=1
gpgcheck=0

[webtatic-testing-source]
name=Webtatic Repository EL7 - $basearch - Testing Source
baseurl=https://repo.webtatic.com/yum/el7-testing/SRPMS/
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;nginxrepo&#34;&gt;nginx.repo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1

[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mariadbrepo&#34;&gt;mariadb.repo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 如果需要其他版本，则到https://mirrors.ustc.edu.cn/mariadb/yum/上选择想要的版本生成repo文件内容
[mariadb]
name = MariaDB
baseurl = https://mirrors.ustc.edu.cn/mariadb/yum/10.5/centos74-amd64/
enabled=1
gpgcheck=0
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;onlyofficerepo&#34;&gt;onlyoffice.repo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[onlyoffice]
name=onlyoffice repo
baseurl=http://download.onlyoffice.com/repo/centos/main/noarch/
gpgcheck=0
enabled=1
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;dockerrepo&#34;&gt;docker.repo&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[docker-ce-stable]
name=Docker CE Stable - $basearch
baseurl=https://download.docker.com/linux/centos/$releasever/$basearch/stable
enabled=1
gpgcheck=0

[docker-ce-stable-debuginfo]
name=Docker CE Stable - Debuginfo $basearch
baseurl=https://download.docker.com/linux/centos/$releasever/debug-$basearch/stable
enabled=0
gpgcheck=0

[docker-ce-stable-source]
name=Docker CE Stable - Sources
baseurl=https://download.docker.com/linux/centos/$releasever/source/stable
enabled=1
gpgcheck=0

[docker-ce-test]
name=Docker CE Test - $basearch
baseurl=https://download.docker.com/linux/centos/$releasever/$basearch/test
enabled=1
gpgcheck=0

[docker-ce-test-debuginfo]
name=Docker CE Test - Debuginfo $basearch
baseurl=https://download.docker.com/linux/centos/$releasever/debug-$basearch/test
enabled=1
gpgcheck=0

[docker-ce-test-source]
name=Docker CE Test - Sources
baseurl=https://download.docker.com/linux/centos/$releasever/source/test
enabled=1
gpgcheck=0

[docker-ce-nightly]
name=Docker CE Nightly - $basearch
baseurl=https://download.docker.com/linux/centos/$releasever/$basearch/nightly
enabled=1
gpgcheck=0

[docker-ce-nightly-debuginfo]
name=Docker CE Nightly - Debuginfo $basearch
baseurl=https://download.docker.com/linux/centos/$releasever/debug-$basearch/nightly
enabled=1
gpgcheck=0

[docker-ce-nightly-source]
name=Docker CE Nightly - Sources
baseurl=https://download.docker.com/linux/centos/$releasever/source/nightly
enabled=1
gpgcheck=0

[libnvidia-container]
name=libnvidia-container
baseurl=https://nvidia.github.io/libnvidia-container/centos7/$basearch
gpgcheck=0
enabled=1

[nvidia-container-runtime]
name=nvidia-container-runtime
baseurl=https://nvidia.github.io/nvidia-container-runtime/centos7/$basearch
gpgcheck=0
enabled=1

[nvidia-docker]
name=nvidia-docker
baseurl=https://nvidia.github.io/nvidia-docker/centos7/$basearch
gpgcheck=0
enabled=1
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;整理-需要下载资源&#34;&gt;整理--需要下载资源&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/centos/7.8.2003/centosplus/x86_64/
https://mirrors.tuna.tsinghua.edu.cn/centos/7.8.2003/extras/x86_64/
https://mirrors.tuna.tsinghua.edu.cn/centos/7.8.2003/updates/x86_64/
https://mirrors.tuna.tsinghua.edu.cn/centos/7.8.2003/os/x86_64/
https://mirrors.tuna.tsinghua.edu.cn/epel/7/x86_64/
https://mirrors.tuna.tsinghua.edu.cn/epel/testing/7/x86_64/
https://repo.webtatic.com/yum/el7/x86_64/
https://repo.webtatic.com/yum/el7/SRPMS/
http://archive.webtatic.com/yum/el7-archive/
https://repo.webtatic.com/yum/el7-testing/
http://download.onlyoffice.com/ #无法用爬虫，但可用wget，文件&amp;quot;onlyoffice下载命令.txt&amp;quot;
http://nginx.org/packages/centos/7Workstation/x86_64/
http://nginx.org/packages/centos/7Server/x86_64/
http://nginx.org/packages/centos/7Client/x86_64/
http://nginx.org/packages/centos/7/x86_64/
http://nginx.org/packages/mainline/centos/7Workstation/x86_64/
http://nginx.org/packages/mainline/centos/7Server/x86_64/
http://nginx.org/packages/mainline/centos/7Client/x86_64/
http://nginx.org/packages/mainline/centos/7/x86_64/
&lt;/code&gt;&lt;/pre&gt;
">常用yum源整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/06-ipv620200523/"" data-c="
          &lt;h1 id=&#34;ipv6原理描述&#34;&gt;IPv6原理描述&lt;/h1&gt;
&lt;h2 id=&#34;ipv6基础描述&#34;&gt;IPv6基础描述&lt;/h2&gt;
&lt;h3 id=&#34;ipv6特点&#34;&gt;IPv6特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;地址空间大，IPv4是32位，而IPv6是128位&lt;/li&gt;
&lt;li&gt;支持分层结构&lt;/li&gt;
&lt;li&gt;无需NAT技术，更有利于寻址&lt;/li&gt;
&lt;li&gt;支持单播、组播和任意播（特殊单播） ，取消了广播&lt;/li&gt;
&lt;li&gt;可以实现无状态的配置（EUI64）&lt;/li&gt;
&lt;li&gt;简化了报文格式&lt;/li&gt;
&lt;li&gt;加强了扩展报文头部的支持&lt;/li&gt;
&lt;li&gt;流标签，比用五元组定义流更加方便&lt;/li&gt;
&lt;li&gt;认证 ipsec&lt;/li&gt;
&lt;li&gt;对移动网络的支持&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ipv6地址表示方法&#34;&gt;IPv6地址表示方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IPv6地址包括128比特，由冒号分割成8段，每段4个16进制数，例如：2031:0000:130F:0000:0000:09C0:876A:130B&lt;/li&gt;
&lt;li&gt;IPv6压缩格式
&lt;ul&gt;
&lt;li&gt;每组中的前导“0”都可以省略，例如：2031:0:130F:0:0:9C0:876A:130B&lt;/li&gt;
&lt;li&gt;地址中包含的连续两个或多个均为0的组，可以用双冒号“::”来代替（&lt;strong&gt;一个地址中仅能使用一次&lt;/strong&gt;），例如：2031:0:130F::9C0:876A:130B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ipv6地址结构&#34;&gt;IPv6地址结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;IPv6地址分两部分
&lt;ul&gt;
&lt;li&gt;网络前缀，n比特，相当于IPv4中的网络ID&lt;/li&gt;
&lt;li&gt;接口标识，128-n比特相当于IPv4中的主机ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接口标识生成方法
&lt;ul&gt;
&lt;li&gt;手工配置&lt;/li&gt;
&lt;li&gt;系统通过软件自动生成&lt;/li&gt;
&lt;li&gt;IEEE EUI-64规范自动生成（依据MAC地址生成）
&lt;ol&gt;
&lt;li&gt;将MAC地址中间插入FFFE，例如：00e0-fc4c-5103转换成00e0-fc&lt;strong&gt;ff-fe&lt;/strong&gt;4c-5103&lt;/li&gt;
&lt;li&gt;将第七位由0变为1，表示该接口标识是全球唯一，例如&lt;br&gt;
00e0-fcff-fe4c-5103&lt;br&gt;
-----&amp;gt; 00000000-e0-fcff-fe4c-5103&lt;br&gt;
-----&amp;gt; 000000&lt;strong&gt;1&lt;/strong&gt;0-e0-fcff-fe4c-5103&lt;br&gt;
-----&amp;gt; 02e0:fcff:fe4c:5103&lt;br&gt;
-----&amp;gt; &lt;strong&gt;2001:12:12:12&lt;/strong&gt;:2E0:FCFF:FE4C:5103&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ipv6配置&#34;&gt;IPv6配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 第一步：全局使能IPv6
ipv6 
# 第二步：接口使能IPv6
int g0/0/0
ipv6 enable 
ipv6 address 2001:12:12:12::/64 eui-64
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;对于IPv6单播地址来说，如果地址的前3比特不是000，则接口标识必须为64位；如果地址的前3位是000，则没有此限制&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;ipv6地址分类&#34;&gt;IPv6地址分类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590421077406.png&#34; alt=&#34; IPv6地址分类&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;单播地址unicast-address&#34;&gt;单播地址（Unicast Address）&lt;/h4&gt;
&lt;p&gt;标识一个接口，目的地址为单播地址的报文会被送到被标识的接口。在IPv6中，一个接口拥有多个IPv6地址是非常常见的现象。&lt;/p&gt;
&lt;h5 id=&#34;可聚合全球单播地址&#34;&gt;可聚合全球单播地址&lt;/h5&gt;
&lt;p&gt;全球单播地址定义用于IPv6 Internet，是全局唯一的和全局可路由的&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590501843637.png&#34; alt=&#34;可聚合全球单播地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似IPv4的公网地址&lt;/li&gt;
&lt;li&gt;由前缀、子网ID和接口标识组成
&lt;ul&gt;
&lt;li&gt;全局路由前缀：由提供商指定给一个组织机构，一般至少为48bit。目前已经分配的全局路由前缀的前3bit均为001,因此前缀为2000::/3&lt;/li&gt;
&lt;li&gt;子网：组织机构可以用子网ID来构建本地网络（Site），与IPv4中的子网号作用相似。子网ID通常&lt;strong&gt;最多分配到第64位&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;主机位：用来标识一个设备，与IPv4中的主机ID作用相似&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;链路本地地址&#34;&gt;链路本地地址&lt;/h5&gt;
&lt;p&gt;在一个节点启动IPv6协议栈时，节点的每个接口会自动配置一个链路本地地址，该地址专门用来和相同链路上的其他主机通信&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590502600240.png&#34; alt=&#34;链路本地地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只能在连接到同一个本地链路的节点之间使用，广泛应用于邻居发现、无状态地址等&lt;/li&gt;
&lt;li&gt;链路本地地址前缀FE80::/10，将接口ID添加在后面作为地址的低64位&lt;/li&gt;
&lt;li&gt;每个IPv6接口都必须具备一个链路本地地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;唯一本地地址&#34;&gt;唯一本地地址&lt;/h5&gt;
&lt;p&gt;为了代替站点本地地址的功能，同时为了这样的地址具有唯一性，避免产生像IPv4的私有地址泄露到公网而造成的问题，RFC4193定义了唯一本地地址&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590503134885.png&#34; alt=&#34;唯一本地地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;概念上类似于IPv4的私网地址，仅能够在本地网络使用，在IPv6 Internet上不可被路由&lt;/li&gt;
&lt;li&gt;固定前缀为FC00::/7，分为两块，其中FC00::/8暂未定义，另一块是FD00::/8，其格式如上图&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#  自动生成IPv6链路本地地址，思科只要开启了IPv6功能 ，就会自动 自成 
interface GigabitEthernet0/0/0
ipv6 enable 
ipv6 address auto link-local     
# 手工配置IPv6链路本地地址
interface GigabitEthernet0/0/0
ipv6 enable 
ipv6 address FE80:1::1 link-local  
# ping
ping ipv6  FE80::2E0:FCFF:FE56:2BF9 -i g0/0/0
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;组播地址multicast-address&#34;&gt;组播地址（Multicast Address）&lt;/h4&gt;
&lt;p&gt;标识多个接口，目的地址为组播地址的报文会被送到被标识的所有接口。只有加入相应组播组的设备接口才会侦听发往该组播地址的报文。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590504106960.png&#34; alt=&#34; 组播地址&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;类似IPv4组播地址&lt;/li&gt;
&lt;li&gt;由前缀、标志（flag）字段、范围(scope)字段和组播组ID组成
&lt;ul&gt;
&lt;li&gt;Flags：
&lt;ul&gt;
&lt;li&gt;前3位设为0&lt;/li&gt;
&lt;li&gt;最后一位定义地址类型
&lt;ul&gt;
&lt;li&gt;0=固定或众所周知&lt;/li&gt;
&lt;li&gt;1=本地分配或短期&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Scope：表示组播组的范围
&lt;ul&gt;
&lt;li&gt;此字段长度为4位，除了使用组播路由协议提供信息外，路由器还要使用组播范围段来判定组播流量能否发送出去&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590504746433.png&#34; alt=&#34;Scope&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Group ID：组播组ID
&lt;ul&gt;
&lt;li&gt;用于标识组播组，这个值在地址范围内是唯一的，此字段的长度为112位。其中，永久分配的组ID不收当前范围的限制，而临时组ID只能在某个特定的范围内有意义。而FF01::到FF0F::的组播地址数据保留地址段，而且也是永久组播地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预定义组播地址
&lt;ul&gt;
&lt;li&gt;Node-local
&lt;ul&gt;
&lt;li&gt;所有节点的组播地址：FF01:0:0:0:0:0:0:1（类似224.0.0.1）&lt;/li&gt;
&lt;li&gt;所有路由器的组播地址：FF01:0:0:0:0:0:0:2（类似224.0.0.2）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Link-local
&lt;ul&gt;
&lt;li&gt;所有节点的组播地址：FF02:0:0:0:0:0:0:1&lt;/li&gt;
&lt;li&gt;所有路由器的组播地址：FF02:0:0:0:0:0:0:2&lt;/li&gt;
&lt;li&gt;Solicited-Node组播地址：FF02:0:0:0:0:1:FFXX:XXXX 被请求节点组播地址，类似ARP&lt;/li&gt;
&lt;li&gt;所有OSPF路由器组播地址：FF02:0:0:0:0:0:0:5&lt;/li&gt;
&lt;li&gt;所有OSPF的DR路由器组播地址：FF02:0:0:0:0:0:0:6&lt;/li&gt;
&lt;li&gt;所有RIP路由器组播地址：FF02:0:0:0:0:0:0:9&lt;/li&gt;
&lt;li&gt;所有PIM路由器组播地址：FF02:0:0:0:0:0:0:D&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;组播地址的mac地址映射&#34;&gt;组播地址的MAC地址映射&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590505247365.png&#34; alt=&#34;组播地址的MAC地址映射&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;在以太网中，一个组播IPv6报文必须执行以太网封装&lt;/li&gt;
&lt;li&gt;组播IPv6报文的目的IP地址是组播IPv6地址，而目的mac地址则必须是组播mac地址，并且该地址必须与组播IPv6地址对应&lt;/li&gt;
&lt;li&gt;33-33是专门为IPv6组播预留的mac地址前缀，mac地址的后32bit从对应的组播IPv6地址的后32bit复制而来&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;请求节点组播地址solicited-node&#34;&gt;请求节点组播地址（Solicited-Node）&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590505839548.png&#34; alt=&#34;请求节点组播地址&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;IPv6中特有的组播地址
&lt;ul&gt;
&lt;li&gt;每个节点必须为分配给他的每个单播和任播地址加入一个组播地址，用于DAD地址重复检测&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Solicited-Node组播地址生成过程
&lt;ul&gt;
&lt;li&gt;接口ID(接口IPv6地址)的后24位：xx:xxxx&lt;/li&gt;
&lt;li&gt;前缀：FF02:0:0:0:0:1:FF，例如主机的mac地址为00-02-b3-&lt;strong&gt;1e-83-29&lt;/strong&gt;，IPv6地址为fe80::0202:b3ff:fe&lt;strong&gt;1e:8329&lt;/strong&gt;，则请求节点组播地址为发ff02::1:ff&lt;strong&gt;1e:8329&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;任播地址anycast-address&#34;&gt;任播地址（Anycast Address）&lt;/h4&gt;
&lt;p&gt;任播地址标识一组网络接口（通常属于不同的节点）。目标地址是任播地址的数据包将发送给其中路由意义上最近的一个网络接口。任播地址与单播地址使用同一个地址空间&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置任播地址
ipv6 address 2001:12:1::1/64 anycast   
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;任播地址和单播地址使用相同的地址空间&lt;/li&gt;
&lt;li&gt;任播地址只可以被分配给路由设备，不能应用于主机，不能做为IPv6报文的源地址&lt;/li&gt;
&lt;li&gt;配置时需明确表示任播地址，用来区别单播和任播&lt;/li&gt;
&lt;li&gt;子网路由器任播地址
&lt;ul&gt;
&lt;li&gt;发送到子网路由器任播地址的报文会被发送到该地址标识的子网中路由意义上最近的一个路由器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主机的ipv6地址&#34;&gt;主机的IPv6地址&lt;/h3&gt;
&lt;p&gt;只有一个网络是配置的IPv4主机通常会为该适配器分配单一的IPv4地址，而IPv6主机则会为每个适配器分配多个IPv6地址。典型的IPv6主机上的接口通常会分配到如下单播地址：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个接口分配到一个链路本地地址&lt;/li&gt;
&lt;li&gt;每个接口分配到二外的单播地址（可以是单个或者多个唯一本地地址或全球地址）&lt;/li&gt;
&lt;li&gt;环回接口分配到环回地址::1&lt;/li&gt;
&lt;li&gt;接口本地范围内所有节点的组播地址FF01::1&lt;/li&gt;
&lt;li&gt;链路本地范围内所有节点的组播地址FF02::1&lt;/li&gt;
&lt;li&gt;每个单播地址的请求节点地址&lt;/li&gt;
&lt;li&gt;已加入的组的组播地址&lt;br&gt;
典型的IPv6主机通常是多宿主的，因为IPv6主机总是至少拥有两个可以接收数据包的地址——用于接收本地链路流量的链路本地和可路由的唯一本地或全球地址&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由器的ipv6地址&#34;&gt;路由器的IPv6地址&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;单播地址
&lt;ol&gt;
&lt;li&gt;每个接口分配到一个链路本地地址&lt;/li&gt;
&lt;li&gt;每个接口分配到额外的单播地址（可以是单个或者多个唯一本地地址或全球地址）&lt;/li&gt;
&lt;li&gt;环回接口分配到的环回地址::1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;任播地址
&lt;ol&gt;
&lt;li&gt;每个子网分配到的一个子网路由器的任播地址&lt;/li&gt;
&lt;li&gt;额外的任播地址（可选）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;侦听如下组播地址的流量
&lt;ol&gt;
&lt;li&gt;接口本地范围内所有节点的组播地址FF01::1&lt;/li&gt;
&lt;li&gt;接口本地范围内所有路由器的组播地址FF01::2&lt;/li&gt;
&lt;li&gt;链路本地范围内所有节点的组播地址FF02::1&lt;/li&gt;
&lt;li&gt;链路本地范围内所有路由器的组播地址FF02::2&lt;/li&gt;
&lt;li&gt;每个单播地址的请求节点地址&lt;/li&gt;
&lt;li&gt;已加入的组的组播地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ipv6报文格式&#34;&gt;IPv6报文格式&lt;/h3&gt;
&lt;h4 id=&#34;基本报头&#34;&gt;基本报头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590509355658.png&#34; alt=&#34;基本报头&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590509741991.png&#34; alt=&#34;字段解释&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IPv6基本报头、IPv6扩展报头和上层协议数据单元&lt;/li&gt;
&lt;li&gt;IPv6基本报头有8个字段，固定大小为40字节，每个IPv6数据报都必须包含报头，基本报头提供报文转发的基本信息，会被转发路径上面的所有路由器解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;扩展报头&#34;&gt;扩展报头&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590509989601.png&#34; alt=&#34;扩展报头&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
扩展报头是可选的，只有需要该扩展报头对应的功能时，数据的发送者才会添加相应的扩展报头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将原IPv4选项字段放入扩展报头&lt;/li&gt;
&lt;li&gt;IPv6报文包含0、1或者多个扩展报头&lt;/li&gt;
&lt;li&gt;固定为8字节长度的整数倍&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;扩展报头种类&#34;&gt;扩展报头种类&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590510189695.png&#34; alt=&#34;扩展报头种类&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;扩展报头规约&#34;&gt;扩展报头规约&lt;/h5&gt;
&lt;p&gt;当超过一种扩展报头被用在同一个分组里时，报头必须按照下列顺序出现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IPv6基本报头&lt;/li&gt;
&lt;li&gt;逐跳选项扩展报头&lt;/li&gt;
&lt;li&gt;目的选项扩展报头&lt;/li&gt;
&lt;li&gt;路由扩展报头&lt;/li&gt;
&lt;li&gt;分段扩展报头&lt;/li&gt;
&lt;li&gt;认证扩展报头&lt;/li&gt;
&lt;li&gt;封装安全有效载荷扩展报头&lt;/li&gt;
&lt;li&gt;目的选项扩展报头&lt;/li&gt;
&lt;li&gt;上层协议数据报文&lt;br&gt;
路由设备转发时根据基本报头中的NextHeader值来决定是否要处理扩展头，并不是所有的扩展报头都需要被转发路由设备查看和处理的。&lt;br&gt;
除了目的选项扩展报头可能出现一次或者两次（一次在路由扩展报头之前，一次在上层协议数据报文之前），其余扩展报头只能出现一次。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;ipv6基本实现&#34;&gt;IPv6基本实现&lt;/h2&gt;
&lt;h3 id=&#34;icmpv6&#34;&gt;ICMPv6&lt;/h3&gt;
&lt;p&gt;实现邻接点发现、无状态地址配置（包括重复地址检测）、PMTU发现等&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590591063496.png&#34; alt=&#34;报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;差错报文分类&#34;&gt;差错报文分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;目的不可达错误报文（类型一）：数据包无法被转发到目标节点或上层协议&lt;/li&gt;
&lt;li&gt;数据包过大错误报文（类型二）：报文超过出接口的链路MTU&lt;/li&gt;
&lt;li&gt;时间超时错误报文（类型三）：Hop Limit字段值等于0；分段重组报文超时&lt;/li&gt;
&lt;li&gt;参数错误报文（类型四）：IPv6报头或者扩展报头出现错误&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;信息报文分类&#34;&gt;信息报文分类&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;回送&lt;strong&gt;请求报文&lt;/strong&gt;：发送到目标节点，使目标节点立即发回一个会送应答报文。回送请求报文的类型字段值为&lt;strong&gt;128&lt;/strong&gt;，代码字段值为0&lt;/li&gt;
&lt;li&gt;回送&lt;strong&gt;应答报文&lt;/strong&gt;：对回送请求报文的应答。回送应答报文的类型字段值为&lt;strong&gt;129&lt;/strong&gt;，代码字段值为0&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;邻居发现协议ndp&#34;&gt;邻居发现协议NDP&lt;/h3&gt;
&lt;p&gt;邻居发现协议NDP（Neighbor Discovery Protocol）是IPv6协议体系中一个重要的基础协议。邻居发现协议替代了IPv4的ARP（Address Resolution Protocol）和ICMP路由器发现（Router Discovery），它定义了使用ICMPv6报文实现地址解析，跟踪邻居状态，重复地址检测，路由器发现以及重定向等功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻居通告报文:
&lt;ul&gt;
&lt;li&gt;邻居请求报文NS：类型字段值为135。&lt;/li&gt;
&lt;li&gt;邻居通告报文NA：类型字段值为136。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在路由器发现中使用了两种ICMPv6报文：路由器通告和路由器请求报文:
&lt;ul&gt;
&lt;li&gt;路由器通告RA：类型字段值为134。&lt;/li&gt;
&lt;li&gt;路由器请求RS：类型字段值为133。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;重定向使用了一种ICMPv6报文：重定向报文。
&lt;ul&gt;
&lt;li&gt;重定向报文：类型字段值为137。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;跟踪邻居状态&#34;&gt;跟踪邻居状态&lt;/h3&gt;
&lt;p&gt;通过邻居或到达邻居的通信，会因各种原因而中断，包括硬件故障、接口下的热插入等。&lt;br&gt;
如果目的地失效，则恢复是不可能的，通信失败；&lt;br&gt;
如果路径失效，则恢复是可能的。&lt;br&gt;
因此节点需要维护一张邻居表，每个邻居都有相应的状态，状态之间可以迁移。&lt;br&gt;
5种邻居状态：未完成（Incomplete）、可达（Reachable）、陈旧（Stale）、延迟（Delay）、探查（Probe）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590592903411.png&#34; alt=&#34;跟踪邻居状态&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面以A、B两个邻居节点之间相互通信过程中A节点的邻居状态变化为例（假设A、B之前从未通信），说明邻居状态迁移的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;A先发送NS报文，并生成缓存条目，此时，邻居状态为Incomplete。&lt;/li&gt;
&lt;li&gt;若B回复NA报文，则邻居状态由Incomplete变为Reachable，否则固定时间后邻居状态由Incomplete变为Empty，即删除表项。&lt;/li&gt;
&lt;li&gt;经过邻居可达时间，邻居状态由Reachable变为Stale，即未知是否可达。&lt;/li&gt;
&lt;li&gt;如果在Reachable状态，A收到B的非请求NA报文，且报文中携带的B的链路层地址和表项中不同，则邻居状态马上变为Stale。&lt;/li&gt;
&lt;li&gt;在Stale状态若A要向B发送数据，则邻居状态由Stale变为Delay，并发送NS请求。&lt;/li&gt;
&lt;li&gt;在经过一段固定时间后，邻居状态由Delay变为Probe，其间若有NA应答，则邻居状态由Delay变为Reachable。&lt;/li&gt;
&lt;li&gt;在Probe状态，A每隔一定时间间隔发送单播NS，发送固定次数后，有应答则邻居状态变为Reachable，否则邻居状态变为Empty，即删除表项。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;重复地址检测dad&#34;&gt;重复地址检测（DAD）&lt;/h3&gt;
&lt;p&gt;在进行DAD检测时，一个IPv6单播地址在分配给一个接口之后且通过重复地址检测之前称为试验地址（Tentative Address）。此时该接口不能使用这个试验地址进行单播通信，但是仍然会加入两个组播组：ALL-NODES组播组和实验地址所对应的Solicited-Node组播组。&lt;br&gt;
IPv6重复地址检测技术和IPv4中的免费ARP类似：节点向一个自己将使用的试验地址所在的Solicited-Node组播组发送一个以该实验地址为请求的目标地址的NS报文，如果收到某个其他站点回应的NA报文，就证明该地址已被网络上使用，节点将不能使用该实验地址通讯。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于ICMPv6实现&lt;/li&gt;
&lt;li&gt;包括NS报文和NA报文&lt;/li&gt;
&lt;li&gt;发送NS(135) 源IP “::”，目标请求节点组播地址 。回应NA（136 ）源是自己的地址，目标FF02::1（所有节点组播地址）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;路由发现&#34;&gt;路由发现&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;发现与本地链路相连的路由器&lt;/li&gt;
&lt;li&gt;获取与地址自动配置相关的前缀和其他配置参数&lt;/li&gt;
&lt;li&gt;包括RA(133)和RS(134)报文&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置接口发送RA报文，华为默认是不会发送RA报文，思科默认会发送，缺省是200秒
interface GigabitEthernet0/0/1
ipv6 enable 
ipv6 address 2001:10:10:10::1/64 
undo ipv6 nd ra halt          

# 配置路由器通过无状态方法来获取IPv6的地址， 如果需要自动生成一条默认路由可以加上参数default
interface GigabitEthernet0/0/0
ipv6 enable 
ipv6 address auto global  # default     
ipv6 nd ra preference high     # 配置RA报文的优先级
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;主机获得前缀及其他参数过程&#34;&gt;主机获得前缀及其他参数过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当存在以下情况时忽略RA发送的前缀：
&lt;ul&gt;
&lt;li&gt;RA报文选项中的“auto”未置位。&lt;/li&gt;
&lt;li&gt;前缀与已有地址前缀重复（包括link-local地址）。&lt;/li&gt;
&lt;li&gt;RA报文选项中的“preferred lifetime”时间大于 “ valid lifetime ”。&lt;/li&gt;
&lt;li&gt;前缀长度与接口ID长度之和不等于128位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;除以上情况外，主机获得前缀同时也获得一些相关时间参数：
&lt;ul&gt;
&lt;li&gt;“preferred lifetime”＝发起新通讯的有效时间。&lt;/li&gt;
&lt;li&gt;“ valid lifetime ”＝原有通讯的有效时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;主机会周期性的收到RA报文，并据此报文来更新自己的时间参数&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;几个生存时间&#34;&gt;几个生存时间&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当地址处于Deprecated状态，地址不能主动的发起连接只能是被动的接受连接，这也是为了保证上层应用而设计的，但是过了valid lifetime时间，地址就变味invalid，这时任何连接都会down掉&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590677468641.png&#34; alt=&#34;几个生存时间&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;标志位&#34;&gt;标志位&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;M位
&lt;ul&gt;
&lt;li&gt;有状态(M＝1)地址配置：通过DHCPv6服务器获取IPv6地址&lt;code&gt;ipv6 nd autoconfig managed-address-flag #配置M位＝1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置使用有状态方法获取到IPv6地址
# AR5
interface GigabitEthernet0/0/0
ipv6 enable 
ipv6 address auto link-local
ipv6 address auto dhcp
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;无状态(M＝0)地址配置：通过RA报文的前缀加上自己EUI－64生成的主机位，形成一个IPV6地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 无状态自动分配
# AR1，配置地址池
dhcpv6 pool HCIP
address prefix 2001:10:10:10::/64
excluded-address 2001:10:10:10::1 to 2001:10:10:10::100
dns-server 2001:10:10:10::1
dns-domain-name qytang.com
q
dhcp enable
interface GigabitEthernet0/0/1 #接口调用
ipv6 enable 
ipv6 address 2001:10:10:10::1/64 
ipv6 nd ra Min-interval 10 
undo ipv6 nd ra halt
ipv6 nd autoconfig other-flag
dhcpv6 server HCIP  #使用地址池HCIP
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;O位（Other-Config-Flag）
&lt;ul&gt;
&lt;li&gt;O＝0（默认），表示主机不应该使用有状态自动配置机制来配置除了IPv6地址外的其他参数。&lt;/li&gt;
&lt;li&gt;O=1，使用命令：&lt;code&gt;ipv6 nd autoconfig other-flag&lt;/code&gt;将该值置1，则主机需使用DHCPv6来配置除了IPv6地址外的其他信息，如DNS，域名等。&lt;br&gt;
&lt;code&gt;O=1需要和M=0配合使用，即通过M=0获取一个地址，通过O=1获取域名等&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;地址配置方法&#34;&gt;地址配置方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;手动配置&lt;br&gt;
手动配置IPv6地址/前缀及其他网络配置参数（DNS、NIS、SNTP服务器地址等参数）&lt;/li&gt;
&lt;li&gt;无状态自动地址分配&lt;br&gt;
由接口ID生成链路本地地址，再根据路由通告报文RA（Router Advertisement）包含的前缀信息自动配置本机地址。&lt;/li&gt;
&lt;li&gt;有状态自动地址分配，即DHCPv6方式。DHCPv6又分为如下两种:
&lt;ol&gt;
&lt;li&gt;DHCPv6有状态自动分配（分为四步交互(默认)和两步交互(使能命令：&lt;code&gt;ipv6 address auto dhcp rapid-commit&lt;/code&gt;)）。&lt;br&gt;
DHCPv6服务器自动分配IPv6地址/PD前缀及其他网络配置参数（DNS、NIS、SNTP服务器地址等参数）。&lt;/li&gt;
&lt;li&gt;DHCPv6无状态自动分配。&lt;br&gt;
主机IPv6地址仍然通过路由通告方式自动生成，DHCPv6服务器只分配除IPv6地址以外的配置参数，包括DNS、NIS、SNTP服务器等参数。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;地址配置过程&#34;&gt;地址配置过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;接口初始化&lt;/li&gt;
&lt;li&gt;接口产生“tentative“的link-local地址&lt;/li&gt;
&lt;li&gt;对“tentative”地址进行地址重复检测（DAD）&lt;/li&gt;
&lt;li&gt;接口产生link-local地址，具备IP连接能力&lt;/li&gt;
&lt;li&gt;由Router Advertisement报文的M比特决定采用何种自动配置技术&lt;br&gt;
无状态自动配置（stateless autoconfiguration）-利用RA信息通告的前缀生成地址&lt;br&gt;
有状态自动配置（stateful autoconfiguration）-必须通过DHCP获得，称为有状态&lt;/li&gt;
&lt;li&gt;获得全局地址&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;path-mtu&#34;&gt;Path MTU&lt;/h3&gt;
&lt;p&gt;为了避免切片，查找整条链路的最小MTU。&lt;/p&gt;
&lt;h3 id=&#34;重定向&#34;&gt;重定向&lt;/h3&gt;
&lt;p&gt;当路由器收到一个报文后，只有在如下情况下，路由器会向报文发送者发送重定向报文：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报文的目的地址不是一个组播地址。&lt;/li&gt;
&lt;li&gt;报文并非通过路由转发给路由器。&lt;/li&gt;
&lt;li&gt;经过路由计算后，路由的下一跳出接口是接收报文的接口。&lt;/li&gt;
&lt;li&gt;路由器发现报文的最佳下一跳IP地址和报文的源IP地址处于同一网段。&lt;/li&gt;
&lt;li&gt;路由器检查报文的源地址，发现自身的邻居表项中有用该地址作为全球单播地址或链路本地地址的邻居存在。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ospfv3&#34;&gt;OSPFv3&lt;/h2&gt;
&lt;h3 id=&#34;ospfv2基本概念&#34;&gt;OSPFv2基本概念&lt;/h3&gt;
&lt;h4 id=&#34;lsa类型&#34;&gt;LSA类型&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSA类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSA作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Router-LSA (Type1)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每个设备都会产生，描述了设备的链路状态和开销，在所属的区域内传播。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Network-LSA (Type2)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由 DR 产生，描述本网段的链路状态，在所属的区域内传播。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Network-summary-LSA (Type3)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由 ABR 产生，描述区域内某个网段的路由，并通告给发布或接收此 LSA的非 Totally STUB 或 NSSA 区域。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR-summary-LSA (Type4)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由 ABR 产生，描述到 ASBR 的路由，通告给除 ASBR 所在区域的其他相关区域。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AS-external-LSA (Type5)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由 ASBR 产生，描述到 AS 外部的路由，通告到所有的区域（除了 STUB区域和 NSSA 区域）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSSA LSA (Type7)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;由 ASBR 产生，描述到 AS 外部的路由，仅在 NSSA 区域内传播。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Opaque LSA (Type9/Type10/Type11)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Opaque LSA 提供用于 OSPF 的扩展的通用机制。其中：Type9 LSA仅在接口所在网段范围内传播。用于支持 GR 的 Grace LSA就是 Type9 LSA 的一种。Type10 LSA 在区域内传播。用于支持 TE 的 LSA 就是 Type10 LSA 的一种。Type11 LSA 在自治域内传播，目前还没有实际应用的例子。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;ospfv3介绍&#34;&gt;OSPFv3介绍&lt;/h3&gt;
&lt;h4 id=&#34;协议介绍&#34;&gt;协议介绍&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;与OSPFv2相比， OSPFv3在工作机制上与OSPFv2基本相同；但为了支持IPv6地址格式， OSPFv3对OSPFv2做了一些改动。&lt;/li&gt;
&lt;li&gt;OSPFv3基于OSPFv2基本原理并增强，是一个独立的路由协议。&lt;/li&gt;
&lt;li&gt;协议号&lt;strong&gt;仍然是89&lt;/strong&gt;，Router Id仍然是一个32位的无符号整数。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590823474733.png&#34; alt=&#34;协议介绍&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ipv6对ospfv3的影响&#34;&gt;IPv6对OSPFv3的影响&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590823567778.png&#34; alt=&#34;IPv6对OSPFv3的影响&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;ospfv3和ospfv2相同点&#34;&gt;OSPFv3和OSPFv2相同点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;网络类型和接口类型。&lt;/li&gt;
&lt;li&gt;接口状态机和邻居状态机。&lt;/li&gt;
&lt;li&gt;链路状态数据库(LSDB)。&lt;/li&gt;
&lt;li&gt;洪泛机制&lt;/li&gt;
&lt;li&gt;五种协议报文: Hello, DD, LSR, LSU, LSAck。&lt;/li&gt;
&lt;li&gt;路由计算基本相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ospfv3与ospfv2的不同&#34;&gt;OSPFv3与OSPFv2的不同&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;OSPFv3基于链路的运行，而不是基于子网的&lt;/li&gt;
&lt;li&gt;OSPFv3使用链路本地地址，移除了IP地址的意义&lt;/li&gt;
&lt;li&gt;OSPFv3链路支持多实例复用，支持一个链路上多个实例&lt;/li&gt;
&lt;li&gt;OSPFv3通过Router ID唯一标识邻居&lt;/li&gt;
&lt;li&gt;OSPFv3的LSA报文里添加LSA的洪泛范围&lt;/li&gt;
&lt;li&gt;认证的变化，OSPFv3移除所有认证字段&lt;/li&gt;
&lt;li&gt;Stub区域的支持&lt;/li&gt;
&lt;li&gt;Option字段的不同&lt;/li&gt;
&lt;li&gt;报文的不同&lt;/li&gt;
&lt;li&gt;LSA的类型和内容不同，新增两种LSA&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;
&lt;h5 id=&#34;报文&#34;&gt;报文&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;OSPFv3协议号仍然为89，在IPv6 Next Header里标识。&lt;/li&gt;
&lt;li&gt;通过包头的TYPE字段来标识5种包类型；&lt;/li&gt;
&lt;li&gt;以组播地址发送协议报文，而IPv6 Hop Limit为1；Virtual－Link则通过单播发送更新；&lt;br&gt;
AllSPfRouters：FF02::5&lt;br&gt;
AllDRouters：FF02::6&lt;/li&gt;
&lt;li&gt;IPv6中，除了virtual link之外，都使用link-local地址（&lt;strong&gt;源是link-local地址，目的是组播地址&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;基于链路的运行&#34;&gt;基于链路的运行&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;OSPFv2是基于网络运行的，两个路由器要形成邻居关系必须在同一个网段。&lt;/li&gt;
&lt;li&gt;OSPFv3的实现是基于链路， 一个链路可以划分为多个子网， &lt;strong&gt;节点即使不在同一个子网内， 只要在同一链路上就可以直接通信（实验一的R5和R6）&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;使用链路本地地址&#34;&gt;使用链路本地地址&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;OSPFv3的路由器使用&lt;strong&gt;链路本地地址作为发送报文的源地址&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;在虚连接上， 必须使用全球范围地址或者站点本地地址作为OSPFv3协议报文的源地址。&lt;/li&gt;
&lt;li&gt;由于链路本地地址只在本链路上有意义且只能在本链路上泛洪，因此链路&lt;strong&gt;本地地址只能出现在Link LSA中&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;链路支持多实例复用&#34;&gt;链路支持多实例复用&lt;/h5&gt;
&lt;p&gt;OSPFv3支持在同一链路上运行多个实例(instance)，实现链路复用并节约成本&lt;br&gt;
OSPFv3一个接口能不能配置多个实例？&lt;strong&gt;条件&lt;/strong&gt;：同一个进程只能配置一个实例，如果是&lt;strong&gt;不同进程可以配置多个&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;通过router-id唯一标识邻居&#34;&gt;通过Router ID唯一标识邻居&lt;/h5&gt;
&lt;p&gt;在OSPFv2中，当网络类型为点到点或者通过虚连接与邻居相连时，通过Router ID来标识邻居路由器，当网络类型为广播或NBMA时，通过邻居接口的IP地址来标识邻居路由器。&lt;br&gt;
OSPFv3取消了这种复杂性，无论对于何种网络类型，都是通过Router ID来唯一标识邻居。&lt;/p&gt;
&lt;h5 id=&#34;认证的变化&#34;&gt;认证的变化&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;验证的变化：OSPFv3报文头中不再包含AuType和Authentication，而一般依赖IPv6的&lt;strong&gt;扩展验证头&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;校验和(Checksum)变化：OSPFv3使用IPv6&lt;strong&gt;标准的CheckSum&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;stub区域的支持&#34;&gt;Stub区域的支持&lt;/h5&gt;
&lt;p&gt;由于OSPFv3支持对未知类型LSA的泛洪，为防止大量未知类型LSA泛洪进入Stub区域，对于向Stub区泛洪的未知类型LSA进行了明确规定， 只有当&lt;strong&gt;未知类型LSA的泛洪范围是区域或链路而且U比特没有置位时&lt;/strong&gt;，未知类型LSA才可以向Stub区域泛洪。&lt;/p&gt;
&lt;h3 id=&#34;报文格式&#34;&gt;报文格式&lt;/h3&gt;
&lt;h4 id=&#34;头部字段说明&#34;&gt;头部字段说明&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590848834011.png&#34; alt=&#34;头部字段说明&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Version：版本，对于OSPFv2，该值是2；对于OSPFv3则是3；&lt;/li&gt;
&lt;li&gt;Type：1 - Hello, 2-DD, 3-LSR, 4-LSU, 5-LSAck;&lt;/li&gt;
&lt;li&gt;Packet Length：OSPFv3报文长度，2字节；&lt;/li&gt;
&lt;li&gt;Router ID：路由器ID；&lt;/li&gt;
&lt;li&gt;Area ID：区域ID；&lt;/li&gt;
&lt;li&gt;Checksum：校验和；&lt;/li&gt;
&lt;li&gt;Instance ID：&lt;strong&gt;链路实例ID&lt;/strong&gt;，通过判断该字段就可以区分同一链路上运行的不同OSPF实例。&lt;strong&gt;实例ID只在本地链路范围内具有意义&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;Reserved(保留): 保留字段，总是0。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;hello报文&#34;&gt;Hello报文&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590848975097.png&#34; alt=&#34;Hello报文&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Hello 报文的不同：与 OSPFv2 Hello 报文相比， OSPFv3 Hello 报文去掉了网络掩码字段，增加了 Interface ID 字， 用来标识发送该 Hello 报文的接口ID。&lt;/li&gt;
&lt;li&gt;Instance ID:  4字节。报文发送者的发送接口标识，仅用来区分同一路由器上的不同接口，不包含地址信息。&lt;/li&gt;
&lt;li&gt;Rtr Pri:  1字节。路由器优先级，优先级高者成为DR。&lt;/li&gt;
&lt;li&gt;Options: 3字节。 OSPFv3中将Options字段扩展为24位。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590849086520.png&#34; alt=&#34;OSPFv3选项Options&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;在OSPFv2中， Option字段出现在每一个Hello报文、 DD报文以及每一个LSA中；在 OSPFv3中， Option字段只在 Hello报文、 DD报文、 Router LSA、 NetworkLSA、 Inter Area Router LSA以及Link LSA中出现，从上图可以看出，与OSPFv2相比， OSPFv3的Option字段增加了R比特、 V比特&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;R：用来标识设备是否是具备转发能力的路由器。如果 R 比特置 0，宣告该节点的路由信息将不会参加路由计算，如果当前设备是一个不想转发非本地地址的报文，可以将 R 比特置 0。&lt;/li&gt;
&lt;li&gt;V6：如果 V6 比特置 0，该路由器或链路也不会参加IPv6路由计算。&lt;/li&gt;
&lt;li&gt;E:  如果为0，不支持AS-External-LSA洪泛，如果E位设置不正确，邻接关系就不能形成；&lt;/li&gt;
&lt;li&gt;MC: 与多播相关；&lt;/li&gt;
&lt;li&gt;N:  是否在NSSA区域（Type-7 LSA）,当且仅当一个接口的所属区域为NSSA区域时设置为1；&lt;/li&gt;
&lt;li&gt;DC: 是否支持按需拨号。&lt;br&gt;
&lt;strong&gt;Options字段的各位的匹配情况会产生不同影响&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;阻止邻居的建立，例如Hello报文中的选项不匹配。&lt;/li&gt;
&lt;li&gt;阻止LSA的洪泛，例如E-Bit，如果为0，不洪泛AS-External-LSA。&lt;/li&gt;
&lt;li&gt;阻止LSA参加路由计算，例如V6-Bit，如果为0，该Router不参加IPv6路由计算。&lt;br&gt;
Options字段使OSPF路由器能支持可选的能力，并且与其它路由器互相通告其能力。通过这种机制，具有不同能力的路由器可以在一个OSPF路由域中&lt;strong&gt;混合工作&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;lsa头部&#34;&gt;LSA头部&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590849646368.png&#34; alt=&#34;LSA头部&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;OSPFv2中的LS Type长度为8比特，指定LSA的类型； OSPFv3的LSA Type字段由OSPFv2的8比特扩充为16比特。
&lt;ul&gt;
&lt;li&gt;U 位：描述了路由器收到&lt;strong&gt;一个类型未知的 LSA 时如何处理&lt;/strong&gt;，取值为 &lt;strong&gt;0 表示把类型未知LSA&lt;/strong&gt; 当成具有链路本地范围的 LSA 一样处理，取值为** 1 表示按照S2/S1 位标识的泛洪范围来处理**。&lt;/li&gt;
&lt;li&gt;S2/S1 位：共同标识 &lt;strong&gt;LSA 的泛洪范围&lt;/strong&gt;，取值 &lt;strong&gt;00 &lt;strong&gt;表示 LSA 只在产生该 LSA 的&lt;/strong&gt;本地链路上泛洪&lt;/strong&gt;；取值** 01 &lt;strong&gt;表示 LSA 的泛洪范围为产生该 LSA 的&lt;/strong&gt;路由器所在区域**；取值 &lt;strong&gt;10&lt;/strong&gt; 表示 LSA 将在&lt;strong&gt;整个自治系统内进行泛洪&lt;/strong&gt;；取值 &lt;strong&gt;11 保留&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;LSA Function Code： LSA 类型编码，描述 LSA 的类型。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;支持对未知类型lsa的处理&#34;&gt;支持对未知类型LSA的处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;U-bit: 指示路由器如何处理无法识别的LSA&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590849990576.png&#34; alt=&#34;U-bit&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;S2/S1，共同标识 LSA 的泛洪范围&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590850030114.png&#34; alt=&#34;S2/S1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;不同的LSA类型对应不同的U, S2和S1位&lt;/code&gt;&lt;br&gt;
在&lt;strong&gt;OSPFv2&lt;/strong&gt;中，收到类型&lt;strong&gt;未知的LSA将直接丢弃&lt;/strong&gt;，OSPFv3在LSA的LS Type字段中增加了一个U比特位来位标识对未知类型LSA的处理方式：&lt;/li&gt;
&lt;li&gt;如果 U 比特置 1，则对于未知类型的 LSA 按照 LSA 中的 LS Type 字段描述的泛洪范围进行泛洪；&lt;/li&gt;
&lt;li&gt;如果 U 比特置 0，对于未知类型的 LSA 仅在链路范围内泛洪。&lt;br&gt;
LSA的泛洪范围已经被明确地定义在LSA的LS Type字段，目前，有&lt;strong&gt;三种LSA泛洪范围&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;链路本地范围(Link-local Scope)：LSA 只在本地链路上泛洪，不会超出这个范围， Link-LSA(新增)&lt;/li&gt;
&lt;li&gt;区域范围(Area Scope)：Router-LSA, Network-LSA, Inter-Area-Prefix-LSA, Inter-Area-Router-LSA, Intra-Area-Prefix-LSA(新增)都是区域范围泛洪的 LSA。&lt;/li&gt;
&lt;li&gt;自治系统范围(AS Scope)：LSA 将被泛洪到整个路由域，AS-External-LSA。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;功能编码&#34;&gt;功能编码&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590850330408.png&#34; alt=&#34;功能编码&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;link-state-id&#34;&gt;Link State ID&lt;/h5&gt;
&lt;p&gt;4字节。不再包含地址信息，对于不同的LSA类型，该字段的含义如下表，同时提供与OSPFv2中含义的对比。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590850871642.png&#34; alt=&#34;Link State ID&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;lsa的类型简述&#34;&gt;LSA的类型简述&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590850942386.png&#34; alt=&#34;LSA的类型&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
OSPFv3新增了Link LSA和Intra Area Prefix LSA。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Router LSA 不再包含地址信息，使能 OSPFv3 的路由器为它所连接的每条链路产生单独的 Link LSA，将当前接口的链路本地地址以及路由器在这条链路上的一系列 IPv6 地址信息向该链路上的所有其它路由器通告。&lt;/li&gt;
&lt;li&gt;Router LSA 和 Network LSA 中不再包含路由信息，这两类 LSA 中所携带的路由信息由 Intra Area Prefix LSA 来描述，该类 LSA 用来公告一个或多个IPv6 地址前缀。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;prefix-option-字段&#34;&gt;Prefix Option 字段&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590851489315.png&#34; alt=&#34;Prefix Option 字段&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在OSPFv2中，使用“IP网段＋掩码”来表示前缀信息，而且两段信息在不同LSA中的位置还各不相同，结构很不清晰。在OSPFv3的LSA中，使用专门的三元组（Prefix-Length, PrefixOptions, Prefix）来表示前缀信息。由LSA公告的每个前缀都拥有一个自己的PrefixOptions 字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Prefix-Length：1字节。前缀的bit位长度，对于缺省路由该字段取值为0。&lt;/li&gt;
&lt;li&gt;PrefixOptions：1字节。前缀信息的选项，用来描述前缀的某些特殊属性字段，格式如下：
&lt;ul&gt;
&lt;li&gt;NU位：非单播位。如果设置为1，则这个前缀不会纳入IPv6单播路由计算中。&lt;/li&gt;
&lt;li&gt;LA位：本地地址位。如果设置为1，则这个前缀是路由器的一个接口地址。&lt;/li&gt;
&lt;li&gt;MC位：组播位。如果设置为1，则这个前缀应该纳入组播计算中，否则不纳入组播计算。&lt;/li&gt;
&lt;li&gt;P位：传播位。如果一个NSSA区域的前缀需要被ABR传播出去，就需要设置这一位。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Prefix：长度不定，为4字节的倍数。用于表示前缀的IPv6网络地址信息。&lt;br&gt;
Prefix-length可变，但必须是32bit（4字节）的整数倍，可用0来填充。因此它的长度可能是0、4、8、12、16字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lsa分类&#34;&gt;LSA分类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590851875439.png&#34; alt=&#34;LSA类型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;router-lsatype1&#34;&gt;Router LSA（Type1）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590852918493.png&#34; alt=&#34;Router LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;此类LSA同ospfv2相比并不包含前缀信息&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LS Type：0x2001，泛洪范围为Area。&lt;/li&gt;
&lt;li&gt;每个Router-LSA包含若干链路描述 ，每个链路描述都描述了路由器的一个接口信息。&lt;/li&gt;
&lt;li&gt;可以使用多个Router-LSA描述信息，通过Link-State ID区分多个不同的Router-LSA。&lt;/li&gt;
&lt;li&gt;W：用于组播路由；&lt;/li&gt;
&lt;li&gt;V：该路由器为虚连接的一端；&lt;/li&gt;
&lt;li&gt;E：该路由器为ASBR；&lt;/li&gt;
&lt;li&gt;B：该路由器为ABR。&lt;/li&gt;
&lt;li&gt;Type：1字节。路由器的该链路的链路类型；&lt;/li&gt;
&lt;li&gt;Metric：2字节。数据报文从此接口发出时的cost值；&lt;/li&gt;
&lt;li&gt;Interface ID：4字节。接口ID，用于标识接口，无地址含义。&lt;/li&gt;
&lt;li&gt;Neighbor Interface ID：4字节。邻居接口ID。&lt;/li&gt;
&lt;li&gt;Neighbor Router ID：4字节。邻居Router ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;router-lsa链接link类型&#34;&gt;Router LSA链接(Link)类型&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590853331763.png&#34; alt=&#34; Router LSA链接&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;network-lsatype2&#34;&gt;Network LSA（Type2）&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590853690926.png&#34; alt=&#34;Network LSA&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;DR产生，LS Type：0x2002，泛洪范围为Area；&lt;/li&gt;
&lt;li&gt;描述该链路上与DR有FULL关系的所有路由器。&lt;/li&gt;
&lt;li&gt;Attached Router：
&lt;ul&gt;
&lt;li&gt;每个路由器4字节。该链路上所有与DR&lt;strong&gt;有Full关系的路由器的Router ID&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;OSPFv3的Network-LSA具有区域泛滥范围，由DR生成。它的Link State ID为DR的Interface ID，而且将OSPFv2中的掩码字段取消了，所以它不再包含前缀信息，而仅仅描述了拓扑连接情况。&lt;/li&gt;
&lt;li&gt;由于其中的Options字段为链路上所有路由器的能力集合，因此DR的能力大小并不会影响其他路由器的LSA传播。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;inter-area-prefix-lsatype3&#34;&gt;Inter-Area-Prefix-LSA（Type3）&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590904761822.png&#34; alt=&#34;Inter-Area-Prefix-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;ABR产生，LS类型值为0x2003，泛洪范围为Area。&lt;/li&gt;
&lt;li&gt;在IPv4中，Inter-Area-Prefix-LSA称为Type 3  Summary-LSA。&lt;/li&gt;
&lt;li&gt;Metric：20bit。表示ABR到达该前缀描述的路由的cost值。&lt;/li&gt;
&lt;li&gt;前缀信息：描述前缀的Prefix三元组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在OSPFv2中，该类型的LSA称为Type 3 Summary-LSA。在OSPFv3中，更名为Inter-Area Prefix-LSA，语义更加明确，它描述了其他区域的前缀信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;边界路由器(ABR)产生&lt;/strong&gt;的第3类LSA，在&lt;strong&gt;Area范围内洪泛&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;描述了到本AS内其他区域的路由信息；&lt;/li&gt;
&lt;li&gt;每个Inter-Area-Prefix-LSA包含&lt;strong&gt;一条&lt;/strong&gt;地址前缀信息；&lt;/li&gt;
&lt;li&gt;该LSA中&lt;strong&gt;不包含Link-Local地址信息&lt;/strong&gt;;&lt;/li&gt;
&lt;li&gt;使用&lt;strong&gt;32位整数作为Link State ID&lt;/strong&gt;来区分同一路由器产生的不同LSA。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;inter-area-router-lsatype4&#34;&gt;Inter-Area-Router-LSA（Type4）&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590855068928.png&#34; alt=&#34; Inter-Area-Router-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;LS Type：0x2004，泛洪范围为Area&lt;/li&gt;
&lt;li&gt;Options：3字节，并非生成LSA的路由器的能力描述，而是描述了目的ASBR的能力。&lt;/li&gt;
&lt;li&gt;Metric：3字节，表示ABR到目的ASBR路由器的cost值。&lt;/li&gt;
&lt;li&gt;Destination Router ID：4字节，目的ASBR路由器的Router ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OSPFv2中，该类型的LSA称为Type 4 Summary-LSA。在OSPFv3中，更名为Inter-Area Router-LSA，语义更加明确，它描述了到达其他区域的ASBR的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边界路由器(ABR)产生的第4类LSA，在Area范围内洪泛；&lt;/li&gt;
&lt;li&gt;描述了到本AS内其他区域的ASBR路由器信息；&lt;/li&gt;
&lt;li&gt;每个Inter-Area-Router-LSA包含一个ASBR路由器信息；&lt;/li&gt;
&lt;li&gt;LSA中的能力选项(Options)与所描述的ASBR Router LSA中能力选项(Options)保持一致；&lt;/li&gt;
&lt;li&gt;使用32位整数作为Link State ID来区分相同的LSA。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;as-external-lsatype5&#34;&gt;AS-External-LSA（Type5）&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590855551432.png&#34; alt=&#34;AS-External-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;外部路由LSA，ASBR生成，LS类型值为0x4005，泛洪范围为AS&lt;/li&gt;
&lt;li&gt;每个AS-External-LSA描述到达自治系统外部的一个前缀的路径，每个AS-external-LSA包含一条地址前缀信息，且不能包含本地链路地址信息&lt;/li&gt;
&lt;li&gt;E：外部路由的Metric类型。如果设置为1，表示此为2类外部路由，其Metric不随着路由的传递而增长。如果设置为0，表示此为1类外部路由，其Metric随着路由的传递而增长。&lt;/li&gt;
&lt;li&gt;F：如果设置为1，则表示后面的Forwarding Address可选字段存在。&lt;/li&gt;
&lt;li&gt;T：如果设置为1，则表示后面的External Route Tag可选字段存在。&lt;/li&gt;
&lt;li&gt;前缀信息：描述前缀的Prefix三元组。&lt;/li&gt;
&lt;li&gt;Ref LS Type：2字节。如果非0，则表示后面的Referenced Link State ID可选字段存在。&lt;/li&gt;
&lt;li&gt;Forwarding Address：16字节。可选的128位IPv6地址。当前面的F位为1时存在。表示到达目的的数据应该转发到这个地址。在公告路由器不是最优的下一跳的时候可以使用。&lt;/li&gt;
&lt;li&gt;External Route Tag：4字节。可选的标记位。可以用于ASBR之间的通信。一个比较常见的例子是，在OSPF自治系统的两个边界路由器上进行路由分发时，通过对引入的路由进行标记，可以很方便地进行路由过滤。&lt;/li&gt;
&lt;li&gt;Referenced Link State ID：4字节。当前面的Ref LS Type字段非0时存在。如果存在，说明此条外部路由有一些相关信息需要参考另外一个LSA。被参考的LSA由以下字段值确定：
&lt;ul&gt;
&lt;li&gt;其LS type等于此AS-external-LSA的Referenced LS Type；&lt;/li&gt;
&lt;li&gt;其Link State ID等于此AS-external-LSA的Referenced Link State ID；&lt;/li&gt;
&lt;li&gt;其Advertising Router等于此ASexternal-LSA的Advertising Router。&lt;br&gt;
&lt;code&gt;这种参考能力是为未来的扩展准备的，目前并没有使用&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;link-lsatype8&#34;&gt;Link-LSA（Type8）&lt;/h4&gt;
&lt;p&gt;该类LSA仅在本链路上传播，具有以下3种目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;向本链路上的其他路由器通告本地链路地址，作为他们的下一跳地址&lt;/li&gt;
&lt;li&gt;向本链路上的其他路由器通告本地上的所有IPv6地址前缀&lt;/li&gt;
&lt;li&gt;允许路由器在该类型LSA中插入一些选项比特，与为本链路产生的网络LSA相关联（在广播网络和NBMA瓦洛洛上为DR提供Options取值）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590903452173.png&#34; alt=&#34;Link-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Rtr Pri: 该路由器在该链路上的 优先级(Router Priority用于选举 DR)；&lt;/li&gt;
&lt;li&gt;Options: 提供给Network LSA的 Options；&lt;/li&gt;
&lt;li&gt;Link Local Interface Address: 路由器与该链路相连的接口上配置的Link Local地址(Link Local地址只出现在Link LSA中)；&lt;/li&gt;
&lt;li&gt;Prefix: 该LSA中携带了多个IPv6地址Prefix；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;intra-area-prefix-lsatype9&#34;&gt;Intra-Area-Prefix-LSA（Type9）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么引入Intra-Area-Prefix-LSA?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OSPFv2中，依附于路由器和Stub网络的subnet出现在Router LSA中，依附于Transit网络的subnet出现在Network-LSA中；OSPFv3中，&lt;strong&gt;Router-LSA和Network-LSA不再包含地址信息&lt;/strong&gt;，所以引入Intra-Area-Prefix-LSA。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Intra-Area-Prefix-LSA携带区域内IPv6 Prefix信息。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;依附于路由器的Prefix&lt;br&gt;
依附于Stub网络的Prefix&lt;br&gt;
依附于Transit网络的Prefix&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590854113720.png&#34; alt=&#34; Intra-Area-Prefix-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;每台路由器或Transit网络可以 产生多个Intra-Area-Prefix-LSA&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;域间前缀LSA，LS Type：0x2009，泛洪范围为Area&lt;/li&gt;
&lt;li&gt;#Prefixes：LSA中包含的Prefix个数。&lt;/li&gt;
&lt;li&gt;Referenced Link State Type:
&lt;ul&gt;
&lt;li&gt;1: 携带的Prefix依附于Router(包括Stub网络)&lt;/li&gt;
&lt;li&gt;2: 携带的Prefix依附于Transit Network&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Referenced Link State ID:
&lt;ul&gt;
&lt;li&gt;Type1:  0&lt;/li&gt;
&lt;li&gt;Type2：DR接口ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Referenced Advertising Router:
&lt;ul&gt;
&lt;li&gt;Type 1：依附的路由器Router ID&lt;/li&gt;
&lt;li&gt;Type 2：DR Router ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Metric：20bit。表示ABR到达该前缀描述的路由的cost值。&lt;/li&gt;
&lt;li&gt;前缀信息：描述前缀的Prefix三元组。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;isisv3&#34;&gt;ISISv3&lt;/h2&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ISIS是一种IGP协议，ISIS使用SPF算法计算路由。&lt;/li&gt;
&lt;li&gt;ISIS的报文采用TLV结构，因此扩展性很好。为支持新的协议和特性，只需要扩展新的TLV或子TLV。可以轻松扩展支持IPv6，TE，MT等协议和特性。IS-IS对IPv6的支持不需要对协议做大的改动，因此协议的继承性很好；不像OSPF，为支持IPv6需要开发全新的协议OSPFv3。&lt;/li&gt;
&lt;li&gt;IS-IS通过新增TLV以实现对IPv6的支持。&lt;strong&gt;236号TLV&lt;/strong&gt;，定义&lt;strong&gt;路由信息&lt;/strong&gt;前缀、度量值等信息来说明网络的可达性。&lt;strong&gt;232号TLV&lt;/strong&gt;，相当于IPv4中的“IP Interface Address”TLV，只不过把原来的32比特的IPv4地址改为128比特的IPv6地址，描述&lt;strong&gt;接口信息&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ipv6-reachability&#34;&gt;IPv6 Reachability&lt;/h4&gt;
&lt;p&gt;类型值为236（0xEC），通过前缀、度量、标记 等来描述可达的IPv6前缀信息。在IPv4中有IPv4内部可达性TLV和IPv4  外部可达性TLV，在IPv6的扩展当中使用一个“X”bit来区分“内部” 和“外部”。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590907627348.png&#34; alt=&#34;IPv6 Reachability&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;U：up/down bit ，标识这个前缀是否是从高level通告下来的（用来防环路）。&lt;/li&gt;
&lt;li&gt;X：external original bit ，标识这个前缀是否是从其他路由协议中引入过来的。&lt;/li&gt;
&lt;li&gt;S：subtlv present bit，子TLV标识位。(可选)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;ipv6-interface-address&#34;&gt;IPv6 Interface Address&lt;/h4&gt;
&lt;p&gt;类型值为232（0xE8），它相当于IPv4中的 “IP Interface Address” TLV，只不过把原来的32比特的IPv4地址 改为128比特的IPv6地址。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590907685744.png&#34; alt=&#34;IPv6 Interface Address&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个TLV结构是直接从TLV132映射过来的，因此，原来TLV132最多可以64个IP地址(32位)，在TLV232中，最多只能有16个IPv6地址(128位)。&lt;/li&gt;
&lt;li&gt;在不同的PDU中，这个字段的内容是不同的，在hello PDU中，“接 口地址TLV”只能包含发送hello包的接口的Link-local地址；对于LSP，“接口地址TLV”只能包含IS的non-link-local IPv6（即全局单播地址）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;st单拓扑&#34;&gt;ST单拓扑&lt;/h3&gt;
&lt;p&gt;IS-IS为所有协议维护相同的SPT，IPv4和IPv6的拓扑必须一致&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590908868835.png&#34; alt=&#34;ST单拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;不足之处&#34;&gt;不足之处&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;网络可维护性的需求在目前的运营商中越来越被重视，独立拓扑的维护网络， 即带内维护网络的需求开始出现。&lt;/li&gt;
&lt;li&gt;IS-IS为所有协议维护相同的SPT，这意味着IPv4和IPv6的拓扑必须一致&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;存在问题&#34;&gt;存在问题&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;不适合分离拓扑的网络部署。&lt;/li&gt;
&lt;li&gt;为维护相同的拓扑，所有接口都必须同时运行IS-IS IPv4和IS-IS IPv6，部署不&lt;br&gt;
灵活。&lt;/li&gt;
&lt;li&gt;不能使用IPv4区域来链接不同的IPv6区域，否则IPv4区域会丢弃IPv6的流量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isis对mt多拓扑的支持&#34;&gt;ISIS对MT多拓扑的支持&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590931948534.png&#34; alt=&#34;ISIS对MT多拓扑的支持&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;MT可以使ISIS在一个路由域中维护多个拓扑&lt;/li&gt;
&lt;li&gt;如果支持MT，ISIS可以为IPv4和IPv6维护分离的拓扑&lt;/li&gt;
&lt;li&gt;重要的是，使用MT，IPv4和IPv6的拓扑就不需要一样了&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;mt多拓扑分离的拓扑&#34;&gt;MT(多拓扑)：分离的拓扑&lt;/h4&gt;
&lt;p&gt;ISIS路由协议主要可以分为以下几个方面：邻居的建立，路由可达（Prefix Reachable）与路由器可达（IS Reachable）的发布，SPF计算以及路由计算。&lt;br&gt;
为了达到多拓扑的相互隔离，以上几个方面均要求携带MT参数以满足这一要求（SPF计算与路由计算在路由器内识别完成）。于是，draft-ietf-isis-wg-multi-topology-11中定义了四种新的TLV分别满足以&lt;br&gt;
上过程，实现了通用环境下的ISIS MT的交互过程。&lt;br&gt;
使能ISIS进程多拓扑：&lt;code&gt;[Huawei-isis-1]ipv6 enable topology ipv6&lt;/code&gt;&lt;br&gt;
接口上使能ISIS：&lt;code&gt;[Huawei-GigabitEthernetX/Y/Z]isis ipv6 enable&lt;/code&gt;&lt;br&gt;
查看ISIS邻居关系：&lt;code&gt;[Huawei]dis isis peer&lt;/code&gt;&lt;br&gt;
查看ISIS路由：&lt;code&gt;[Huawei]dis isis route&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;新增四个TLV&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TLV229：Multi-Topology Identifier&lt;/li&gt;
&lt;li&gt;TLV222：Multi-Topologies Intermediate System&lt;/li&gt;
&lt;li&gt;TLV235：Multi-Topologies Reachable IPv4 Prefixes&lt;/li&gt;
&lt;li&gt;TLV237：Multi-Topologies Reachable IPv6 Prefixes&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ipv6过渡技术&#34;&gt;IPv6过渡技术&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590939623986.png&#34; alt=&#34;IPv6过渡技术&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;IPv6与IPv4共存技术：
&lt;ul&gt;
&lt;li&gt;双协议栈：
&lt;ul&gt;
&lt;li&gt;IPv6节点同时支持IPv6和IPv4协议栈。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;隧道：
&lt;ul&gt;
&lt;li&gt;IPv6报文作为IPv4的载荷，由IPv4 Internet中连接多个IPv6孤岛。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;IPv6与IPv4互通技术：
&lt;ul&gt;
&lt;li&gt;提供IPv6与IPv4互相访问的技术。&lt;/li&gt;
&lt;li&gt;适用于IPv6 Internet与IPv4 Internet共存，而两者又有互相通讯的需求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;双栈协议&#34;&gt;双栈协议&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940226124.png&#34; alt=&#34;双栈协议&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所有设备必须支持IPv4/IPv6协议栈，连接双栈网络的接口必须同时配置IPv4地址和IPv6地址&lt;/p&gt;
&lt;h2 id=&#34;ipv6-over-ipv4隧道技术&#34;&gt;IPv6 over IPv4隧道技术&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940296740.png&#34; alt=&#34; IPv6 over IPv4隧道技术&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
通过隧道技术，使IPv6报文在IPv4网络中传输，实现IPv6网络之间的孤岛互连&lt;br&gt;
&lt;strong&gt;IPv6 over IPv4隧道分类&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手动隧道包括手动隧道和GRE隧道；&lt;/li&gt;
&lt;li&gt;自动隧道包括IPv4兼容IPv6自动隧道、6to4隧道和ISATAP隧道&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;6over4手动隧道&#34;&gt;6over4手动隧道&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940506925.png&#34; alt=&#34;6over4手动隧道&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;如果一个边界设备要与多个设备建立手动隧道，就需要在设备上配置多个隧道，配置比较麻烦。所以手动隧道通&lt;strong&gt;常用于边界路由器与边界路由器，或者主机与边界路由器之间&lt;/strong&gt;，为两个IPv6网络提供连接。&lt;/li&gt;
&lt;li&gt;手动隧道优缺点
&lt;ul&gt;
&lt;li&gt;优点：可以用于任何IPv6穿越IPv4的环境，通用性好。&lt;/li&gt;
&lt;li&gt;缺点：必须手工配置，源地址和目的地址均需手工指定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转发机制
&lt;ul&gt;
&lt;li&gt;IPv6 over IPv4手动隧道转发机制为：当隧道边界设备的IPv6侧收到一个IPv6报文后， 根据IPv6报文的目的地址查找IPv6路由转发表，如果该报文是从此虚拟隧道接口转发出去，则根据隧道接口配置的隧道源端和目的端的IPv4地址进行封装。封装后的报文变成一个IPv4报文，交给IPv4协议栈处理。报文通过IPv4网络转发到隧道的终点。隧道终点收到一个隧道协议报文后，进行隧道解封装。并将解封装后的报文交给IPv6协议栈处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gre隧道&#34;&gt;GRE隧道&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940749643.png&#34; alt=&#34;GRE隧道&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6over4手动隧道的一种，手工指定隧道的端点地址，GRE承载IPv6协议。&lt;/p&gt;
&lt;h3 id=&#34;ipv4兼容ipv6&#34;&gt;IPv4兼容IPv6&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590940839043.png&#34; alt=&#34;IPv4兼容IPv6&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;IPv6 over IPv4隧道自动隧道的一种&lt;/li&gt;
&lt;li&gt;采用IPv4兼容地址，即::IPv4/96&lt;/li&gt;
&lt;li&gt;每台主机须有合法的IP地址&lt;br&gt;
IPv4兼容IPv6自动隧道，其承载的IPv6报文的目的地址（即自动隧道所使用的的特殊地址）是IPv4兼容IPv6地址。IPv4兼容IPv6地址的前96位全部为0，后32位为ipv4地址。&lt;br&gt;
&lt;strong&gt;缺点&lt;/strong&gt;：由于IPv4兼容IPv6隧道要求每一个主机都要有一个合法的IP地址，而且通讯的主机要支持双栈、支持IPv4兼容IPv6隧道，不适合大面积部署，目前已经被6to4隧道所取代&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;6to4隧道&#34;&gt;6to4隧道&lt;/h3&gt;
&lt;h4 id=&#34;1&#34;&gt;1&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941496380.png&#34; alt=&#34;6to4隧道1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6over4自动隧道的一种，支持Router到Router、Host到Router、Router到Host、 Host到Host，采用6to4专用地址，即2002:IPv4::/48。&lt;br&gt;
&lt;strong&gt;地址格式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FP：可聚合全球单播地址的格式前缀（Format Prefix），其值为001。&lt;/li&gt;
&lt;li&gt;TLA：顶级聚合标识符（Top Level Aggregator），有13个比特位，其二进制值为0 0000 0000 0010。&lt;/li&gt;
&lt;li&gt;SLA：站点级聚合标识符（Site Level Aggregator）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;6to4&lt;strong&gt;地址&lt;/strong&gt;可以表示为&lt;strong&gt;2002::/16&lt;/strong&gt;，而一个6to4&lt;strong&gt;网络&lt;/strong&gt;可以表示为&lt;strong&gt;2002:IPv4地址::/48&lt;/strong&gt;。6to4地址的网络前缀长度为64bit，其中前48bit（2002: a.b.c.d）被分配给路由器上的IPv4地址决定了，用户不能改变，而后16位（SLA）是由用户自己定义的。&lt;/p&gt;
&lt;h4 id=&#34;2&#34;&gt;2&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941788338.png&#34; alt=&#34;6to4隧道2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可连接多个6to4网络，通过SLA ID区分。&lt;br&gt;
一个IPv4地址只能用于一个6to4隧道的源地址，如果一个边界路由器连接了多个6to4网络使用同样的IPv4地址做为隧道的源地址，则使用6to地址中的SLA ID来区分，但他们共用一个隧道。&lt;/p&gt;
&lt;h4 id=&#34;3&#34;&gt;3&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941840050.png&#34; alt=&#34;6to4隧道3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6to4中继，实现6to4网络和IPv6普通网络互通。&lt;br&gt;
普通IPv6网络需要与6to4网络通过IPv4网络互通，这可以通过6to4中继路由器方式实现。所谓6to4中继，就是通过6to4隧道转发的IPv6报文的&lt;strong&gt;目的地址不是6to4地址&lt;/strong&gt;，但&lt;strong&gt;转发的下一跳是6to4地址&lt;/strong&gt;，该下一跳为路由器我们称之为&lt;strong&gt;6to4中继&lt;/strong&gt;。隧道的IPv4目的地址依然从下一跳的6to4地址中获得。&lt;br&gt;
如果6to4网络2中的主机要与IPv6网络互通，在其边界路由器上配置路由指向的下一跳为6to4中继路由器的6to4地址，中继路由器的6to4地址是与中继路由器的6to4隧道的源地址相匹配的。6to4网络2中去往普通IPv6网络的报文都会按照路由表指示的下一跳发送到6to4中继路由器。6to4中继路由器再将此报文转发到纯IPv6网络中去。当报文返回时，6to4中继路由器根据返回报文的目的地址（为6to4地址）进行IPv4报文头封装，数据就能够顺利到达6to4网络中了。&lt;/p&gt;
&lt;h3 id=&#34;isatap隧道&#34;&gt;ISATAP隧道&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590941979772.png&#34; alt=&#34;ISATAP隧道&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
6over4自动隧道的一种，支持Host到Router、Router到Host、 Host到Host，采用ISATAP隧道专用地址&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ISATAP（Intra-Site Automatic Tunnel Addressing Protocol）是另外一种自动隧道技术。ISATAP隧道同样使用了内嵌IPv4地址的特殊IPv6地址形式，只是和6to4不同的是，6to4是使用IPv4地址做为网络前缀，而ISATAP用IPv4地址做为接口标识。&lt;/li&gt;
&lt;li&gt;地址描述
&lt;ul&gt;
&lt;li&gt;如果IPv4地址是全局唯一的，则u位为1，否则u位为0。g位是IEEE 群体/个体标志。由于ISATAP是通过接口标识来表现的，所以，ISATAP地址有全局单播地址、链路本地地址、ULA地址、组播地址等形式。ISATAP地址的前64位是通过向ISATAP路由器发送请求来得到的，它可以进行地址自动配置。在ISATAP隧道的两端设备之间可以运行ND协议。ISATAP隧道将IPv4网络看作一个非广播的点到多点的链路（NBMA）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;转发过程描述：
&lt;ul&gt;
&lt;li&gt;在IPv4网络内部有两个双栈主机PC2和PC3，它们分别有一个私网IPv4地址。要使其具有ISATAP功能，需要进行如下操作：
&lt;ul&gt;
&lt;li&gt;首先配置ISATAP隧道接口，这时会根据IPv4地址生成ISATAP类型的接口ID。&lt;/li&gt;
&lt;li&gt;根据接口ID生成一个ISATAP链路本地IPv6地址，生成链路本地地址以后，主机就有了在本地链路上进行IPv6通信的能力。&lt;/li&gt;
&lt;li&gt;进行自动配置，主机获得IPv6全球单播地址、ULA地址等。&lt;/li&gt;
&lt;li&gt;当主机与其它IPv6主机进行通讯时，从隧道接口转发，将从报文的下一跳IPv6地址中取出IPv4地址作为IPv4封装的目的地址。如果目的主机在本站点内，则下一跳就是目的主机本身，如果目的主机不在本站点内，则下一跳为ISATAP路由器的地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;nat64&#34;&gt;NAT64&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590942107941.png&#34; alt=&#34;NAT64&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
NAT64技术实际上是一种协议转换技术，能够将分组在V4及V6格式之间灵活转换。IPv6过渡中的协议翻译技术就是将IPv6数据包的每个字段与IPv4数据包中的字段建立起一一映射的关系，从而在两个网络的边缘实现数据报文的转换。&lt;/p&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;实验一ospfv3&#34;&gt;实验一：OSPFv3&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590827202758.png&#34; alt=&#34;OSPFv3&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# .......................初始化配置
# AR1
sys
sys AR1
ospfv3 10 
router-id 1.1.1.1
q
ipv6
int g/0/0
ipv6 enable 
ipv6 addr 2001:1234::1 64
ospfv3 10 area 10
int lo 0
ipv6 enable
ipv6 addr 2002:1::1 128
ospfv3 10 area 10
# AR2
sys
sys AR2
ospfv3 10 
router-id 2.2.2.2
q
ipv6
int g/0/0
ipv6 enable 
ipv6 addr 2001:1234::2 64
ospfv3 10 area 10
int lo 0
ipv6 enable
ipv6 addr 2002:1::2 128
ospfv3 10 area 10
# AR3
sys
sys AR3
ospfv3 10 
router-id 3.3.3.3
q
ipv6
int g/0/0
ipv6 enable 
ipv6 addr 2001:1234::3 64
ospfv3 10 area 10
int lo 0
ipv6 enable
ipv6 addr 2002:1::3 128
ospfv3 10 area 10
# AR4
sys
sys AR4
ospfv3 10 
router-id 4.4.4.4
q
ipv6
int g/0/0
ipv6 enable 
ipv6 addr 2001:1234::4 64
ospfv3 10 area 10
int lo 0
ipv6 enable
ipv6 addr 2002:1::4 128
ospfv3 10 area 0
int s1/0/0
ipv6 enable
ipv6 addr 2001:45::4 64
ospfv3 10 area 0
# AR5
sys
sys AR5
ospfv3 10 
router-id 5.5.5.5
q
ipv6
int g/0/0
ipv6 enable 
ipv6 addr 2001:56::5 64
ospfv3 10 area 20
int lo 0
ipv6 enable
ipv6 addr 2002:1::5 128
ospfv3 10 area 0
int s1/0/0
ipv6 enable
ipv6 addr 2001:45::5 64
ospfv3 10 area 0
# AR6
sys
sys AR6
ospfv3 10 
router-id 6.6.6.6
q
ipv6
int g/0/0
ipv6 enable 
ipv6 addr 2001:65::6 64
ospfv3 10 area 20
int lo 0
ipv6 enable
ipv6 addr 2002:1::6 128
ospfv3 10 area 20
q
isis
is-level level-2
network-entity 47.0067.666666666666.00
ipv6 enable
int g0/0/1
ipv6 enable
ipv6 addr 2001:67::6 64
isis ipv6 enable
# AR7
sys
sys AR7
isis
is-level level-2
network-entity 47.0067.777777777777.00
ipv6 enable
int g0/0/1
ipv6 enable
ipv6 addr 2001:67::7 64
isis ipv6 enable
int lo 0
ipv6 enable
ip addr 2002:1::7 128
isis ipv6 enable
int g0/0/1
ipv6 enable
ipv6 addr 2001:78::7 64
isis ipv6 enable
# AR8
sys
sys AR8
isis
is-level level-2
network-entity 47.0067.888888888888.00
ipv6 enable
int g0/0/0
ipv6 enable
ipv6 addr 2001:78::8 64
isis ipv6 enable
int lo 0
ipv6 enable
ip addr 2002:1::8 128
isis ipv6 enable
# .......................路由引入
#AR6
ospfv3 10
import-route isis 1
isis
ipv6 import-route ospfv3 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二isis双栈&#34;&gt;实验二：ISIS双栈&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590934101034.png&#34; alt=&#34;ISIS双栈&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.........................初始化配置
# AR1
sys
sys AR1
isis
net 47.0123.111111111111.00
is-level level-2
ipv6 enable topology ipv6
int g0/0/0
ip add 12.1.1.1 24
isis enable
ipv6 enable
ipv6 addr 2001:12::1 64
isis ipv6 enable
int g0/0/1
ip add 13.1.1.1 24
isis enable
ipv6 enable
ipv6 addr 2001:13::1 64
isis ipv6 enable
int lo 0
ip add 1.1.1.1 32
isis enable
ipv6 enable
ipv6 addr 2002:1::1 128
isis ipv6 enable
# AR2
sys
sys AR2
isis
net 47.1234.222222222222.00
ipv6 enable topology ipv6
int g0/0/0
ip add 12.1.1.2 24
isis enable
ipv6 enable
ipv6 addr 2001:12::2 64
isis ipv6 enable
int g0/0/1
ip add 24.1.1.2 24
isis enable
ipv6 enable
ipv6 addr 2001:24::2 64
isis ipv6 enable
int g0/0/2
isis circuit-level level-2
ip add 23.1.1.2 24
isis enable
ipv6 enable
ipv6 addr 2001:23::2 64
isis ipv6 enable
int lo 0
ip add 2.2.2.2 32
isis enable
ipv6 enable
ipv6 addr 2002:2::2 128
isis ipv6 enable
# AR3
sys
sys AR3
isis
net 47.1234.333333333333.00
ipv6 enable topology ipv6
int g0/0/0
ip add 34.1.1.3 24
isis enable
ipv6 enable
ipv6 addr 2001:34::3 64
isis ipv6 enable
int g0/0/1
ip add 13.1.1.3 24
isis enable
ipv6 enable
ipv6 addr 2001:13::3 64
isis ipv6 enable
int g0/0/2
isis circuit-level level-2
ip add 23.1.1.3 24
isis enable
ipv6 enable
ipv6 addr 2001:23::3 64
isis ipv6 enable
int lo 0
ip add 3.3.3.3 32
isis enable
ipv6 enable
ipv6 addr 2002:3::3 128
isis ipv6 enable
# AR4
sys
sys AR4
isis
net 47.0234.444444444444.00
is-level level-1
ipv6 enable topology ipv6
int g0/0/1
ip add 24.1.1.4 24
isis enable
ipv6 enable
ipv6 addr 2001:24::4 64
isis ipv6 enable
int g0/0/2
ip add 34.1.1.4 24
isis enable
ipv6 enable
ipv6 addr 2001:34::4 64
isis ipv6 enable
int lo 0
ip add 4.4.4.4 32
isis enable
ipv6 enable
ipv6 addr 2002:4::4 128
isis ipv6 enable
#...............................................查看IPv4和IPv6的路由情况
# 查看邻居
dis isis peer
# 查看路由
dis ip rou pr isis
dis ipv6 rou pr isis
# 查看数据库
dis isis lsdb
# ..........................实现AR4中流量IPv4的走AR2、IPv6的走AR3
# AR4中ipv4和ipv6都有两条默认路由
# 方法：修改开销
# AR4
int g0/0/1
isis ipv6 cost 50 # 此时在AR4上ipv6的流量不在进行负载，由于g0/0/2默认开销10&amp;lt;g0/0/1开销50，所以IPv6的流量走g0/0/2
int g0/0/2
isis cost 50 #同理，ipv4的流量走g0/0/1
#...................路由的渗透
# AR2
import-route isis level-2 into level-1 tag 100
ipv6 import-route isis level-2 into level-1 tag 200
# AR3
import-route isis level-2 into level-1 tag 300
ipv6 import-route isis level-2 into level-1 tag 400
# AR1/2/3/4
isis
cost-style wide
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三6to4的手动隧道&#34;&gt;实验三：6to4的手动隧道&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590945083165.png&#34; alt=&#34;6to4的手动隧道&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.........初始化配置，保证1.1.1.1和3.3.3.3通信（#AR1 ping -a 1.1.1.1 3.3.3.3）
# AR1
sys
sys AR1
int g0/0/0
ip add 12.1.1.1 24
ospf network-type p2p
int g0/0/1
ipv6 enable 
ipv6 addr 2001:123::1 64
int lo 0
ip addr 1.1.1.1 32
ospf 10 router 1.1.1.1
area 0
network 12.1.1.1 0.0.0.0
network 1.1.1.1 0.0.0.0
# AR2
sys
sys AR2
int g0/0/0
ip addr 12.1.1.2 24
ospf network-type p2p
int g0/0/1
ip addr 23.1.1.2 24
ospf network-type p2p
ospf 10 router 2.2.2.2
area 0
network 12.1.1.2 0.0.0.0
network 23.1.1.2 0.0.0.0
# AR3
sys
sys AR3
int g0/0/0
ip add 23.1.1.3 24
ospf network-type p2p
int g0/0/1
ipv6 enable 
ipv6 addr 2001:234::1 64
int lo 0
ip addr 3.3.3.3 32
ospf 10 router 3.3.3.3
area 0
network  23.1.1.3 0.0.0.0
network 3.3.3.3 0.0.0.0
#.........................配置隧道（下面配置为并行配置）
#.....使用ipv6 over ipv4隧道
# AR1
int Tunnel 0/0/0
tunnel-protocol ipv6-ipv4
source 1.1.1.1
destination 3.3.3.3
ipv6 enable
ipv6 addr 2001:13::1 64
q
ipv6 route-static 2001:234:: 64 Tunnel 0/0/0
# AR3
int Tunnel 0/0/0
tunnel-protocol ipv6-ipv4
source 3.3.3.3
destination 1.1.1.1
ipv6 enable
ipv6 addr 2001:13::3 64
q
ipv6 route-static 2001:123:: 64 Tunnel 0/0/0
#.....使用gre隧道
# AR1
int Tunnel 0/0/0
tunnel-protocol gre
source lo 0
destination 3.3.3.3
ipv6 enable
ipv6 addr 2001:13::1 64
q
ipv6 route-static 2001:234:: 64 Tunnel 0/0/0
# AR3
int Tunnel 0/0/0
tunnel-protocol gre
source lo 0
destination 1.1.1.1
ipv6 enable
ipv6 addr 2001:13::3 64
q
ipv6 route-static 2001:123:: 64 Tunnel 0/0/0
#.....使用自动隧道
# AR1
int Tunnel 0/0/0
tunnel-protocol ipv6-ipv4 auto-tunnel
source lo 0
destination 3.3.3.3
ipv6 enable
ipv6 addr ::1.1.1.1 96
# AR3
int Tunnel 0/0/0
tunnel-protocol ipv6-ipv4 auto-tunnel
source lo 0
destination 1.1.1.1
ipv6 enable
ipv6 addr ::3.3.3.3 96
#.............................................同理，可以自行配置4to6的隧道
&lt;/code&gt;&lt;/pre&gt;
">06 IPv6（2020.0523）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/05-bgp20200518/"" data-c="
          &lt;h1 id=&#34;bgp概述&#34;&gt;BGP概述&lt;/h1&gt;
&lt;p&gt;动态路由协议可以按照工作范围分为IGP(rip\ospf\eigrp\isis)以及EGP(bgp)。IGP工作在同一个AS内，主要用来发现和计算路由，为AS内提供路由信息的交换；而EGP工作在AS与AS之间，在AS间提供无环路的路由信息交换，BGP则是EGP的一种。&lt;/p&gt;
&lt;h2 id=&#34;自治系统as&#34;&gt;自治系统AS&lt;/h2&gt;
&lt;p&gt;由同一个技术管理机构管理、使用统一选路策略的一些路由器的集合。自治系统内部的路由协议IGP，自治系统之间的路由协议EGP。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;EGP，运行于AS之间的路由协议，现通常都是指BGP。BGP着重于控制路由的传播和选择最优的路由。&lt;/li&gt;
&lt;li&gt;IGP，运行于AS内部的路由协议，主要有: RIP, OSPF及ISIS。IGP着重于发现和计算路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bgp特征&#34;&gt;BGP特征&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BGP是外部路由协议，用来在AS之间传递路由信息&lt;/li&gt;
&lt;li&gt;是一种增强的距离矢量路由协议
&lt;ul&gt;
&lt;li&gt;可靠的路由更新机制（&lt;strong&gt;TCP端口号179&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;丰富的Metric度量方法&lt;/li&gt;
&lt;li&gt;从设计上避免了环路的发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;为路由附带属性信息&lt;/li&gt;
&lt;li&gt;支持CIDR（无类别域间选路）&lt;/li&gt;
&lt;li&gt;丰富的路由过滤和路由策略&lt;br&gt;
&lt;code&gt;BGP重启进程之前要考虑好，因为路由信息庞大，更新极其缓慢&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;BGP版本：rfc1105-bgpv1；rfc1163-bgpv2；rfc1267-bgpv3；rfc4271/1771-bgpv4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;bgp基本工作机制&#34;&gt;BGP基本工作机制&lt;/h1&gt;
&lt;h2 id=&#34;bgp路由传递&#34;&gt;BGP路由传递&lt;/h2&gt;
&lt;p&gt;BGP对等体的建立、更新和删除等交互过程主要有&lt;strong&gt;5种报文、6种状态机和5个原则&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;bgp可靠的路由更新&#34;&gt;BGP可靠的路由更新&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;传输协议：TCP，端口号179&lt;/li&gt;
&lt;li&gt;无需周期性更新&lt;/li&gt;
&lt;li&gt;路由更新：只发送增量路由&lt;/li&gt;
&lt;li&gt;周期性&lt;strong&gt;发送keepAlive报文&lt;/strong&gt;检测TCP的连通性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;适应
&lt;ul&gt;
&lt;li&gt;让IP报文通过本路由器到达其他AS&lt;/li&gt;
&lt;li&gt;有多条到达其他AS的链路，可以不同路由分别进行选路由&lt;/li&gt;
&lt;li&gt;需要进行流量控制或控制选路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;不适应
&lt;ul&gt;
&lt;li&gt;网络简单，只有单个出口&lt;/li&gt;
&lt;li&gt;设备性能够不够（CPU，内存等）&lt;/li&gt;
&lt;li&gt;能力够不够（对BGP要有足够的理解，足够的熟练度）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Peer（对等体，邻居），BGP的邻居称为BGP的peer&lt;/li&gt;
&lt;li&gt;Speaker，运行了BGP的设备叫BGP Speaker&lt;/li&gt;
&lt;li&gt;AS&lt;/li&gt;
&lt;li&gt;IBGP和EBGP&lt;/li&gt;
&lt;li&gt;NLRI（网络可达信息）是BGP更新报文的一部分，携带BGP的属性和路由&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步&lt;/strong&gt;：是IBGP与IGP的同步，从IBGP收到一条路由，是否要通告给EBGP邻居，要看同步情况&lt;/li&gt;
&lt;li&gt;BGP的水平分割：从IBGP收到的路由，不会再通告给他的IBGP邻居，是为了防环&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp消息类型&#34;&gt;BGP消息类型&lt;/h1&gt;
&lt;p&gt;BGP报文有五种类型，其中Open、KeepAlive、Notification报文用于邻居关系的建立和维护&lt;br&gt;
BGP报文由BGP报文头和具体报文内容两部分组成，&lt;strong&gt;消息最长为4096字节，最短为19字节&lt;/strong&gt;（只包含报文头）。&lt;br&gt;
&lt;strong&gt;报文头帧格式&lt;/strong&gt;：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589898404907.png&#34; alt=&#34;报文头帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Marker&lt;/strong&gt;：占16字节，用于检查BGP对等体的同步信息是否完整，以及用于BGP验证的计算。&lt;strong&gt;不使用验证时所有比特均为1&lt;/strong&gt;（十六进制则全“FF”）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Length&lt;/strong&gt;：占2个字节（无符号位），BGP消息总长度（包括报文头在内），&lt;strong&gt;以字节为单位&lt;/strong&gt;。长度范围是&lt;strong&gt;19～4096&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Type&lt;/strong&gt;：占1个字节（无符号位），BGP消息的类型。Type有5个可选值，表示BGP报文头后面所接的5类报文： 1 OPEN ；2 UPDATE ；3 NOTIFICATION ；4 KEEPALIVE ；5 REFRESH。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;open&#34;&gt;Open&lt;/h2&gt;
&lt;p&gt;负责和对等体建立邻居关系。主要包括BGP版本、AS号等信息，试图建立BGP邻居关系的两个路由器在建立了TCP会话之后开始叫唤Open信息已确认能否形成邻居关系。&lt;/p&gt;
&lt;h3 id=&#34;报文格式&#34;&gt;报文格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589898708624.png&#34; alt=&#34;OPEN报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589899213717.png&#34; alt=&#34;OPEN报文参数&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589899259545.png&#34; alt=&#34;AFI及SAFI编码说明&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;keepalive&#34;&gt;KeepAlive&lt;/h2&gt;
&lt;p&gt;该消息在对等体之间周期性地发送，用以维护连接。&lt;/p&gt;
&lt;h3 id=&#34;报文格式-2&#34;&gt;报文格式&lt;/h3&gt;
&lt;p&gt;如果BGP报文头中的TYPE为4，则该报文为KEEPALIVE报文。KEEPALIVE报文用于保持BGP连接。KEEPALIVE报文只有BGP报文头，没有具体内容，故其报文长度应固定为19个字节。&lt;/p&gt;
&lt;h2 id=&#34;update&#34;&gt;Update&lt;/h2&gt;
&lt;p&gt;该消息被用来在BGP对等体之间传递路由信息。包含&lt;strong&gt;撤销、撤销路由&lt;/strong&gt;和可达路由信息及其各种路由属性，是BGP报文中最重要的报文。&lt;/p&gt;
&lt;h3 id=&#34;报文格式-3&#34;&gt;报文格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589899354620.png&#34; alt=&#34;UPDATE报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589899582141.png&#34; alt=&#34;UPDATE报文参数&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589899751244.png&#34; alt=&#34;路由属性的类型号列表&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;notification&#34;&gt;Notification&lt;/h2&gt;
&lt;p&gt;当BGP Speaker检测到错误的时候，就发送该消息给对等体。BGP的差错检测机制，一旦检测到任何形式的差错，BGP Speaker会发送一个Notification报文，随后与之相关的邻居关系将被关闭。&lt;/p&gt;
&lt;h3 id=&#34;报文格式-4&#34;&gt;报文格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589900129233.png&#34; alt=&#34;NOTIFICATION报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Error code：占1个字节（无符号位），定义错误的类型，非特定的错误类型用零表示。&lt;/li&gt;
&lt;li&gt;Error subcode：占1个字节（无符号位），指定错误细节编号，非特定的错误细节编号用零表示。&lt;/li&gt;
&lt;li&gt;Data：指定错误数据内容。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589900373925.png&#34; alt=&#34;错误码&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;route-refresh&#34;&gt;Route-refresh&lt;/h2&gt;
&lt;p&gt;用来通知对等体自己支持路由刷新能力。&lt;/p&gt;
&lt;h3 id=&#34;报文格式-5&#34;&gt;报文格式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589901191982.png&#34; alt=&#34;REFRESH报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;bgp状态机&#34;&gt;BGP状态机&lt;/h1&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589901373017.png&#34; alt=&#34;BGP状态机&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589902479648.png&#34; alt=&#34;BGP状态机2&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Idle状态是BGP&lt;strong&gt;初始状态&lt;/strong&gt;。在Idle状态下，BGP拒绝邻居发送的连接请求。只有在收到本设备的Start事件后，BGP才开始尝试和其它BGP对等体进行TCP连接，并转至Connect状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Start事件是由一个操作者配置一个BGP过程，或者重置一个已经存在的过程或者路由器软件重置BGP过程引起的&lt;br&gt;
任何状态中收到Notification报文或TCP拆链通知等Error事件后，BGP都会转至Idle状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在Connect状态下，BGP启动连接重传定时器（Connect Retry），等待TCP完成连接。
&lt;ul&gt;
&lt;li&gt;如果TCP连接成功，那么BGP向对等体发送Open报文，并转至OpenSent状态。&lt;/li&gt;
&lt;li&gt;如果TCP连接失败，那么BGP转至Active状态。&lt;/li&gt;
&lt;li&gt;如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP继续尝试和其它BGP对等体进行TCP连接，停留在Connect状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在Active状态下，BGP总是在试图建立TCP连接。
&lt;ul&gt;
&lt;li&gt;如果TCP连接成功，那么BGP向对等体发送Open报文，关闭连接重传定时器，并转至OpenSent状态。&lt;/li&gt;
&lt;li&gt;如果TCP连接失败，那么BGP停留在Active状态。&lt;/li&gt;
&lt;li&gt;如果连接重传定时器超时，BGP仍没有收到BGP对等体的响应，那么BGP转至Connect状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在OpenSent状态下，BGP等待对等体的Open报文，并对收到的Open报文中的AS号、版本号、认证码等进行检查。
&lt;ul&gt;
&lt;li&gt;如果收到的Open报文正确，那么BGP发送Keepalive报文，并转至OpenConfirm状态。&lt;/li&gt;
&lt;li&gt;如果发现收到的Open报文有错误，那么BGP发送Notification报文给对等体，并转至Idle状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在OpenConfirm状态下，BGP等待Keepalive或Notification报文。如果收到Keepalive报文，则转至Established状态，如果收到Notification报文，则转至Idle状态。&lt;/li&gt;
&lt;li&gt;在Established状态下，BGP可以和对等体交换Update、Keepalive、Route-refresh报文和Notification报文。
&lt;ul&gt;
&lt;li&gt;如果收到正确的Update或Keepalive报文，那么BGP就认为对端处于正常运行状态，将保持BGP连接。&lt;/li&gt;
&lt;li&gt;如果收到错误的Update或Keepalive报文，那么BGP发送Notification报文通知对端，并转至Idle状态。&lt;/li&gt;
&lt;li&gt;Route-refresh报文不会改变BGP状态。&lt;/li&gt;
&lt;li&gt;如果收到Notification报文，那么BGP转至Idle状态。&lt;/li&gt;
&lt;li&gt;如果收到TCP拆链通知，那么BGP断开连接，转至Idle状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp路由通告原则&#34;&gt;BGP路由通告原则&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;连接建立时，BGP Speaker只把本身用的&lt;strong&gt;最优路由通告给对等体&lt;/strong&gt;；多条路径时，BGP Speaker只选&lt;strong&gt;最优的路由放入路由表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BGP Speaker从EBGP获得的路由会&lt;strong&gt;向它所有BGP对等体通告&lt;/strong&gt;（包括EBGP和IBGP）。&lt;br&gt;
从&lt;strong&gt;EBGP&lt;/strong&gt;收到的路由&lt;strong&gt;通告给IBGP&lt;/strong&gt;，&lt;strong&gt;不会修改下一跳&lt;/strong&gt;（&lt;strong&gt;EBGP通告给EBGP会自动修改&lt;/strong&gt;）。如果需要修改下一跳为自身，则需要进行配置。&lt;br&gt;
IBGP是为EBGP服务的，用于承载EBGP路由，传递给其他AS。&lt;/li&gt;
&lt;li&gt;BGP Speaker从IBGP获得的路由不会通告给它的IBGP邻居。&lt;br&gt;
IBGP逻辑全互连，导致AS内部路由器需要维护&lt;strong&gt;更多的IBGP会话&lt;/strong&gt;，解决方案：路由反射器和联盟&lt;/li&gt;
&lt;li&gt;BGP Speaker从IBGP获得的路由是否通告给它的EBGP对等体要依IGP和BGP同步的情况来决定。&lt;br&gt;
BGP与IGP同步（华为设备无法同步）的概念：BGP Speaker不将从IBGP对等体获得的路由信息通告给它的EBGP对等体，&lt;strong&gt;除非该路由信息也能通过IGP获得&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;从IBGP对等体获得的BGP路由，BGP设备只发布给它的EBGP对等体&lt;/li&gt;
&lt;li&gt;从EBGP对等体获得的BGP路由，BGP设备发布给它所有EBGP和IBGP对等体&lt;/li&gt;
&lt;li&gt;当存在多条到达同一目的地址的有效路由时，BGP设备只将最优路由发布给对等体&lt;/li&gt;
&lt;li&gt;路由更新时，BGP设备只发送更新的BGP路由&lt;/li&gt;
&lt;li&gt;所有对等体发送的路由，BGP设备都会接收。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;bgp的路由黑洞&#34;&gt;BGP的路由黑洞&lt;/h1&gt;
&lt;p&gt;简单的说，它会默默的将数据包丢弃，使所有数据包有去无回，主要原因是没有相应的路由&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589986054853.png&#34; alt=&#34;BGP的路由黑洞&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;举例&lt;/strong&gt;：AR6无法ping通AR1的11.11.11.11，主要是AR5的路由表中11.11.11.11的下一跳是2.2.2.2（AR5和AR2没有直连），在其转发表中2.2.2.2的下一跳是35.1.1.3（或者45.1.1.4），但是AR3（或者AR4）中没有关于11.11.11.11的路由，导致所有涉及11.11.11.11的数据包被丢弃。&lt;/p&gt;
&lt;h2 id=&#34;解决路由黑洞方法&#34;&gt;解决路由黑洞方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;开启&lt;strong&gt;同步&lt;/strong&gt;（思科支持），&lt;strong&gt;华为不支持&lt;/strong&gt;。开启同步后，从IBGP收到的路由，如果IGP中不存在，就不会通告EBGP邻居。【即AR5中不存在11.11.11.11/32，所以AR5不会讲此路由通告给AR6】&lt;/li&gt;
&lt;li&gt;物理线路直连（&lt;strong&gt;不可取&lt;/strong&gt;），但是可以使用&lt;strong&gt;GRE隧道&lt;/strong&gt;。【即在AR2和AR5之间建立GRE通道】&lt;/li&gt;
&lt;li&gt;全互联可以解决 ，管理成本增加。&lt;/li&gt;
&lt;li&gt;RR（配置路由反射器）。路由反射器不是解决路由黑洞的，是解决水平分割的问题。【在R3上配置RR，R2和R5不再需要配置BGP邻居】&lt;/li&gt;
&lt;li&gt;联邦是用来解决水平分割的问题，但也可以解决路由黑洞。&lt;/li&gt;
&lt;li&gt;将EBGP路由引入IGP可以解决路由黑洞 （&lt;strong&gt;不可取&lt;/strong&gt;），会造成IGP负担过重。&lt;/li&gt;
&lt;li&gt;MPLS网络。&lt;/li&gt;
&lt;li&gt;可以在黑洞设备上配置静态也可以解决（&lt;strong&gt;不可取&lt;/strong&gt;）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp路由的来源&#34;&gt;BGP路由的来源&lt;/h1&gt;
&lt;p&gt;成为BGP路由的3个来源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;network命令&lt;br&gt;
BGP的network命令为通告路由，把IGP(比如OSPF)发现的路由信息通过network命令注入到BGP设备的BGP路由表中&lt;strong&gt;需要严格匹配掩码&lt;/strong&gt;。network宣告的路由的起源属性为i 。本地该路由的下一跳是0.0.0.0。&lt;/li&gt;
&lt;li&gt;import-route命令&lt;br&gt;
通过import-route命令把IGP路由或静态路由注入到BGP设备的BGP路由表中，import-route引入的路由的起源属性为？。&lt;/li&gt;
&lt;li&gt;aggregate命令&lt;br&gt;
聚合路由，本地该路由的下一跳是127.0.0.1&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp路径属性&#34;&gt;BGP路径属性&lt;/h1&gt;
&lt;p&gt;BGP路径属性是一组描述BGP前缀特性的参数，公认属性是所有BGP路由器都必须识别的属性，可选属性不需要都被BGP路由器所识别，可以分为四大类：&lt;/p&gt;
&lt;h2 id=&#34;公认必遵&#34;&gt;公认必遵&lt;/h2&gt;
&lt;p&gt;所有BGP路由器都可以识别，且必须存在于Update消息中。如果缺少这种属性，路由信息就会出错。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Origin：起源属性&lt;br&gt;
一般的，具体的实现按如下方式决定一条路由的Origin属性：
&lt;ul&gt;
&lt;li&gt;某条路由是直接而具体的注入到BGP路由表中的，则origin属性为IGP
&lt;ul&gt;
&lt;li&gt;通过network命令注入BGP的路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;通过EGP学到的路由，则origin属性为EGP&lt;/li&gt;
&lt;li&gt;其他情形下，Origin属性都为 Incomplete
&lt;ul&gt;
&lt;li&gt;通过import命令注入BGP的路由&lt;br&gt;
&lt;code&gt;Origin属性值默认情况下不被任何路由器修改&lt;/code&gt;&lt;br&gt;
&lt;code&gt;路由优先级：i(network宣告) 优于 e(EGP) 优于 ？(import-route引入的路由)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;AS_Path&lt;br&gt;
用于防环和选路，在默认情况下，BGP是通过AS号来检测路由环路的。&lt;/li&gt;
&lt;li&gt;Next_Hop&lt;br&gt;
BGP设备在向EBGP对等体发布某一条路由时，会把该路由信息的下一跳属性   设置为   &lt;strong&gt;本地与对端建立BGP邻居关系的接口地址&lt;/strong&gt;。&lt;br&gt;
BGP设备将本地始发路由发布给IBGP对等体时，会把该路由信息的下一跳属性   设置为   &lt;strong&gt;本地与对端建立BGP邻居关系的接口地址&lt;/strong&gt;。&lt;br&gt;
BGP设备在&lt;strong&gt;向IBGP对等体发布从EBGP对等体学来的路由&lt;/strong&gt;时，&lt;strong&gt;并不改变该路由信息的下一跳属性&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;公认任意&#34;&gt;公认任意&lt;/h2&gt;
&lt;p&gt;所有BGP路由器都可以识别，但不要求必须存在于Update消息中，可以根据具体情况来决定是否添加到Update消息中。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Local_Pref&lt;br&gt;
在某些情况下，一个ISP可能通过两条高速链路连接两个大的ISP作为自己到INTERNET的出口（越大越优）&lt;br&gt;
Local_Pref属性可以针对 IBGP的出\入 方向和 EBGP的入 方向调用，但是不能针对 EBGP的出 方向调用。&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 使用路由策略修改Local_Pref值，使得访问44.44.44.44和55.55.55.55的走不通的链路，从而实现选路功能
acl number 2001  
rule 5 permit source 44.44.44.44 0 
acl number 2002  
rule 5 permit source 55.55.55.55 0 

route-policy Local-pre permit node 10 
if-match acl 2001 
apply local-preference 150 
route-policy Local-pre permit node 20 
if-match acl 2002 
apply local-preference 200 
route-policy Local-pre permit node 30 

bgp 100
peer 14.1.1.4 route-policy Local-pre import
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Atomic_Aggregate&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;可选过渡&#34;&gt;可选过渡&lt;/h2&gt;
&lt;p&gt;BGP路由器可以选择是否在Update消息中携带这种属性。接收的路由器如果不识别这种属性，可以转发给邻居路由器，邻居路由器可能会识别并使用到这种属性。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Aggregator&lt;/li&gt;
&lt;li&gt;Community&lt;br&gt;
团体属性是由一系列4字节(0x00000000-0xFFFFFFFF)数值所组成
&lt;ul&gt;
&lt;li&gt;保留团体属性
&lt;ul&gt;
&lt;li&gt;0x00000000-0x0000FFFF&lt;/li&gt;
&lt;li&gt;0xFFFF0000-0xFFFFFFFF&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;公认团体属性
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NO_EXPORT&lt;/strong&gt;(0xFFFFFF01)：路由器收到带有这一团体值的路由后，&lt;strong&gt;不应把该路由通告给一个联盟之外的对等体&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NO_ADVERTISE&lt;/strong&gt;(0xFFFFFF02)：路由器收到带有这一团体值的路由后，&lt;strong&gt;不应该把该路由通告给任何的BGP对等体&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NO_EXPORT_SUBCONFED&lt;/strong&gt;(0xFFFFFF03)：路由器收到带有这一团体值的路由后，可以把该路由通告给它的IBGP对等体，但&lt;strong&gt;不能通告给任何EBGP对等体&lt;/strong&gt;（包括联盟内的EBGP对等体）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;私有团体属性
&lt;ul&gt;
&lt;li&gt;AS(2B):Number(2B)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; # 通过路由策略和团体属性的结合，达到路由传递范围的限制
 # AR4：as200，AR1：as100
 # AR4：添加no-export属性
 route-policy Comm permit node 10 
 apply community no-export 
 bgp 200
 peer 14.1.1.1 route-policy Comm export
 peer 14.1.1.1 advertise-community
 # AR1:去掉no-export属性，从而可以使得该条路由继续通告
 ip community-filter 10 permit no-export
 route-policy Comm permit node 10 
 apply community none
 # AR1：在现有团体属性基础上添加新的团体属性100:100
 route-policy COMM_NO_noexport permit node 10
 if-match community-filter 10
 apply community 100:100 additive
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;可选非过渡&#34;&gt;可选非过渡&lt;/h2&gt;
&lt;p&gt;BGP路由器可以选择是否在Update消息中携带这种属性。在整个路由发布的路径上，如果部分路由器不能识别这种属性，可能会导致该属性无法发挥效用。因此接收的路由器如果不识别这种属性，将丢弃这种属性，不必再转发给邻居路由器。例如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Multi_Exit_Disc&lt;br&gt;
MED（和cost值类似）用来区别达到同一邻居AS的多条入口链路（MED值越小越优），通过EBGP发送MED值给对等体。&lt;br&gt;
MED属性可以针对 EBGP\IBGP 的 出\入 方向调用。&lt;br&gt;
从不同AS过来的路由是不会比较med的，可以通过&lt;code&gt;compare-different-as-med&lt;/code&gt;忽略AS。&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 使用路由策略修改MED值，使得20.20.20.20和21.21.21.21的优先级不相同，从而实现选路功能
acl number 2020  
rule 5 permit source 20.20.20.20 0 
acl number 2021  
rule 5 permit source 21.21.21.21 0 

route-policy Med permit node 10
if-match acl 2020
apply cost 50   # 华为没有med，此处修改的是cost值
route-policy Med permit node 20 
if-match acl 2021 
apply cost 100 

peer 35.1.1.5 route-policy Med export  # 在邻居上使用路由规则（出方向）
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Originator ID&lt;/li&gt;
&lt;li&gt;Cluster List&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;bgp路径选择过程选路规则按照数字顺序依次进行选路&#34;&gt;BGP路径选择过程（选路规则：按照数字顺序依次进行选路）&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;如果此路由的下一跳不可达，忽略此路由&lt;/li&gt;
&lt;li&gt;Preferred-Value值数值高的优先（只在本地有效）&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;route-policy Prefer permit node 10
apply preferred-value 200
bgp 100
peer 3.3.3.3 route-policy Pref import
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;Local-Preference值最高的路由优先&lt;/li&gt;
&lt;li&gt;聚合路由优先于非聚合路由&lt;/li&gt;
&lt;li&gt;本地手动聚合路由的优先级高于本地自动聚合的路由&lt;/li&gt;
&lt;li&gt;本地通过network命令引入的路由的优先级高于本地通过import-route命令引入的路由&lt;/li&gt;
&lt;li&gt;AS路径的长度最短的路径优先&lt;/li&gt;
&lt;li&gt;比较Origin属性，IGP优于EGP，EGP优于Incomplete（即i优e优于?）&lt;/li&gt;
&lt;li&gt;选择MED较小的路由&lt;/li&gt;
&lt;li&gt;EBGP路由优于IBGP路由&lt;/li&gt;
&lt;li&gt;BGP优先选择到BGP下一跳的IGP度量最低的路径&lt;br&gt;
&lt;code&gt;当以上全部相同，则为等价路由，可以负载分担&lt;/code&gt;&lt;br&gt;
【注】：A S-Path必须一致&lt;br&gt;
当负载分担时，以下3条原则无效
&lt;ol&gt;
&lt;li&gt;比较Cluster List长度，短者优先&lt;/li&gt;
&lt;li&gt;比较Originator_ID(如果没有Originator_ID，则用Router ID比较)，选择数值较小的路径&lt;/li&gt;
&lt;li&gt;比较对等体的IP地址，选择IP地址数值最小的路径&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;当到达同一目的地存在多条路由时，BGP依次对比下列属性来选择路由：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;优选协议首选值（Pref_Val）最高的路由。【对比思科的权重weight】协议首选值（Pref_Val）是华为设备的特有属性，该属性仅在本地有效&lt;/li&gt;
&lt;li&gt;优选本地优先级（Local_Pref）最高的路由。如果路由没有本地优先级，BGP选路时将该路由按缺省的本地优先级100来处理&lt;/li&gt;
&lt;li&gt;依次优选手动聚合路由、自动聚合路由、network命令引入的路由、import-route命令引入的路由、从对等体学习的路由。【对比思科，本地起源即本地通告产生的路由】&lt;/li&gt;
&lt;li&gt;优选AS路径（AS_Path）最短的路由。【与思科相同，此为公认必遵属性】&lt;/li&gt;
&lt;li&gt;依次优选Origin类型为IGP、EGP、Incomplete的路由。【与思科相同，此为公认必遵属性】&lt;br&gt;
-.-.-.-.-.-.-.--.-.-.-.-.-.-.--.-.-.-.-.-.-.-.-.-.-.-.-.-.-&lt;/li&gt;
&lt;li&gt;对于来自同一AS的路由，优选MED值最低的路由&lt;/li&gt;
&lt;li&gt;依次优选EBGP路由、IBGP路由、LocalCross路由、RemoteCross路由&lt;/li&gt;
&lt;li&gt;优选到BGP下一跳IGP度量值（metric）最小的路由。【6、7、8选路原则也相同，此处思科如果在前8条选路原则选择不出最优路由，则使能负载均衡，华为也有相同的属性，命令为&lt;code&gt;maximum load-balancing [ebgp|ibgp] number&lt;/code&gt;，配置BGP负载分担的最大等价路由条数。缺省情况下，BGP负载分担的最大等价路由条数为1，即不进行负载分担】&lt;br&gt;
-.-.-.-.-.-.-.--.-.-.-.-.-.-.--.-.-.-.-.-.-.-.-.-.-.-.-.-.-&lt;br&gt;
华为并未说明优选更“老”（建立时间更久）的BGP&lt;/li&gt;
&lt;li&gt;优选Cluster_List最短的路由。【对比思科，华为在此处第9条和第10条颠倒】&lt;/li&gt;
&lt;li&gt;优选Router_ID最小的设备发布的路由（可以由路由反射器的Oringinator_ID代替）&lt;/li&gt;
&lt;li&gt;优选从具有最小IP地址的对等体学来的路由&lt;br&gt;
&lt;code&gt;记忆华为选路原则：世界恋爱组织亚洲办公室，纪念碑下的半兽人&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;```shell
世界恋爱组织亚洲办公室；纪念碑；半兽人
分别对应的英文单词为：
1、W（world） Weight
2、L（love）local preference，本地优先级
3、O（organization）Sourced，本地起源
4、A（asia）AS-PATH
5、O（Office）Origin，起源代码
---
6、M,MED，多出口分离器
7、E，EBGP优于IBGP
8、M，到达更新源的metric小的下一跳
9、L，负载均衡
---
10、O，建立时间更久的EBGP邻居
11、R，更小的RID
12、C，更短的Cluster-list
13、优选来自用最低地址建立BGP 连接的邻居的路由条目
最重要的，下一跳可达是选路的前提条件
```
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;bgp的防环机制&#34;&gt;BGP的防环机制&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;EBGP&lt;/strong&gt;：通过as-path属性，丢弃从EBGP对等体接收到的在as-path属性里包含自身as号的任何更新信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IBGP&lt;/strong&gt;：BGP路由器不会将任何从IBGP对等体接收到的更新信息传给其他IBGP对等体
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IBGP防环机带来的问题&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;为确保更新信息可以到达所有的IBGP对等体
&lt;ul&gt;
&lt;li&gt;解决方案：IBGP Speaker与IBGP Speaker之间要保证会话的全互连【从而又带来了IBGP会话数&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;(&lt;/mo&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;mo&gt;−&lt;/mo&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mo&gt;)&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;/&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;n(n-1)/2&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;−&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;的问题，即IBGP设备过多之后导致维护成本增加】&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路由反射（Route Reflector，RR）：&lt;strong&gt;适合现有网络的改造&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;联盟（Confederation）：&lt;strong&gt;适合新网络的搭建&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;bgp路由反射器&#34;&gt;BGP路由反射器&lt;/h1&gt;
&lt;h2 id=&#34;角色&#34;&gt;角色&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590220985716.png&#34; alt=&#34;BGP路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;路由反射器RR（Route Reflector）：允许把从IBGP对等体学到的路由&lt;strong&gt;反射到其他IBGP对等体的BGP设备&lt;/strong&gt;，类似OSPF网络中的DR。&lt;/li&gt;
&lt;li&gt;客户机（Client）：与RR形成反射邻居关系的IBGP设备。&lt;strong&gt;在AS内部客户机只需要与RR直连&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;非客户机（Non-Client）：既不是RR也不是客户机的IBGP设备。在AS&lt;strong&gt;内部非客户机与RR&lt;/strong&gt;之间，以及&lt;strong&gt;所有的非客户机之间&lt;/strong&gt;仍然必须建立&lt;strong&gt;全连接关系&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;始发者（Originator）：在AS内部始发路由的设备。Originator_ID属性用于&lt;strong&gt;防止集群内产生路由环路&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;集群（Cluster）：路由反射器及其客户机的集合。Cluster_List属性用于防止集群间产生路由环路。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;路由反射宣告原则&#34;&gt;路由反射宣告原则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从非客户机IBGP学到的路由，发布给此RR的所有客户机和EBGP对等体&lt;/li&gt;
&lt;li&gt;从客户机学到的路由，发布给此RR所有非客户机和客户机（发起此路由的客户机除外）&lt;/li&gt;
&lt;li&gt;从EBGP对等体学到的路由，发布给所有的非客户机和客户机&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;路由反射簇即路由反射集群cluster&#34;&gt;路由反射簇（即路由反射集群，Cluster）&lt;/h2&gt;
&lt;p&gt;当一个AS内存在多台RR为Client提供冗余时，RR间的路由更新很有可能会形成环路，为防止该现象，需要使用Cluster。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过4字节的Cluster_ID来标识Cluster，通常会使用LoopBack地址作为Cluster_ID&lt;/li&gt;
&lt;li&gt;一个Cluster里可以包括一个或者多个RR；一个Client可以同时属于多个Cluster&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;originator_id属性&#34;&gt;Originator_ID属性&lt;/h2&gt;
&lt;p&gt;Originator ID由RR产生，使用的Router ID的值标识路由的始发者，用于防止集群内产生路由环路。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一条路由第一次被RR反射的时候，RR将Originator_ID属性加入这条路由，标识这条路由的发起设备。如果一条路由中已经存在了Originator_ID属性，则RR将不会创建新的Originator_ID属性。&lt;/li&gt;
&lt;li&gt;当设备接收到这条路由的时候，将比较收到的Originator ID和本地的Router ID，如果两个ID相同，则不接收此路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cluster_list属性&#34;&gt;Cluster_List属性&lt;/h2&gt;
&lt;p&gt;路由反射器和它的客户机组成一个集群（Cluster），使用AS内唯一的Cluster ID作为标识。为了防止集群间产生路由环路，路由反射器使用Cluster_List属性，记录路由经过的所有集群的Cluster ID。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一条路由第一次被RR反射的时候，RR会把本地Cluster ID添加到Cluster List的前面。如果没有Cluster_List属性，RR就创建一个。&lt;/li&gt;
&lt;li&gt;当RR接收到一条更新路由时，RR会检查Cluster List。如果Cluster List中已经有本地Cluster ID，丢弃该路由；如果没有本地Cluster ID，将其加入Cluster List，然后反射该更新路由。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;备份路由反射器&#34;&gt;备份路由反射器&lt;/h2&gt;
&lt;p&gt;为增加网络的&lt;strong&gt;可靠性&lt;/strong&gt;，防止单点故障对网络造成影响，有时需要在一个集群中配置一个以上的RR。由于RR打破了从IBGP对等体收到的路由不能传递给其他IBGP对等体的限制，所以同一集群内的RR之间中可能存在环路。这时，该&lt;strong&gt;集群中的所有RR必须使用相同的Cluster ID&lt;/strong&gt;，以避免RR之间的路由环路。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590225110630.png&#34; alt=&#34;备份路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;路由反射器RR1和RR2在同一个集群内，配置了相同的Cluster ID&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当客户机Client1从EBGP对等体接收到一条更新路由，它将通过IBGP向RR1和RR2通告这条路由。&lt;/li&gt;
&lt;li&gt;RR1和RR2在接收到该更新路由后，将本地Cluster ID添加到Cluster List前面，然后向其他的客户机（Client2、Client3）反射，同时相互反射。&lt;/li&gt;
&lt;li&gt;RR1和RR2在接收到该反射路由后，检查Cluster List，发现自己的Cluster ID已经包含在Cluster List中。于是RR1和RR2丢弃该更新路由，从而避免了路由环路。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多集群路由反射器&#34;&gt;多集群路由反射器&lt;/h2&gt;
&lt;p&gt;一个AS中可以存在多个集群，各个集群的RR之间建立IBGP对等体。当RR所处的网络层不同时，可以将较低网络层次的RR配成客户机，形成分级RR。当RR所处的网络层相同时，可以将不同集群的RR全连接，形成同级RR。&lt;/p&gt;
&lt;h3 id=&#34;分级路由反射器&#34;&gt;分级路由反射器&lt;/h3&gt;
&lt;p&gt;在实际的RR部署中，常用的是分级RR的场景。ISP为AS100提供Internet路由。AS100内部分为两个集群，其中Cluster1内的四台设备是核心路由器，采用备份RR的形式保证可靠性。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590225258979.png&#34; alt=&#34;分级路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;同级路由反射器&#34;&gt;同级路由反射器&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590225345221.png&#34; alt=&#34;同级路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
一个骨干网被分成多个集群。各集群的RR互为非客户机关系，并建立全连接。此时虽然每个客户机只与所在集群的RR建立IBGP连接，但所有RR和客户机都能收到全部路由信息。&lt;/p&gt;
&lt;h1 id=&#34;bgp联盟&#34;&gt;BGP联盟&lt;/h1&gt;
&lt;p&gt;解决AS内部的IBGP网络连接激增问题，除了使用路由反射器之外，还可以使用联盟（Confederation）。联盟&lt;strong&gt;将一个AS划分为若干个子AS&lt;/strong&gt;。&lt;strong&gt;每个子AS内部建立IBGP全连接关系，子AS之间建立联盟EBGP连接关系，但联盟外部AS仍认为联盟是一个AS&lt;/strong&gt;。配置联盟后，原AS号将作为每个路由器的联盟ID。这样有两个&lt;strong&gt;好处&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以保留原有的IBGP属性，包括Local Preference属性、MED属性和NEXT_HOP属性等；&lt;/li&gt;
&lt;li&gt;联盟相关的属性在传出联盟时会自动被删除，即管理员无需在联盟的出口处配置过滤子AS号等信息的操作。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1590226126773.png&#34; alt=&#34;BGP联盟&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
AS100使用联盟后被划分为3个子AS：AS65001、AS65002和AS65003，使用AS100作为联盟ID。此时IBGP的连接数量从10条减少到4条，不仅简化了设备的配置，也减轻了网络和CPU的负担。而AS100外的BGP设备因为仅知道AS100的存在，并不知道AS100内部的联盟关系，所以不会增加CPU的负担。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;路由反射器和联盟的比较&#34;&gt;路由反射器和联盟的比较&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;路由反射器&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;联盟&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要更改现有的网络拓扑，兼容性好&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要改变逻辑拓扑&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;配置方便，只需要对作为反射器的设备进行配置，客户机并不需要知道自己是客户机&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;所有设备需要重新进行配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;集群与集群之间仍然需要全连接&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;联盟的子AS之间是特殊的EBGP连接，不需要全连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;适用于中、大规模网络（对现有网络进行改造）&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;适用于大规模网络（新建大型网络）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;实验一简单配置bgp&#34;&gt;实验一：简单配置BGP&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589817043629.png&#34; alt=&#34;简单配置BGP&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;华为&lt;/strong&gt;BGP如果用&lt;strong&gt;默认路由&lt;/strong&gt;，邻居可以正常UP，但是&lt;strong&gt;路由不是有效的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;思科BGP如果用默认路由建立，邻居不会UP&lt;/li&gt;
&lt;li&gt;IBGP通常用环回口建，EBGP通常能直连建立邻居，&lt;strong&gt;一台设备只能启用一个BGP进程&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;BGP设备将EBGP路由传递给IBGP时&lt;strong&gt;不会修改下一跳&lt;/strong&gt;，需要&lt;strong&gt;手工配置&lt;/strong&gt;修改&lt;/li&gt;
&lt;li&gt;BGP的水平分割：从IBGP收到的路由，不会传递给IBGP邻居&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ...........................初始化配置
# AR1
sys 
sys AR1
int lo 0
ip addr 1.1.1.1 32
int lo 10
ip addr 11.11.11.11 32
int g0/0/0
ip addr 12.1.1.1 24
# AR2
sys 
sys AR2
int lo 0
ip addr 2.2.2.2 32
int g0/0/0
ip addr 12.1.1.2 24
int g0/0/1
ip addr 23.1.1.2 24
int g0/0/2
ip addr 24.1.1.2 24
# AR3
sys 
sys AR3
int lo 0
ip addr 3.3.3.3 32
int g0/0/0
ip addr 23.1.1.3 24
int g0/0/1
ip addr 35.1.1.3 24
# AR4
sys 
sys AR4
int lo 0
ip addr 4.4.4.4 32
int g0/0/0
ip addr 24.1.1.4 24
int g0/0/1
ip addr 45.1.1.4 24
# AR5
sys 
sys AR5
int lo 0
ip addr 5.5.5.5 32
int g0/0/0
ip addr 35.1.1.5 24
int g0/0/1
ip addr 45.1.1.5 24
int g0/0/2
ip addr 56.1.1.5 24
# AR6
sys 
sys AR6
int lo 0
ip addr 6.6.6.6 32
int lo 10
ip addr 66.6.6.66.66 32
int g0/0/0
ip addr 56.1.1.6 24
# ......................................配置OSPF，保证IBGP内网络连通
# AR2
ospf 10 router-id 2.2.2.2
area 0
net 23.1.1.2 0
net 24.1.1.2 0
net 2.2.2.2 0
int g0/0/1
ospf network-type p2p
int g0/0/2
ospf network-type p2p
# AR3
ospf 10 router-id 3.3.3.3
area 0
net 23.1.1.3 0
net 35.1.1.3 0
net 3.3.3.3 0
int g0/0/0
ospf network-type p2p
int g0/0/1
ospf network-type p2p
# AR4
ospf 10 router-id 4.4.4.4
area 0
net 24.1.1.4 0
net 45.1.1.4 0
net 4.4.4.4 0
int g0/0/0
ospf network-type p2p
int g0/0/1
ospf network-type p2p
# AR4
ospf 10 router-id 5.5.5.5
area 0
net 34.1.1.5 0
net 45.1.1.5 0
net 5.5.5.5 0
int g0/0/0
ospf network-type p2p
int g0/0/1
ospf network-type p2p
# .....................................配置BGP
# AR1
bgp 100
router-id 1.1.1.1
peer 12.1.1.2 as-number 200
peer 2.2.2.2 as-number 200
peer 2.2.2.2 connect-interface lo 0
peer 2.2.2.2 ebgp-max-hop 2
network 11.11.11.11 32
# AR2
bgp 200
router-id 2.2.2.2
peer 12.1.1.1 as-number 100
peer 1.1.1.1 as-number 100
peer 1.1.1.1 connect-interface lo 0
peer 1.1.1.1 ebgp-max-hop 2
peer 3.3.3.3 as-number 200
peer 3.3.3.3 connect-interface lo 0
peer 4.4.4.4 as-number 200
peer 4.4.4.4 connect-interface lo 0
# AR3
bgp 200
router-id 3.3.3.3
peer 2.2.2.2 as-number 200
peer 2.2.2.2 connect-interface lo 0
peer 5.5.5.5 as-number 200
peer 5.5.5.5 connect-interface lo 0
# AR4
bgp 200
router-id 4.4.4.4
peer 2.2.2.2 as-number 200
peer 2.2.2.2 connect-interface lo 0
peer 5.5.5.5 as-number 200
peer 5.5.5.5 connect-interface lo 0
# AR5
bgp 200
router-id 5.5.5.5
peer 3.3.3.3. as-number 200
peer 3.3.3.3 connect-interface lo 0
peer 4.4.4.4 as-number 200
peer 4.4.4.4 connect-interface lo 0
peer 56.1.1.6 as-number 300
peer 6.6.6.6 as-number 300
peer 6.6.6.6 connect-interface lo 0
peer 6.6.6.6 ebgp-max-hop 2
# AR6
bgp 300
router-id 6.6.6.6
peer 5.5.5.5 as-number 200
peer 5.5.5.5 connect-interface lo 0
peer 5.5.5.5 ebgp-max-hop 2
peer 56.1.1.5 as-number 200
net 66.66.66.66 32
# .............................配置静态
# AR5
ip route-static 6.6.6.6 32 56.1.1.6
# AR6
ip route-static 5.5.5.5 32 56.1.1.5
#................................手动配置下一条
# AR2
bgp 200
peer 3.3.3.3 next-hop-local
peer 4.4.4.4 next-hop-local
# AR5
bgp 200
peer 3.3.3.3 next-hop-local
peer 4.4.4.4 next-hop-local
# 手工刷新路由表
# AR2/5
refresh bgp all export 
# AR3/4
refresh bgp all import 
# .......................................使11.11.11.11和66.66.66.66通信
# AR2
bgp 200
peer 5.5.5.5 as-number 200
peer 5.5.5.5 connect-interface lo 0
peer 5.5.5.5 next-hop-local
# AR5
bgp 200
peer 2.2.2.2 as-number 200
peer 2.2.2.2 connect-interface lo 0
peer 2.2.2.2 next-hop-local
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二bgp优化次优路径&#34;&gt;实验二：BGP优化次优路径&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590160819588.png&#34; alt=&#34;BGP优化次优路径&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ...............................配置
# AR1
sys
sys AR1
int lo 0 
ip addr 1.1.1.1 32
int g0/0/0
ip addr 123.1.1.1 24
bgp 100
router-id 1.1.1.1
peer 123.1.1.2 as 200
# AR2
sys
sys AR2
int lo 0 
ip addr 2.2.2.2 32
int g0/0/0
ip addr 123.1.1.2 24
bgp 200
router-id 2.2.2.2
peer 123.1.1.1 as 100
peer 123.1.1.3 as 300
# AR3
sys
sys AR2
int lo 0 
ip addr 3.3.3.3 32
int lo 100 
ip addr 100.100.100.100 32
int g0/0/0
ip addr 123.1.1.3 24
bgp 300
router-id 3.3.3.3
peer 123.1.1.2 as 200
net 100.100.100.100 32

# ...........................查看
# AR2/1
dis bgp ro # 100.100.100.100这条路由的下一跳为123.1.1.3，此时没有修改下一跳，重定向了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三路由反射器只写主要配置&#34;&gt;实验三：路由反射器(只写主要配置)&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1590223587262.png&#34; alt=&#34;路由反射器&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1：路由反射器
bgp 100
router-id 1.1.1.1
group QYT internal     # 配置组为IBGP 
peer QYT connect-interface LoopBack0
peer 2.2.2.2 as-number 100 # 此命令可省略，IBGP默认as-number相同
peer 2.2.2.2 group QYT 
peer 2.2.2.2 reflect-client      # 指定2.2.2.2为反射客户端 
peer 3.3.3.3 as-number 100 # 此命令可省略，IBGP默认as-number相同
peer 3.3.3.3 group QYT 
peer 3.3.3.3 reflect-client      # 指定3.3.3.3为反射客户端 
peer 4.4.4.4 group QYT 
peer 5.5.5.5 group QYT 
group Ebgp externa     # 配置组为EBGP 
peer Ebgp as-number 200 
peer 16.1.1.6 group Ebgp 
reflector cluster-id 1.1.1.1    # 配置RR的簇ID 

# AR2：客户端
bgp 100
router-id 2.2.2.2
peer 1.1.1.1 as-number 100
peer 1.1.1.1 connect-interface LoopBack0
# AR3：客户端
bgp 100
router-id 3.3.3.3
peer 1.1.1.1 as-number 100
peer 1.1.1.1 connect-interface LoopBack0
# AR4：非客户端
bgp 100
router-id 4.4.4.4
peer 1.1.1.1 as-number 100
peer 1.1.1.1 connect-interface LoopBack0
# AR5：非客户端
bgp 100
router-id 5.5.5.5
peer 1.1.1.1 as-number 100
peer 1.1.1.1 connect-interface LoopBack0

# AR6：EBGP邻居
bgp 200
router-id 6.6.6.6
peer 16.1.1.1 as-number 100

# 查看AR1/3/4/5/6
dis bgp rou 22.22.22.22
dis bgp rou 44.44.44.44
dis bgp rou 66.66.66.66
&lt;/code&gt;&lt;/pre&gt;
">05 BGP（2020.0518）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-zhi-du-qu-pei-zhi-wen-jian/"" data-c="
          &lt;h1 id=&#34;介绍&#34;&gt;介绍&lt;/h1&gt;
&lt;p&gt;configparser模块主要用于读取配置文件，configparser模块支持读取&lt;code&gt;.conf和.ini&lt;/code&gt;等类型的文件。&lt;br&gt;
该模块的作用 就是使用模块中的&lt;code&gt;RawConfigParser()、ConfigParser()、 SafeConfigParser()&lt;/code&gt;这三个方法（&lt;strong&gt;三者择其一&lt;/strong&gt;），创建一个对象使用对象的方法对指定的配置文件做增删改查操作。&lt;/p&gt;
&lt;h1 id=&#34;配置文件格式&#34;&gt;配置文件格式&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[section] 
name=value
或者
name: value
&amp;quot;#&amp;quot; 和&amp;quot;;&amp;quot; 表示注释

[DEFAULT] #设置默认的变量值，初始化
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[My Section]
foodir: %(dir)s/whatever
dir=frob
long: this value continues
   in the next line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;%(dir)s&lt;/code&gt;会被&lt;code&gt;frob&lt;/code&gt;代替。默认值会以字典的形式传递给ConfigParser的构造器。section一般存放的哦内置目录下，如果切换到其他的目录需啊哟指定存放位置。&lt;/p&gt;
&lt;h1 id=&#34;方法&#34;&gt;方法&lt;/h1&gt;
&lt;p&gt;下面这三种方式使用时，切记注意。在调用这三个函数时，切记这三个函数会将调用&lt;code&gt;optionxform()&lt;/code&gt;，在传递键值对数据时，&lt;strong&gt;会将键名全部转化为小写&lt;/strong&gt;。&lt;br&gt;
传递参数使用函数optionxform()，foo %(bar)s 和 foo %(BAR)s是相同的，optionxform()会将大写字母全部转换为小写。&lt;/p&gt;
&lt;h2 id=&#34;rawconfigparser&#34;&gt;RawConfigParser()&lt;/h2&gt;
&lt;p&gt;不支持可变参数，在section中不能存在%()s&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ConfigParser.RawConfigParser([defaults[, dict_type[, allow_no_value]]]) 
    defaults : 如果指定默认值，则使用默认值的键值对
    dict_type：使用新的section的键值对
    allow_no_value ：默认是False，如果是True，表示可以接收空值（None）
    return：对象
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对象操作&#34;&gt;对象操作&lt;/h3&gt;
&lt;p&gt;对象的操作可以分为两大类，一种是对配置文件的操作，另一种是对读取后数据流的操作。&lt;/p&gt;
&lt;h4 id=&#34;对配置文件的操作&#34;&gt;对配置文件的操作&lt;/h4&gt;
&lt;h5 id=&#34;读取配置文件&#34;&gt;读取配置文件&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;read(filenames)：filesnames是一个列表，需要从文件加载初始值的应用程序应该在调用read()之前使用readfp()加载所需的文件或文件。&lt;/li&gt;
&lt;li&gt;readfp(fp[, filename])：在fp中，从文件或文件类对象中读取和解析配置数据(只使用readline()方法)。如果文件名被省略，并且fp有一个name属性，它被用于文件名;默认值为&amp;lt; ? &amp;gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;写入配置文件&#34;&gt;写入配置文件&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;write(fileobject)：将配置的表示写入指定的文件对象。这个表示可以由未来的read()调用解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;对内存中数据流的操作&#34;&gt;对内存中数据流的操作&lt;/h4&gt;
&lt;h5 id=&#34;增加配置文件中的值&#34;&gt;增加配置文件中的值&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;add_section(section)：向实例添加一个section&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;删除配置文件中的值&#34;&gt;删除配置文件中的值&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;remove_section(section)：从配置中删除指定的section。如果这个部分确实存在，返回True;否则返回False。&lt;/li&gt;
&lt;li&gt;remove_option(section, option)：从指定的部分中删除指定的选项。如果该部分不存在，请提出NoSectionError。如果存在的选项被删除，返回True;否则返回False。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;修改配置文件中的值&#34;&gt;修改配置文件中的值&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;set(section, option, value)：如果给定的部分存在，将给定的选项设置为指定的值&lt;/li&gt;
&lt;li&gt;optionxform(option)：也可以在一个实例上重新设置它，对于一个需要字符串参数的函数。例如，将其设置为str，将使选项名称&lt;strong&gt;区分大小写&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;查找配置文件中的值&#34;&gt;查找配置文件中的值&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;defaults()：返回包含实例范围默认值的字典。&lt;/li&gt;
&lt;li&gt;sections()：返回可用的section的列表;默认section不包括在列表中&lt;/li&gt;
&lt;li&gt;options(section)：返回指定section中可用的选项列表。&lt;/li&gt;
&lt;li&gt;items(section)：返回给定section中每个选项的(name,value)对的列表。&lt;/li&gt;
&lt;li&gt;has_section(section)：指示指定的section是否出现在配置中。默认的section未被确认&lt;/li&gt;
&lt;li&gt;has_option(section, option)：如果给定的section存在，并且包含给定的选项，则返回True;否则返回False&lt;/li&gt;
&lt;li&gt;get(section, option)：为指定的section获取一个选项值。&lt;/li&gt;
&lt;li&gt;getint(section, option)：它将指定section中的选项强制转换为整数&lt;/li&gt;
&lt;li&gt;getfloat(section, option)：它将指定section中的选项强制转换为浮点型&lt;/li&gt;
&lt;li&gt;getboolean(section, option)：强制转换为布尔型，”1”, “yes”, “true”, and “on”, 转换为True，”0”, “no”, “false”, and “off”, 转换为Falseo 其他返回ValueError.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;configparser&#34;&gt;ConfigParser(）&lt;/h2&gt;
&lt;p&gt;在default中必须出现%()s&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ConfigParser.ConfigParser([defaults[, dict_type[, allow_no_value]]]) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对象操作-2&#34;&gt;对象操作&lt;/h3&gt;
&lt;p&gt;ConfigParser中包含RawConfigParser相同的方法，还有一部分增加的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get(section, option[, raw[, vars]])：为指定的section获取一个选项值。如果提供了vars，它必须是一个字典。该选项在vars(如果提供)、分段和默认值中查找,&lt;/li&gt;
&lt;li&gt;items(section[, raw[, vars]])：返回给定section中每个选项的(名称、值)对的列表&lt;/li&gt;
&lt;li&gt;add_set(section,option,value)：对section中的option信息进行写入。本方法和&lt;code&gt;set&lt;/code&gt;方法相同&lt;br&gt;
&lt;code&gt;所有的“%”插值都在返回值中展开，除非原始的参数是真的。内插键的值与选项相同&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;safeconfigparser&#34;&gt;SafeConfigParser()&lt;/h2&gt;
&lt;p&gt;更加智能化，在section中是否存在%()s会自动判断&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ConfigParser.SafeConfigParser([defaults[, dict_type[, allow_no_value]]]) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;对象操作-3&#34;&gt;对象操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;set(section, option, value)&lt;/code&gt;&lt;br&gt;
如果给定的部分存在，将给定的选项设置为指定的值;否则提高NoSectionError。值必须是字符串(str或unicode);如果没有，则会出现类型错误&lt;/p&gt;
&lt;h1 id=&#34;异常&#34;&gt;异常&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;ConfigParser.Error：所有异常的基类&lt;/li&gt;
&lt;li&gt;ConfigParser.NoSectionError：指定的section没有找到&lt;/li&gt;
&lt;li&gt;ConfigParser.DuplicateSectionError：调用add_section() 时，section名称已经被使用&lt;/li&gt;
&lt;li&gt;ConfigParser.NoOptionError：指定的参数没有找到&lt;/li&gt;
&lt;li&gt;ConfigParser.InterpolationError：当执行字符串插值时出现问题时，出现异常的基类&lt;/li&gt;
&lt;li&gt;ConfigParser.InterpolationDepthError：当字符串插值无法完成时，因为迭代次数超过了最大的范围，所以无法完成。InterpolationError的子类&lt;/li&gt;
&lt;li&gt;InterpolationMissingOptionError：当引用的选项不存在时，会出现异常。InterpolationError的子类&lt;/li&gt;
&lt;li&gt;ConfigParser.InterpolationSyntaxError：当产生替换的源文本不符合所需的语法时，就会出现异常。InterpolationError的子类。&lt;/li&gt;
&lt;li&gt;ConfigParser.MissingSectionHeaderError：当试图解析一个没有分段标题的文件时，会出现异常。&lt;/li&gt;
&lt;li&gt;ConfigParser.ParsingError：当试图解析文件时发生错误时，会出现异常&lt;/li&gt;
&lt;li&gt;ConfigParser.MAX_INTERPOLATION_DEPTH：当raw参数为false时，get()的递归插值的最大深度。这只适用于ConfigParser类&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;实例&#34;&gt;实例&lt;/h1&gt;
&lt;p&gt;配置文件config.ini&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[user]
user_name = Mr,X
password = 222

[connect]
ip = 127.0.0.1
port = 4723
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;初始化操作&#34;&gt;初始化操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import configparser
# 生成ConfigParser对象
config = configparser.ConfigParser()
# 读取配置文件
filename = &#39;config.ini&#39;
config.read(filename, encoding=&#39;utf-8&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;基本操作&#34;&gt;基本操作&lt;/h2&gt;
&lt;h3 id=&#34;获取节点sections&#34;&gt;获取节点sections&lt;/h3&gt;
&lt;p&gt;ConfigParser.sections()，以列表形式返回configparser对象的所有节点信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 获取所有节点
all_sections = config.sections()
print(&#39;sections: &#39;, all_sections)   
# 结果sections:  [&#39;user&#39;, &#39;connect&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取指定节点的的所有配置信息&#34;&gt;获取指定节点的的所有配置信息&lt;/h3&gt;
&lt;p&gt;ConfigParser.items(section)，以列表形式返回某个节点section对应的所有配置信息&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 获取指定节点的配置信息
items = config.items(&#39;user&#39;)
print(items)            
# 结果 [(&#39;user_name&#39;, &amp;quot;&#39;Mr,X&#39;&amp;quot;), (&#39;password&#39;, &amp;quot;&#39;222&#39;&amp;quot;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取指定节点的options&#34;&gt;获取指定节点的options&lt;/h3&gt;
&lt;p&gt;ConfigParser.options(section)，以列表形式返回某个节点section的所有key值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 获取指定节点的options信息
options = config.options(&#39;user&#39;)
print(options)         
 # 结果 [&#39;user_name&#39;, &#39;password&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取指定节点下指定option的值&#34;&gt;获取指定节点下指定option的值&lt;/h3&gt;
&lt;p&gt;ConfigParser.get(section, option)，返回结果是字符串类型&lt;br&gt;
ConfigParser.getint(section, option)，返回结果是int类型&lt;br&gt;
ConfigParsergetboolean(section, option)，返回结果是bool类型&lt;br&gt;
ConfigParser.getfloat(section, option)，返回结果是float类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 获取指定节点指定option的值
name = config.get(&#39;user&#39;, &#39;user_name&#39;)
print(name, type(name))            
# 结果 &#39;Mr,X&#39; &amp;lt;class &#39;str&#39;&amp;gt;
port = config.getint(&#39;connect&#39;, &#39;port&#39;)
print(port, type(port))           
# 结果  4723 &amp;lt;class &#39;int&#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;检查section或option是否存在&#34;&gt;检查section或option是否存在&lt;/h3&gt;
&lt;p&gt;ConfigParser.has_section(section)&lt;br&gt;
ConfigParser.has_option(section, option)&lt;br&gt;
返回bool值，若存在返回True，不存在返回False&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 检查section是否存在
result = config.has_section(&#39;user&#39;)
print(result)   
# 结果 True
result = config.has_section(&#39;user1&#39;)
print(result)   
# 结果 False

# 检查option是否存在
result = config.has_option(&#39;user&#39;, &#39;user_name&#39;)
print(result)   # 结果 True
result = config.has_option(&#39;user&#39;, &#39;user_name1&#39;)
print(result)   # 结果 False
result = config.has_option(&#39;user1&#39;, &#39;user_name&#39;)
print(result)   # 结果 False
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加section&#34;&gt;添加section&lt;/h3&gt;
&lt;p&gt;ConfigParser.add_section(section)，如果section不存在，则添加节点section；若section已存在，再执行add操作会报错&lt;code&gt;configparser.DuplicateSectionError: Section XX already exists&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 添加section
if not config.has_section(&#39;remark&#39;):
    config.add_section(&#39;remark&#39;)
config.set(&#39;remark&#39;, &#39;info&#39;, &#39;ok&#39;)
config.write(open(filename, &#39;w&#39;))
remark = config.items(&#39;remark&#39;)
print(remark)    
# 结果 [(&#39;info&#39;, &#39;ok&#39;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改或添加指定节点下指定option的值&#34;&gt;修改或添加指定节点下指定option的值&lt;/h3&gt;
&lt;p&gt;ConfigParser.set(section, option, value)，若option存在，则会替换之前option的值为value；若option不存在，则会创建optiion并赋值为value&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 修改指定option的值
config.set(&#39;user&#39;, &#39;user_name&#39;, &#39;Mr L&#39;)
config.set(&#39;user&#39;, &#39;isRemember&#39;, &#39;True&#39;)
config.write(open(filename, &#39;w&#39;))
# 重新查看修改后节点信息
items = config.items(&#39;user&#39;)
print(items)    
# 结果 [(&#39;user_name&#39;, &#39;Mr L&#39;), (&#39;password&#39;, &#39;222&#39;), (&#39;isremember&#39;, &#39;True&#39;)]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除section或option&#34;&gt;删除section或option&lt;/h3&gt;
&lt;p&gt;ConfigParser.remove_section(section)，若section存在，执行删除操作；若section不存在，则不会执行任何操作&lt;br&gt;
ConfigParser.remove_option(section, option)，若option存在，执行删除操作；若option不存在，则不会执行任何操作；若section不存在，则会报错configparser.NoSectionError: No section: XXX&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 删除section
config.remove_section(&#39;remark&#39;)         # section存在
config.remove_section(&#39;no_section&#39;)     # section不存在

# 删除option
config.remove_option(&#39;user&#39;, &#39;isremember&#39;)  # option存在
config.remove_option(&#39;user&#39;, &#39;no_option&#39;)   # option不存在
config.write(open(filename, &#39;w&#39;))

all_sections = config.sections()
print(all_sections)     
# 结果 [&#39;user&#39;, &#39;connect&#39;]
options = config.options(&#39;user&#39;)
print(options)      
# 结果 [&#39;user_name&#39;, &#39;password&#39;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;写入内容&#34;&gt;写入内容&lt;/h3&gt;
&lt;p&gt;ConfigParser.write(open(filename, &#39;w&#39;))，对configparser对象执行的一些修改操作，必须重新写回到文件才可生效&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;config.write(open(filename, &#39;w&#39;))
&lt;/code&gt;&lt;/pre&gt;
">Python之读取配置文件</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-zhi-can-shu-chuan-ru/"" data-c="
          &lt;h1 id=&#34;方法一sysargv&#34;&gt;方法一：sys.argv&lt;/h1&gt;
&lt;p&gt;这个模块是我在工作中最常见的其他人写的Python脚本传入命令行参数的方式，也是最简单（粗暴）的方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sys.argv 是命令行参数列表&lt;/li&gt;
&lt;li&gt;len(sys.argv) 是命令行参数个数&lt;/li&gt;
&lt;li&gt;sys.argv[0] 表示脚本名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实例&#34;&gt;实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys
def test_for_sys(year, name, body):
    print(&#39;the year is&#39;, year)
    print(&#39;the name is&#39;, name)
    print(&#39;the body is&#39;, body)
if __name__ == &#39;__main__&#39;:
    try:
        year, name, body = sys.argv[1:4]
        test_for_sys(year, name, body)
    except Exception as e:
        print(sys.argv)
        print(e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般我的 Python 脚本的启动函数就像上的例子一样，可能需要传入几个必要参数，这个时候，如果我们在使用命令行传入的时候，就可以使用 sys.argv 这个属性，任何一个 Python 脚本在启动的时候都有这个属性，它是一个列表，列表的第一个参数是脚本的命令，列表后面的参数就是命令行传入的参数，所以可以在脚本中提取这些参数传入到函数中运行。&lt;br&gt;
执行以上代码，输出结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;G:\Allcodes\testscripts&amp;gt;python test_cmd.py 2018 Leijun &amp;quot;are you ok?&amp;quot;
the year is 2018
the name is Leijun
the body is are you ok?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很好理解，由于 sys.argv 是一个由参数组成的列表，所以如果脚本中需要的参数比你命令行中输入的多，那肯定会报错，因为你输入的参数不够，反过来，如果你输入的参数比函数需要的多，那么无所谓，多的参数因为不会被提取使用，所以不影响脚本运行。&lt;/p&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;sys.argv 形式传入参数的方式比较&lt;strong&gt;简单&lt;/strong&gt;，但是也很&lt;strong&gt;死板&lt;/strong&gt;，因为传入的参数是一个&lt;strong&gt;有序的列表&lt;/strong&gt;，所以在命令行中&lt;strong&gt;必须按照脚本规定的顺序去输入参数&lt;/strong&gt;，这种方法比较适合脚本中需要的&lt;strong&gt;参数个数很少且参数固定的脚本&lt;/strong&gt;。&lt;/p&gt;
&lt;h1 id=&#34;方法二getopt模块&#34;&gt;方法二：getopt模块&lt;/h1&gt;
&lt;p&gt;getopt模块是专门处理命令行参数的模块，用于获取命令行选项和参数，也就是sys.argv。命令行选项使得程序的参数更加灵活。支持短选项模式（-）和长选项模式（--）。&lt;br&gt;
该模块提供了&lt;strong&gt;两个方法及一个异常处理&lt;/strong&gt;来解析命令行参数。&lt;/p&gt;
&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;
&lt;h3 id=&#34;getoptgetopt&#34;&gt;getopt.getopt&lt;/h3&gt;
&lt;p&gt;getopt.getopt 方法用于解析命令行参数列表，语法格式如下：&lt;br&gt;
&lt;code&gt;getopt.getopt(args, options[, long_options])&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;参数说明&#34;&gt;参数说明&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;args: 要解析的命令行参数列表。&lt;/li&gt;
&lt;li&gt;options: 以字符串的格式定义，options后的冒号(:)表示该选项必须有附加的参数，不带冒号表示该选项不附加参数。&lt;/li&gt;
&lt;li&gt;long_options: 以列表的格式定义，long_options 后的等号(=)表示如果设置该选项，必须有附加的参数，否则就不附加参数。&lt;br&gt;
该方法返回值由两个元素组成: 第一个是 (option, value) 元组的列表。 第二个是参数列表，包含那些没有&#39;-&#39;或&#39;--&#39;的参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;getoptgnu_getopt&#34;&gt;getopt.gnu_getopt&lt;/h3&gt;
&lt;h2 id=&#34;异常处理&#34;&gt;异常处理&lt;/h2&gt;
&lt;h3 id=&#34;exception-getoptgetopterror&#34;&gt;Exception getopt.GetoptError&lt;/h3&gt;
&lt;p&gt;在没有找到参数列表，或选项的需要的参数为空时会触发该异常，异常的参数是一个字符串，表示错误的原因，属性 msg 和 opt 为相关选项的错误信息。&lt;/p&gt;
&lt;h2 id=&#34;实例-2&#34;&gt;实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import sys, getopt
def main(argv):
   inputfile = &#39;&#39;
   outputfile = &#39;&#39;
   try:
      opts, args = getopt.getopt(argv,&amp;quot;hi:o:&amp;quot;,[&amp;quot;ifile=&amp;quot;,&amp;quot;ofile=&amp;quot;])
   except getopt.GetoptError:
      print (&#39;test.py -i &amp;lt;inputfile&amp;gt; -o &amp;lt;outputfile&amp;gt;&#39;)
      sys.exit(2)
   for opt, arg in opts:
      if opt == &#39;-h&#39;:
         print (&#39;test.py -i &amp;lt;inputfile&amp;gt; -o &amp;lt;outputfile&amp;gt;&#39;)
         sys.exit()
      elif opt in (&amp;quot;-i&amp;quot;, &amp;quot;--ifile&amp;quot;):
         inputfile = arg
      elif opt in (&amp;quot;-o&amp;quot;, &amp;quot;--ofile&amp;quot;):
         outputfile = arg
   print (&#39;输入的文件为：&#39;, inputfile)
   print (&#39;输出的文件为：&#39;, outputfile)

if __name__ == &amp;quot;__main__&amp;quot;:
   main(sys.argv[1:])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行以上代码，输出结果为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;$ python3 test.py -h
usage: test.py -i &amp;lt;inputfile&amp;gt; -o &amp;lt;outputfile&amp;gt;

$ python3 test.py -i inputfile -o outputfile
输入的文件为： inputfile
输出的文件为： outputfile
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;方法三argparse-模块&#34;&gt;方法三：argparse 模块&lt;/h1&gt;
&lt;p&gt;argparse 模块也是 Python 自带的一个命令行参数模块，这个模块才是真的为了命令行参数而生的模块，相较之下 sys.argv 只是碰巧可以用在命令行参数上面而已。&lt;/p&gt;
&lt;h2 id=&#34;参数&#34;&gt;参数&lt;/h2&gt;
&lt;p&gt;在添加命令行参数的属性的时候，还可以有更多的设置，如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;name or flags：也就是在使用参数的时候使用的符号，--foo 或者 -f&lt;/li&gt;
&lt;li&gt;action：根据我的理解，这个属性可以选择参数在只提供符号而不输入实际的值的时候给予一个默认的值&lt;/li&gt;
&lt;li&gt;nargs：这个属性规定了参数可以输入的个数&lt;/li&gt;
&lt;li&gt;const：这属性跟 action 属性一起使用&lt;/li&gt;
&lt;li&gt;default：这属性就是给参数设置一个默认值&lt;/li&gt;
&lt;li&gt;type：这个属性规定了参数的数据类型&lt;/li&gt;
&lt;li&gt;choices：这个属性给参数限定了一个选择的迭代，参数只能在这个范围内选择参数的值，否则报错&lt;/li&gt;
&lt;li&gt;required：参数的值为必填&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;实例-3&#34;&gt;实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import argparse

def test_for_sys(year, name, body):
    print(&#39;the year is&#39;, year)
    print(&#39;the name is&#39;, name)
    print(&#39;the body is&#39;, body)

parser = argparse.ArgumentParser(description=&#39;Test for argparse&#39;)
parser.add_argument(&#39;--name&#39;, &#39;-n&#39;, help=&#39;name 属性，非必要参数&#39;)
parser.add_argument(&#39;--year&#39;, &#39;-y&#39;, help=&#39;year 属性，非必要参数，但是有默认值&#39;, default=2017)
parser.add_argument(&#39;--body&#39;, &#39;-b&#39;, help=&#39;body 属性，必要参数&#39;, required=True)
args = parser.parse_args()

if __name__ == &#39;__main__&#39;:
    try:
        test_for_sys(args.year, args.name, args.body)
    except Exception as e:
        print(e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;argparse&lt;/code&gt; 模块的方式也挺简单的，首先需要构建一个参数实例，也就是代码中的&lt;code&gt;parser = argparse.ArgumentParser(description=&#39;Test for argparse&#39;)&lt;/code&gt;&lt;br&gt;
这行代码就生成了一个命令行参数的对象，之后就可以给对象添加一些参数属性，最后只需要从属性从提取传入的参数进行使用即可。&lt;br&gt;
上面的代码添加了3个参数，添加参数的前两个字段很容易理解，&lt;code&gt;--name&lt;/code&gt; 和 &lt;code&gt;-n&lt;/code&gt; 都可以用来在命令行中使用，都表示了参数 &lt;code&gt;name&lt;/code&gt;，这样后面使用 &lt;code&gt;parse_args()&lt;/code&gt; 方法获取到所有参数之后，就可以使用 &lt;code&gt;args.name&lt;/code&gt; 这种形式来提取对应的参数。&lt;br&gt;
首先来看看使用了命令行参数之后脚本的“&lt;strong&gt;帮助&lt;/strong&gt;”：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;G:\Allcodes\testscripts&amp;gt;python test_cmd.py --help
usage: test_cmd.py [-h] [--name NAME] [--year YEAR] --body BODY

Test for argparse

optional arguments:
  -h, --help            show this help message and exit
  --name NAME, -n NAME  name 属性，非必要参数
  --year YEAR, -y YEAR  year 属性，非必要参数，但是有默认值
  --body BODY, -b BODY  body 属性，必要参数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，脚本生成了一个 &lt;code&gt;help&lt;/code&gt;，这样就可以在脚本中对每个参数的使用进行一些描述，方便其他人更加了解每个参数的含义，方便使用。&lt;br&gt;
看一下运行成功的几个命令，首先是不传入 &lt;code&gt;year&lt;/code&gt; 参数，而使用默认的参数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;G:\Allcodes\testscripts&amp;gt;python test_cmd.py -n Leijun --body &amp;quot;are you ok?&amp;quot;
the year is 2017
the name is Leijun
the body is are you ok?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后是不提供 &lt;code&gt;name&lt;/code&gt; 参数，但是不会报错，最后可以看到从参数中会得到一个 &lt;code&gt;None&lt;/code&gt; 并传入到了脚本中进行使用:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;G:\Allcodes\testscripts&amp;gt;python test_cmd.py --body &amp;quot;are you ok?&amp;quot;
the year is 2017
the name is None
the body is are you ok?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后看一个报错的执行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;G:\Allcodes\testscripts&amp;gt;python test_cmd.py
usage: test_cmd.py [-h] [--name NAME] [--year YEAR] --body BODY
test_cmd.py: error: the following arguments are required: --body/-b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到上面的报错提示了 &lt;code&gt;body&lt;/code&gt; 参数是一个必要参数，不能少。&lt;/p&gt;
&lt;h2 id=&#34;小结-2&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;其实我非常喜欢这个内置的命令行参数模块，因为它不仅方便使用，更重要的是它就是内置的，不需要单独安装依赖。&lt;/p&gt;
&lt;h1 id=&#34;方法四click-库&#34;&gt;方法四：click 库&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;Click&lt;/code&gt; 是 &lt;code&gt;Flask&lt;/code&gt; 的团队 &lt;code&gt;pallets&lt;/code&gt; 开发的优秀开源项目，它为命令行工具的开发封装了大量方法，使开发者只需要专注于功能实现。这是一个第三方库，专门为了命令行而生的非常有名的 Python 命令行模块。&lt;/p&gt;
&lt;h2 id=&#34;实例-4&#34;&gt;实例&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import click

@click.command()
@click.option(&#39;--name&#39;,default=&#39;Leijun&#39;,help=&#39;name 参数，非必须，有默认值&#39;)
@click.option(&#39;--year&#39;,help=&#39;year 参数&#39;,type=int)
@click.option(&#39;--body&#39;,help=&#39;body 参数&#39;)
def test_for_sys(year, name, body):
    print(&#39;the year is&#39;, year)
    print(&#39;the name is&#39;, name)
    print(&#39;the body is&#39;, body)

if __name__ == &#39;__main__&#39;:
    test_for_sys()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;G:\Allcodes\testscripts&amp;gt;python test_cmd.py --year 2019
the year is 2019
the name is Leijun
the body is None
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到 &lt;code&gt;click&lt;/code&gt; 是使用装饰器的方式给函数添加命令行属性，比较特殊的是最后调用函数的时候是没有带上参数的，因为参数会自动通过命令行的形式传入。其他设置参数的属性跟前面的 &lt;code&gt;argparse&lt;/code&gt; 的方式非常相似，具体的参数可以参考文档和其他的教程用法，这里就不做过多的说明。&lt;/p&gt;
&lt;h2 id=&#34;小结-3&#34;&gt;小结&lt;/h2&gt;
&lt;p&gt;click 库也是一个非常人性化的命令行参数模块，它其实非常强大，强大到把所有的命令行参数可能涉及的情况都考虑到了，需要自己去探索。&lt;/p&gt;
&lt;h1 id=&#34;总结&#34;&gt;总结&lt;/h1&gt;
&lt;p&gt;以上就是我接触和使用到的四种给Python脚本设置命令行参数的方法，其中第一种是我在工作中见到的其他同事写的脚本中的方式，但是我并不喜欢这种方式，因为它真的太死板了；我最喜欢的是 &lt;code&gt;argparse&lt;/code&gt;模块，这个模块是内置模块，但是功能完全够用，非常方便。&lt;/p&gt;
">Python之参数传入</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/04-lu-you-ce-lue-20200511/"" data-c="
          &lt;h1 id=&#34;路由引入&#34;&gt;路由引入&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么需要配置路由引入？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;部署不同路由协议的机构合并；采用不同厂商的协议；同一设备同一协议但不同进程的配置&lt;br&gt;
不同的网络使用不同的协议，并且这些网络需要共享路由信息：1. 简单的网络可以使用RIP，2. 网络类型复杂的可以选用OSPF，3. 大型骨干网络一般选用ISIS&lt;br&gt;
网络协议的限制，比如使用拨号链路连接两个ISIS网络，而在拨号链路上是不适合运行ISIS协议的；需要配置静态路由，然后将静态路由引入ISIS&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;路由引入的本质&lt;/strong&gt;：把其他协议（或者同一协议不同进程）学习到的路由表，以及&lt;strong&gt;运行该协议的直连引进到本协议的数据库&lt;/strong&gt;，例如将OSPF的路由引入RIP，会将下面两条命令显示所有的OSPF的路由全部引入RIP：&lt;code&gt;dis ip rou pro ospf(对应第一句话)&lt;/code&gt;和&lt;code&gt;dis ospf int(对应第二句话)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;路由引入需要注意开销值的变化&#34;&gt;路由引入需要注意开销值的变化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;引入OSPF或者ISIS路由到RIP时，如果不指定COST，&lt;strong&gt;开销值默认是1&lt;/strong&gt;。应该手工配置开销值以反映网络的真实拓扑&lt;/li&gt;
&lt;li&gt;引入OSPF默认为1&lt;/li&gt;
&lt;li&gt;引入ISIS，narrow时默认为64，&lt;strong&gt;wide为10，即引入ISIS路由之前一般需要先更改ISIS的cost-type&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;思科设备将其他协议引入距离矢量协议时默认开销值是无穷大，因此必须要加开销值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;路由引入导致的次优路径&#34;&gt;路由引入导致的次优路径&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589294816184.png&#34; alt=&#34;路由引入导致的次优路径&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;解决方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;filter-policy&lt;/code&gt;过滤。ISIS数据库中还有4.4.4.4，但是ISIS路由表没有4.4.4.4。此方法能解决次优路径问题，但是导致没有备份路由（冗余），所以&lt;strong&gt;该方法不可取&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;修改路由协议的优先级。即将ISIS的优先级的值修改为100以上，使得RIP优选，例如&lt;code&gt;isis &amp;amp;&amp;amp; preference 101&lt;/code&gt;；或者修改RIP的优先级，将RIP的优先级修改为15以下&lt;code&gt;rip &amp;amp;&amp;amp; preference 14&lt;/code&gt;。此方法如果在RTC上将ISIS引入RIP的路由，会导致RTB方位RTA的次优路径，此时可以通过以下命令解决&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# RTB 
acl 2003
rule permit source 14.1.1.0 0.0.0.255
rule permit source 4.4.4.4 0
q
route-policy PRE-RIP
if-match acl 2003
apply preference 14
q
rip
preference route-policy PRE-RIP
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;不同设备不同协议的优先级&#34;&gt;不同设备不同协议的优先级&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;协议\设备&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;思科&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;华为&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Juniper&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;直连&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OSPF内部&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;110&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ISIS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;115&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;15&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;15(可以更细化)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;静态&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;60&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;RIP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OSPF外部&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;110&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;150&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;150&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;iBGP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;200&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;170&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;eBGP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;20&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;255&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;150&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;EIGRP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;内部90,外部170&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;路由过滤&#34;&gt;路由过滤&lt;/h1&gt;
&lt;h2 id=&#34;作用&#34;&gt;作用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;避免路由引入导致的次优路由&lt;/li&gt;
&lt;li&gt;避免路由回馈导致的路由环路&lt;br&gt;
路由回馈：从本协议出去的路由，又重新回到本协议，有可能会产生环路&lt;/li&gt;
&lt;li&gt;进行精确的路由引入和路由通告控制&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;规则&#34;&gt;规则&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;可以在出方向过滤路由&lt;br&gt;
只能过滤路由信息，链路状态信息是不能被过滤的；对OSPF来说，只能过滤3/5/7类路由&lt;/li&gt;
&lt;li&gt;可以在入方向上过滤路由&lt;br&gt;
对于链路状态路由协议，仅仅是不把路由加入到路由表中（filter-policy）&lt;/li&gt;
&lt;li&gt;可以过滤从其他路由协议引入的路由&lt;br&gt;
只能在出方向过滤，可以在ASBR重分布时操作或者在某节点使用filter-policy；在入方向过滤是没有意义的&lt;/li&gt;
&lt;li&gt;可以使用filter-policy进行过滤，也可以使用ip-prefix进行过滤&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;路由协议的迁移&#34;&gt;路由协议的迁移&lt;/h1&gt;
&lt;p&gt;有时候，需要使用新的路由协议来取代原有网络中的路由协议，而且要尽可能减小协议迁移时的网络中断时间。比如原来网络使用OSPF协议，现在要迁移到ISIS协议，可以在每台路由器上同时运行这两种路由协议，适当调整两种路由协议的优先级，使得在最初的时候ISIS只在后台运行，在对ISIS的邻居关系以及LSDB等参数经过仔细检查之后，对ISIS的优先级进行修改，从而使得ISIS取代当前运行的路由协议&lt;br&gt;
方法步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;此时网络中值运行OSPF，执行硬件和软件检查并进行升级，确保软件和硬件能够支持迁移&lt;/li&gt;
&lt;li&gt;配置ISIS，设置合适的优先级，保证ISIS只在后台运行，从而在每台路由器上都建立了ISIS链路状态数据库，但路由表和转发表不变。在这个阶段对ISIS的运行情况进行验证，只有当每台路由器都建立了LSDB并且数据库中存在所有预期的LSP，同时已确认可以产生反映当前IP路由表中路由的ISIS路由时，这个阶段可以结束&lt;/li&gt;
&lt;li&gt;改变优先级，使得ISIS取代原来的OSPF，在前台运行&lt;/li&gt;
&lt;li&gt;网络运行正常后，把OSPF删除&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;路由协议发布缺省路由&#34;&gt;路由协议发布缺省路由&lt;/h1&gt;
&lt;p&gt;所有路由协议都可以下发缺省路由&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;OSPF可以配置多种下发方式
&lt;ul&gt;
&lt;li&gt;在ABR上下发&lt;/li&gt;
&lt;li&gt;在ASBR上下发&lt;/li&gt;
&lt;li&gt;强制下发&lt;/li&gt;
&lt;li&gt;非强制下发&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589468895279.png&#34; alt=&#34;OSPF路由下放&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ISIS没有命令实现OSPF的非强制下发功能，但是可以通过路由策略来实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;路由选择工具&#34;&gt;路由选择工具&lt;/h1&gt;
&lt;h2 id=&#34;访问控制列表acl&#34;&gt;访问控制列表ACL&lt;/h2&gt;
&lt;p&gt;用于匹配路由信息或者数据包地址，过滤不符合条件的路由信息和数据包&lt;br&gt;
访问控制列表是由&lt;code&gt;permit|deny&lt;/code&gt;语句组成的一系列有顺序的规则，这些规则根据源地址、目的地址、端口号等来描述&lt;/p&gt;
&lt;h3 id=&#34;按照访问控制列表的用途可以分为三类&#34;&gt;按照访问控制列表的用途，可以分为三类：&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基本访问控制列表：匹配源IP&lt;/li&gt;
&lt;li&gt;高级访问控制列表：匹配源IP、目的IP、源端口、目的端口、协议号&lt;/li&gt;
&lt;li&gt;基于接口的访问控制列表：匹配接口&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;访问控制类别的使用用途是依靠数字的范围来指定的&#34;&gt;访问控制类别的使用用途是依靠数字的范围来指定的&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1000~1999：基于接口的访问控制列表&lt;/li&gt;
&lt;li&gt;2000~2999：基本访问控制列表&lt;/li&gt;
&lt;li&gt;3000~3999：高级访问控制列表&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;匹配顺序&#34;&gt;匹配顺序&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;acl number 2001 match-order auto|config&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置顺序（config，默认方式）&lt;br&gt;
按照用户胚子ACL规则的先后进行匹配&lt;/li&gt;
&lt;li&gt;自动排序（auto）&lt;br&gt;
使用“深度优先”的原则，“深度优先”是把指定范围最小的语句排在最前面&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;前缀列表ip-prefix&#34;&gt;前缀列表ip-prefix&lt;/h2&gt;
&lt;p&gt;匹配对象为路由信息的目的地址或者直接作用于路由器对象gateway&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前缀列表用来过滤IP前缀，能&lt;strong&gt;同时匹配前缀号和前缀长度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;前缀列表的性能比访问控制列表高&lt;/li&gt;
&lt;li&gt;前缀列表不能用于数据包的过滤（&lt;strong&gt;不能用于IP报文的过滤，只能用于路由信息的过滤&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix test index 10 permit 10.0.0.0 16 greater-equal 24 less-equal 28&lt;/code&gt;前缀号必须是10.0（16定义的范围），前缀长度取值区间[24,28]，满足条件的如10.0.1.0/24、10.0.2.0/25、10.0.2.192/26等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix pre index 10 permit 10.1.0.0 24&lt;/code&gt;没有great,没有less就等于24&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix pre index 10 permit 10.1.0.0 16 greater-equal 24&lt;/code&gt;没有Less，那么less就等于32，即 great 24  less 32&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix pre permit 10.1.0.0 16 less-equal 32&lt;/code&gt;没有great，那么great就等于&lt;strong&gt;掩码&lt;/strong&gt;16&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix pre permit 0.0.0.0 0 greater-equal 32 less-equal 32&lt;/code&gt;放行所有的主机路由 32&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix pre permit 0.0.0.0 1 greater-equal 8 less-equal 8&lt;/code&gt;放行所有的A类路由&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix pre permit 128.0.0.0 2 greater-equal 16 less-equal 16&lt;/code&gt;匹配所有的B类路由&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ip ip-prefix pre permit 192.0.0.0 3 greater-equal 24 less-equal 24&lt;/code&gt;匹配所有的C类路由&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;怎么理解这里的“1/2/3”需要匹配的前缀呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;128=10&lt;/strong&gt; 00 0000 ， /2  意思是说【最前面的“10”这两个位不可以变，可以变的是后面剩下的“6个位”，“10 &lt;strong&gt;11 1111=191&lt;/strong&gt;”】而且这里ge/le=16 限定了mask=16(B类地址)。所以地址为：128.0.0.0-191.255.255.255 /16&lt;br&gt;
&lt;strong&gt;192=110&lt;/strong&gt; 0 0000  ，/3  不能表的意思是说【最前面的“110”这两个位不可以变，可以变的是后面剩下的“5个位”、“110 &lt;strong&gt;1 1111=223&lt;/strong&gt;”】而且这里ge/le=24 限定了mask=24(C类地址) 。所以地址为：192.0.0.0-223.255.255.255 /24&lt;br&gt;
mask=0    //匹配前面的0位&lt;br&gt;
mask=1    //匹配前面的第一位1&lt;br&gt;
mask=2    //匹配前面的第一位和第二位     以此类推！！！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;路由策略&#34;&gt;路由策略&lt;/h2&gt;
&lt;p&gt;主要用于路由过滤和路由属性的设置等，从而影响流量所经过的路径，主要通过route-policy实现，设定匹配规则，由if-match和apply子句组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个routing-policy下可以&lt;strong&gt;有多个节点&lt;/strong&gt;，不同的节点号用node标识，不同node各个部分之间的关系是“&lt;strong&gt;或&lt;/strong&gt;”的关系，&lt;strong&gt;按照顺序依次匹配路由策略的节点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;每个节点下可以有&lt;strong&gt;多个if-match和apply子句&lt;/strong&gt;，if-match子句之间是“&lt;strong&gt;与&lt;/strong&gt;”的关系&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;允许模式&lt;/strong&gt;：当路由项满足该节点的所有if-match子句时，将被允许通过该节点的过滤并执行该节点的apply子句，如路由项不满足该节点的if-match子句，将试图匹配路由策略的下一个节点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拒绝模式&lt;/strong&gt;：当路由项满足该节点的所有if-match子句时，将被拒绝通过该节点的过滤，并且不会继续下一个节点的测试&lt;/li&gt;
&lt;li&gt;if-match子句&lt;strong&gt;可以引用其它的过滤工具&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;路由策略原理&#34;&gt;路由策略原理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589726738470.png&#34; alt=&#34;路由策略原理&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;自治系统路径信息访问列表as-path-filter&#34;&gt;自治系统路径信息访问列表as-path-filter&lt;/h2&gt;
&lt;p&gt;仅用于BGP协议，匹配BGP路由信息的自治系统路径域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;该列表用来过滤BGP的as-path属性&lt;/li&gt;
&lt;li&gt;as-path属性使用正则表达式来定义，举例：
&lt;ul&gt;
&lt;li&gt;匹配所有as-path属性：ip as-path-filter 10 permit .*&lt;/li&gt;
&lt;li&gt;匹配从AS100发起的路由：ip as-path-filter 10 permit _100$&lt;/li&gt;
&lt;li&gt;匹配从AS200接收的路由：ip as-path-filter 10 permit ^200_&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;团体属性列表community-filter&#34;&gt;团体属性列表Community-filter&lt;/h2&gt;
&lt;p&gt;仅用于BGP协议，匹配BGP路由信息的自治系统团体域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;团体列表使用团体属性表示和过滤BGP路由&lt;/li&gt;
&lt;li&gt;团体列表有基本和高级两种
&lt;ul&gt;
&lt;li&gt;基本团体列表用来匹配实际的团体属性值和常量
&lt;ul&gt;
&lt;li&gt;ip community-filter 1 permit 100:1 100:2&lt;/li&gt;
&lt;li&gt;ip community-filter 1 permit 100:1&lt;/li&gt;
&lt;li&gt;ip community-filter 1 permit no-export&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高级团体列表可以使用正则表达式
&lt;ul&gt;
&lt;li&gt;ip community-filter 100 permit ^10&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;策略路由pbr&#34;&gt;策略路由PBR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;策略路由是一种依据&lt;strong&gt;用户制定的策略&lt;/strong&gt;进行报文转发路径选择的机制，与单纯依照IP报文的目的地址查找路由表进行转发不同，可应用于安全、QoS、负载分担等目的&lt;/li&gt;
&lt;li&gt;策略路由支持基于ACL、报文长度等信息，来灵活地指定数据包的转发路径&lt;/li&gt;
&lt;li&gt;在华为设备上策略路由可以分为三种：
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本地发起的流量&lt;/strong&gt;：在全局下调用，只能影响源于本地的流量，即仅对本机&lt;strong&gt;下发的报文&lt;/strong&gt;进行处理，对转发的报文不起作用。一条本地策略路由可以配置多个策略点，并且这些策略点具有不同的优先级，本机下发报文优先匹配优先级高的策略点。&lt;/li&gt;
&lt;li&gt;接口应用的流量：只对&lt;strong&gt;转发的报文&lt;/strong&gt;起作用，对本地下发的报文（比如本地的Ping报文）不起作用&lt;/li&gt;
&lt;li&gt;智能策略路由：（模拟器不支持）基于&lt;strong&gt;业务需求&lt;/strong&gt;的策略路由，通过匹配&lt;strong&gt;链路质量和网络业务对链路质量&lt;/strong&gt;的需求，实现智能选路&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置基于acl简化的策略路由&#34;&gt;配置基于ACL简化的策略路由&lt;/h2&gt;
&lt;p&gt;配置基于ACL简化流策略的策略路由，将报文重定向到指定远程下一条&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;traffic-redirect acl 3001 remote 10.1.30.1 global inbound
# traffic-redirect nexthop命令用来将报文重定向到单个下一跳IP地址的动作
# 全局调用
traffic-redirect acl 3001 nexthop 10.1.1.1 global inbound 
# 接口下调用
int g0/0/0
traffic-redirect acl 3001 nexthop 10.1.1.1 inbound 
# vlan下调用
vlan 100
traffic-redirect acl 3001 nexthop 10.1.1.1 inbound 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;实验一路由引入&#34;&gt;实验一：路由引入&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589294149620.png&#34; alt=&#34;路由引入&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1
sys
sys AR1
int lo 0
int 1.1.1.1 32
int g0/0/0
ip addr 12.1.1.1 24
int g0/0/1
ip addr 15.1.1.1 24
int g0/0/2
ip addr 16.1.1.1 24
q 
router-id 1.1.1.1
ospf 10
net 1.1.1.1 0.0.0.0
net 12.1.1.1 0.0.0.0
int g0/0/0
ospf nework-type p2p
q
rip
version 2
undo summary
net 1.0.0.0
net 15.0.0.0
q
isis
net 47.0167.111111111111.00
int g0/0/2
isis enable
int lo 0
isis enable
q
rip 
import-route ospf 10
q
isis
import-route rip
# AR2
sys
sys AR2
int lo 0
int 2.2.2.2 32
int g0/0/1
ip addr 12.1.1.2 24
int g0/0/0
ip addr 192.168.10.2 24
q 
router-id 2.2.2.2
ospf 10
net 2.2.2.2 0.0.0.0
net 12.1.1.2 0.0.0.0
net 192.168.10.2 0.0.0.0
int g0/0/0
ospf nework-type p2mp
int g0/0/1
ospf nework-type p2p
# AR3
sys
sys AR3
int lo 0
int 3.3.3.3 32
int g0/0/0
ip addr 192.168.10.3 24
q 
router-id 3.3.3.3
ospf 10
net 3.3.3.3 0.0.0.0
net 192.168.10.3 0.0.0.0
int g0/0/0
ospf nework-type p2mp
# AR4
sys
sys AR4
int lo 0
int 4.4.4.4 32
int g0/0/0
ip addr 192.168.10.4 24
q 
router-id 4.4.4.4
ospf 10
net 4.4.4.4 0.0.0.0
net 192.168.10.4 0.0.0.0
int g0/0/0
ospf nework-type p2mp
# AR5
sys
sys AR5
int lo 0
ip addr 5.5.5.5 32
int lo 10
ip addr 50.50.50.50 32
int g0/0/0
ip addr 15.1.1.5 24
rip
version 2
undo summary
net 5.0.0.0
net 15.0.0.0
net 50.0.0.0
# AR6
sys
sys AR6
int lo 0
int 6.6.6.6 32
int g0/0/0
ip addr 16.1.1.6 24
int g0/0/1
ip addr 67.1.1.6 24
isis
is-level level-2
net 47.0167.666666666666.00
int lo 0
isis enable
int g0/0/0
isis enable
int g0/0/1
isis enable
# AR7
sys
sys AR6
int lo 0
int 7.7.7.7 32
int g0/0/0
ip addr 67.1.1.7 24
isis
is-level level-2
net 47.0167.777777777777.00
int lo 0
isis enable
int g0/0/0
isis enable
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二pbr&#34;&gt;实验二：PBR&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589730617402.png&#34; alt=&#34;PBR&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ........................预配置
# AR1
sys
sys AR1
int g0/0/2 
ip addr 192.168.10.254 24
int g2/0/0
ip addr 192.168.20.254 24
int g0/0/0
ip addr 12.1.1.1 24
int g0/0/1
ip addr 13.1.1.1 24
ospf 10 route 1.1.1.1
net 12.1.1.1 0
net 13.1.1.1 0
net 192.168.10.0 0.0.0.255
net 192.168.20.0 0.0.0.255
silent-interface g0/0/2
silent-interface g2/0/0
# AR2
sys
sys AR2
int g0/0/0
ip addr 12.1.1.2 24
int g0/0/1
ip addr 24.1.1.2 24
ospf 10 route 2.2.2.2
net 12.1.1.2 0
net 24.1.1.2 0
# AR3
sys
sys AR3
int g0/0/0
ip addr 13.1.1.3 24
int g0/0/1
ip addr 34.1.1.3 24
ospf 10 route 3.3.3.3
net 13.1.1.3 0
net 34.1.1.3 0
# AR4
sys
sys AR4
int g0/0/0
ip addr 24.1.1.4 24
int g0/0/1
ip addr 34.1.1.4 24
int g0/0/1
ip addr 45.1.1.4 24
ospf 10 route 4.4.4.4
net 24.1.1.4 0
net 34.1.1.4 0
net 45.1.1.4 0
# AR5
sys
sys AR5
int lo 0
ip addr 5.5.5.5 32
int g0/0/0
ip addr 45.1.1.5 24
ospf 10 route 5.5.5.5
net 5.5.5.5 0
net 45.1.1.5 0
# AR7
sys
sys AR7
int g0/0/0
ip addr 192.168.10.20 24
q
ip route-static 0.0.0.0 0 192.168.10.254
# AR8
sys
sys AR8
int g0/0/0
ip addr 192.168.20.10 24
q
ip route-static 0.0.0.0 0 192.168.20.254
# PC1 
192.168.10.10/24,192.168.10.254
# PC2
192.168.20.20/24,192.168.20.254
# ..................................基于本地的策略路由
# 要求：
# 环回口10-10.10.10.11的流量走AR2；环回口11-10.10.10.12的流量走AR3
# AR1
int lo 10
ip addr 10.10.10.11 32
ospf  en area 0
int lo 11
ip addr 10.10.10.12 32
ospf  en area 0
q

acl 2001
rule permit source 10.10.10.11 0
acl 2002
rule permit source 10.10.10.12 0
policy-based-route PBR permit node 10
if-match acl 2001
apply ip-address next-hop 12.1.1.2
policy-based-route PBR permit node 20
if-match acl 2002
apply ip-address next-hop 13.1.1.3
q

ip local policy-based-route PBR  # 在全局下，本地策略路由的调用

# 测试
tracert -a 10.10.10.11 5.5.5.5
tracert -a 10.10.10.12 5.5.5.5
# ..................................基于接口的策略路由
# 要求：
# PC1和AR8的流量走AR2；PC2和AR7的流量走AR3
# AR1
acl 2003
rule permit source  192.168.10.10 0
rule permit source  192.168.20.10 0
acl 2004
rule permit source  192.168.10.20 0
rule permit source  192.168.20.20 0
q
traffic classifier C1    # 定义流量分类
if-match acl 2003
traffic classifier C2
if-match acl 2004
traffic behavior B1   # 定义流量行为
redirect ip-nexthop 12.1.1.2
traffic behavior B2
redirect ip-nexthop 13.1.1.3
traffic policy PBR_10  # 进行流量和行为的关联
classifier C1 behavior B1
classifier C2 behavior B2
int g0/0/2       # 在接口上调用
traffic-policy PBR_10 inbound
int g2/0/0
traffic-policy PBR_10 inbound
# 查看
# AR1
dis traffic-policy applied-record
# 测试
# AR7/8
tracert 5.5.5.5
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三防火墙策略路由&#34;&gt;实验三：防火墙+策略路由&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589734337729.png&#34; alt=&#34;防火墙+策略路由&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#................................初始化配置
# AR1
sys
sys AR1
int g0/0/1
ip addr 172.16.1.1 24
int g0/0/0
ip addr 10.1.1.1 24
ip route-static 192.168.10.0 24 10.1.1.2
# AR-Border
sys
sys Border
int g0/0/0
ip addr 10.1.1.2 24
int g0/0/1
ip addr 12.1.1.1 24
int g0/0/2
ip addr 21.1.1.1 24
int g2/0/0
ip addr 192.168.10.1 24
q
ip route-static 0.0.0.0 0 10.1.1.1
# FW1
admin
admin@123
# 修改密码为huawei@123
sys
sys FW
int g1/0/0
ip addr 12.1.1.2 24
service-manage ping permit # 放行ping流量
int g1/0/1
ip addr 21.1.1.2 24
service-manage ping permit
q
firewall zone trust # 将接口加入信任区域（zone）
add int g1/0/1
q
firewall zone untrust  # 将接口加入不信任区域（zone）
add int g1/0/0
q
ip route-static 0.0.0.0 0 21.1.1.1 # 配置默认路由
security-policy # 配置安全策略
rule name Permit_http_icmp_ftp
source-zone untrust
destination-zone trust
source-address 172.16.1.0 24
destination-address 192.168.10.0 24
action permit

# 策略路由，使用防火墙
# AR-Border
acl 3001
rule permit tcp destination 192.168.10.0 0.0.0.255 destination-port eq ftp
rule permit tcp destination 192.168.10.0 0.0.0.255 destination-port eq www
rule permit tcp destination 192.168.10.0 0.0.0.255 destination-port eq telnet
rule permit icmp destination 192.168.10.10 0
q
traffic classifier C1
if-match acl 3001
q
traffic behavior B1
redirect ip-nexthop 12.1.1.2 
q
traffic policy P1
classifier C1 behavior B1
int g0/0/0
traffic-policy P1 inbound
&lt;/code&gt;&lt;/pre&gt;
">04 路由策略（2020.0511）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/02-isis20200503/"" data-c="
          &lt;h1 id=&#34;isis原理&#34;&gt;ISIS原理&lt;/h1&gt;
&lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;h3 id=&#34;概述&#34;&gt;概述&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ISIS的意思是标识中间系统到中间系统，是为ISO&lt;strong&gt;无连接网络&lt;/strong&gt;协议设计的&lt;strong&gt;路由选择协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ISIS协议的时间和OSPF发布的时间基本同一时间，都基于&lt;strong&gt;链路状态&lt;/strong&gt;并使用&lt;strong&gt;最短路径优先算法&lt;/strong&gt;进行路由计算的一种IGP协议&lt;/li&gt;
&lt;li&gt;ISIS现在更多的作为&lt;strong&gt;服务应用商网络的IGP的层面&lt;/strong&gt;（华为设备优先级为15）&lt;/li&gt;
&lt;li&gt;为了提供对IP的路由支持，IETF在RFC1195中对ISIS进行了扩充和修改，目前在&lt;strong&gt;大型的ISP网络中被广泛的部署&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ISIS是一个&lt;strong&gt;扁平化&lt;/strong&gt;的层次结构&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;历史&#34;&gt;历史&lt;/h3&gt;
&lt;p&gt;ISIS是ISO定义的OSI协议栈中无连接网络服务CLNS的一部分，用于动态路由数据包。CLNS由以下3个协议构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CLNP：类似TCP/IP中的IP协议，CLNP为OSI的传输层服务&lt;/li&gt;
&lt;li&gt;ISIS：中间系统（路由器）间的路由协议，类似于IP中的OSPF&lt;/li&gt;
&lt;li&gt;ESIS：主机系统与中间系统间的协议，就像IP中的ARP等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;场景应用&#34;&gt;场景应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;园区网特点：&lt;code&gt;区域多样、策略多变、调度精细，使用OSPF&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;应用型网络，主要面向企业网用户。&lt;/li&gt;
&lt;li&gt;路由器数量偏少，动态路由的LSDB库容量相对偏少，三层路由域相对偏少。&lt;/li&gt;
&lt;li&gt;有出口路由的概念，对内部外部路由划分敏感。&lt;/li&gt;
&lt;li&gt;地域性跨度不大，带宽充足，链路状态协议开销对带宽占用比偏少。&lt;/li&gt;
&lt;li&gt;路由策略和策略路由应用频繁多变，需要精细化的路由操作。&lt;/li&gt;
&lt;li&gt;OSPF的多路由类型（内部/外部），多区域类型（骨干/普通/特殊），开销规则优良（根据带宽设定），网络类型多样（最多五种类型）的特点在园区网得到了极大的发挥。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;骨干网特点：&lt;code&gt;区域扁平、收敛极快、承载庞大，使用ISIS+BGP&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;服务型网络，由ISP（互联网服务提供商）组建，并为终端用户提供互联服务。&lt;/li&gt;
&lt;li&gt;路由调度占据绝对统治地位，路由器数量庞大。&lt;/li&gt;
&lt;li&gt;架构层面&lt;strong&gt;扁平化&lt;/strong&gt;，要求IGP作为基础路由为上层BGP协议服务。&lt;/li&gt;
&lt;li&gt;LSDB规模宏大，对链路收敛极度敏感，线路费用高昂。&lt;/li&gt;
&lt;li&gt;追求简单高效，扩展性高，满足各种客户业务需求（IPV6/IPX）。&lt;/li&gt;
&lt;li&gt;IS-IS的快速算法（PRC得到加强），简便报文结构（TLV），快速邻居关系建立，大容量路由传递（基于二层开销低）等一系列特点在骨干网有着天然的优势。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ospf和isis的共同特征&#34;&gt;OSPF和ISIS的共同特征&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;维护一个链路状态数据库，基于SPF算法&lt;/li&gt;
&lt;li&gt;都利用hello包形成和维护邻居关系&lt;/li&gt;
&lt;li&gt;使用区域的概念来构成层次化的拓扑结构&lt;/li&gt;
&lt;li&gt;都提供在区域间进行地址汇总的能力&lt;/li&gt;
&lt;li&gt;无类路由协议&lt;/li&gt;
&lt;li&gt;都选举一个指定路由器来描述广播性网络&lt;/li&gt;
&lt;li&gt;认证能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;ospf和isis的差异&#34;&gt;OSPF和ISIS的差异&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;差异性&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;ISIS&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;OSPF&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络方式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;少，2种&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多，5种&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开销方式&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;复杂&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;简便，参考带宽100M&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;少，2种&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由报文类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;简单&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;多样&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由收敛速度&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;很快&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;扩展性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一般&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由负载能力&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;超强&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;网络类型和开销方式：&lt;br&gt;
IS-IS协议只支持两种网络类型，且所有带宽默认开销值都是一样的，OSPF协议支持四种网络类型，且会根据不同的带宽设定相应的开销值，对帧中继，按需链路等网络类型有很好的支持。&lt;/li&gt;
&lt;li&gt;区域类型：&lt;br&gt;
IS-IS协议分L1/L2区域，L2区域是骨干区域有全部明细路由。L1去往L2只有默认路由。OSPF协议分骨干区域，普通区域，特殊区域。普通区域和特殊区域跨区域访问需要经过骨干区域。&lt;/li&gt;
&lt;li&gt;报文类型：&lt;br&gt;
IS-IS协议路由承载报文类型只有LSP报文且里面路由信息是不区分内部与外部的，简单高效，无需递归计算。OSPF协议路由承载报文LSA类型多样，有1/2/3/4/5/7类等。路由级别等级森严，且需要递归计算，适合精细化调度计算。&lt;/li&gt;
&lt;li&gt;路由算法：&lt;br&gt;
ISIS协议区域内某个节点上的网段发生变化时，触发的是PRC算法，收敛比较快，计算路由的报文开销也比较小。OSPF协议由于网络地址参与了拓扑的构建，在区域内当网段地址改变触发的是i-spf算法，相对来说过程繁琐复杂些。&lt;/li&gt;
&lt;li&gt;扩展性：&lt;br&gt;
ISIS协议任何路由信息都使用TLV传递，结构简单，易于扩展，如对IPv6的支持只增加2个TLV就解决了。且ISIS本身对IPX等协议是支持的。OSPF协议本身是为IP特定开发的，支持IPv4和IPv6的OSPF协议是两个独立的版本（OSPFv2和OSPFv3）。&lt;/li&gt;
&lt;li&gt;邻居关系建立：&lt;br&gt;
邻居关系建立主要是通过HELLO包交互并协商各种参数，包括电路类型（level-1/level-2），Hold time，网络类型，支持协议，区域号，系统ID，PDU长度，接口IP等。&lt;/li&gt;
&lt;li&gt;链路信息交换：&lt;br&gt;
与OSPF不同，ISIS交互链路状态的基本载体不是LSA（link state advertisement），而是LSP（link state PDU）；交互的过程没有OSPF协议那样经历了多个阶段，主要是通过CSNP和PSNP两种协议报文来同步，请求以及确认链路状态信息（承载的是链路状态信息摘要），而链路状态信息的详细拓扑和路由信息是由LSP报文传递。&lt;/li&gt;
&lt;li&gt;路由计算：&lt;br&gt;
SPF计算和OSPF基本一样的，但ISIS算法分离了拓扑结构和IP网段，加快了网络收敛速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isis地址结构&#34;&gt;ISIS地址结构&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;NSAP是OSI协议中用于定位资源的地址，相当于OSI的网络层协议CLNP的地址（类似IP地址的概念）
&lt;ul&gt;
&lt;li&gt;由IDP和DSP组成，IDP和DSP的长度都是可变的，NSAP总长度最多是20字节，最少是8字节
&lt;ul&gt;
&lt;li&gt;IDP相当于IP地址中的主网络号，是由ISO规定的，由AFI的IDI两部分组成，&lt;strong&gt;AFI表示地址分配机构和地址格式(长度固定为1B)&lt;/strong&gt;，IDI用来标识域&lt;/li&gt;
&lt;li&gt;DSP相当于IP地址中的子网号和主机地址，由HighOrderDSP、SystemID、SEL三部分组成，HighOrderDSP用来分割区域，SystemID用来区分主句，SEL用来指示服务类型
&lt;ul&gt;
&lt;li&gt;AreaAddress(AreaID)由IDP和DSP中的HighOrderDSP组成，既能够标识路由域，也能够标识路由域中的区域，它们一起被称为区域地质，类似OSPF中的区域编号AreaID，同一Level1区域内的所有路由器必须具有相同的区域地址，Level2区域内的路由器可以具有不同的区域地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SystemID&lt;/strong&gt;用来在区域内唯一标识主机或路由器，在设备的实现中，它的&lt;strong&gt;长度固定为48bit(6字节)&lt;/strong&gt;，一般情况先，使用设备的RouterID转换为SystemID&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SEL&lt;/strong&gt;的作用类似于IP中的“协议标识符”，不同的传输协议对应不同的SEL，在IP上SEL均为00，&lt;strong&gt;长度固定为1B(8bit)&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;NET是一类特殊的NSAP（SEL=00），在路由器上配置ISIS时，只需要考虑NET即可
&lt;ul&gt;
&lt;li&gt;网络实体名称NET指的是设备本身的网络层的意思，可以看做是一类特殊的NSAP（SEL=00）,NET的长度与NSAP相同，最多为20字节，最少为8字节，&lt;strong&gt;在路由器上配置ISIS时，只需要考虑NET即可，NSAP不必去关注&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在配置ISIS过程中，NET最多只能配置3个，在配置多个NET时，必须保证他们的SystemID都相同&lt;br&gt;
&lt;code&gt;没有NET地址ISIS无法运行，该地址包含了区域ID和系统ID，而他本质上是一个ISO地址，最后的SEL等同于TCP的端口号，永远等于00&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;TCP/IP协议栈&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;IP协议&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;IP地址&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;OSPF&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;AreaID+RouterID&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;OSI系统&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;CLNP协议&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSAP地址&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ISIS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NET标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588665973437.png&#34; alt=&#34;ISIS地址结构&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;最短长度8B：1B的AFI + 6B的SystemID + 1B的SEL&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588667599284.png&#34; alt=&#34;ISIS地址例子&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;用ISIS做网络设计需要注意：保证L2路由器连续&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588776831130.png&#34; alt=&#34;术语对照表&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;关于systemid&#34;&gt;关于SystemID&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个中间系统（路由器）至少有一个NET，&lt;strong&gt;华为设备最多支持3个&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;同一个Area的中间系统必须有相同的AreaID（Level1必须一样，Level2可以不一样）&lt;/li&gt;
&lt;li&gt;每个中间系统在&lt;strong&gt;一个Area中必须有一个唯一的SystemID&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个domain中的两个Level2中间系统不能有相同的SystemID&lt;/li&gt;
&lt;li&gt;NSAP至少为8字节，最多为20个字节&lt;/li&gt;
&lt;li&gt;对于传统IP应用程序而言，1字节定义AFI（标识二进制DSP语法的地址域），最少2字节定义实际区域信息（IDI+HighOrder+DSP），6字节定义系统ID和1字节的NSEL，故NSAP地址最少为10字节&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isis整体拓扑&#34;&gt;ISIS整体拓扑&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588690827975.png&#34; alt=&#34;ISIS整体拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
将&lt;strong&gt;Level-1路由器部署在非骨干区域&lt;/strong&gt;，&lt;strong&gt;Level-2路由器和Level-1-2（类似ABR，ISIS默认设置）路由器部署在骨干区域&lt;/strong&gt;。&lt;strong&gt;每一个非骨干区域都通过Level-1-2路由器与骨干区域相连&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在OSPF中，每个链路只属于一个区域；而在IS-IS中，每个链路可以属于不同的区域&lt;code&gt;OSPF基于接口，即一个设备上的多个接口可以属于不同的Area；ISIS基于设备，即一个设备只能属于一个Level&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在IS-IS中，单个区域没有物理的骨干与非骨干区域的概念；而在OSPF中，Area0被定义为骨干区域&lt;/li&gt;
&lt;li&gt;在IS-IS中，&lt;strong&gt;Level-1和Level-2级别的路由器分别采用SPF算法，分别生成最短路径树SPT&lt;/strong&gt;；在OSPF中，只有在同一个区域内才使用SPF算法，区域之间的路由需要通过骨干区域来转发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isis路由器分类&#34;&gt;ISIS路由器分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Level-1路由器&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Level-1路由器负责区域内的路由，它只属于同一区域的Level-1和Level-1-2路由器形成邻居关系，属于不同区域的Level-1路由器不能形成邻居关系&lt;/li&gt;
&lt;li&gt;Level-1路由器只负责维护Level-1的链路状态数据库LSDB，该LSDB包含本区域的路由信息&lt;/li&gt;
&lt;li&gt;到本区域外的报文转发给最近的Level-1-2路由器&lt;/li&gt;
&lt;li&gt;Level-1路由器必须通过Level-1-2路由器才能连接至其他区域&lt;/li&gt;
&lt;li&gt;Level-1区域&lt;strong&gt;建立的条件&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;要求Area号必须一致&lt;/li&gt;
&lt;li&gt;Level-1路由器可以和Level-1路由器建立Level-1的邻居&lt;/li&gt;
&lt;li&gt;Level-1路由器可以和Level-1-2路由器建立Level-1的邻居&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Level-2路由器&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Level-2路由器负责区域间的路由，他可以和同一或者不同区域的Level-2路由器或者其他区域的Level-1-2路由器形成邻居关系&lt;/li&gt;
&lt;li&gt;Level-2路由器维护一个Level-2的LSDB，该LSDB包含ISIS区域内的所有路由信息&lt;/li&gt;
&lt;li&gt;所有Level-2级别（即形成Level-2邻居关系）的路由器组成路由域的骨干网，负责在不同区域间通信，路由域中Level-2级别的路由器必须是物理连续的，以保证骨干网的连续性&lt;/li&gt;
&lt;li&gt;Level-2区域&lt;strong&gt;建立的条件&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Area号可以不一致&lt;/li&gt;
&lt;li&gt;Level-2路由器可以和Level-2路由器建立Level-2的邻居&lt;/li&gt;
&lt;li&gt;Level-2路由器可以和Level-1-2路由器建立Level-2的邻居&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Level-1-2路由器（默认）&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;同时属于Level-1和Level-2的路由器&lt;/li&gt;
&lt;li&gt;可以与同一区域的Level-1和Level-1-2路由器形成Level-1邻居关系，也可以和其他区域的Level-2和Level-1-2路由器形成Level-2邻居关系&lt;/li&gt;
&lt;li&gt;Level-1路由器必须通过Level-1-2路由器才能连接至其他区域&lt;/li&gt;
&lt;li&gt;Level-1-2路由器维护两个LSDB，Level-1的LSDB用于区域内路由，Level-2的LSDB用于区域间路由&lt;br&gt;
&lt;code&gt;既有Level-1又有Level-2的情况下，Level-1-2必须和Level-1的AreaID保持一致，否则无法建立邻居，导致无法进行通信&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;Level-1-2路由器之间建立什么样的邻居？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;区域号不同&lt;/strong&gt;：一个，Level-2区域&lt;br&gt;
&lt;strong&gt;区域号相同&lt;/strong&gt;：两个，Level-1区域和Level-2区域&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;isis报文类型&#34;&gt;ISIS报文类型&lt;/h2&gt;
&lt;h3 id=&#34;hello-pduiihhello报文&#34;&gt;Hello PDU（IIH）（hello报文）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于邻居发现，协商参数并建立邻居关系，后期充当保活报文。&lt;/li&gt;
&lt;li&gt;ISIS目前只支持&lt;strong&gt;点到点和广播&lt;/strong&gt;两种网络类型。&lt;/li&gt;
&lt;li&gt;广播网中的Level-1 IS-IS使用Level-1 LAN IIH；广播网中的Level-2 IS-IS使用Level-2 LAN IIH；非广播网络中则使用P2P IIH。它们的报文格式有所不同。P2P IIH中相对于LAN IIH来说，多了一个表示本地链路ID的Local Circuit ID字段，缺少了表示广播网中DIS的优先级的Priority字段以及表示DIS和伪节点System ID的LAN ID字段。&lt;/li&gt;
&lt;li&gt;在广播网络中，ISIS通过MAC地址来标识邻居（OSPF是通过RID来标识的）；在P2P中，是通过系统ID来标识邻居的，通过电路ID来标识自己的哪个接口与对端相连&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588779975219.png&#34; alt=&#34;LSDB-DIS&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;level-1-lan-iih&#34;&gt;Level-1 LAN IIH&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;组播MAC&lt;/strong&gt;：0180-c200-0014&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588780182952.png&#34; alt=&#34;L1和L2的帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;level-2-lan-iih&#34;&gt;Level-2 LAN IIH&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;组播MAC&lt;/strong&gt;：0180-c200-0015&lt;/p&gt;
&lt;h4 id=&#34;p2p-iih&#34;&gt;P2P IIH&lt;/h4&gt;
&lt;p&gt;非广播网络中则使用P2P IIH，但是其没有表示DIS（虚节点）的相关字段&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588780285711.png&#34; alt=&#34;P2P的帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;lsp-pdu链路状态报文&#34;&gt;LSP PDU（链路状态报文）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于交换链路状态信息，相当于OSPF的LSU&lt;/li&gt;
&lt;li&gt;Level–1 LSP由Level-1路由器传送，Level–2 LSP由Level-2路由器传送，Level-1-2路由器则可传送以上两种LSP&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;level-1-lsp&#34;&gt;Level-1 LSP&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588781421394.png&#34; alt=&#34;LSP报文&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;level-2-lsp&#34;&gt;Level-2 LSP&lt;/h4&gt;
&lt;h3 id=&#34;snp-pdu序列号报文&#34;&gt;SNP PDU（序列号报文）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用于维护LSDB的完整与同步，且为摘要信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;csnp全序列号报文&#34;&gt;CSNP（全序列号报文）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;类似于OSPF的DBD信息，用来同步LSDB&lt;/li&gt;
&lt;li&gt;DIS定期泛洪CSNP(10秒)&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;level-1-csnp&#34;&gt;Level-1 CSNP&lt;/h5&gt;
&lt;h5 id=&#34;level-2-csnp&#34;&gt;Level-2 CSNP&lt;/h5&gt;
&lt;h4 id=&#34;psnp部分序列号报文&#34;&gt;PSNP（部分序列号报文）&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在广播网络中，类似于OSPF的LSR；在P2P网络中，类似于OSPF的LSR和LSAck&lt;/li&gt;
&lt;li&gt;非DIS设备向DIS发送PSNP，用于请求非DIS设备上缺少的LSDB中的详细路由信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;level-1-psnp&#34;&gt;Level-1 PSNP&lt;/h5&gt;
&lt;h5 id=&#34;level-2-psnp&#34;&gt;Level-2 PSNP&lt;/h5&gt;
&lt;h2 id=&#34;isis网络类型&#34;&gt;ISIS网络类型&lt;/h2&gt;
&lt;h3 id=&#34;isis支持的网络类型&#34;&gt;ISIS支持的网络类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;点对点链路，例如PPP和HDLC&lt;code&gt;不选举DIS&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;广播链路
&lt;ul&gt;
&lt;li&gt;DIS：&lt;strong&gt;指定中间系统&lt;/strong&gt;，为了在广播网络中实现&lt;strong&gt;更高效的数据库同步&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;伪节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dis&#34;&gt;DIS&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在广播网络中，IS-IS需要在所有的路由器中选举一个路由器作为DIS，&lt;strong&gt;Level-1和Level-2的DIS是分别选举的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以为不同级别的DIS选举设置不同的优先级&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;优先级为0的路由器也参与DIS的选举，只是具有最小可能成为DIS&lt;/strong&gt;，且DIS选举&lt;strong&gt;支持抢占&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同一网段上的同一级别的路由器之间都会形成邻接关系&lt;/strong&gt;，包括所有的非DIS路由器之间也会形成邻接关系，但LSDB的同步仍然依靠DIS来保证&lt;/li&gt;
&lt;li&gt;DIS用来创建和更新伪节点，并负责生成伪节点的链路状态协议数据单元LSP，用来描述这个网络上有哪些网络设备&lt;/li&gt;
&lt;li&gt;IS-IS中DIS发送Hello时间间隔为10/3秒，而其他非DIS路由器发送Hello间隔为10秒&lt;/li&gt;
&lt;li&gt;ISIS的LSP的更新时间为900秒，Hold time时间为1200秒，是从大往小减的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ISIS系统中没有DIS也能完成数据库同步&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么DIS不需要备份的DIS？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;DIS支持抢占&lt;/li&gt;
&lt;li&gt;DIS 发送Hello消息的时间为 10/3秒&lt;/li&gt;
&lt;li&gt;ISIS主要用在运营商网络中，而运营商网络一般很少会更换设备，所以影响不大&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;dis的选举&#34;&gt;DIS的选举&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;比较优先级，越高越优，默认优先级为64，取值范围（0-127）&lt;/li&gt;
&lt;li&gt;如果优先级相同，比较MAC地址，越大越优&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;h3 id=&#34;广播邻接关系建立&#34;&gt;广播邻接关系建立&lt;/h3&gt;
&lt;p&gt;两台运行IS-IS的路由器在交互协议报文实现路由功能之前必须首先建立邻接关系。在不同类型的网络上，IS-IS 的邻接建立方式并不相同&lt;/p&gt;
&lt;h4 id=&#34;广播&#34;&gt;广播&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在广播网络上，使用LAN IIH报文来建立邻接关系。有两种类型的LAN IIH：L1 LAN IIH（组播MAC:01-80-C2-00-00-14）和L2 LAN IIH （组播MAC:01-80-C2-00-00-15） 。&lt;/li&gt;
&lt;li&gt;Level-1路由器通过交互L1 LAN IIH报文来建立邻接关系；Level-2路由器通过交互L2 LAN IIH报文来建立邻接关系；Level-1-2路由器会同时交互L1 LAN IIH报文和L2 LAN IIH报文来建立邻接关系。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588860400476.png&#34; alt=&#34;广播邻接关系建立&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
以两台L2路由器在广播链路上建立邻居关系为例：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;R1组播发送Level-2 LAN IIH（组播MAC:01-80-C2-00-00-15），此报文中无邻居标识。&lt;/li&gt;
&lt;li&gt;R2收到此报文后，将自己和R1的邻居状态标识为Initial。然后，R2再组播向R1回复Level-2 LAN IIH，此报文中标识R1为R2的邻居。&lt;/li&gt;
&lt;li&gt;R1收到此报文后，将自己与R2的邻居状态标识为Up。然后R1再组播向R2发送一个标识R2为R1邻居的Level-2 LAN IIH。&lt;/li&gt;
&lt;li&gt;R2收到此报文后，将自己与R1的邻居状态标识为Up。这样，两个路由器成功建立了邻居关系。&lt;br&gt;
&lt;code&gt;因为是广播网络，需要选举DIS，所以在邻居关系建立后，路由器会等待两个Hello报文间隔再进行DIS的选举。Hello报文中包含Priority字段，Priority值最大的将被选举为该广播网的DIS&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;IS-IS和OSPF关于邻接关系的区别：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IS-IS两个邻居路由器只要相互交换HELLO数据包就认为相互形成了邻接关系；而OSPF中，两台路由器进入2-Way状态则认为形成了邻居关系，但是只要进入Full状态才被认为进入完全邻接关系。&lt;br&gt;
IS-IS中，优先级为0的路由器亦然可以参与DIS选举；而OSPF汇总优先级为0表示不参与选举。&lt;br&gt;
IS-IS中，DIS是基于抢占的；OSPF中DR/BDR已经选举不得抢占。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;p2p&#34;&gt;P2P&lt;/h4&gt;
&lt;p&gt;在P2P连路上，邻接关系建立不同于广播链路，分为两次握手机制和&lt;strong&gt;三次握手机制（默认）&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588860853052.png&#34; alt=&#34;P2P邻接关系建立&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两次握手2-way（容易存在单通的风险，即链路两端分别为Up和Down）&lt;br&gt;
只要路由器收到对端发来的Hello报文，就单方面宣布邻居为Up状态，建立邻居关系&lt;/li&gt;
&lt;li&gt;三次握手3-way（默认方式）&lt;br&gt;
通过三次发送P2P的Hello PDU最终建立邻居关系，类似广播邻居关系建立&lt;br&gt;
&lt;code&gt;修改命令：isis ppp-negotiation 2-way/3-way&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;dis和dr的对比&#34;&gt;DIS和DR的对比&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;类比点&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;ISIS-DIS&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;OSPF-DR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选举优先级&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0优先级也可以参与选举&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0优先级不参与选举&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选举等待 时间&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;2个Hello间隔20/3s&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;备份&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;无&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;有，BDR&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;邻接关系&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;所有路由器相互都是邻接关系&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DRother之间是2-way关系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;抢占性&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;支持抢占&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;作用&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;周期发送CSNP，保障MA网络LSDB同步&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;主要为了减少LSA泛洪&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;链路状态信息载体&#34;&gt;链路状态信息载体&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ISIS TLV&lt;/strong&gt;：TLV的含义：类型Type、长度Length、值Value，实际上是一个数据结构，这个结构包含这三个字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用TLV结构建立报文的好处是灵活性和扩展性好，采用TLV使得报文的整体结构稳定，增加新特点只需要增加新TLV即可，无需改变整个报文的整体结构&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;LSP PDU&lt;br&gt;
用于交换链路状态信息
&lt;ol&gt;
&lt;li&gt;实节点LSP&lt;/li&gt;
&lt;li&gt;伪节点LSP（只在广播链路存在）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;SNP PDU&lt;br&gt;
用于维护LSDB的完整与同步，且为摘要信息
&lt;ol&gt;
&lt;li&gt;CSNP，用于同步LSP&lt;/li&gt;
&lt;li&gt;PSNP，用于请求和确认LSP&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lsp交互过程&#34;&gt;LSP交互过程&lt;/h3&gt;
&lt;h4 id=&#34;广播网络&#34;&gt;广播网络&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;LSP交互不需要确认&lt;/code&gt;&lt;br&gt;
CSNP报文在广播网络中的作用：确认机制，相当于ACK&lt;br&gt;
PSNP报文在广播网络中的作用：请求（LSR）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588862762123.png&#34; alt=&#34;广播网络LSP交互过程&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新加入的路由器R3已经与R2（&lt;strong&gt;DIS&lt;/strong&gt;）、R1建立邻居关系&lt;/li&gt;
&lt;li&gt;R3使用组播地址发送自己的LSP&lt;/li&gt;
&lt;li&gt;R2收到R3的LSP之后，会将R3加入LSDB中，并等待CSNP报文定时器超时（10s）并发送CSNP报文，进行该网络的LSDB同步&lt;/li&gt;
&lt;li&gt;R3收到DIS发来的CSNP后，对比自己的LSDB，然后向R2发送PSNP用来请求自己没有的LSP&lt;/li&gt;
&lt;li&gt;R2收到R3发来的PSNP之后，将R3请求的LSP发送给R3&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;在广播网络中设备的LSDB更新过程如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;DIS接收到LSP，在数据库中搜索对应的记录，若没有该LSP，则将其加入数据库，并广播新数据库内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;序列号越大越优&lt;/strong&gt;：若收到的LSP序列号大于本地LSP的序列号，就替换为新报文，并广播新数据库内容；若收到的LSP序列号小本地LSP的序列号，就向入端接口发送本地LSP报文&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RemainingLifetime剩余生存时间越小越优&lt;/strong&gt;：若两个序列号相等，则比较RemainingLifetime。若收到的LSP的RemainingLifetime小于本地LSP的Remaining Lifetime，就替换为新报文，并广播新数据库内容；若收到的LSP的Remaining Lifetime大于本地LSP的Remaining Lifetime，就向入端接口发送本地LSP报文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Checksum越大越优&lt;/strong&gt;：若两个序列号和RemainingLifetime都相等，则比较Checksum。若收到的LSP的Checksum大于本地LSP的Checksum，就替换为新报文，并广播新数据库内容；若收到的LSP的Checksum小于本地LSP的Checksum，就向入端接口发送本地LSP报文。&lt;/li&gt;
&lt;li&gt;若两个序列号、Remaining Lifetime和Checksum都相等，则不转发该报文&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;p2p网络&#34;&gt;P2P网络&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;LSP交互需要确认&lt;/code&gt;&lt;br&gt;
PSNP报文在P2P网络中的作用：作为ACK应答以确认收到的LSP，用来请求所需的LSP&lt;br&gt;
在P2P链路上，&lt;strong&gt;CSNP只会发送一次&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588863344689.png&#34; alt=&#34;P2P网络LSP交互过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;实际抓包过程：第一阶段R1和R2各发一个LSP；第二阶段R1和R2各发送一个PSNP；第三阶段R1发送LSP，R2发送CSNP进行确认&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在P2P网络中设备的LSDB更新过程如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;序列号越大越优&lt;/strong&gt;：若收到的LSP比本地的序列号更小，则直接给对方发送本地的LSP，然后等待对方给自己一个PSNP报文作为确认；若收到的LSP比本地的序列号更大，则将这个新的LSP存入自己的LSDB，再通过一个PSNP报文来确认收到此LSP，最后再将这个新LSP发送给除了发送该LSP的邻居以外的邻居&lt;br&gt;
&lt;strong&gt;RemainingLifetime剩余生存时间越小越优&lt;/strong&gt;：若收到的LSP序列号和本地相同，则比较Remaining Lifetime，若收到LSP的Remaining Lifetime小于本地LSP的Remaining Lifetime，则将收到的LSP存入LSDB中并发送PSNP报文来确认收到此LSP，然后将该LSP发送给除了发送该LSP的邻居以外的邻居；若收到LSP的Remaining Lifetime大于本地LSP的Remaining Lifetime，则直接给对方发送本地的LSP，然后等待对方给自己一个PSNP报文作为确认&lt;br&gt;
&lt;strong&gt;Checksum越大越优&lt;/strong&gt;：若收到的LSP和本地LSP的序列号以及Remaining Lifetime都相同，且都不为0，则比较Checksum，若收到LSP的Checksum大于本地LSP的Checksum，则将收到的LSP存入LSDB中并发送PSNP报文来确认收到此LSP，然后将该LSP发送给除了发送该LSP的邻居以外的邻居；若收到LSP的Checksum小于本地LSP的Checksum，则直接给对方发送本地的LSP，然后等待对方给自己一个PSNP报文作为确认&lt;br&gt;
若收到的LSP和本地LSP的序列号、Remaining Lifetime和Checksum都相同，则不转发该报文&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ISIS中的ABR生成默认路由（ATT=1）的条件：一边为Level-1，另外一边为Level-2&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ISIS中Level-2可以学习到Level-1中的路由，但是Level-1无法学习到Level-2的路由&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;lsp产生的原因&#34;&gt;LSP产生的原因&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;邻居Up或Down&lt;/li&gt;
&lt;li&gt;IS-IS相关接口Up或Down&lt;/li&gt;
&lt;li&gt;引入的IP路由发生变化&lt;/li&gt;
&lt;li&gt;区域间的IP路由发生变化&lt;/li&gt;
&lt;li&gt;接口被赋了新的metric值&lt;/li&gt;
&lt;li&gt;周期性更新&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;收到邻居新的lsp的处理过程&#34;&gt;收到邻居新的LSP的处理过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;将接收的新的LSP合入到自己的LSDB数据库中，并标记为flooding&lt;/li&gt;
&lt;li&gt;发送新的LSP到除了收到该LSP的接口之外的接口&lt;/li&gt;
&lt;li&gt;邻居再扩散到其他邻居。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;路由算法&#34;&gt;路由算法&lt;/h3&gt;
&lt;p&gt;设备默认接口开销值都是10&lt;/p&gt;
&lt;h4 id=&#34;spf计算过程&#34;&gt;SPF计算过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;单区域LSDB同步完成&lt;/li&gt;
&lt;li&gt;生成全网拓扑结构图&lt;/li&gt;
&lt;li&gt;以本节点为根生成最短路径树&lt;/li&gt;
&lt;li&gt;默认跨越每个节点的开销一样&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;isis的计算特点&#34;&gt;ISIS的计算特点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在本区域收到的LSP更新，如果是部分拓扑的变化执行的SSPF内路由器第一次启动的时候执行的是Full-SPF算法&lt;/li&gt;
&lt;li&gt;如果只是路由信息的变法，执行的是PRC算法&lt;/li&gt;
&lt;li&gt;由于采用拓扑与网络分离的算法，路由收敛速度得到了加强&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;isis路由计算的开销方式&#34;&gt;ISIS路由计算的开销方式&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;Narrow模式：设备默认模式开销都是10，手工配置接口开销取值范围为1-63&lt;/li&gt;
&lt;li&gt;Wide模式：设备默认开销模式都是10，手工配置接口开销取值范围为1-16777215&lt;br&gt;
&lt;code&gt;进程下执行auto-cost enable，两种模式都会参考接口带宽计算开销值，但是参考准则有差异&lt;/code&gt;&lt;br&gt;
&lt;code&gt;接口视图下配置开销值：isis cost 60&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;区域间路由&#34;&gt;区域间路由&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588951097495.png&#34; alt=&#34;区域间路由&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;路由渗透&#34;&gt;路由渗透&lt;/h3&gt;
&lt;p&gt;通常情况下，Level-1区域内的路由通过Level-1路由器进行管理。所有的Level-2和Level-1-2路由器构成一个连续的骨干区域。Level-1区域必须且只能与骨干区域相连，不同的Level-1区域之间并不相连。Level-1-2路由器将学习到的Level-1路由信息装进Level-2 LSP，再泛洪LSP给其他Level-2和Level-1-2路由器。&lt;br&gt;
因此，Level-1-2和Level-2路由器知道整个IS-IS路由域的路由信息。但是，为了有效减小路由表的规模，在缺省情况下，Level-1-2路由器并不将自己知道的其他Level-1区域以及骨干区域的路由信息通报给它所在的Level-1区域。这样，Level-1路由器将不了解本区域以外的路由信息，可能导致与本区域之外的目的地址通信时无法选择最佳的路由。&lt;br&gt;
&lt;code&gt;简而言之，路由渗透解决非骨干区域访问骨干区域时，因为不知道明细路由而导致的次优路径问题&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;isis 1
import-route isis level-2 into level-1  # 将Level 2的路由渗透到Level1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;isis路由过载&#34;&gt;ISIS路由过载&lt;/h3&gt;
&lt;p&gt;ISIS过载标志位是指ISIS LSP报文中的&lt;strong&gt;OL字段&lt;/strong&gt;。对设备设置过载标志位后，其它设备在进行SPF计算时不会使用这台设备做转发，只计算该设备上的直连路由（一般用于承载BGP的核心ISIS）&lt;br&gt;
&lt;code&gt;如果因为设备进入异常状态导致系统进入过载状态，此时系统将删除全部引入或渗透的路由信息&lt;/code&gt;&lt;br&gt;
&lt;code&gt;如果因为用户配置导致系统进入过载状态，此时会根据用户的配置决定是否删除全部引入或渗透路由&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;过载原因&#34;&gt;过载原因&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当系统因为各种原因&lt;strong&gt;无法保存新的LSP&lt;/strong&gt;，以致无法维持正常的LSDB同步时，该系统计算出的路由信息将出现错误。在这种情况下，系统就可以自动进入过载状态，即通过该设备到达的路由不计算，但该设备的直连路由不会被忽略&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了设备异常可导致自动进入过载状态，也可以通过手动配置（&lt;code&gt;isis 1 &amp;amp;&amp;amp; set-overload&lt;/code&gt;）使系统进入过载状态。当网络中的某些IS-IS设备&lt;strong&gt;需要升级或维护&lt;/strong&gt;时，需要暂时将该设备从网络中隔离。此时可以给该设备设置过载标志位，这样就可以避免其他设备通过该节点来转发流量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isis收敛特性&#34;&gt;ISIS收敛特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;快速收敛&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增量最短路径优先算法ISPF：是指当网络拓扑改变的时候，只对受影响的节点进行路由计算，而不是对全部节点重新进行路由计算，从而加快了路由的计算。
&lt;ul&gt;
&lt;li&gt;只对受影响的节点进行路由计算&lt;/li&gt;
&lt;li&gt;仅第一次计算全部节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;部分路由计算PRC：是指当网络上路由发生变化的时候，只对发生变化的路由进行重新计算。    PRC的原理和ISPF相同，都是只对发生变化的路由进行重新计算。不同的是，PRC不需要计算节点路径，而是根据ISPF算出来的SPT来更新路由。&lt;/li&gt;
&lt;li&gt;智能定时器：在进行SPF计算和产生LSP的时候用到的一种智能定时器。该定时器首次超时时间是一个固定的时间。如果在定时器超时前，又有触发定时器的事件发生，则该定时器下一次的超时时间会增加。&lt;/li&gt;
&lt;li&gt;LSP快速扩散：此特性可以加快LSP的扩散速度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按优先级收敛&lt;br&gt;
IS-IS按优先级收敛是指在大量路由情况下，能够让某些特定的路由（例如匹配指定IP前缀的路由）优先收敛的一种技术。通过对不同的路由配置不同的收敛优先级，达到重要的路由先收敛的目的，提高网络的可靠性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;isis认证&#34;&gt;ISIS认证&lt;/h3&gt;
&lt;h4 id=&#34;分类&#34;&gt;分类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;接口认证&lt;/strong&gt;：是指使能ISIS协议的接口以指定方式和密码对Level-1和Level-2的Hello报文进行认证，&lt;code&gt;针对Hello报文做的认证，会影响ISIS邻居，也会影响路由&lt;/code&gt;有以下两种设置
&lt;ul&gt;
&lt;li&gt;发送带认证TLV的认证报文，本地对收到的报文也进行认证检查&lt;/li&gt;
&lt;li&gt;发送带认证TLV的认证报文，但是本地对收到的报文不进行认证检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区域认证&lt;/strong&gt;：是指运行ISIS的区域以指定方式和密码对Level-1的SNP和LSP报文进行认证&lt;code&gt;针对Level-1的SNP和LSP做的认证，不会影响ISIS邻居，但是会影响Level-1的LSDB的同步，仅影响Level-1的路由，不会影响Level-2的路由&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由域认证&lt;/strong&gt;：是指运行ISIS的路由域以指定方式和密码对Level-2的SNP和LSP报文进行认证，&lt;code&gt;针对Level-2的LSP和SNP的认证，不会影响ISIS邻居，但是会影响Level-2的LSDB的同步，仅影响Level-2的路由，不影响Level-1的路由&lt;/code&gt;可以设置为SNP和LSP分开认证：
&lt;ul&gt;
&lt;li&gt;本地发送的LSP报文和SNP报文都携带认证TLV，对收到的LSP报文和SNP报文都进行认证检查&lt;/li&gt;
&lt;li&gt;本地发送的LSP报文携带认证TLV，对收到的LSP报文进行认证检查；发送的SNP报文携带认证TLV，但不对收到的SNP报文进行检查&lt;/li&gt;
&lt;li&gt;本地发送的LSP报文携带认证TLV，对收到的LSP报文进行认证检查；发送的SNP报文不携带认证TLV，也不对收到的SNP报文进行认证检查&lt;/li&gt;
&lt;li&gt;本地发送的LSP报文和SNP报文都携带认证TLV，对收到的LSP报文和SNP报文都不进行认证检查&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;报文认证方式&#34;&gt;报文认证方式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;明文认证&lt;/li&gt;
&lt;li&gt;MD5认证&lt;/li&gt;
&lt;li&gt;Keychian认证：通过配置随时间变化的密码链表来进一步提升网络的安全性&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;认证信息的携带形式&#34;&gt;认证信息的携带形式&lt;/h4&gt;
&lt;p&gt;ISIS通过TLV的形式携带认证信息，认证TLV的类型为10，具体格式如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Type：ISO定义认证报文的类型值为10，长度为1字节&lt;/li&gt;
&lt;li&gt;Length：指定认证TLV值的长度，长度1字节&lt;/li&gt;
&lt;li&gt;Value：指定认证的具体内容，其中包括了认证的类型和认证的密码，长度为1～254字节，其中认证的类型为1字节，具体定义如下：
&lt;ul&gt;
&lt;li&gt;0：保留的类型&lt;/li&gt;
&lt;li&gt;1：明文认证&lt;/li&gt;
&lt;li&gt;54：MD5认证&lt;/li&gt;
&lt;li&gt;255：路由域私有认证方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;度量值&#34;&gt;度量值&lt;/h3&gt;
&lt;p&gt;在早期的ISO10589中，使能IS-IS协议的接口下最大只能配置值为63（&lt;strong&gt;默认是10&lt;/strong&gt;）的开销值，此时认为&lt;strong&gt;ISIS开销类型为narrow&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;窄度量值&#34;&gt;窄度量值&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;128号TLV（IP Internal Reachability TLV）：用来携带路由域内的IS-IS路由信息&lt;/li&gt;
&lt;li&gt;130号TLV（IP External Reachability TLV）：用来携带路由域外的IS-IS路由信息&lt;/li&gt;
&lt;li&gt;2号TLV(IS Neighbors TLV)：用来携带邻居信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;宽度量值&#34;&gt;宽度量值&lt;/h4&gt;
&lt;p&gt;OSPF与ISIS协议都被扩展以便携带MPLS TE接口参数，对于ISIS协议来说，使用以下两种新的TLV：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;135号TLV(Extended IP Reachability TLV)：用来替换原有的IP reachability TLV，携带ISIS路由信息，它扩展了路由开销值的范围，并可以携带sub TLV&lt;/li&gt;
&lt;li&gt;22号TLV（IS Extended Neighbors TLV）：用来携带邻居信息&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1589100789194.png&#34; alt=&#34;接收和发送的类型详细列表&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;ISIS有邻居却没有路由的情况&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;度量值类型不相同或者不兼容&lt;/li&gt;
&lt;li&gt;ISIS设置了区域认证或者路由域认证&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;lsp分片扩展&#34;&gt;LSP分片扩展&lt;/h3&gt;
&lt;p&gt;当ISIS要发布的链路状态协议数据报文PDU中的信息量太大时，IS-S路由器将会生成多个LSP分片，用来携带更多的ISIS信息。&lt;br&gt;
ISIS LSP分片由LSP ID中的LSP Number字段进行标识，这个字段的长度是1字节。因此，一个IS-IS进程最多可产生256个LSP分片，携带的信息量有限。在RFC3786中规定，IS-IS可以配置虚拟的SystemID ，并生成虚拟IS-IS的LSP报文来携带路由等信息。&lt;br&gt;
&lt;code&gt;lsp-fragments-extend命令用来使能IS-IS路由器的LSP分片扩展功能，为了使IS-IS路由器生成扩展LSP分片，应通过命令virtual-system至少配置一个虚拟系统ID&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;基本概念-2&#34;&gt;基本概念&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;初始系统（Originating System）：初始系统是实际运行ISIS协议的路由器。允许一个单独的ISIS进程像多个虚拟路由器一样发布LSP，而“Originating System”指的是那个“真正”的IS-IS进程。&lt;/li&gt;
&lt;li&gt;系统ID（Normal System-ID）：初始系统的系统ID。&lt;/li&gt;
&lt;li&gt;虚拟系统（Virtual System）：由附加系统ID标识的系统，用来生成扩展LSP分片。这些分片在其LSP ID中携带附加系统ID。&lt;/li&gt;
&lt;li&gt;附加系统ID（Additional System-ID）：虚拟系统的系统ID，由网络管理器统一分配。每个附加系统ID都允许生成256个扩展的LSP分片。&lt;code&gt;附加系统ID和系统ID一样，在整个路由域中必须唯一&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;24号TLV（IS Alias ID TLV）：用来表示初始系统与虚拟系统的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;工作原理&#34;&gt;工作原理&lt;/h4&gt;
&lt;p&gt;在IS-IS中，每个系统ID都标识一个系统，每个系统都最多可生成256个LSP分片。&lt;strong&gt;通过增加附加系统ID，可以最多配置50个虚拟系统&lt;/strong&gt;，从而使得&lt;strong&gt;ISIS进程最多可生成13056个LSP分片&lt;/strong&gt;。&lt;br&gt;
使能分片扩展功能之后，如果存在由于报文装满而丢失的信息，系统会提醒重启IS-IS。重启之后，初始系统会尽最大能力装载路由信息，装不下的信息将放入虚拟系统的LSP中发送出去，并通过24号TLV来告知其他路由器此虚拟系统和自己的关系。&lt;/p&gt;
&lt;h4 id=&#34;工作模式&#34;&gt;工作模式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589101539252.png&#34; alt=&#34;LSP分片工作模式&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;Mode-1：用于网络中的部分路由器不支持LSP分片扩展特性的情况&lt;br&gt;
RouterB是不支持分片扩展的路由器，RouterA设置为Mode-1模式的分片扩展，RouterA1和RouterA2是RouterA的虚拟系统，RouterA将一部分路由信息放入RouterA1和RouterA2的LSP报文中向外发送。RouterB收到RouterA，RouterA1和RouterA2的报文时，&lt;strong&gt;认为对端有三台独立的路由器&lt;/strong&gt;，并进行正常的路由计算。同时&lt;strong&gt;RouterA到RouterA1和RouterA2的开销都是0&lt;/strong&gt;，所以，RouterB到RouterA的路由开销值与RouterB到RouterA1路由开销值都相等&lt;/li&gt;
&lt;li&gt;Mode-2：用于网络中所有路由器都支持LSP分片扩展特性的情况&lt;br&gt;
RouterB是支持分片扩展的路由器，RouterA设置为Mode-2模式的分片扩展，RouterA1和RouterA2是RouterA的虚拟系统，RouterA将一部分路由信息放入到RouterA1和RouterA2的LSP报文中向外发送。当RouterB收到RouterA1和RouterA2的LSP时，通过IS Alias ID TLV知道他们的初始系统是RouterA，则把RouterA1，RouterA2所发布的信息都视为RouterA的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;管理标记&#34;&gt;管理标记&lt;/h3&gt;
&lt;p&gt;管理标记特性允许在IS-IS域中通过管理标记对IP地址前缀进行控制，可以达到简化管理。其用途包括控制不同级别和不同区域间的路由引入，以及在同一路由器上运行的IS-IS多实例（即我们说的Tag）&lt;br&gt;
&lt;code&gt;使能管理标记时，必须使能IS-IS wide metric属性&lt;/code&gt;&lt;br&gt;
&lt;code&gt;circuit default-tag命令用来配置指定IS-IS进程下所有接口的管理标记值。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# AR1
route-policy TAG permit no 10
if-match tag 100
isis
import-route isis level-2 into level-1 filter-policy route-policy TAG #将携带tag值为100的路由渗透到Level-1
# AR2
int lo 0
ip addr 22.22.22.22 32
isis enable
isis tag-value 100 # 给该条路由设置tag值为100
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;默认路由的下放&#34;&gt;默认路由的下放&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;isis
import-route static
default-route-advertise always [ level-1 | level-2 | level-1-2 ]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;接口开销&#34;&gt;接口开销&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bandwidth-reference&lt;/code&gt;命令用来设置IS-IS接口开销自动计算功能中所使用的带宽参考值。&lt;br&gt;
&lt;code&gt;接口的开销值= (bandwidth-reference/接口带宽值)×10&lt;/code&gt;&lt;br&gt;
当通过该公式计算的接口开销值大于16777214时，接口仍按照开销值为16777214参与路由计算，即接口开销值不会大于16777214。&lt;/p&gt;
&lt;h1 id=&#34;故障诊断&#34;&gt;故障诊断&lt;/h1&gt;
&lt;h2 id=&#34;故障排除流程&#34;&gt;故障排除流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;检查接口是否在ISIS中使能&lt;/li&gt;
&lt;li&gt;基本配置是否正确&lt;/li&gt;
&lt;li&gt;相应接口级别是否配置正确&lt;/li&gt;
&lt;li&gt;路由器区域是否相同&lt;/li&gt;
&lt;li&gt;相邻接口IP地址是否处于相同子网中&lt;/li&gt;
&lt;li&gt;系统ID是否重复&lt;/li&gt;
&lt;li&gt;是否开启了认证，认证配置是否正确&lt;/li&gt;
&lt;li&gt;接口是否发送标准hello报文&lt;br&gt;
&lt;code&gt;不同网段需要建邻居，需要在相应接口下配置忽略IP：int s1/0/0 &amp;amp;&amp;amp; isis peer-ip-ignore。以太口虽然可以改为p2p链路，从而建立邻居，学习到相应路由，但是无法ping通。&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;实验一配置isis&#34;&gt;实验一：配置ISIS&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588670348547.png&#34; alt=&#34;配置ISIS&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.......................................配置IP地址
# SW1
sys
sys SW1
# AR1
sys
sys AR1
int lo 0
ip addr 1.1.1.1 32
int g0/0/0
ip addr 172.16.10.1 24
# AR2
sys
sys AR2
int lo 0
ip addr 2.2.2.2 32
int g0/0/0
ip addr 172.16.10.2 24
# AR3
sys
sys AR3
int lo 0
ip addr 3.3.3.3 32
int g0/0/0
ip addr 172.16.10.3 24
int g0/0/1
ip addr 14.1.1.1 24
# AR4
sys
sys AR4
int lo 0
ip addr 4.4.4.4 32
int g0/0/0
ip addr 14.1.1.4 24
int s1/0/0
ip addr 45.1.1.4 24
# AR5
sys
sys AR5
int lo 0
ip addr 5.5.5.5 32
int s1/0/0
ip addr 45.1.1.5 24
#...............................................................配置ISIS
# ISIS不支持进程下宣告，只能在接口上宣告
# AR1
isis # 默认进程号为1
is-name AR1  # 配置设备名称（可选项），便于记忆和查看邻居
# is-level level-1
net 49.0123.1111.1111.1111.00
int g0/0/0
isis enable # 默认进程号为1
int g1/0/0
isis enable 
int lo 0
isis enable
# AR2
isis 
is-name AR2
# is-level level-1
net 49.0123.2222.2222.22222.00
int g0/0/0
isis enable 
int lo 0
isis enable
# AR3
isis 
is-name AR3
# is-level level-1
net 49.0123.3333333333333.00  # 配置SystemID时中间可以不用&amp;quot;.&amp;quot;,但是必须使用12个数字（即6B）
int g0/0/0
isis enable 
int lo 0
isis enable
# AR4
isis 
is-name AR4
# is-level level-2
net 49.0045.444444444444.00
int g0/0/0
isis enable 
int lo 0
isis enable
int s1/0/0
isis enable
# AR5
isis 
is-name AR5
# is-level level-2
net 49.0045.555555555555.00
int lo 0
isis enable
int s1/0/0
isis enable
# .................................................查看ISIS邻居\路由\j接口宣告情况
# AR1/2/3/4/5
dis isis peer
dis ip rou pro isis
dis isis int 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二查看isis下放的默认路由att1&#34;&gt;实验二：查看ISIS下放的默认路由（ATT=1）&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1588866324756.png&#34; alt=&#34;查看ATT=1的默认路由&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1
sys
sys AR1
isis 
is-name AR1  
is-level level-1
net 49.0123.1111.1111.1111.00
int lo 0
ip addr 1.1.1.1 32
isis enable
int g0/0/0
ip addr 172.16.10.1 24
isis enable
# AR2
sys
sys AR2
isis 
is-name AR2
net 49.0123.2222.2222.2222.00
int lo 0
ip addr 2.2.2.2 32
isis enable
int g0/0/0
ip addr 172.16.10.2 24
isis enable
int g0/0/1
ip addr 24.1.1.2 24
isis enable
# AR3
sys
sys AR3
isis 
is-name AR3
net 49.0123.3333.3333.3333.00
int lo 0
ip addr 3.3.3.3 32
isis enable
int g0/0/0
ip addr 172.16.10.3 24
isis enable
int s1/0/0
ip addr 34.1.1.3 24
isis enable
# AR4
sys
sys AR4
isis 
is-name AR4
is-level level-2
net 49.0045.4444.4444.4444.00
int lo 0
ip addr 4.4.4.4 32
isis enable
int g0/0/0
ip addr 24.1.1.4 24
isis enable
int g0/0/1
ip addr 45.1.1.4 24
isis enable
int s1/0/0
ip addr 34.1.1.4 24
isis enable
# AR5
sys
sys AR5
isis 
is-name AR5
is-level level-2
net 49.0045.5555.5555.5555.00
int lo 0
ip addr 5.5.5.5 32
isis enable
int g0/0/0
ip addr 45.1.1.5 24
isis enable

# 查看默认路由
# AR1
dis isis lsdb
dis ip rou pro isis
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三isis综合实验&#34;&gt;实验三：ISIS综合实验&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1589207754937.png&#34; alt=&#34;ISIS综合实验&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基础配置：
&lt;ul&gt;
&lt;li&gt;R1\R2\R3是Level-1路由器，R6是Level-2路由器。SystemID为0000.0000.000x。ISIS的进程号为1&lt;/li&gt;
&lt;li&gt;通告相关接口，网段10.0.x.0/24暂不通告&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;网络改造：
&lt;ul&gt;
&lt;li&gt;R4和R6、R5和R6之间不能有DIS选举&lt;/li&gt;
&lt;li&gt;R1\R2\R3共享网络中，要求R3为DIS，需要在R1和R2上配置，且优先级设置尽量小但仍可以参加DIS选举&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路由信息发布：
&lt;ul&gt;
&lt;li&gt;R6引入10.0.x.0/24网段，并标记为100&lt;/li&gt;
&lt;li&gt;要求区域47.0001能够通过R4学到10.0.x.0/24网段明细，且必须保持这些路由的标记为100&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路由信息的接收：
&lt;ul&gt;
&lt;li&gt;R2只允许通过缺省路由方位区域47.0002的网络，不能使用ACL和前缀列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路由选择：
&lt;ul&gt;
&lt;li&gt;R3上有两条默认路由，分别是到R4和R5的，现在需要让数据转发只能走R5&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;安全设置：
&lt;ul&gt;
&lt;li&gt;区域47.0001的所有路由器发送LSP和SNP需要进行认证，认证类型为MD5，密码为huawei&lt;/li&gt;
&lt;li&gt;Level-2路由器发送的IIH需要进行认证，认证类型为MD5，密码为huawei&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;路由汇总：
&lt;ul&gt;
&lt;li&gt;将AR6上的10.0.x.0/24汇总成10.0.0.0/8，并且带tag为100&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ..............................基础配置
# AR1
sys
sys AR1
isis 
is-name AR1
is-level level-1
net 47.0001.111111111111.00
int lo 0
ip addr 1.1.1.1 32
isis enable
int g0/0/0
ip addr 192.168.10.1 24
isis enable
# AR2
sys
sys AR2
isis 
is-name AR2
is-level level-1
net 47.0001.222222222222.00
int lo 0
ip addr 2.2.2.2 32
isis enable
int g0/0/0
ip addr 192.168.10.2 24
isis enable
# AR3
sys
sys AR3
isis 
is-name AR3
is-level level-1
net 47.0001.333333333333.00
int lo 0
ip addr 3.3.3.3 32
isis enable
int g0/0/0
ip addr 192.168.10.3 24
isis enable
int s1/0/0
ip addr 34.1.1.3 24
isis enable
int s1/0/1
ip addr 35.1.1.3 24
isis enable
# AR4
sys
sys AR4
isis 
is-name AR4
net 47.0001.444444444444.00
int lo 0
ip addr 4.4.4.4 32
isis enable
int g0/0/0
ip addr 46.1.1.4 24
isis enable
int s1/0/0
ip addr 34.1.1.4 24
isis enable
# AR5
sys
sys AR5
isis 
is-name AR5
net 47.0001.555555555555.00
int lo 0
ip addr 5.5.5.5 32
isis enable
int g0/0/0
ip addr 56.1.1.5 24
isis enable
int s1/0/0
ip addr 35.1.1.5 24
isis enable
# AR6
sys
sys AR6
isis 
is-name AR6
is-level  level-2
net 47.0002.666666666666.00
int lo 0
ip addr 6.6.6.6 32
isis enable
int g0/0/0
ip addr 46.1.1.6 24
isis enable
int g0/0/1
ip addr 56.1.1.6 24
isis enable
int lo 10
ip addr 10.0.0.0 24
int lo 11
ip addr 10.0.1.0 24
int lo 12
ip addr 10.0.2.0 24
int lo 13
ip addr 10.0.3.0 24

# ....................................网络改造
# AR4
int g0/0/0
isis circuit-type p2p
isis ppp-negotiation 3-way only
# AR5
int g0/0/0
isis circuit-type p2p
isis ppp-negotiation 3-way only
# AR6
int g0/0/0
isis circuit-type p2p
isis ppp-negotiation 3-way only
int g0/0/1
isis circuit-type p2p
isis ppp-negotiation 3-way only
# AR1
int g0/0/0
isis dis-priority 0
# AR2
int g0/0/0
isis dis-priority 0
#.....................................路由信息发布
# AR6
acl 2001
rule permit source 10.0.0.0 0.0.3.255
q
route-policy Import-DIR permit node 10
if-match acl 2001
apply tag 100
isis
import-route direct route-policy Import-DIR level-2
cost-style wide
# AR1/2/3/4/5
isis
cost-style wide
# AR4
route-policy Tag permit node 10
if-match tag 100
q
isis
import-route isis level-2 into level-1 filter-policy route-policy Tag
# .............................................路由信息接收
# AR2
router-policy Deny_tag deny node 10
if-match tag 100
q
isis
filter-policy
route-policy Deny_tag import
#...............................................路由选择
# AR3
isis
nexthop 35.1.1.5 weight 1  # nexthop用来配置等价路由的优先级，weight（1~254）值越小越优
#...............................................安全设置
# AR1/2/3/4/5
isis
area-authentication-mode md5 huawei
# AR4/AR5
int g0/0/0
isis authentication-mode md5 huawei
# AR6
int g0/0/0
isis authentication-mode md5 huawei
int g0/0/1
isis authentication-mode md5 huawei
# .....................................路由汇总
# AR6
isis 
summary 10.0.0.0 255.0.0.0 level-2 tag 100
&lt;/code&gt;&lt;/pre&gt;
">03 ISIS（2020.0503）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-zhi-psutil/"" data-c="
          &lt;p&gt;用Python来编写脚本简化日常的运维工作。在Python中获取系统信息的好办法是使用psutil这个第三方模块，psutil = process and system utilities，它不仅可以通过一两行代码实现系统监控，还可以跨平台使用，支持Linux／UNIX／OSX／Windows等，是系统管理员和运维小伙伴不可或缺的必备模块。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;获取cpu信息&#34;&gt;获取CPU信息&lt;/h1&gt;
&lt;h2 id=&#34;函数解析&#34;&gt;函数解析&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.cpu_count()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cpu_count(,[logical]):默认返回逻辑CPU的个数,当设置logical的参数为False时，返回物理CPU的个数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.cpu_percent()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cpu_percent(,[percpu],[interval])：返回CPU的利用率,percpu为True时显示所有物理核心的利用率,interval不为0时,则阻塞时显示interval执行的时间内的平均利用率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.cpu_times()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cpu_times(,[percpu])：以命名元组(namedtuple)的形式返回cpu的时间花费,percpu=True表示获取每个CPU的时间花费&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.cpu_times_percent()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cpu_times_percent(,[percpu])：功能和cpu_times大致相同，看字面意思就能知道，该函数返回的是耗时比例。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.cpu_stats()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cpu_stats()以命名元组的形式返回CPU的统计信息，包括上下文切换，中断，软中断和系统调用次数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.cpu_freq()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;cpu_freq([percpu])：返回cpu频率&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;代码展示&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import psutil
# 查看cpu个数
psutil.cpu_count() # 逻辑CPU
psutil.cpu_count(logical=False) # 物理CPU
# 查看cpu利用率
psutil.cpu_percent()
psutil.cpu_percent(percpu=True)
 psutil.cpu_percent(1)
# 查看cpu时间花费
psutil.cpu_times()
psutil.cpu_times(percpu=True)
psutil.cpu_times().user
psutil.cpu_times().iowait
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;获取内存信息&#34;&gt;获取内存信息&lt;/h1&gt;
&lt;h2 id=&#34;函数解释&#34;&gt;函数解释&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.virtual_memory()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以命名元组的形式返回内存使用情况，包括总内存，可用内存，内存利用率，buffer和cache等，单位为字节。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.swap_memory()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以命名元组的形式返回swap/memory使用情况，包含swap中页的换入和换出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;代码展示-2&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import psutil
psutil.virtual_memory()
psutil.virtual_memory().total
psutil.virtual_memory().used
psutil.virtual_memory().free
psutil.swap_memory()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;补充内容单位转换&#34;&gt;补充内容：单位转换&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import psutil
def bytes2human(n):
     symbols = (&#39;K&#39;,&#39;M&#39;,&#39;G&#39;,&#39;T&#39;,&#39;P&#39;,&#39;E&#39;,&#39;Z&#39;,&#39;Y&#39;)
     prefix = {}
     for i,s in enumerate(symbols):
         prefix[s] = 1 &amp;lt;&amp;lt; (i + 1) * 10
     for s in reversed(symbols):
         if n &amp;gt;= prefix[s]:
             value = float(n) / prefix[s]
             return &#39;%.1f%s&#39; % (value,s)
     return &#39;%sB&#39; % n
print(bytes2human(psutil.virtual_memory().total))
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;获取硬盘信息&#34;&gt;获取硬盘信息&lt;/h1&gt;
&lt;h2 id=&#34;函数解释-2&#34;&gt;函数解释&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.disk_io_counters()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;disk_io_counters([perdisk])：以命名元组的形式返回磁盘io统计信息(汇总的)，包括读、写的次数，读、写的字节数等。当perdisk的值为True，则分别列出单个磁盘的统计信息(字典：key为磁盘名称，value为统计的namedtuple)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.disk_partitions()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;disk_partitions([all=False])：以命名元组的形式返回所有已挂载的磁盘，包含磁盘名称，挂载点，文件系统类型等信息。当all等于True时，返回包含/proc等特殊文件系统的挂载信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.disk_usage()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;disk_usage(path)：以命名元组的形式返回path所在磁盘的使用情况，包括磁盘的容量、已经使用的磁盘容量、磁盘的空间利用率等。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;代码展示-3&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import psutil
# 查看所有已挂在的磁盘(磁盘分区信息)
psutil.disk_partitions()
# 使用列表表达式查询指定挂载点信息
[device for device in psutil.disk_partitions() if device.mountpoint == &#39;/&#39;]
# 查看磁盘使用情况
psutil.disk_usage(&#39;/&#39;)
# 查看磁盘io统计汇总
psutil.disk_io_counters()
# 分别列出单个磁盘的统计信息
psutil.disk_io_counters(perdisk=True)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;获取网络信息&#34;&gt;获取网络信息&lt;/h1&gt;
&lt;h2 id=&#34;函数解释-3&#34;&gt;函数解释&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.net_io_counter([pernic])&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以命名元组的形式返回当前系统中每块网卡的网络io统计信息，包括收发字节数，收发包的数量、出错的情况和删包情况。当pernic为True时，则列出所有网卡的统计信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.net_connections([kind])&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以列表的形式返回每个网络连接的详细信息(namedtuple)。命名元组包含fd, family, type, laddr, raddr, status, pid等信息。kind表示过滤的连接类型，支持的值如下：(默认为inet)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.net_if_addrs()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以字典的形式返回网卡的配置信息，包括IP地址和mac地址、子网掩码和广播地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.net_if_stats()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;返回网卡的详细信息，包括是否启动、通信类型、传输速度与mtu。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.users()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以命名元组的方式返回当前登陆用户的信息，包括用户名，登陆时间，终端，与主机信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.boot_time()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以时间戳的形式返回系统的启动时间&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;代码展示-4&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import psutil
# 查看网卡信息统计(获取网络读写字节／包的个数)
psutil.net_io_counters()
# 获取单个网卡的io信息
psutil.net_io_counters(pernic=True)
# 查看网卡配置信息
psutil.net_if_addrs()
# 获取网络接口状态
psutil.net_if_stats()
# 查看当前登录用户信息
psutil.users()
# 要获取当前网络连接信息
psutil.net_connections() #可能会得到一个AccessDenied错误，原因是psutil获取信息也是要走系统接口，而获取网络连接信息需要root权限，这种情况下，可以退出Python交互环境，用sudo重新启动
# 以linux时间格式返回，可以使用时间戳转换
psutil.boot_time()    
# 转换成自然时间格式
datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(&amp;quot;%Y-%m-%d %H: %M: %S&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;获取进程信息&#34;&gt;获取进程信息&lt;/h1&gt;
&lt;h2 id=&#34;函数解释-4&#34;&gt;函数解释&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;函数&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.pids()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以列表的形式返回当前正在运行的进程&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.pid_exists(1)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;判断给点定的pid是否存在&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.process_iter()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;迭代当前正在运行的进程，返回的是每个进程的Process对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;psutil.Process()&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;对进程进行封装，可以使用该类的方法获取进行的详细信息，或者给进程发送信号。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;进程相关信息的方法&#34;&gt;进程相关信息的方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;children：子进程列表&lt;/li&gt;
&lt;li&gt;cmdline：获取启动进程的命令行参数&lt;/li&gt;
&lt;li&gt;connectios：进程相关网络连接&lt;/li&gt;
&lt;li&gt;cpu_affinity：get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好&lt;/li&gt;
&lt;li&gt;cpu_times：进程的cpu时间信息,包括user,system两个cpu信息&lt;/li&gt;
&lt;li&gt;create_time：获取进程的创建时间(时间戳格式)&lt;/li&gt;
&lt;li&gt;cwd：进程的工作目录绝对路径&lt;/li&gt;
&lt;li&gt;exe：进程的bin路径&lt;/li&gt;
&lt;li&gt;environ：进程环境变量&lt;/li&gt;
&lt;li&gt;gids：进程的gid信息&lt;/li&gt;
&lt;li&gt;io_counters：进程的IO信息,包括读写IO数字及参数&lt;/li&gt;
&lt;li&gt;is_running：判断进程是否正在运行&lt;/li&gt;
&lt;li&gt;kill：发送SIGKILL信号结束进程&lt;/li&gt;
&lt;li&gt;memory_info：进程内存rss,vms信息&lt;/li&gt;
&lt;li&gt;memory_percent：进程内存利用率&lt;/li&gt;
&lt;li&gt;name：获取进程的名称&lt;/li&gt;
&lt;li&gt;num_fds：进程打开的文件个数&lt;/li&gt;
&lt;li&gt;num_threads：进程开启的线程数&lt;/li&gt;
&lt;li&gt;open_files：进程打开的文件&lt;/li&gt;
&lt;li&gt;ppid：父进程ID&lt;/li&gt;
&lt;li&gt;parent：父进程&lt;/li&gt;
&lt;li&gt;send_signal：给进程发送信号，类似与os.kill等&lt;/li&gt;
&lt;li&gt;status：进程状态&lt;/li&gt;
&lt;li&gt;terminal：进程终端&lt;/li&gt;
&lt;li&gt;terminate：发送SIGTEAM信号结束进程&lt;/li&gt;
&lt;li&gt;uids：进程uid信息&lt;/li&gt;
&lt;li&gt;username：进程用户名&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码展示-5&#34;&gt;代码展示&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import psutil
# 以列表形式查看正在运行的进程
psutil.pids()
# 查看进程运行状态，以布尔形式显示
psutil.pid_exists(1)
# 迭代当前正在运行进程，查看列表中前三个实例的信息
list(psutil.process_iter())[:3]
# 通过进程号实例化对象
process = psutil.Process(1)
print(process)
psutil.Process(pid=1, name=&#39;systemd&#39;, started=&#39;16:19:47&#39;)
# 获取进程的名称
process.name()
process.create_time()
process.num_fds()
process.num_threads()
# Process方法
p=psutil.Process(1252)
p.name()      #进程名
p.exe()         #进程的bin路径
p.cwd()        #进程的工作目录绝对路径
p.status()     #进程状态
p.cmdline()  #进程启动的命令行
p.create_time()  #进程创建时间
p.ppid() # 父进程ID
p.parent() # 父进程
p.children() # 子进程列表
p.uids()      #进程uid信息
p.gids()      #进程的gid信息
p.cpu_times()    #进程的cpu时间信息,包括user,system两个cpu信息
p.cpu_affinity()  #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好
p.memory_percent()  #进程内存利用率
p.memory_info()    #进程内存rss,vms信息
p.io_counters()    #进程的IO信息,包括读写IO数字及参数
p.connectios()    #返回进程列表
p.num_threads()  #进程开启的线程数
# psutil的Popen方法启动应用程序，可以跟踪程序的相关信息
from subprocess import PIPE
p = psutil.Popen([&amp;quot;/usr/bin/python&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;print(&#39;hello&#39;)&amp;quot;],stdout=PIPE)
p.name()
p.username()
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;实战脚本&#34;&gt;实战脚本&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 查看系统硬件脚本
#!/usr/bin/env python
#coding:utf-8
import psutil
import datetime
import time

# 当前时间
now_time = time.strftime(&#39;%Y-%m-%d-%H:%M:%S&#39;, time.localtime(time.time()))
print(now_time)

# 查看cpu物理个数的信息
print(u&amp;quot;物理CPU个数: %s&amp;quot; % psutil.cpu_count(logical=False))

#CPU的使用率
cpu = (str(psutil.cpu_percent(1))) + &#39;%&#39;
print(u&amp;quot;cup使用率: %s&amp;quot; % cpu)

#查看内存信息,剩余内存.free  总共.total
#round()函数方法为返回浮点数x的四舍五入值。

free = str(round(psutil.virtual_memory().free / (1024.0 * 1024.0 * 1024.0), 2))
total = str(round(psutil.virtual_memory().total / (1024.0 * 1024.0 * 1024.0), 2))
memory = int(psutil.virtual_memory().total - psutil.virtual_memory().free) / float(psutil.virtual_memory().total)
print(u&amp;quot;物理内存： %s G&amp;quot; % total)
print(u&amp;quot;剩余物理内存： %s G&amp;quot; % free)
print(u&amp;quot;物理内存使用率： %s %%&amp;quot; % int(memory * 100))
# 系统启动时间
print(u&amp;quot;系统启动时间: %s&amp;quot; % datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;))

# 系统用户
users_count = len(psutil.users())
users_list = &amp;quot;,&amp;quot;.join([u.name for u in psutil.users()])
print(u&amp;quot;当前有%s个用户，分别是 %s&amp;quot; % (users_count, users_list))

#网卡，可以得到网卡属性，连接数，当前流量等信息
net = psutil.net_io_counters()
bytes_sent = &#39;{0:.2f} Mb&#39;.format(net.bytes_recv / 1024 / 1024)
bytes_rcvd = &#39;{0:.2f} Mb&#39;.format(net.bytes_sent / 1024 / 1024)
print(u&amp;quot;网卡接收流量 %s 网卡发送流量 %s&amp;quot; % (bytes_rcvd, bytes_sent))
io = psutil.disk_partitions()

print(&#39;-----------------------------磁盘信息---------------------------------------&#39;)

print(&amp;quot;系统磁盘信息：&amp;quot; + str(io))

for i in io:
    o = psutil.disk_usage(i.device)
    print(&amp;quot;总容量：&amp;quot; + str(int(o.total / (1024.0 * 1024.0 * 1024.0))) + &amp;quot;G&amp;quot;)
    print(&amp;quot;已用容量：&amp;quot; + str(int(o.used / (1024.0 * 1024.0 * 1024.0))) + &amp;quot;G&amp;quot;)
    print(&amp;quot;可用容量：&amp;quot; + str(int(o.free / (1024.0 * 1024.0 * 1024.0))) + &amp;quot;G&amp;quot;)

print(&#39;-----------------------------进程信息-------------------------------------&#39;)
# 查看系统全部进程
for pnum in psutil.pids():
    p = psutil.Process(pnum)
    print(u&amp;quot;进程名 %-20s  内存利用率 %-18s 进程状态 %-10s 创建时间 %-10s &amp;quot; \
    % (p.name(), p.memory_percent(), p.status(), p.create_time()))
&lt;/code&gt;&lt;/pre&gt;
">Python之psutil</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/02-ospf/"" data-c="
          &lt;p&gt;OSPF，开放式最短路径优先算法，SPF算法：迪杰科斯特拉算法，工作在IP层，协议号89&lt;/p&gt;
&lt;h1 id=&#34;基本特点&#34;&gt;基本特点&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;收敛速度比较快（相对RIP快些，在IGP协议中，收敛最快的为EIGRP协议）&lt;/li&gt;
&lt;li&gt;无类路由协议，VLSM(可变长子网掩码，由小变大)和CIDR(无类别域间路由，由大变小)&lt;/li&gt;
&lt;li&gt;OSPF支持负载均衡&lt;/li&gt;
&lt;li&gt;支持区域划分，提供分级管理，使得SPF的算法更优，算法使用频率更低，节约了链路状态数据库，降低了路由的开销。【只有区域0为骨干区域，OSPF要求所有非骨干区域都要和骨干区域(即area0)连接】&lt;/li&gt;
&lt;li&gt;OSPF支持3种认证：0是不认证，1是明文认证，2是MD5认证&lt;/li&gt;
&lt;li&gt;支持触发更新（不仅防环，还能更快的收敛）&lt;/li&gt;
&lt;li&gt;OSPF的路由优先级10（内部，OSPF自身产生的）和150（外部，从其他协议引入的）&lt;/li&gt;
&lt;li&gt;OSPF的度量值采用开销cost作为标准（RIP使用跳数选路，容易产生次优路径）&lt;/li&gt;
&lt;li&gt;OSPF要维护3张表：邻居表、拓扑表、路由表【配置好OSPF之后，设备之间先泛洪LSA构建&lt;strong&gt;邻居表&lt;/strong&gt;，相互交换信息之后构建数据库LSDB，运行SPF算法形成&lt;strong&gt;路由表&lt;/strong&gt;】&lt;/li&gt;
&lt;li&gt;OSPF采用组播【组播地址：224.0.0.5(所有设备监听)和224.0.0.6(仅DR和BDR监听)】的方式来收发报文，可以减少对没有运行OSPF设备的干扰（RIP的组播地址：224.0.0.9，EIGRP的组播地址：224.0.0.10）&lt;/li&gt;
&lt;li&gt;OSPF为了确保链路状态数据库的同步，每1800秒（30分钟）更新一次&lt;/li&gt;
&lt;li&gt;OSPF是没有环路的协议，但仅限于一个区域内，在一个区域内是绝对无环的，基于算法的天然无环。OSPF在区域内是链路状态协议，在区域间是距离矢量协议算法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;概念术语&#34;&gt;概念术语&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;链路：OSPF路由器的一个接口&lt;/li&gt;
&lt;li&gt;链路状态：各条链路的状态信息，例如接口的IP地址、开销等等&lt;/li&gt;
&lt;li&gt;区域：同一组路由器组成，共享共同的信息&lt;/li&gt;
&lt;li&gt;自制系统：一个自制系统是指使用同一种路由协议交换路由信息的一组路由器&lt;/li&gt;
&lt;li&gt;LSA（链路状态通告）和LSU（链路状态更新）&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;LSA：用来描述路由器的信息和链路的状态&lt;/li&gt;
&lt;li&gt;LSU：可以包含一个或者多个LSA，通过LSA给邻居&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;SPF算法：迪杰科斯特拉算法，和ISIS使用同种算法&lt;/li&gt;
&lt;li&gt;邻居（Neighbor）关系和邻接（Adjacency）关系&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;邻居关系：两台设备共享同一条链路，并且交互了一些参数（hello报文），形成邻居关系（2-way状态）【有端口连接到同一个网段的两个路由器就是邻居路由器，邻居关系由OSPF的Hello协议维护（女朋友）】&lt;/li&gt;
&lt;li&gt;邻接关系：相互交换LSA同步数据库的OSPF设备【从邻居关系中选出的为了交换路由信息而形成的关系（领证了）】&lt;br&gt;
&lt;code&gt;邻居是形成邻接关系的必要条件&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;DR（指定路由器）和BDR（备份指定路由器）&lt;/li&gt;
&lt;li&gt;Router ID，用来标识运行OSPF的设备，是一个类IP地址。每一个路由器必须要有一个RouterID，如果没有手工指定，会自动选举，选举规则为【比较逻辑接口，选择地址最大的一个；如果没有逻辑接口，比较激活的物理接口IP，选择地址最大的。如果修改RouterID，不会立即生效，需要重启OSPF进程&lt;code&gt;reset ospf process&lt;/code&gt;或者设备】&lt;br&gt;
配置方法：进程下配置(进程下配置的优先于全局的)&lt;code&gt;ospf 10 router-id 2.2.2.2&lt;/code&gt;或者全局下配置(各进程会自动调用)&lt;code&gt;router-id 1.1.1.1&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ospf路由器的分类&#34;&gt;OSPF路由器的分类&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;内部路由器（IR）&lt;/strong&gt;：内部路由器是指所有所连接的网段都在一个区域的路由器，属于同一个区域的IR维护相同的LSDB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区域边界路由器（ABR）&lt;/strong&gt;：区域边界路由器是指连接到多个区域的路由器，ABR为每一个所连接的区域维护一个LSDB，连接&lt;strong&gt;骨干区域和非骨干区域&lt;/strong&gt;的设备。【位于一个或多个OSPF区域边界上、将这些区域连接到主干网络的路由器。&lt;strong&gt;ABR被认为同时是OSPF主干和相连区域的成员，可以同时属于两个以上的区域&lt;/strong&gt;，但&lt;strong&gt;其中一个必须是骨干区域&lt;/strong&gt;（area 0）。因此，它们&lt;strong&gt;同时维护着描述主干拓扑和其他区域拓扑的路由选择表&lt;/strong&gt;。】&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;骨干路由器（BR)&lt;/strong&gt;：骨干路由器是指至少有一个端口（或者虚连接）连接到骨干区域的路由器，包括所有的ABR和所有端口都在骨干区域的路由器&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AS边界路由器ASBR&lt;/strong&gt;：和其他AS中的路由器交换路由信息的路由器，这种路由器向整个AS通告AS外部路由信息。AS边界路由器可以是内部路由器IR，或者是ABR，可以属于骨干区域也可以不属于骨干区域。【与其他AS交换路由信息的路由器称为ASBR，使用了多种路由协议。它位于OSPF自主系统和非OSPF网络之间。ASBR可以运行OSPF和另一路由选择协议（如RIP），把OSPF上的路由发布到其他路由协议上。只要一台OSPF路由器引入了外部路由的信息，它就成为了ASBR。&lt;strong&gt;ASBR必须处于非存根OSPF区域中&lt;/strong&gt;。&lt;strong&gt;由ASBR发出的LSA5，用于向自治系统区域通告网络拓扑&lt;/strong&gt;。&lt;strong&gt;ABSR一般是位于非OSPF区域和OSPF区域间互联的路由器，而ABR是OSPF多个区域连接区域0间的路由器&lt;/strong&gt;。】&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;ospf报文&#34;&gt;OSPF报文&lt;/h1&gt;
&lt;h2 id=&#34;报文头部&#34;&gt;报文头部&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587202960222.png&#34; alt=&#34;OSPF报文头部&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如何验证OSPF报文头部是否合法？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.版本号必须为2&lt;br&gt;
2.Area ID必须要和接收端的Area ID一致&lt;br&gt;
3.认证类型和认证密码必须一致&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;RouterID不能冲突&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;报文分类&#34;&gt;报文分类&lt;/h2&gt;
&lt;h3 id=&#34;hellohello-packet&#34;&gt;Hello（Hello Packet）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;（刚进饭店，服务员打招呼）周期性的发送，用来发现、建立和维护OSPF的邻居关系，报文内容包括一些定时器的数值、DR、BDR以及自己已知的邻居&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587204145080.png&#34; alt=&#34;OSPF-hello&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;静默端口（silent-interface）既不接收hello报文，也不发送hello报文&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Network Mask：&lt;br&gt;
发送Hello报文的接口的网络掩码，只有在广播网络或者NBMA网络才有意义（在P2P和P2MP链路上是不检测的）&lt;/li&gt;
&lt;li&gt;HelloInterval：&lt;br&gt;
发送Hello报文的时间间隔，单位为秒，在广播网络中是10秒一次，在NBMA中是30秒一次&lt;code&gt;修改hello时间：进入接口视图执行ospf timer hello 5，相应的RouterDeadInterval时间也会修改为20秒&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Options：&lt;br&gt;
标识发送此报文的OSPF路由器所支持的可选功能，具体的可选功能不在本课程的讨论范围之列
&lt;ul&gt;
&lt;li&gt;DN位：Down比特位，是用来防环的（MPLS VPN应用）&lt;/li&gt;
&lt;li&gt;O位：用来支持9、10、11类LSA的能力&lt;/li&gt;
&lt;li&gt;DC位：当始发链路支持按需链路时该比特位会置位&lt;/li&gt;
&lt;li&gt;N位：N位表明是否支持7类LSA，N=0表明不接收和发送7类LSA&lt;/li&gt;
&lt;li&gt;P位：用在NSSA LSA（7类LSA），是否做7类转成5类&lt;/li&gt;
&lt;li&gt;E位：能否接收外部路由（5类LSA），默认E位是1，是可以接收外部路由&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Rtr Pri：&lt;br&gt;
发送Hello报文的接口的Router Priority，路由的优先级，用来选举DR和BDR的&lt;/li&gt;
&lt;li&gt;RouterDeadInterval：&lt;br&gt;
宣告邻居路由器不继续在该网段上运行OSPF的时间间隔，单位为秒，通常为4倍HelloInterval，即在广播网络中是40秒，在NBMA中是120秒&lt;code&gt;修改死亡时间：进入接口视图后执行ospf timer dead 80，此时不会影响hello时间，即hello时间影响dead时间，但是dead时间不影响hello时间&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Designated Router：&lt;br&gt;
发送Hello报文的路由器所选举出的&lt;strong&gt;DR接口的IP地址&lt;/strong&gt;。如果设置为0.0.0.0，表示未选举DR路由器。&lt;/li&gt;
&lt;li&gt;Backup Designated Router：&lt;br&gt;
发送Hello报文的路由器所选举出的BDR的IP地址。如果设置为0.0.0.0，表示未选举BDR路由器。&lt;/li&gt;
&lt;li&gt;Neighbor：邻居路由器的Router ID列表，表示本路由器已经从该邻居收到合法的Hello报文，邻居路由器的Rtouer ID（表明OSPF的邻居状态）&lt;br&gt;
&lt;code&gt;同一个区域内的路由器上的ospf的hello时间和dead时间必须一致，否则无法启动&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;验证一个Hello报文是否合法之前首先需要验证一个OSPF报文是否合法。&lt;br&gt;
验证一个接收到的Hello报文是否合法包括：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果接收端口的网络类型是广播型，点到多点或者NBMA，所接收的Hello报文中Network Mask字段必须和接收端口的网络掩码一致，如果接收端口的网络类型为点到点类型或者是虚连接，则不检查Network Mask字段；&lt;/li&gt;
&lt;li&gt;所接收的Hello报文中的HelloInterval字段必须和接收端口的配置保持一致；&lt;/li&gt;
&lt;li&gt;所接收的Hello报文中的RouterDeadInterval字段必须和接收端口的配置保持一致；&lt;/li&gt;
&lt;li&gt;所接收的Hello报文中的Options字段中的E位（表示是否接收外部路由信息）必须和相关区域的配置保持一致。关于此比特的具体意义将在《OSPF特殊区域》中详细解释。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;邻居状态机&#34;&gt;邻居状态机&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587217625536.png&#34; alt=&#34;ospf-邻居状态机&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h5 id=&#34;down&#34;&gt;Down&lt;/h5&gt;
&lt;p&gt;这是邻居的初始状态，表示没有从邻居收到任何信息或者邻居失效后变为该状态。在NBMA网络上，此状态下仍然可以向静态配置的邻居发送Hello报文，发送间隔为PollInterval，通常和RouterDeadInterval间隔相同。&lt;/p&gt;
&lt;h5 id=&#34;attempt&#34;&gt;Attempt&lt;/h5&gt;
&lt;p&gt;此状态只在NBMA网络上存在，表示没有收到邻居的任何信息，但是已经周期性的向邻居发送报文，发送间隔为HelloInterval。如果RouterDeadInterval间隔内未收到邻居的Hello报文，则转为Down状态。&lt;/p&gt;
&lt;h5 id=&#34;init&#34;&gt;Init&lt;/h5&gt;
&lt;p&gt;在此状态下，路由器已经从邻居收到了Hello报文，但是自己不在所收到的Hello报文的邻居列表中，表示尚未与邻居建立双向通信关系。在此状态下的邻居要被包含在自己所发送的Hello报文的邻居列表中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1-WayReceived&lt;br&gt;
此事件表示路由器发现自己没有在邻居发送Hello报文的邻居列表中，通常是由于对端邻居重启造成的。&lt;/li&gt;
&lt;li&gt;2-WayReceived&lt;br&gt;
此事件表示路由器发现与邻居的双向通信已经开始（发现自己在邻居发送的Hello报文的邻居列表中）。Init状态下产生此事件之后，如果需要和邻居建立邻接关系则&lt;strong&gt;进入ExStart状态&lt;/strong&gt;，开始&lt;strong&gt;数据库同步&lt;/strong&gt;过程，如果不能与邻居建立邻接关系则进入&lt;strong&gt;2-Way&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;成为邻居的6个条件：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.RID不同&lt;br&gt;
2.特殊区域的flag字段相同&lt;br&gt;
3.子网掩码相同&lt;br&gt;
4.验证相同&lt;br&gt;
5.区域号相同&lt;br&gt;
6.hello/dead相同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;2-way&#34;&gt;2-Way&lt;/h5&gt;
&lt;p&gt;在此状态下，双向通信已经建立，但是没有与邻居建立邻接关系。&lt;strong&gt;这是建立邻接关系以前的最高级状态。DR和BDR是从达到2-way或者更高状态的邻居中选举出来的，即此状态是选举DR和BDR的开始（选举周期为40秒，选举期之后没有抢占性）&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;两端同时进入2-way标志着邻居关系的建立，进入2-way后，要建立邻接关系（Full）的情况如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;接口类型为p2p（点到点），p2MP（点到多）&lt;/li&gt;
&lt;li&gt;自己为DR，或者为BDR&lt;/li&gt;
&lt;li&gt;邻居为DR，或BDR&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;2-way状态（邻居关系）建立&lt;/strong&gt;的过程：&lt;code&gt;RTA和RTB的Router ID分别为1.1.1.1和2.2.2.2&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;RTA启动OSPF后，RTA会发送第一个Hello报文（以组播的方式发送，目的地址为224.0.0.5），此时状态为Down，&lt;code&gt;需要注意的是，首次发送hello报文的时候不包含邻居字段，报文长度为44&lt;/code&gt;。RTB收到RTA的Hello报文后，状态置为init。&lt;/li&gt;
&lt;li&gt;RTB发送Hello报文，RTA收到RTB发送的报文之后，状态为Init。&lt;/li&gt;
&lt;li&gt;RTB向RTA发送&lt;strong&gt;邻居列表为1.1.1.1&lt;/strong&gt;的Hello报文，Hello报文发送三个周期（也有超过3个周期），RTA在收到RTB发来的报文邻居列表中发现自己的Router ID，而且&lt;strong&gt;匹配6个条件&lt;/strong&gt;（建立邻居的6个条件）成功之后，状态为2-way，也称为邻居状态。&lt;/li&gt;
&lt;li&gt;RTA向RTB发送&lt;strong&gt;邻居列表为2.2.2.2&lt;/strong&gt;的hello报文，Hello报文发送三个周期（也有超过3个周期），RTB在收到hello报文邻居列表中发现自己的Router ID，而且匹配6个条件（建立邻居的6个条件）成功之后， 状态置为2-way，也称为邻居状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;DR和BDR的作用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;减少邻接关系的数量，从而减少链路状态信息以及路由信息的交换次数，这样可以节省带宽，减少路由器硬件的负担。&lt;/li&gt;
&lt;li&gt;一个既不是DR也不是BDR的路由器只与DR和BDR形成邻接关系并交换链路状态信息以及路由信息，这样就大大减少了大型广播型网络和NBMA网络中的邻接关系数量&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;DR和BDR的选举规则：&lt;code&gt;两端同时进入2-way，开始选举&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首先检查Hello报文中的DR字段和BDR字段是否为空，如果都为空（意味着没有DR和BDR），会&lt;strong&gt;首先选举出BDR&lt;/strong&gt;，&lt;strong&gt;选举规则&lt;/strong&gt;：比较优先级，越大越优（默认为1，取置范围为0-255，  0表示不参与选举），如果相同，比较Router ID，越大越优；&lt;strong&gt;BDR选举出后，会自动升级为DR，然后重新选举BDR，规则和之前一样&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果DR字段为空，BDR不为空，则BDR升级为DR，重新再选举出BDR；如果BDR为空，DR不为空，重新选举出BDR&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;exstart&#34;&gt;Exstart&lt;/h5&gt;
&lt;p&gt;交换信息的初始化状态。发送DBD（包含本地的LSA的摘要信息）报文，选举主从路由器，并确定初始的DBD序号，达到此状态或者更高状态的邻居才能称为邻接&lt;code&gt;发送第一个DBD报文，由2-way转成Exstart&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;exchange&#34;&gt;Exchange&lt;/h5&gt;
&lt;p&gt;交换信息的状态。该状态下，相互间发送DBD，告知对端本地所有的LSA的目录；同时，可以发送	LSR,LSU,LSACK来学习对端的LSA&lt;code&gt;主从选举完毕之后，由Exstart转换成Exchange&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;loading&#34;&gt;Loading&lt;/h5&gt;
&lt;p&gt;加载状态（没有学习完的状态）。发送LSR,LSU,LSACK，专门学习对端的LSA的详细信息&lt;code&gt;当DBD报文中的M=0时，由Exchange转成Loading&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;full&#34;&gt;Full&lt;/h5&gt;
&lt;p&gt;邻接状态（学习完的状态）。彼此的LSDB同步，即所有的LSA相同&lt;code&gt;重传列表为空，由Loading转成Full&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;dbddatabase-description-packet数据库描述报文&#34;&gt;DBD（Database Description Packet,数据库描述报文）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;（服务员给的菜单）描述本地LSDB的摘要信息，用于两台路由器进行数据库的同步。DBD报文只是一个LSA（LSDB）的摘要信息，里边不包括LSA。报文内容包括LSDB中每一条LSA的Header（LSA的Header可以唯一标识一条LSA）。LSA Header只占一条LSA的整个数据量的一小部分，这样可以减少路由器之间的协议报文流量，对端路由器根据LSA Header就可以判断出是否已有这条LSA。在两台路由器交换DD报文的过程中，一台为Master，另一台为Slave。由Master规定起始序列号，每发送一个DD报文序列号加1，Slave方使用Master的序列号作为确认。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587286604710.png&#34; alt=&#34;OSPF-DBD&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.51cto.com/juispan/2049562&#34;&gt;前两个DBD报文是空报文，用来选举主从。详细邻接关系建立，可以参考本链接&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;OSPF的两种确认机制&lt;/strong&gt;：1.显式确认-LSA、LSU、LSAck；2.隐式确认&lt;br&gt;
&lt;code&gt;DR和BDR的选举和主从选举没有任何关系。DR和BDR选举看优先级，主要是同步数据库；主从选举看RouteID，主要是做一个隐式确认。&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;主从选举以及数据交互过程简述（从Exstart开始到Exchange结束）&lt;/strong&gt;：&lt;code&gt;RTA和RTB的Router ID分别为1.1.1.1和2.2.2.2&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;A-&amp;gt;B：seq=x，I=1，M=1，MS=1（空报文）。A变为Exstart状态。&lt;/li&gt;
&lt;li&gt;B-&amp;gt;A：seq=y，I=1，M=1，MS=1（空报文）。B变为Exstart状态。此时已经通过RouterID确认了主从，主为B，从为A&lt;/li&gt;
&lt;li&gt;A-&amp;gt;B：&lt;strong&gt;seq=y&lt;/strong&gt;，I=0，M=1，MS=0。当OSPF接口收到一个DBD包且其中I=0的时候，它就知道与该邻居的exstart阶段已经过去了，于是将邻居的状态置为exchange。&lt;strong&gt;从没有权利修改seq，只能使用主的seq，表示确认收到主的发送的那个seq&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;B-&amp;gt;A：seq=y+1，I=0，M=1，MS=1。AB通过DBD的交互，了解到对方OSPF DB中的摘要情况。在这个过程中，可能交互数个DBD报文，这些报文的I位都置0，且M位一般置1，除非这是某个OSPF接口发送的最后一个DBD包。&lt;br&gt;
....（多个DBD报文）&lt;/li&gt;
&lt;li&gt;B-&amp;gt;A：seq=y+n，I=0，M=0，MS=1。当Ａ收到一个M位置0的DBD包的时候，它就知道，这是邻居B发来的最后一个DBD包了，如果它搜集完这个邻居B发来的DBD并且发现这些DBD里有它感兴趣的LSA，它期望更详细的LSA信息时，它将B置为&lt;strong&gt;Loading状态&lt;/strong&gt;，并且开始发送LSR报文去请求特定LSA的详细信息。&lt;/li&gt;
&lt;li&gt;A-&amp;gt;B：seq=y+n，I=0，M=0，MS=0。&lt;/li&gt;
&lt;li&gt;A-&amp;gt;B：LSR。（&lt;strong&gt;Loading到Full状态的转换&lt;/strong&gt;）B收到这个LSR后，会以LSU进行回应，其中就包含了对方请求的LSA详细信息，因此，只有在LSU报文中，才能看到LSA的完整信息&lt;/li&gt;
&lt;li&gt;B-&amp;gt;A：LSU。&lt;/li&gt;
&lt;li&gt;A-&amp;gt;B：LSAck。收到LSU后，A将LSU中所包含的LSA放进自己的LSDB，并且给B发一个LSAck进行确认。当OSPF接口上所有的待请求的LSA全部收到更新后，它会将邻居置为Full状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;MTU对邻接关系建立的影响&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;MTU在DBD报文中携带，所以&lt;strong&gt;MTU不一致不会影响OSPF邻居关系的建立&lt;/strong&gt;，但是会&lt;strong&gt;影响邻接的建立&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;思科设备默认是检测MTU的。华为设备默认是不检测MTU的，华为可以通过命令配置检测，如果MTU不一致，会进入什么状态&lt;br&gt;
2.1 如果主的MTU大于从的MTU，两端会同时卡在Exstart状态。&lt;code&gt;【假设AR1的MTU1400，AR2的为1500】原因：AR1发送一个DBD（1400，MS=1），状态由2-way转换成Exstart，同时，AR2也会发送一个DBD（1500，MS=1），状态由2-way转换成Exstart；由于AR2的MTU大于AR1的MTU，AR1无法接受AR2的DBD报文，AR1不知道谁是主（AR1自己认为自己是主），AR2这个主也得不到AR1的确认(即AR2收不到 与自己发出的那个报文相同seq 的 AR1发出的确认报文)，即无法进行主从选举，导致卡在Exstart状态&lt;/code&gt;&lt;br&gt;
2.2 如果主的MTU小于从的MTU，从会进入Exchange，主会卡在extart状态。&lt;code&gt;【假设AR1的MTU1400，AR2的为1300】原因：AR2发送一个DBD（1300，MS=1），状态由2-way转换成Exstart，同时，AR1发送一个DBD（1400，MS=1），状态由2-way转换成Exstart；由于AR1的MTU比AR2的MTU大，从而可以正常接收AR2的报文，知道AR2是主，则AR1的状态由Exstart转为Exchange；AR1发送第二个DBD报文（MS=0），这个报文AR2无法正常接收，导致状态仍然为Exstart&lt;/code&gt;&lt;br&gt;
2.3 如果忽略MTU检测（MTU不一致），&lt;strong&gt;路由条目多的情况下，有可能会卡在Loading状态；如果路由条目比较少，报文长度没有超过MTU，则可以达到full状态&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;ospf的接口状态机&#34;&gt;OSPF的接口状态机&lt;/h4&gt;
&lt;h5 id=&#34;loopback&#34;&gt;Loopback&lt;/h5&gt;
&lt;p&gt;这时，路由器到网络的接口处于回环Loopback，回环可能以硬件或软件的方式实现。回环接口不能用于正常的数据传输，但仍能通过ICMP ping或位错误检测来收集接口信息。IP包仍需要被发往回环接口。为此，要在Router-LSA中宣告此接口为接口IP地址的主机路径。&lt;/p&gt;
&lt;h5 id=&#34;down-2&#34;&gt;Down&lt;/h5&gt;
&lt;p&gt;这是接口的初始状态，这时下层协议指出接口为断开，接口上没有协议流量的收发。这时，接口上的所有参数都被设为初始值，关闭所有的接口记时器，该接口上也没有相关联的邻接。&lt;/p&gt;
&lt;h5 id=&#34;point-to-point&#34;&gt;Point-to-Point&lt;/h5&gt;
&lt;p&gt;这时，连接到物理点对点网络或虚拟通道的接口开始工作。进入此状态之后，路由器试图与邻居路由器形成邻接。并按HelloInterval的间隔发送Hello包。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587310643544.png&#34; alt=&#34;端口状态转换--p2p、p2mp或虚连接&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h5 id=&#34;waiting&#34;&gt;Waiting&lt;/h5&gt;
&lt;p&gt;在此状态时，路由器试图判定网络上DR和BDR。为此，路由器对其接收到的Hello包进行监听。在结束等待前，路由器不能被选举为DR或BDR。这可以避免不必要地改变DR和BDR。&lt;/p&gt;
&lt;h5 id=&#34;drother&#34;&gt;DROther&lt;/h5&gt;
&lt;p&gt;广播或NBMA网络上的其他路由器被选举为DR，其自身也没有被选为BDR。路由器开始与DR和BDR（如果存在的话）形成邻接。&lt;/p&gt;
&lt;h5 id=&#34;bdr&#34;&gt;BDR&lt;/h5&gt;
&lt;p&gt;在此状态时，路由器是所接入网络的BDR。并将在当前的DR失效时成为DR。该路由器与接入该网络的所有其他路由器形成邻接。在洪泛过程中，BDR的工作与DR稍有不同。&lt;/p&gt;
&lt;h5 id=&#34;dr&#34;&gt;DR&lt;/h5&gt;
&lt;p&gt;在此状态时，路由器是所接入网络的DR。该路由器与接入该网络的所有其他路由器形成邻接。路由器必须为网络节点生成一个Network-LSA。该Network-LSA包含了所有接入该网络的路由器（包括DR自身）。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587310689309.png&#34; alt=&#34;端口状态转换-广播或NBMA网络&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;ospf支持的网络类型&#34;&gt;OSPF支持的网络类型&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;P2P网络（只把两台路由器直接相连的网络，例如运行PPP的64K串行线路就是一个点到点网络&lt;strong&gt;不需要选举DR和BDR，hello时间10s，dead时间40s，5种报文全部组播&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;Broadcast网络（支持两台以上路由器，并且具有广播能力的网络，例如含有四台路由器的以太网&lt;strong&gt;需要选举DR和BDR，hello时间10s，dead时间40s，hello报文组播、DBD和LSR是单播、LSU和LSAck有单播也有组播&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;NBMA网络（例如使用SVC进行通信的ATM网络【全连接ATM网络】，&lt;strong&gt;需要选举DR和BDR，hello时间30s，dead时间120s，5种报文均是单播&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;P2MP网络（&lt;strong&gt;不需要选举DR和BDR，hello时间30s，dead时间120s，hello报文组播、其他报文全是单播&lt;/strong&gt;））&lt;/li&gt;
&lt;li&gt;虚链接（【注意事项：虚连接不能配置在骨干区域(Area0)和末节区域(实验中的Area20)，不能跨越多个区域】）&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;网络类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Hello时间&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;dead时间&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Hello报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;DBD报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSR报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSU报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSACK报文&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;是否选举DR/BDR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NBMA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P2MP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;30&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;120&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;P2P&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不需要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Broadcast&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;40&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播/组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;单播/组播&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;需要&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;不同的网络类型之间是否可以建立邻接关系？是否有路由？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;P2P与Broadcast&lt;/strong&gt;：可以建立邻接关系，但是没有路由。&lt;strong&gt;原因&lt;/strong&gt;：P2P没有DR和BDR，即没有二类LSA，导致Broadcast无法识别相应报文&lt;br&gt;
&lt;strong&gt;P2MP与Broadcast&lt;/strong&gt;：因为hello时间不相同，无法建立邻居关系。如果将P2MP的hello时间修改为10s,可以建立邻接关系，但是没有路由。&lt;strong&gt;原因同上&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;NBMA和Broadcast&lt;/strong&gt;：因为hello时间不相同，无法建立邻居关系。即使修改hello时间也无法建立邻接关系。&lt;strong&gt;原因&lt;/strong&gt;：NBMA的hello报文为单播，Broadcast的hello报文为组播&lt;br&gt;
&lt;strong&gt;P2P和P2MP&lt;/strong&gt;：因为hello时间不相同，无法建立邻居关系。修改P2MP的hello时间为10s之后可以建立邻接关系并且&lt;strong&gt;有路由&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;常见的链路层类型对应的默认网络类型&#34;&gt;常见的链路层类型对应的默认网络类型&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;网络类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;常见链路层协议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Point-to-point&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PPP链路、LAPB链路、HDLC链路&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Broadcast&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以太网链路&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NBMA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;帧中继链路、ATM链路&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;lsrlink-state-request链路状态请求&#34;&gt;LSR（Link State Request,链路状态请求）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;（看菜单点菜）用于向对方请求所需的LSA，只有在OSPF邻居双方成功交换了DBD后才会向对方发送LSR。两台路由器互相交换过DD报文之后，知道对端的路由器有哪些LSA是本地的LSDB所缺少的和哪些LSA是已经失效的，这时需要发送LSR报文向对方请求所需的LSA。内容包括所需要的LSA的摘要，其中&lt;strong&gt;LS type、Link State ID和Advertising Router可以唯一标识出一个LSA&lt;/strong&gt;，当两个LSA一样时，需要根据LSA中的LS sequence number、LS checksum和LS age来判断出所需要LSA的新旧。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311400960.png&#34; alt=&#34;OSPF-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;OSPF的LSA每1800秒更新一次，如果3600秒没有收到更新，则认为失效（老化）；OSPF不能删除非自身产生的LSA&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;什么情况下更新LSA？&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;1800秒更新一次&lt;/li&gt;
&lt;li&gt;触发更新（接口地址、开销值等发生变化）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;lsulink-state-update链路状态更新&#34;&gt;LSU（Link State Update,链路状态更新）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;（服务员上菜）用于向对方回复具体的LSR。用来向对端Router发送其所需要的LSA或者泛洪自己更新的LSA，内容是多条LSA（全部内容）的集合。LSU报文在支持组播和广播的链路上是以组播形式将LSA泛洪出去。为了实现泛洪的可靠性传输，需要LSAck报文对其进行确认。对没有收到确认报文的LSA进行重传，重传的LSA是直接发送到邻居的。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311547987.png&#34; alt=&#34;OSPF-LSU&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;lsa的头部和5种报文&#34;&gt;LSA的头部和5种报文&lt;/h4&gt;
&lt;h5 id=&#34;lsa相同的头部&#34;&gt;LSA相同的头部&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311683821.png&#34; alt=&#34;OSPF-LSAHead&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;LAS的序列号（LS Sequence Number）:32位有符号整数，用于检测过期和重复的LSA。数值0x80000000（过渡使用，从0x7FFFFFFF到0x80000001的过渡），也就是 -2^31 是最小的数值，但此数值被保留，可用的最小数值为0x80000001(初始序号，-2^31+1 )，每次更新该LSA，序列号+1，序列号越大则该LSA越新，最大为0x7FFFFFFF，达到最大值之后，，必须先将当前LSA从路由域中废止（LSA提前老化），然后重新泛洪，当所有邻接的邻居收到确认后，重新从0x80000001开始。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;LSA的新旧比较&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;先比较LSA的序列号，越大越新&lt;/li&gt;
&lt;li&gt;LSA的序列号相同情况下，比较校验值（Checksum）,越大越新&lt;/li&gt;
&lt;li&gt;LSA的序列号、校验值均相同的情况下，比较LSA的Age是否等于Max-age时间3600，相等则最新&lt;/li&gt;
&lt;li&gt;LSA的序列号、校验值均相同的情况下，LSA的Age不等于3600，会比较age与3600之间的差值，如果差值大于900（即15分钟），越小月新&lt;/li&gt;
&lt;li&gt;LSA的序列号、校验值均相同的情况下，LSA的Age不等于3600，且age与3600之间的差值小于900，则会认为是同一条LSA，忽略其中一条&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;router-lsatype1&#34;&gt;Router-LSA（Type1）&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;每个路由器都会产生&lt;/strong&gt;，描述了路由器的&lt;strong&gt;链路状态和开销&lt;/strong&gt;，&lt;strong&gt;只在所属的区域内泛洪&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311744247.png&#34; alt=&#34;OSPF-Router-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OSPF选路依据？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;OSPF依据Metric(即Cost)来进行选路，参考带宽为100Mb/s，Metric的参考值为10^8/带宽（100M/接口带宽），即56kb/s的串口为1785、64kb/s的串口为1562、2.048Mb/s的E1为48、100Mb/s的Ethernet为1。【注意】1000Mb/s以上的Metric均为1，为了能够在100Mb/s以上的接口上实现负载分担，则需要进行参考带宽的调整，命令如下：ospf 10   &amp;amp;&amp;amp;   bandwidth-reference 1000，此数据需要在实施OSPF的每个设备上都修改，单位是Mbits/s。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;OSPF的网段类型&lt;br&gt;
LSDB通过描述一个有向线段图来描述网络拓扑结构，该有向图的端点有三种类型：&lt;strong&gt;路由器节点、Stub网段、Transit网段&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Stub网段（末节网络）：该网段只有数据入口，例如y几个Loopback接口就是一个Stub网段。&lt;/li&gt;
&lt;li&gt;Transit网段：有至少两台路由器的广播型网段或NBMA网段就是一种Transit网段。从一个Transit网段到连接到这个网段的路由器的开销为0&lt;/li&gt;
&lt;li&gt;点到点网段：两个接口处于不同网段时，两台路由器经由两条有向线段相连，两个接口的网段被表示成stub网段，每个路由器通告一个stub连接到该路由器所连得网段；两个接口处于同一网段时，两台路由器经由两条有向线段相连，每个方向一条，连接两个接口的网段被表示成stub网段，两个路由器同时通告stub连接到该PPP网段&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587562873173.png&#34; alt=&#34;stub&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587562882311.png&#34; alt=&#34;transit&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587563373174.png&#34; alt=&#34;点到点&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一类&lt;/strong&gt;LSA支持的&lt;strong&gt;四种链路&lt;/strong&gt;类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Point-to-Point&lt;/strong&gt;：描述一个从本路由器到邻居路由器之间的点到点链接&lt;br&gt;
&lt;strong&gt;TransNet&lt;/strong&gt;：描述一个从本路由器到一个Transit网段（例如广播型网段或者NBMA网段）的链接&lt;br&gt;
&lt;strong&gt;StubNet&lt;/strong&gt;：描述一个从本路由器到一个Stub网段（例如Loopback接口）的链接&lt;br&gt;
&lt;strong&gt;Virtual&lt;/strong&gt;：表示这是一个从本路由器到虚连接对端ABR的链接，&lt;strong&gt;虚连接是属于骨干区域的一条虚拟路由，且虚连接不能跨区域建立&lt;/strong&gt;【虚连接不能在骨干区域、stubnet和NSSA上配置，虚连接只能在ABR上配置】&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;虚连接的应用场景：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.解决非骨干区域没有连接到骨干区域的问题&lt;br&gt;
2.解决骨干区域被分割的问题&lt;br&gt;
3.解决没有骨干区域的场景（可以建立虚连接充当骨干区域，即虚连接相当于骨干区域，只有华为设备可以，思科设备不支持）&lt;br&gt;
4.保障骨干区域的健壮性（预防骨干区域被分割或者ABR只接受三类LSA不选路的问题）&lt;br&gt;
5.解决次优路径问题（三类LSA的优先级低于一类LSA，即内部OSPF优先级(AR19)&amp;gt;外部OSPF优先级(AR18)）**&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587830850069.png&#34; alt=&#34;虚连接应用场景&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;虚连接的缺点&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;容易产生环路&lt;/li&gt;
&lt;li&gt;不能做汇总&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587917548285.png&#34; alt=&#34;虚连接--环路&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;虚连接的远端地址：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚连接的两个端点需要相互交换协议报文，但是虚连接的邻居是用Router ID来标识的，不能作为协议报文的目的IP地址。每个虚连接的端点都要计算两个最短路径树，一个是本地最短路径树，另一个是虚连接邻居的最短路径树。计算虚连接邻居的最短路径树之后，在最短路径树上查找如何到达本地路由器（通过Router ID来标识），虚连接邻居到达本地路由器的出端口的IP地址为本地路由器发送给虚连接诶邻居的协议报文目的IP地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;广播类型的接口的链路类型是transnet，环回口链路类型是stubnet，点到点链会生成p2p和stubnet两种类型。OPSF是先计算p2p和transnet，再计算stubnet&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Type&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Link ID&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Link Data&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Point-to-point&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;邻居的Router ID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该网段上本地接口的IP地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;TransNet&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DR的接口IP地址&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该网段上本地接口的IP地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;StubNet&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该Stub网段的IP网络地址&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;该Stub网段的网络掩码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Virtual&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;虚连接邻居的Router ID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;去往该虚连接邻居的本地接口的IP地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id=&#34;network-lsatype2&#34;&gt;Network-LSA（Type2）&lt;/h5&gt;
&lt;p&gt;由&lt;strong&gt;广播网或NBMA网络中的DR&lt;/strong&gt;产生，Network-LSA中记录了这一网络上&lt;strong&gt;所有路由器的Router ID和该网络的掩码&lt;/strong&gt;，描述本网段的&lt;strong&gt;链路状态&lt;/strong&gt;，&lt;strong&gt;在所属的区域内传播&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587311827323.png&#34; alt=&#34;OSPF-Network-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;计算过程的两个阶段&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;计算transit和p2p节点，忽略stub节点，生成一个最短路径树，即构建SPF树。依据Router-LSA和Network-LSA。&lt;/li&gt;
&lt;li&gt;只计算stub节点，将stub网段挂到最短路径树上去，即计算最优路由。依据SPF树干和Router-LSA、Network-LSA中的路由信息&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;计算的详细过程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;第一阶段&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;AR1：（dis lsdb router 1.1.1.1）最短路径树-1.1.1.1（0）；候选列表（p2p）-2.2.2.2（48）、4.4.4.4-1562。对比候选列表之后，将2.2.2.2放入最短路径树，形成最短路径树-1.1.1.1（0）、2.2.2.2（48）。&lt;img src=&#34;https://fqj-web.github.io/post-images/1587708294300.png&#34; alt=&#34;1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
查看到2.2.2.2所有路由（dis lsdb router 2.2.2.2），查找不在最短路径树中metric最小的放入最短路径树，形成最短路径树-1.1.1.1（0）、2.2.2.2（48）、10.3.1.3（48+1）&lt;img src=&#34;https://fqj-web.github.io/post-images/1587708929509.png&#34; alt=&#34;2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由于10.3.1.3是广播类型，需要查看其邻居（即查看二类LSA，dis ospf lsdb network 10.3.1.3），其中2.2.2.2已经包含在最短路径树中，只需要考虑3.3.3.3和4.4.4.4，由于到达10.3.1.3的开销值为49，即到达10.3.1.0/24这个网络的开销值为49，所以到达3.3.3.3和4.4.4.4的开销值为49&lt;img src=&#34;https://fqj-web.github.io/post-images/1587709532658.png&#34; alt=&#34;3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
现在查看3.3.3.3和4.4.4.4中（dis ospf lsdb router 3.3.3.3）&lt;img src=&#34;https://fqj-web.github.io/post-images/1587739427675.png&#34; alt=&#34;4&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
由于10.3.1.3和1.1.1.1已经存在最短路径树中，所以最短路径树仍然为1.1.1.1 &lt;img src=&#34;https://fqj-web.github.io/post-images/1587740242650.png&#34; alt=&#34;5&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;第二阶段&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587741949038.png&#34; alt=&#34;第二阶段&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;network-summary-lsatype3&#34;&gt;Network-summary-LSA（Type3）&lt;/h5&gt;
&lt;p&gt;描述区域内所有&lt;strong&gt;网段&lt;/strong&gt;的路由，并通告给其他相关区域（&lt;strong&gt;即跨区域进行路由传递&lt;/strong&gt;）&lt;code&gt;Type3和Type4的LSA有相同的格式，它们都是由ABR产生，可以跨区域传递，描述的是路由信息，与拓扑无关。ABR会将区域内的一类LSA和二类LSA转成三类LSA（此功能只有ABR具有，这也是为了防环），然后泛洪到其他区域，ABR产生的三类LSA将用于计算区域间路由&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587312009002.png&#34; alt=&#34;OSPF-Network-summary-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;通告缺省路由时，Link State ID和Network Mask都设置为0.0.0.0，查看三类LSA命令：dis ospf lsdb summary xx.xx.xx.xx&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;OSPF的防环&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了避免区域间的环路，OSPF规定不允许直接在两个非骨干区域间发布路由信息，只允许在&lt;strong&gt;一个区域内部&lt;/strong&gt;或者&lt;strong&gt;在骨干区域和非骨干区域之间&lt;/strong&gt;发布路由信息；&lt;strong&gt;只有ABR具有将一类LSA和二类LSA转成三类LSA的功能（必须为真ABR）&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;根据三类LSA计算区域间路由步骤&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;根据三类LSA中的&lt;strong&gt;Adv Rou&lt;/strong&gt;字段判断出&lt;strong&gt;ABR&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;根据&lt;strong&gt;sid、Net Mask、Metric&lt;/strong&gt;字段获得ABR到达目的&lt;strong&gt;网络号、掩码、开销&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果多个ABR产生了指向相同目的网络的三类LSA，则根节点将根据本路由器到达目的网络的&lt;strong&gt;累计开销&lt;/strong&gt;进行比较，最终生成&lt;strong&gt;最小开销路由&lt;/strong&gt;；如果根节点到达目的网络的&lt;strong&gt;累计开销值相同&lt;/strong&gt;，则产生&lt;strong&gt;等价负载的路由&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;真假ABR&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;假ABR&lt;/strong&gt;：骨干区域或者非骨干区域有一端是环回接口&lt;br&gt;
&lt;strong&gt;真ABR&lt;/strong&gt;：连接骨干与非骨干区域的设备，并且在骨干区域&lt;strong&gt;有活动的邻接&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;真ABR从非骨干区域收到的三类LSA只接收（更新LSDB）、不选路（即不加入路由表）；假ABR即接收又选路&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;asbr-summary-lsatype4&#34;&gt;ASBR-summary-LSA（Type4）&lt;/h5&gt;
&lt;p&gt;描述&lt;strong&gt;ABR到ASBR的路由&lt;/strong&gt;，通告给除ASBR所在区域的其他相关区域，四类LSA&lt;strong&gt;不能跨区域&lt;/strong&gt;。&lt;code&gt;报文格式与Network-summary-LSA相同&lt;/code&gt;&lt;strong&gt;由ABR发出，ASBR汇总LSA除了所通告的目的地是一个ASBR而不是一个网络外，其他同Network Summary LSA&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LS id：ASBR的RID&lt;/li&gt;
&lt;li&gt;Adv rtr：ABR的RID&lt;/li&gt;
&lt;li&gt;metric：ABR到ASBR的开销值&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么三类LSA无法取代四类LSA？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为三类LSA描述的是路由信息，四类LSA描述的是ASBR的拓扑信息（LsID是ASBR的RouterID ）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h5 id=&#34;as-external-lsatype5&#34;&gt;AS-External-LSA（Type5）&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;由ASBR产生&lt;/strong&gt;，是自治系统外的路由引入OSPF产生的，描述的&lt;strong&gt;是ASBR到外部路由（目标网络）的开销（华为默认为1）&lt;/strong&gt;，这是五种LSA中，唯一一种通告到所有区域（除了Stub区域和NSSA区域）的LSA。&lt;strong&gt;5类LSA可以跨区域，而且在传递过程中是不能被改变的&lt;/strong&gt;。&lt;strong&gt;发自ASBR路由器，用来通告到达OSPF自治系统外部的目的地，或者OSPF自治系统那个外部的缺省路由的LSA。这种LSA将在全AS内泛洪（4个特殊区域除外）&lt;/strong&gt;。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587312103475.png&#34; alt=&#34;OSPF-AS-External-LSA&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;Type5的LSA可以用来通告缺省路由，此时Link State ID和Network Mask都设置为0.0.0.0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LS id：网络前缀&lt;/li&gt;
&lt;li&gt;Adv rtr：ASBR的RID&lt;/li&gt;
&lt;li&gt;FA地址：防止次优路径和环路。&lt;strong&gt;携带FA地址的三个条件：1.接口类型不能是P2P、P2MP；2.接口不能配置为静默接口(silent接口)；3.下一条地址要为域内或者域间可达&lt;/strong&gt;&lt;code&gt;OSPF的五类LSA如果携带了FA地址，计算路由时会优先考虑FA地址，如果没有携带FA地址，则会考虑ASBR&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;外部度量值类型（E比特位）&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;OE1&lt;/strong&gt;：第一类外部路由&lt;code&gt;引入其他协议的路由时修改为OE1的指令：import-route rip 1 type 1&lt;/code&gt;。在传递过程中&lt;strong&gt;开销值累加&lt;/strong&gt;。&lt;code&gt;OE1的路由优先于OE2&lt;/code&gt;。OE1的路由比较的是总开销值，不区分内外。&lt;br&gt;
&lt;strong&gt;OE2&lt;/strong&gt;：第二类外部路由，&lt;strong&gt;默认类型&lt;/strong&gt;。在传递过程中&lt;strong&gt;开销值不会累加&lt;/strong&gt;，只计算引入时的外部开销值，不计算内部开销值。OE2只看外部开销（忽略内部开销）；如果外部开销相同，则比较内部开销；如果内部和外部开销都相同，则进行负载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;lsa报文简略总结&#34;&gt;LSA报文简略总结&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;LSA种类&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;内容&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Link State ID&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Adv Router&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;传输区域&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;一类LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Router-LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;链路状态信息的集合&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;产生LSA的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设备的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;二类LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;network-LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;链路内的设备的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DR接口的IP&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;DR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;三类LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Network-Summary-LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络前缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;可以跨区域(除stub、NSSA)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;四类LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR-Summary-LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR的信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;五类LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;AS-External-LSA&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;路由信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络前缀&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ASBR的RouterID&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;跨区域(除stub、NSSA)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;不同报文中LinkStateID的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;Router-LSA中的LsID为生成此LSA的RouterID&lt;/li&gt;
&lt;li&gt;Network-LSA中的LsID为DR的接口IP地址&lt;/li&gt;
&lt;li&gt;Network-summary-LSA中的LsID为通告的网络地址&lt;/li&gt;
&lt;li&gt;ASBR-summary-LSA中的LsID为ASBR的RouterID&lt;/li&gt;
&lt;li&gt;AS-External-LSA中的LsID为通告的网络地址&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;lsa报文分类型详细汇总&#34;&gt;LSA报文分类型详细汇总&lt;/h4&gt;
&lt;h5 id=&#34;router-lsa&#34;&gt;Router-LSA&lt;/h5&gt;
&lt;p&gt;路由LSA ，是ospf 区域内的所有路由器产生的，包含的信息：该路由有几个接口参与了OSPF，以及它们所在的网段，只在本区域内泛洪。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;报文内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Type      : Router
  Ls id     : 2.2.2.2
  Adv rtr   : 2.2.2.2  
  Ls age    : 24 
  Len       : 36 
  Options   :  ABR      #当前数据采自stub区域，普通区域该位会置ABR E
  seq#      : 80000005 
  chksum    : 0x819e
  Link count: 1
   * Link ID: 12.1.1.2     
     Data   : 12.1.1.2     
     Link Type: TransNet     
     Metric : 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;作用
&lt;ol&gt;
&lt;li&gt;描述该路由器所有接口的链路信息（transenet、stub、p2p、virtual-link）、是否为ABR或者ASBR、开销值等&lt;/li&gt;
&lt;li&gt;P2P和P2MP区域内仅存在该lsa&lt;/li&gt;
&lt;li&gt;所有路由器发出、仅存于区域内&lt;/li&gt;
&lt;li&gt;通告者为产生该lsa的路由器的router id&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;network-lsa&#34;&gt;Network-LSA&lt;/h5&gt;
&lt;p&gt;网络LSA ，它是ospf区域内的DR产生的，它包含的信息：多少路由器在它的网络上，该网络的前缀和掩码，也只在本区域内泛洪。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;报文内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Type      : Network
  Ls id     : 12.1.1.2
  Adv rtr   : 2.2.2.2  
  Ls age    : 40 
  Len       : 32 
  Options   : None         #当前数据采自stub区域，普通区域该位会置 E
  seq#      : 80000002 
  chksum    : 0x1027
  Net mask  : 255.255.255.0
  Priority  : Low
     Attached Router    2.2.2.2
     Attached Router    1.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;作用
&lt;ol&gt;
&lt;li&gt;描述多点网络伪节点连接的路由器&lt;/li&gt;
&lt;li&gt;DR发出、仅存于区域内&lt;/li&gt;
&lt;li&gt;net mask与link id进行与运算，可获知网络号&lt;/li&gt;
&lt;li&gt;通告者为DR，相当于是一个补充，仅MA网络的补充描述（MA、NBMA）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;network-summary-lsa&#34;&gt;Network-summary-LSA&lt;/h5&gt;
&lt;p&gt;汇总LSA，它是ABR路由器产生的，在整个AS里泛洪。&lt;strong&gt;通过三类LSA，可以知道目标路由器在哪个AS里；通过二类LSA，可以知道目标路由器在哪个区域；通过一类LSA，可以知道目标路由器具体是哪一个&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;报文内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Type      : Sum-Net
  Ls id     : 12.1.1.0
  Adv rtr   : 2.2.2.2  
  Ls age    : 581 
  Len       : 28 
  Options   :  E  
  seq#      : 80000004 
  chksum    : 0x7fc3
  Net mask  : 255.255.255.0
  Tos 0  metric: 1
  Priority  : Low
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;作用
&lt;ol&gt;
&lt;li&gt;区域间链路状态信息的汇总，告知其他区域，本区域内的链路状态信息（本区域内的LSA1+LSA2）&lt;/li&gt;
&lt;li&gt;ABR发出，向相邻区域通告，通告给其他区域后，通告者会修改为ABR的router id&lt;/li&gt;
&lt;li&gt;相当于城际列车（跨区的列车，但没有出市）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;asbr-summary-lsa&#34;&gt;ASBR-summary-LSA&lt;/h5&gt;
&lt;p&gt;也叫汇总LSA，它是ASBR路由器产生的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;作用
&lt;ol&gt;
&lt;li&gt;告知asbr的位置&lt;/li&gt;
&lt;li&gt;ABR发出，引入外部路由的区域不存在4类lsa&lt;/li&gt;
&lt;li&gt;相当于本区的代理告诉你去国外得先去机场&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;as-external-lsa&#34;&gt;AS-External-LSA&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;报文内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Type      : External
  Ls id     : 44.44.44.44
  Adv rtr   : 4.4.4.4  
  Ls age    : 856 
  Len       : 36 
  Options   :  E  
  seq#      : 80000002 
  chksum    : 0x947a
  Net mask  : 255.255.255.255 
  TOS 0  Metric: 1 
  E type    : 2
  Forwarding Address : 0.0.0.0 
  Tag       : 1 
  Priority  : Medium
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;作用
&lt;ol&gt;
&lt;li&gt;告知引入外部路由的路由器&lt;/li&gt;
&lt;li&gt;由ASBR发出，引入外部路由的区域通过1类LSA去往外部路由&lt;/li&gt;
&lt;li&gt;相当于机场，去往国外的通道&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;nssa-lsa&#34;&gt;NSSA-LSA&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;报文内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Type      : NSSA
  Ls id     : 44.44.44.44
  Adv rtr   : 4.4.4.4  
  Ls age    : 89 
  Len       : 36 
  Options   :  NP  
  seq#      : 80000001 
  chksum    : 0xe8f6
  Net mask  : 255.255.255.255 
  TOS 0  Metric: 1 
  E type    : 2
  Forwarding Address : 34.1.1.4 
  Tag       : 1 
  Priority  : Low
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;作用
&lt;ol&gt;
&lt;li&gt;仅nssa网络中存在&lt;/li&gt;
&lt;li&gt;缺省存在默认路由，当引入外部路由后，该外部路由也会体现为nssa类型&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lsacklink-state-acknowledgment链路状态确认&#34;&gt;LSAck（Link State Acknowledgment,链路状态确认）&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用：&lt;/strong&gt;（结账买单）用来对收到的LSU的确认。用来对接收到的LSU报文进行确认，内容是需要确认的LSA的Header（一个LSAck报文可对多个LSA进行确认），LSAck报文根据不同的链路以单播或组播的形式发送。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587312186750.png&#34; alt=&#34;OSPF-LSAck&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;ospf特殊区域&#34;&gt;OSPF特殊区域&lt;/h1&gt;
&lt;h2 id=&#34;stub-末节区域&#34;&gt;Stub 末节区域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将区域设置为末节区域，需要在末节区域的所有设备上配置&lt;code&gt;stub&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;末节区域会&lt;strong&gt;过滤五类LSA（四类LSA也会被过滤掉）&lt;/strong&gt;，ABR会向该区域下放一条默认路由（三类LSA）&lt;/li&gt;
&lt;li&gt;无法配置外部路由（即便强行配置也无法配置上去）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 需要在该区域的所有设备上都配置
ospf 10 router-id 2.2.2.2
area 10
stub
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;totally-stub-完全末节区域&#34;&gt;Totally Stub 完全末节区域&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只需要在ABR上配置，区域内其他设备配置为末节区域即可&lt;/li&gt;
&lt;li&gt;完全末节区域不仅会&lt;strong&gt;过滤掉四类和五类LSA，也会过滤掉三类LSA&lt;/strong&gt;，同时ABR会向该区域下放一条默认路由（三类LSA）（一共有三类LSA：一类、二类和下放路由使用的三类）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ospf 10 router-id 2.2.2.2
area 10
stub no-summary
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Stub和Totally Stub的一些条件&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;建议该区域只能有一个出口，即只有一个ABR&lt;/li&gt;
&lt;li&gt;虚连接不能跨越Stub区域&lt;/li&gt;
&lt;li&gt;Stub区域不能有ASBR&lt;/li&gt;
&lt;li&gt;不能将骨干区域配置为Stub区域&lt;/li&gt;
&lt;li&gt;Stub区域发送的Hello报文中的E比特位会置0&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;nssa-非完全末节区域&#34;&gt;NSSA 非完全末节区域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;产生背景&lt;/strong&gt;：OSPF规定Stub区域不能引入外部路由，这样可以避免大量外部路由对Stub区域路由器带宽和存储资源的消耗。对于既需要引入外部路由又要避免外部路由带来的资源消耗的场景，stub区域就不在满足需求，因此产生了NSSA区域&lt;/li&gt;
&lt;li&gt;将区域设置为NSSA区域，需要在末节区域的所有设备上配置&lt;code&gt;nssa&lt;/code&gt;命令&lt;/li&gt;
&lt;li&gt;NSSA区域会&lt;strong&gt;过滤五类LSA（四类LSA也会被过滤掉）&lt;/strong&gt;，同时引进七类LSA（即NSSA-LSA，是由五类LSA转换而成），同时ABR会向该区域下放一条默认路由（七类LSA）&lt;/li&gt;
&lt;li&gt;七类LSA的优先级：ON1（类似OE1）和ON2(类似OE2)&lt;/li&gt;
&lt;li&gt;FA地址：对于&lt;strong&gt;五类LSA是可选项&lt;/strong&gt;，但是&lt;strong&gt;七类LSA是必选项&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在五类LSA中&lt;/strong&gt;，FA地址只有满足那三个条件才会携带，携带的是下一条的地址&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在七类LSA中&lt;/strong&gt;，如果满足五类LSA的三大条件，FA地址是ASBR上外部路由的下一条地址；如果不满足条件，FA地址是ASBR上某个接口的IP，优选环回口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 需要在该区域的所有设备上都配置
ospf 10 router-id 2.2.2.2
area 10
nssa
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;totally-nssa&#34;&gt;Totally NSSA&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只需要在ABR上设置，区域内其他路由设备设置为naas即可&lt;/li&gt;
&lt;li&gt;过滤掉&lt;strong&gt;三类、四类和五类LSA&lt;/strong&gt;，同时引入外部路由作为七类LSA存在，同时ABR会向该区域通告两条默认路由：一个是三类sum-net（优先级高），一个是七类nssa&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ospf 10 router-id 2.2.2.2
area 10
naas no-summary
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;OSPF路由的优先级&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;思科&lt;/strong&gt;：O(一类和二类)&amp;gt;OIA(三类)&amp;gt;OE1(五类外部度量值类型1)&amp;gt;ON1(七类外部度量值类型1)&amp;gt;OE1(五类外部度量值类型2)&amp;gt;ON2(七类外部度量值类型2)&lt;br&gt;
&lt;strong&gt;华为&lt;/strong&gt;：O(一类和二类)&amp;gt;OIA(三类)&amp;gt;OE1=ON1&amp;gt;OE2=ON2（五类和七类的优先级相同，即华为不区分五类和七类LSA）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;七类LSA转五类LSA的条件&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果有多个ABR，则RouterID大的进行七转五，也可以使用&lt;code&gt;nssa translator-always&lt;/code&gt;命令来指定ABR进行七转五（一个区域中只有一个设备进行七转五）。如果做七转五时抑制掉FA地址则需要使用命令&lt;code&gt;nssa translator-always suppress-forwarding-address&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;LSA的汇总&lt;/strong&gt;&lt;br&gt;
汇总之后，非本区域设备无法看到相应的明细路由&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;三类LSA&lt;/strong&gt;：在ABR上配置，需要汇总的网段所在OSPF的区域进行配置&lt;br&gt;
&lt;strong&gt;五类LSA&lt;/strong&gt;：在ASBR上配置，在OSPF进程下配置&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.............................................三类LSA汇总
# AR2
ospf 10
area 10 # 需要汇总的网段在Area10中
abr-summary 10.1.0.0 255.255.248.0
#.............................................五类LSA汇总
# AR5
ospf 10
asbr-summary 192.168.0.0 255.255.248.0
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;路由的过滤&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;方法一&lt;/strong&gt;：先做acl匹配路由，然后在路由的起始区域的&lt;strong&gt;出或者入方向&lt;/strong&gt;配置（即出入方向上配置均可）&lt;br&gt;
&lt;strong&gt;方法二&lt;/strong&gt;：对路由进行汇总时携带参数&lt;code&gt;not-advertise&lt;/code&gt;，即汇总但是不通告&lt;br&gt;
&lt;strong&gt;方法三&lt;/strong&gt;：使用filter-policy进行过滤。运行完SPF算法，在进入路由表是进行的过滤，即&lt;strong&gt;只过滤路由不过滤LSA&lt;/strong&gt;。如果该方法在普通设备上，只影响本地；如果在ABR上配置。还会影响其他设备，主要是通过影响三类LSA导致路由无法传递&lt;br&gt;
&lt;strong&gt;方法四&lt;/strong&gt;：在接口下针对LSA进行过滤，可以过滤三类、五类、七类、全部等等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ......................................................................方法一
# AR2
acl 2001
rule deny source 10.1.0.0 0.0.3.255
rule permit source any
ospf 10
area 10
filter 2001 export    #或者filter 2001 import
# ......................................................................方法二
# AR2
ospf 10
area 10
abr-summary 10.1.0.0 255.255.0.0 not-advertise #对三类LSA汇总不通告，进行过滤
# AR5
ospf 10
asbr-summary 192.168.0.0 255.255.0.0 not-advertise  #对五类LSA汇总不通告，进行过滤
# ......................................................................方法三
# AR1
acl 2001
rule deny source 10.1.0.0 0.0.7.255
rule permit source any
ospf 10
filter-policy 2001 import   # 此时AR1上没有相应路由，但是AR2上有，即此方法只过滤路由，不过滤LSA
# AR5：在引入外部路由时过滤
ospf 10
filter-policy 2001 export rip 1
import-route rip 1
# ......................................................................方法四
# AR2：针对五类LSA
int s1/0/0
ospf filter-lsa-out ase
# AR2：针对三类LSA
int s1/0/0
ospf filter-lsa-out summary
# AR1：过滤掉所有LSA
int g0/0/1
ospf filter-lsa-out all
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;lsa存在的区域特殊类型之间的区别&#34;&gt;LSA存在的区域(特殊类型之间的区别)&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;特殊区域类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Stub&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Totally Stub&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;NSSA&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;Totally NSSA&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域中LSA类型&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;LSA1/2/3&lt;br&gt;ABR产生LSA3(0.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;LSA1/2&lt;br&gt;ABR产生LSA3(0.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;LSA1/2/3/7&lt;br&gt;ABR(ASBR)产生LSA7(0.0.0.0)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;LSA1/2/7&lt;br&gt;ABR(ASBR)产生LSA3(0.0.0.0)&lt;br&gt;LSA7(0.0.0.0)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;ABR/ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域内不允许ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域内不允许ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域内允许部署ASBR,&lt;br&gt;区域边界路由既是ABR也是ASBR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;区域内允许部署ASBR,&lt;br&gt;区域边界路由既是ABR也是ASBR&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;LSA补充&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二、三、五类LSA都存在net mask字段，用来携带网络信息&lt;br&gt;
二类LSA既包含拓扑信息也包含网络信息，所以网络改变时，即使物理没有改变，也会触发二类lsa，导致重新的区域内SPF计算&lt;br&gt;
当同区域不相邻的两台路由器AR1和AR2的RouterID冲突，会导致AR1和AR2产生的LSA会迅速累加&lt;br&gt;
仅5类和7类lsa包含FA地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;ospf的认证&#34;&gt;OSPF的认证&lt;/h1&gt;
&lt;p&gt;OSPF认证存在于OSPF报文的头部&lt;/p&gt;
&lt;h2 id=&#34;分类&#34;&gt;分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;0：不认证&lt;/li&gt;
&lt;li&gt;1：明文认证&lt;/li&gt;
&lt;li&gt;2：MD5认证&lt;br&gt;
&lt;code&gt;OSPF的认证分为区域认证（在区域中配置）和接口认证（在接口下配置），接口认证由于区域认证&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ........................................1：明文认证
# AR2：在区域下配置
ospf 10
area 0
authentication-mode simple huawei12
# AR4
ospf 10
area 0  
authentication-mode simple huawei12
# AR3 ：在接口下配置
int g/0/0
ospf authentication-mode simple cipher huawei12

# ........................................2：MD5认证
# AR3
ospf 10
area 0  
authentication-mode md5 1 qyt123
# AR4
int g0/0/1 
ospf authentication-mode md5 1 qyt123

# .............................................配置虚连接的认证
# AR5
ospf 10
area 20
vlink-peer 4.4.4.4 simple cipher qyt123
# AR4
ospf 10
area 20
vlink-peer 5.5.5.5 simple cipher qyt123
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ospf缺省路由的下放&#34;&gt;OSPF缺省路由的下放&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;普通区域&lt;/strong&gt;：可以在ASBR上通过&lt;code&gt;default-route-advertise&lt;/code&gt;下放一条路由（五类LSA）。&lt;br&gt;
&lt;code&gt;default-route-advertise&lt;/code&gt;需要本地有默认路由，才会在OSPF中下放默认路由；&lt;br&gt;
&lt;code&gt;default-route-advertise always&lt;/code&gt;即便本地没有默认路由，也会在OSPF中下放一条默认路由。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Stub区域和Totally Stub区域&lt;/strong&gt;：会自动下放一条缺省三类LSA，通告这个Stub区域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Nssa区域&lt;/strong&gt;：ABR会自动生成一条缺省的七类LSA，通告到整个NSSA区域。ASBR需要手工配置，可以产生一条七类LSA的缺省路由，通告整个NSSA区域&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Totally Nssa区域&lt;/strong&gt;：ABR会下放两条缺省的默认路由（三类和七类），通告到整个NSSA区域。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#..................................................普通区域
# AR5：不加always
ip route-static 0.0.0.0 0.0.0.0 56.1.1.6
ospf 10
default-route-advertise
# AR5：加always
ospf 10
default-route-advertise
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ospf的可靠性技术&#34;&gt;OSPF的可靠性技术&lt;/h1&gt;
&lt;h2 id=&#34;gr&#34;&gt;GR&lt;/h2&gt;
&lt;p&gt;GR是Graceful Restart的简称，又被称为平滑重启，是一种用于保证当路由协议重启时数据正常转发并且不影响关键业务的技术。&lt;br&gt;
重启之前发送&lt;strong&gt;九类LSA&lt;/strong&gt;（组播224.0.0.5）&lt;br&gt;
平滑重启指令&lt;code&gt;reset ospf 10 process graceful-restart&lt;/code&gt;&lt;br&gt;
在主备倒换端，系统支持NSR和GR两种不同的高可靠性保护，他们是&lt;strong&gt;互斥的&lt;/strong&gt;。即，对于一个特定协议，系统倒换后，&lt;strong&gt;只能采用NSR或GR两种处理方式的一种&lt;/strong&gt;。设备在部署NSR时，仍然可以支持GR Helper的功能，以支持自己的邻居GR过程，最大可能的保证用户全网网络节点业务的高可靠性。&lt;/p&gt;
&lt;h2 id=&#34;nsr&#34;&gt;NSR&lt;/h2&gt;
&lt;p&gt;不间断路由NSR（Non-Stopping Routing），是在有主用主控板和备用主控板的设备上，主用主控板发生故障时不影响邻居关系的一种可靠性技术。&lt;br&gt;
通过协议备份机制，实现主备倒换时&lt;strong&gt;控制平面（RIB，路由）和转发平面（FIB，业务）均不中断&lt;/strong&gt;。&lt;br&gt;
在设备发生倒换的过程中，路由处理不中断，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;邻居和拓扑信息不丢失&lt;/li&gt;
&lt;li&gt;邻居关系不中断&lt;br&gt;
这种方式的优点有：&lt;/li&gt;
&lt;li&gt;不依赖也不影响对端设备，没有互通问题&lt;/li&gt;
&lt;li&gt;路由的收敛速度要比NSF快&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;nsf&#34;&gt;NSF&lt;/h2&gt;
&lt;p&gt;不间断转发NSF，通过协议的GR（Graceful Restart）机制，支持系统主备倒换时，&lt;strong&gt;转发业务不中断&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当由于某种原因系统发生故障时，在系统重启过程中，转发平面（业务）不中断&lt;/li&gt;
&lt;li&gt;系统恢复后，设备能够重新建立邻居关系，从邻居处获取路由信息并重建路由表&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;frr&#34;&gt;FRR&lt;/h2&gt;
&lt;p&gt;快速重路由FRR（Fast Reroute）是指当物理层或链路层检测到故障时将故障消息上报至上层路由系统，并立即启用一条备份链路转发报文。IP FRR是一种快速实现路由备份的方式。&lt;br&gt;
IP FRR特性能够保证转发系统快速应对出现的链路故障，直接启用备份路由进行数据转发，尽快让业务恢复正常。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 开启FRR
ospf 10
frr
loop-free-alternate # 用来是能OSPF IP FRR功能，利用LFA算法计算备份下一条和备份出接口
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;ospf的option选项&#34;&gt;OSPF的Option选项&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;区域类型&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;E位(五类)&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;N位(七类)&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;普通区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1(允许)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0(不允许)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Stub区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;NSSA区域&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;0&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;ospf排错&#34;&gt;OSPF排错&lt;/h1&gt;
&lt;p&gt;使用命令&lt;code&gt;dis ospf error&lt;/code&gt;可以查看OSPF配置的所有错误；使用命令&lt;code&gt;dis ospf error int gx/x/x&lt;/code&gt;可以查看接口下OSPF配置的错误&lt;/p&gt;
&lt;h2 id=&#34;影响ospf邻居建立的因素ospf邻居未建立原因&#34;&gt;影响OSPF邻居建立的因素（OSPF邻居未建立原因）&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;链路层故障：测网线，测光纤，ping&lt;/li&gt;
&lt;li&gt;接口没有宣告：使用命令&lt;code&gt;dis ospf int&lt;/code&gt;查看接口宣告情况&lt;/li&gt;
&lt;li&gt;区域ID不一致：使用命令&lt;code&gt;dis ospf peer bri&lt;/code&gt;查看邻居情况&lt;/li&gt;
&lt;li&gt;静默端口（被动接口）&lt;/li&gt;
&lt;li&gt;Hello时间不一致导致邻居无法建立&lt;/li&gt;
&lt;li&gt;Dead时间不一致&lt;/li&gt;
&lt;li&gt;MA网络掩码不一致&lt;/li&gt;
&lt;li&gt;Option选项不一致导致邻居无法建立：主要查看E（五类）和N位（七类）&lt;/li&gt;
&lt;li&gt;认证类型和认证密码不一致导致邻居无法建立&lt;/li&gt;
&lt;li&gt;RouterID冲突，有可能会导致邻居无法建立：同一个区域无法建立邻居；骨干区域普通路由器(非ABR、ASBR)和普通区域的普通路由(非ABR、ASBR)冲突不影响邻居关系的建立&lt;/li&gt;
&lt;li&gt;配置了ACL&lt;/li&gt;
&lt;li&gt;MTU会影响邻接的建立，不影响邻居&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;补充&#34;&gt;补充&lt;/h1&gt;
&lt;h2 id=&#34;route-policy&#34;&gt;route-policy&lt;/h2&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;route-policy命令用来创建路由策略并进入Route-Policy视图&lt;/li&gt;
&lt;li&gt;undo route-policy命令用来删除指定的路由策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;命令格式&#34;&gt;命令格式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;route-policy route-policy-name { permit | deny } node node&lt;/li&gt;
&lt;li&gt;undo route-policy route-policy-name [ node node ]&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参数说明&#34;&gt;参数说明&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;route-policy-name：指定Route-Policy名称。如果该名称的路由策略不存在，则创建一个新的路由策略并进入它的Route-Policy视图。如果该名称的路由策略已经存在，则直接进入它的Route-Policy视图&lt;/li&gt;
&lt;li&gt;permit（deny）：指定Route-Policy节点的匹配模式为允许（拒绝）。如果路由与节点所有的if-match子句匹配成功，则执行此节点apply子句（则该路由将被拒绝通过）；否则，进行下一节点。&lt;/li&gt;
&lt;li&gt;node &lt;em&gt;node&lt;/em&gt; ：指定Route-Policy的节点号。当使用Route-Policy时，node的值小的节点先进行匹配。一个节点匹配成功后，路由将不再匹配其他节点。全部节点匹配失败后，路由将被过滤&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;实验&#34;&gt;实验&lt;/h1&gt;
&lt;h2 id=&#34;实验一查看ospf内部和外部路由的优先级&#34;&gt;实验一：查看OSPF内部和外部路由的优先级&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587046773502.png&#34; alt=&#34;实验一：查看OSPF内部和外部路由的优先级&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#...........................配置IP地址
# AR1
system-view
sysname AR1
int g0/0/0
ip addr 172.16.10.1 24
int s1/0/0
ip addr 12.1.1.1 24
int lo 0
ip addr 1.1.1.1 32

# AR2
system-view
sysname AR2
int g0/0/0
ip addr 24.1.1.2 24
int s1/0/0
ip addr 12.1.1.2 24
int g0/0/1
ip addr 23.1.1.2 24
int lo 0
ip addr 2.2.2.2 32

# AR3
system-view
sysname AR3
int g0/0/0
ip addr 23.1.1.3 24
int g0/0/1
ip addr 34.1.1.3 24
int lo 0
ip addr 3.3.3.3 32

# AR4
system-view
sysname AR4
int g0/0/0
ip addr 24.1.1.4 24
int g0/0/1
ip addr 34.1.1.4 24
int g0/0/2
ip addr 45.1.1.4 24
int lo 0
ip addr 4.4.4.4 32

# AR5
system-view
sysname AR5
int g0/0/0
ip addr 45.1.1.5 24
int g0/0/1
ip addr 56.1.1.5 24
int lo 0
ip addr 5.5.5.5 32

# AR6
system-view
sysname AR6
int g0/0/0
ip addr  56.1.1.6 24
int lo 0 
ip addr 6.6.6.6 32
int lo 10
ip addr 200.200.200.200.32

# AR7
system-view
sysname AR7
int g0/0/0
ip addr 172.16.10.7 24
int lo 0
ip addr 7.7.7.7 32

# AR8
system-view
sysname AR8
int g0/0/0
ip addr 172.16.10.8 24
int lo 0
ip addr 8.8.8.8 32

#.........................................配置OSPF
# AR1
ospf 10 router-id 1.1.1.1   # router-id一般配置和环回接口地址相同
area 10
network 172.16.10.1 0.0.0.0  # 精确宣告
network 12.1.1.1 0.0.0.0
network 1.1.1.1 0.0.0.0
dis ospf int  # 查看ospf接口的相关信息
# AR7
ospf 10 router-id 7.7.7.7
area 10
network 176.16.10.0 0.0.0.255  # 宣告网段
network 7.7.7.7 0.0.0.0
# AR8
ospf 10 router-id 8.8.8.8
area 10
network 176.16.10.0 0.0.0.255
network 8.8.8.8 0.0.0.0
# AR2
ospf 10 router-id 2.2.2.2
area 10
network 12.1.1.2 0.0.0.0
area 0
network 24.1.1.2 0.0.0.0
network 23.1.1.2 0.0.0.0
network 2.2.2.2 0.0.0.0  # 通常情况下宣告进区域0，当然也可以宣告进区域10
# AR3
router-id 3.3.3.3 # 在全局下制定Router-ID
ospf 10
area 0
int g0/0/0
ospf enable 10 area 0  # 在接口下宣告（需要提前启用OSPF进程）
int g0/0/1
ospf enable 10 area 0
int lo 0
ospf enable 10 area 0
# AR4
ospf 10 router-id 4.4.4.4
area 0
network 24.1.1.4 0.0.0.0
network 34.1.1.4 0.0.0.0
network 4.4.4.4 0.0.0.0
area 20
network 45.1.1.4 0.0.0.0
# AR5
ospf 10 router-id 5.5.5.5
area 20 
network 45.1.1.5 0.0.0.0
q
rip 
version 2
undo summary  # 关闭自动汇总
network 5.0.0.0
network 56.0.0.0
ospf 10   # 实施ospf和rip的双向引入
import-route rip
rip
import-route ospf 10
# AR6
rip 
version 2
undo summary  # 关闭自动汇总
network 6.0.0.0
network 56.0.0.0
nerwork 200.200.200.0

# 查看OSPF三张表
# AR1/7
dis ospf peer bri  # 查看邻居表
dis ospf lsdb  # 查看拓扑表（链路状态数据库）
dis ip routing-table pro ospf  # 查看路由表，查看OSPF内外路由的优先级
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验二查看ospf的选举过程通过抓包也可以观察到主从选举以及lsdb同步过程&#34;&gt;实验二：查看OSPF的选举过程，通过抓包也可以观察到主从选举以及LSDB同步过程&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587222895775.png&#34; alt=&#34;实验二：查看OSPF的选举过程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1
system-view
sysname AR1 
int g0/0/0
ip addr 192.168.10.1 24
ospf 10 router-id 1.1.1.1
area 0
network 192.168.10.0 0.0.0.255

# AR2
system-view
sysname AR2
int g0/0/0
ip addr 192.168.10.2 24
ospf 10 router-id 2.2.2.2
area 0
network 192.168.10.0 0.0.0.255
# 此时AR2（优先级相同，Router-ID比较大）已经成为DR，AR1是BDR

# AR3
system-view
sysname AR3
int g0/0/0
ip addr 192.168.10.3 24
ospf 10 router-id 3.3.3.3
area 0
network 192.168.10.0 0.0.0.255
# 由于过了选举期，DR仍然为AR2，AR3变成DROther
# 此时AR2重置进程（reset ospf process），则原来的BDR的AR1变成DR，新的BDR为AR3
# 即DR是AR1，BDR为AR3

# AR4
system-view
sysname AR4
int g0/0/0
ip addr 192.168.10.4 24
ospf 10 router-id 4.4.4.4
area 0
network 192.168.10.0 0.0.0.255
# 由于过了选举期，DR仍然为AR1，AR3为BDR，AR4为DROther
# 此时将AR1的优先级改为0（int g0/0/0   &amp;amp;&amp;amp;   ospf de-priority 0）
# 此时AR3由BDR变成DR，AR4由DROther变成BDR，AR2为DROther

## 如果网络中的路由器的优先级全部为0，则所有路由器之间的关系均为2-way

## 全部重新选举
## 将AR1的优先级改为1默认状态（int g0/0/0   &amp;amp;&amp;amp;   ospf de-priority 1）
## 使用CRT连接台路由器，对所有的路由器同时执行reset ospf process重置进程
## 则AR4变为DR，AR3变为BDR，AR2为DROther

## 此时将交换机的g0/0/1和g0/0/2接口放入vlan10中
# sw1
sys
vlan 10
port-group group-member g0/0/1 g0/0/2
port link-type access
port default vlan 10
#  然后使用CRT将所有的ospf进程重置
# 此时AR4变为DR，AR3变为BDR，AR2也为DR，AR1为BDR
# 然后进行vlan之间的选举DR和DR比较，BDR和BDR比较
# 则 AR4变为DR，AR3变为BDR，AR2变成DROther，AR1变成DROther
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验三查看mtu对邻接关系建立的影响&#34;&gt;实验三：查看MTU对邻接关系建立的影响&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587304638383.png&#34; alt=&#34;实验三：查看MTU对邻接关系建立的影响&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1
system-view
sysname AR1 
int g0/0/0
ip addr 192.168.10.1 24
ospf 10 router-id 1.1.1.1
area 0
network 192.168.10.0 0.0.0.255

# AR2
system-view
sysname AR2
int g0/0/0
ip addr 192.168.10.2 24
ospf 10 router-id 2.2.2.2
area 0
network 192.168.10.0 0.0.0.255
# 此时AR2（优先级相同，Router-ID比较大）已经成为DR，AR1是BDR；AR2在主从选举中由于Router-ID比较大变为主，AR1是从

# AR1/AR2
int g0/0/0
ospf timer hello 5  # 40秒时间太长，将hello报文缩短，方便实验
ospf mtu-enable  # 开启MTU检测

# 验证：主AR2-MTU1500&amp;gt;从AR1-MTU1400，两端会同时卡在exstart状态
# AR1
int g0/0/0
mtu 1400
# 使用CRT同时对AR1和AR2重置OSPF进程reset ospf process

# 验证：主AR2MTU1300&amp;lt;从AR1MTU1400，从AR1会进入exchange，主AR1会卡在extart状态
# AR2
int g0/0/0
mtu 1300
# 使用CRT同时对AR1和AR2重置OSPF进程reset ospf process

# 验证：忽略MTU检测（MTU不一致），卡在Loading状态。AR1的MTU=1300，AR2的MTU=1400
# AR1/AR2
int g0/0/0
un ospf mtu-enable
# 使用CRT同时对AR1和AR2重置OSPF进程reset ospf process
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验四ospf支持的前4种网络类型&#34;&gt;实验四：OSPF支持的前4种网络类型&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587396424392.png&#34; alt=&#34;实验四：OSPF支持的4种网络类型&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ................................................................NBMA网络
# 添加帧中继交换机的映射
# AR1
system-view
sysname AR1
int s1/0/0
link-protocol fr
ip addr 172.16.10.1 24
fr map ip 172.16.10.2 102 broadcast
fr map ip 172.16.10.3 103 broadcast
int lo 0
ip addr 1.1.1.1 32
router id 1.1.1.1
ospf 10
area 0
network 172.16.10.1 0.0.0.0
network 1.1.1.1 0.0.0.0
q
peer 172.16.10.2
peer 172.16.10.3
# dis ospf peer br  # 查看OSPF邻居，有2.2.2.2和3.3.3.3
# dis ospf int  # AR1是BDR

# AR2
system-view
sysname AR2
int s1/0/0
link-protocol fr
ip addr 172.16.10.2 24
fr map ip 172.16.10.1 201 broadcast
int lo 0
ip addr 2.2.2.2 32
router id 2.2.2.2
network 172.16.10.2 0.0.0.0
network 2.2.2.2 0.0.0.0
q
peer 172.16.10.1
# dis ospf peer br  # 查看OSPF邻居，有1.1.1.1
# dis ospf int  # AR2是DR

# AR3
system-view
sysname AR3
int s1/0/0
link-protocol fr
ip addr 172.16.10.3 24
fr map ip 172.16.10.1 301 broadcast
int lo 0
ip addr 3.3.3.3 32
router id 3.3.3.3
network 172.16.10.3 0.0.0.0
network 3.3.3.3 0.0.0.0
q
peer 172.16.10.1
# dis ospf peer br  # 查看OSPF邻居，有1.1.1.1
# dis ospf int  # AR3也是DR
# 因为NBMA是非广播网络，AR2和AR3无法通信，但是AR1可以与AR2和AR3进行通信
# 导致AR1只承认AR3这个DR，即只有到AR3的路由，缺少去往AR2的路由；AR3上也有一条去往AR1的路由；AR2上无路由
# 解决此问题的唯一方案是修改优先级，使得AR1为DR，同时使得AR2和AR3无法进行选举（防止其中一个路由器重启之后导致重新进行选举）
#【如果仅仅将AR2的优先级修改为0，放弃选举DR，此网络可以正常选举DR(ar3)、BDR(ar1)、DROther(ar2)，但是没有对应的路由，无法从根本上上解决问题】
# AR1
int s1/0/0
ospf de-priority 100
# AR2/AR3
int s1/0/0
ospf de-priority 0
# 使用CRT将AR1/2/3的OSPF进程重置reset ospf process

# ................................................................点到多点网络
# AR1
int s1/0/0
undo ospf de-priority
ospf 10
undo peer 172.16.10.2
undo peer 172.16.10.3
int s1/0/0
ospf network-type p2mp  # 修改接口类型为点到多
# AR2
int s1/0/0
undo ospf de-priority
ospf 10
undo peer 172.16.10.1
int s1/0/0
ospf network-type p2mp
# AR3
int s1/0/0
undo ospf de-priority
ospf 10
undo peer 172.16.10.1
int s1/0/0
ospf network-type p2mp

# ................................................................广播网络
# AR1
int g0/0/0 
ip addr 14.1.1.1 24
ospf 10
a 0
network 14.1.1.1 0.0.0.0

# AR4
sys
sys AR4
int g0/0/0 
ip addr 14.1.1.4 24
q
router id 4.4.4.4
int lo 0
ip addr 4.4.4.4 32
ospf 10
a 0
network 14.1.1.4 0.0.0.0
network 4.4.4.4 0.0.0.0

# ................................................................点到点网络
# AR4
int s1/0/0
ip add 45.1.1.4 24
ospf 10
area 0
network 45.1.1.4 0.0.0.0

# AR5
sys
sys AR4
int s1/0/0
ip add 45.1.1.5 24
int lo 0
ip addr 5.5.5.5 32
ospf 10 router 5.5.5.5
area 0
network 45.1.1.5 0.0.0.0
network 5.5.5.5 0.0.0.0

# ..................................不同的网络类型能否建立邻接关系，是否有路由
#....................P2P与Broadcast(AR1和AR4)
# 可以建立邻接关系，但是没有路由
# AR1
int g0/0/0
ospf netowrk-type p2p
#....................P2MP与Broadcast(AR1和AR4)
# 可以建立邻接关系，但是没有路由
# AR1
int g0/0/0
ospf netowrk-type p2mp
ospf timer hello 10
#....................NBMA与Broadcast(AR1和AR4)
# 可以建立邻接关系，但是没有路由
# AR1
int g0/0/0
ospf netowrk-type nbma
ospf timer hello 10
#....................P2P与P2MP(AR1和AR2、AR3)
# 可以建立邻接关系，有路由
# AR1
int s1/0/0
ospf network-type p2mp
ospf timer hello 10
# AR2
int s1/0/0
ospf network-type p2p
# AR3
int s1/0/0
ospf network-type p2p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验五ospf支持的第5种网络-虚链接&#34;&gt;实验五：OSPF支持的第5种网络--虚链接&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587475656438.png&#34; alt=&#34;实验四：OSPF支持的第5种网络--虚链接&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1
sys
sysname AR1
router id 1.1.1.1
ospf 10 
area 0
int lo 0
ip addr 1.1.1.1 32
ospf enable 10 area 0
int g0/0/0
ip addr 12.1.1.1 24
ospf enable 10 area 0
# AR2
sys
sysname AR2
router id 2.2.2.2
ospf 10 
area 0
area 10
int lo 0
ip addr 2.2.2.2 32
ospf enable 10 area 0
int g0/0/0
ip addr 12.1.1.2 24
ospf enable 10 area 0
int g0/0/1
ip addr 23.1.1.2 24
ospf enable 10 area 10
# AR3
sys
sysname AR3
router id 3.3.3.3
ospf 10 
area 10
# network 3.3.3.3 0.0.0.0
# network 23.1.1.3 0.0.0.0
# network 34.1.1.3 0.0.0.0
int lo 0
ip addr 3.3.3.3 32
ospf enable 10 area 10
int g0/0/0
ip addr 23.1.1.3 24
ospf enable 10 area 10
int g0/0/1
ip addr 34.1.1.3 24
ospf enable 10 area 10
# AR4
sys
sysname AR4
router id 4.4.4.4
ospf 10 
area 10
area 20
int lo 0
ip addr 4.4.4.4 32
ospf enable 10 area 10
int g0/0/0
ip addr 34.1.1.4 24
ospf enable 10 area 10
int g0/0/1
ip addr 45.1.1.4 24
ospf enable 10 area 20
# AR5
sys
sysname AR5
router id 5.5.5.5
ospf 10 
area 20
int lo 0
ip addr 5.5.5.5 32
ospf enable 10 area 20
int g0/0/0
ip addr 45.1.1.5 24
ospf enable 10 area 20

#查看OSPF的邻居和路由表
dis ospf peer br
dis ip rou pro ospf
# 邻居关系正常
# 路由关系。AR1仅有到AR2/3/4的路由，AR2仅有到AR1/3/4的路由，AR3仅有到AR1/2/4的路由，AR4有到AR1/2/3/4的路由。原因：Area20没有连接到骨干区域，无法相互学习路由。
# 解决方法：配置虚连接。虚连接只能在ABR上配置.
# AR2
ospf 10
area 10
vlink-peer 4.4.4.4
# AR4
ospf 10
area 10
vlink-peer 2.2.2.2
# 此时在去查看路由表就有5.5.5.5的路由了
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验六计算最短路径树-物理拓扑&#34;&gt;实验六：计算最短路径树--物理拓扑&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1587656565056.png&#34; alt=&#34;实验拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1587656583594.png&#34; alt=&#34;有向图&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# AR1
sys
sys AR1
ospf 10 route 1.1.1.1
area 0
int lo 0
ip addr 1.1.1.1 32
ospf enable 10 area 0
int s1/0/1
ip addr 10.1.1.1 30
ospf enable 10 area 0
int s1/0/0
ip addr 10.5.1.1 30
ospf cost 1562
ospf enable 10 area 0

# AR2
sys
sys AR2
ospf 10 route 2.2.2.2
area 0
int lo 0
ip addr 2.2.2.2 32
ospf enable 10 area 0
int g0/0/0 
ip addr 10.3.1.1 24
ospf enable 10 area 0
int s1/0/1
ip addr 10.2.1.1 30
ospf enable 10 area 0

# AR3
sys
sys AR3
ospf 10 route 3.3.3.3
area 0
int lo 0
ip addr 3.3.3.3 32
ospf enable 10 area 0
int g0/0/0 
ip addr 10.3.1.2 24
ospf enable 10 area 0

# AR4
sys
sys AR4
ospf 10 route 4.4.4.4
area 0
int lo 0
ip addr 4.4.4.4 32
ospf enable 10 area 0
int s1/0/1
ip addr 10.4.1.1 30
ospf cost 1562
ospf enable 10 area 0
int g0/0/0 
ip addr 10.3.1.3 24
ospf enable 10 area 0

# 查看数据库
dis ospf lsdb
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实验七ospf综合实验&#34;&gt;实验七：OSPF综合实验&lt;/h2&gt;
&lt;h3 id=&#34;实验要求&#34;&gt;实验要求&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;配置AR1/AR2/AR3/AR14的OSPF区域0，要求最快收敛&lt;/li&gt;
&lt;li&gt;将R2的环回口Lo10引入OSPF区域，R10的环回口Lo10宣告进RIP&lt;/li&gt;
&lt;li&gt;将R7/R8的环回口的10网段引入进OSPF，其他非Area 40区域不能看到10网段的明细路由；Area40不能有2/3/4/5类LSA，（默认路由除外），但是可以访问100.100.100.100&lt;/li&gt;
&lt;li&gt;Area0做MD5认证，密码为QYT@123&lt;/li&gt;
&lt;li&gt;R5将RIP引入OSPF路由，其他各站点都可以访问100.100.100.100&lt;/li&gt;
&lt;li&gt;R2的环回口Lo10通过串行路访问100.100.100.100网络，串行链路出现故障后要通过R4-R9-R1访问&lt;/li&gt;
&lt;li&gt;全网互通&lt;br&gt;
&lt;code&gt;备注：每个设备都配置Lo0接口为router-id，Lo0接口的地址为x.x.x.x/32，例如R1的地址为1.1.1.1/32&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1588439419294.png&#34; alt=&#34;实验七：OSPF综合实验&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ........................................预配置：配置IP地址并配置OSPF区域
#AR1
sys
sys AR1
router id 1.1.1.1
int lo 0
ip addr 1.1.1.1 32
int s1/0/0
ip addr 172.16.10.1 24
int g0/0/0
ip addr 15.1.1.1 24
int g0/0/1
ip addr 19.1.1.1 24
ospf 10
area 0 
net 1.1.1.1 0.0.0.0
net 172.16.10.1 0.0.0.0
area 10 
net 15.1.1.1 0.0.0.0
area 50
net 19.1.1.1 0.0.0.0
#AR2
sys
sys AR2
router id 2.2.2.2
int lo 0
ip addr 2.2.2.2 32
int lo 0
ip addr 22.22.22.22 32
int s1/0/0
ip addr 172.16.20.2 24
int g0/0/0
ip addr 24.1.1.2 24
ospf 10
area 0 
net 2.2.2.2 0.0.0.0
net 172.16.20.2 0.0.0.0
area 20 
net 24.1.1.2 0.0.0.0
#AR3
sys
sys AR3
router id 3.3.3.3
int lo 0
ip addr 3.3.3.3 32
int s1/0/0
ip addr 172.16.30.3 24
int g0/0/0
ip addr 36.1.1.3 24
ospf 10
area 0 
net 3.3.3.3 0.0.0.0
net 172.16.30.3 0.0.0.0
area 30 
net 36.1.1.3 0.0.0.0
#AR4
sys
sys AR4
router id 4.4.4.4
int lo 0
ip addr 4.4.4.4 32
int g0/0/0
ip addr 24.1.1.4 24
int g0/0/1
ip addr 49.1.1.4 24
ospf 10
area 20
net 4.4.4.4 0.0.0.0
net 24.1.1.4 0.0.0.0
net 49.1.1.4 0.0.0.0
#AR5
sys
sys AR5
router id 5.5.5.5
int lo 0
ip addr 5.5.5.5 32
int g0/0/0
ip addr 15.1.1.5 24
int g0/0/1
ip addr 51.1.1.5 24
ospf 10
area 10
net 5.5.5.5 0.0.0.0
net 15.1.1.5 0.0.0.0
#AR6
sys
sys AR6
router id 6.6.6.6
int lo 0
ip addr 6.6.6.6 32
int g0/0/0
ip addr 36.1.1.6 24
int g0/0/1
ip addr 192.168.10.6 24
ospf 10
area 30
net 6.6.6.6 0.0.0.0
net 36.1.1.6 0.0.0.0
area 40
net 192.168.10.6 0.0.0.0
#AR7
sys
sys AR7
router id 7.7.7.7
int lo 0
ip addr 7.7.7.7 32
int lo 10
ip addr 10.1.0.1 24
int lo 11
ip addr 10.1.1.1 24
int g0/0/0
ip addr 192.168.10.7 24
ospf 10
area 40
net 7.7.7.7 0.0.0.0
net 192.168.10.7 0.0.0.0
#AR8
sys
sys AR8
router id 8.8.8.8
int lo 0
ip addr 8.8.8.8 32
int lo 10
ip addr 10.1.2.1 24
int lo 11
ip addr 10.1.3.1 24
int g0/0/0
ip addr 192.168.10.8 24
ospf 10
area 40
net 8.8.8.8 0.0.0.0
net 192.168.10.8 0.0.0.0
#AR9
sys
sys AR9
router id 9.9.9.9
int lo 0
ip addr 9.9.9.9 32
int g0/0/0
ip addr 19.1.1.9 24
int g0/0/1
ip addr 49.1.1.9 24
ospf 10
area 20
net 9.9.9.9 0.0.0.0
net 49.1.1.9 0.0.0.0
area 50
net 19.1.1.9 0.0.0.0
#AR10
sys
sys AR10
router id 10.10.10.10
int lo 0
ip addr 10.10.10.10 32
int lo 10
ip addr 100.100.100.100 32
int g0/0/0
ip addr 51.1.1.10 24
#AR14
sys
sys AR3
router id 14.14.14.14
int lo 0
ip addr 14.14.14.14 32
int s1/0/0
ip addr 172.16.10.14 24
int s1/0/1
ip addr 172.16.20.14 24
int s2/0/0
ip addr 172.16.30.14 24
ospf 10
area 0
net 14.14.14.14 0.0.0.0
net 172.16.10.14 0.0.0.0
net 172.16.20.14 0.0.0.0
net 172.16.30.14 0.0.0.0
# 1. 配置AR1/AR2/AR3/AR14的OSPF区域0，要求最快收敛
# AR1/2/3/14在预配置中已经配置过

# 2. 将R2的环回口Lo10引入OSPF区域，R10的环回口Lo10宣告进RIP
# AR2
acl 2001
rule permit source 22.22.22.22 0
q
route-policy Import-dir permit node 10
if-match acl 2001
ospf 10
import-route direct route-policy Import-dir 
# AR10
rip
ver 2
undo summary
net 51.0.0.0
net 100.0.0.0

# 3. 将R7/R8的环回口的10网段引入进OSPF，其他非Area 40区域不能看到10网段的明细路由；Area40不能有2/3/4/5类LSA，（默认路由除外），但是可以访问100.100.100.100
# AR7
acl 2001
rule permit source 10.1.0.0 0.0.3.255
q
route-policy Import-dir permit node 10
if-match acl 2001
ospf 10
import-route direct route-policy Import-dir
area 40
nssa
int g0/0/0
ospf network-type p2mp
# AR8
acl 2001
rule permit source 10.1.0.0 0.0.3.255
route-policy Import-dir permit node 10
if-match acl 2001
ospf 10
import-route direct route-policy Import-dir
area 40
nssa
int g0/0/0
ospf network-type p2mp
# AR6
ospf 10
asbr-summary 10.1.0.0 255.255.252.0  # 如果不想让其他区域看到明细路由，需要在ASBR上使用五类LSA汇总
area 40
nssa no-summary
int g0/0/1
ospf network-type p2mp
ospf 10
area 30
vlink-peer 3.3.3.3
# AR3
ospf 10
area 30
vlink-peer 6.6.6.6

# 5. R5将RIP引入OSPF路由，其他各站点都可以访问100.100.100.100
# AR5
# 需要双向引入，不然无法访问100.100.100.100
ospf 10
import-route rip
rip
import-route ospf 10

# 6. R2的环回口Lo10通过串行路访问100.100.100.100网络，串行链路出现故障后要通过R4-R9-R1访问
# AR2为什么不能自行选择R4-R9-R1这条路呢？OSPF的防环机制，两个非骨干区域之间发布路由信息，即区域20和50之间无法相互之间发布路由信息，导致区域20和50无法通信。
# AR2
ospf 10
area 20 
vlink-peer 9.9.9.9
# AR9
ospf 10
area 20
vlink-peer 2.2.2.2
area 50 
vlink-peer 1.1.1.1
# AR1
ospf 10
area 50 
vlink-peer 9.9.9.9
# AR2
int g0/0/0
ospf cost 200
# AR1
int g0/0/1
ospf cost 200

# 4. Area0做MD5认证，密码为QYT@123
# AR1/2/3/14/9/6
ospf 10
area 0
authentication-mode md5 1 QYT@123
&lt;/code&gt;&lt;/pre&gt;
">02 OSPF（2020.0415）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/01-na-hui-gu/"" data-c="
          &lt;h1 id=&#34;电子书籍准备&#34;&gt;电子书籍准备&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;TCP/IP路由技术卷1（IGP）&lt;/li&gt;
&lt;li&gt;TCP/IP路由技术卷2（BGP）&lt;/li&gt;
&lt;li&gt;OSPF/ISIS详解&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;hcie重认证以及考试&#34;&gt;HCIE重认证以及考试&lt;/h1&gt;
&lt;p&gt;证书有效期2年，重认证3年，如在证书有效期2年内通过重认证，证书有效期刷新自成绩发布起计算2年；如在缓冲期1年内通过重认证，证书有效期刷新自原证书截止日起计算2年。&lt;br&gt;
证书挂靠，&amp;gt;4000/年，挂靠除了经济利益之后，升级设备系统或者下载ensp都需要挂靠之后才能取得相应权限。&lt;br&gt;
需要双证，第一证件（身份证、驾照、军官证等）和第二证件或者两个第一证件。&lt;/p&gt;
&lt;h1 id=&#34;hcie考试&#34;&gt;HCIE考试&lt;/h1&gt;
&lt;p&gt;笔试：90min，600/1000&lt;br&gt;
实验：480min，80/100，上午（3hour）排错和诊断，下午（5hour）环境搭建&lt;br&gt;
面试：60min，通过/不通过，3道题（项目，最重要，时间最长，注意措辞；2道理论）&lt;/p&gt;
&lt;h1 id=&#34;课程内容&#34;&gt;课程内容&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;IGP路由（OSPF和ISIS以及路由控制）&lt;/li&gt;
&lt;li&gt;BGP部分&lt;/li&gt;
&lt;li&gt;交换知识&lt;/li&gt;
&lt;li&gt;MPLS VPN&lt;/li&gt;
&lt;li&gt;QoS&lt;/li&gt;
&lt;li&gt;组播&lt;/li&gt;
&lt;li&gt;IPv6&lt;/li&gt;
&lt;li&gt;IPSEC VPN技术&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;组织&#34;&gt;组织&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;ISO：国际标准化组织。OSI七层模型&lt;/li&gt;
&lt;li&gt;IEEE：国际电子电气工程协会。定义二层标准，例如802.1D、802.1w、802.1s、802.11&lt;/li&gt;
&lt;li&gt;IETF：互联网工程任务组。定义RFC文档&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;知识点&#34;&gt;知识点&lt;/h1&gt;
&lt;h2 id=&#34;网络模型&#34;&gt;网络模型&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;冲突域：CSMA\CD，发送数据之前先侦听，先听后发，边发边听，冲突停发，延迟后发&lt;/li&gt;
&lt;li&gt;广播域：处在同一个逻辑组，属于二层概念&lt;/li&gt;
&lt;li&gt;OSI七层协议：
&lt;ol&gt;
&lt;li&gt;物理层：传输比特流，规定电平、速率、针脚等，物理设备有双绞线、集线器、中继器、RJ45、同轴电缆、无线电波、光纤&lt;/li&gt;
&lt;li&gt;数据链路层：传输数据帧，Mac，二层交换机&lt;/li&gt;
&lt;li&gt;网络层：传输数据包（报文），IP等，路由器，三层交换机&lt;code&gt;路由器和三层交换机的区别：本质上，路由器的本质是路由转发，三层交换机的本质是数据转发；功能上，路由器有VPN和NAT；使用上，内部网络用交换机，外部网络上用路由器；接口上，路由器可以接串口线，但是交换机没有&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;传输层：传输数据段，TCP（面向连接）/UDP（无连接）等，端到端的连接，建立、维护、拆除连接的功能&lt;/li&gt;
&lt;li&gt;会话层：向两个实体提供建立连接和使用连接的方法&lt;/li&gt;
&lt;li&gt;表示层：编码，数据格式转换，加解密&lt;/li&gt;
&lt;li&gt;应用层：应用数据，直接面向用户&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;TCP/IP
&lt;ol&gt;
&lt;li&gt;网络接口层：对应OSI物理层和数据链路层&lt;/li&gt;
&lt;li&gt;网络层：对应OSI网络层&lt;/li&gt;
&lt;li&gt;传输层：对应OSI传输层&lt;/li&gt;
&lt;li&gt;应用层：对应OSI剩下三层&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二层数据链路层&#34;&gt;二层：数据链路层&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;当Type字段值&amp;lt;=1500(0x5DC)时为802.3，&amp;gt;=1536(0x0600)为Ethernet Ⅱ 以太帧&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;ethernet-ii-以太帧&#34;&gt;Ethernet Ⅱ 以太帧&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;帧格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586671980508.png&#34; alt=&#34;Ethernet Ⅱ 以太帧&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;Type值对应的协议&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586672267977.png&#34; alt=&#34;Type值对应的协议&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;8023-llc-snap以太帧&#34;&gt;802.3 LLC SNAP以太帧&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;帧格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586672668442.png&#34; alt=&#34;802.3 LLC SNAP以太帧&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mac地址&#34;&gt;MAC地址&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;长度&lt;br&gt;
6字节（48bit）:前24比特是OUI（厂商标识符），例如AA-BB-CC为思科的标识；后24字节为厂商自定义。&lt;/li&gt;
&lt;li&gt;三种数据帧&lt;br&gt;
&lt;code&gt;BUM报文：未知单播帧、广播帧、组播帧的统称，收到BUM报文之后进行泛洪处理&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;单播&lt;code&gt;第1个字节的第8个比特为0&lt;/code&gt;&lt;br&gt;
已知单播帧，在交换机表项中，根据CAM表项直接转发（三层交换机也维护一张用于二层交换的地址表（通常称为CAM表），该表是MAC地址与出接口的对应关系）&lt;br&gt;
未知单播帧，不在交换机表项中，泛洪&lt;/li&gt;
&lt;li&gt;组播&lt;code&gt;第1个字节的第8个比特为1&lt;/code&gt;&lt;br&gt;
泛洪，常见组播帧：01-00-5E-xx-xx-xx（IP二层组播地址），33-33-33-xx-xx-xx（IPv6二层组播地址）等等，具体请参考以下两个链接:&lt;a href=&#34;http://standards.ieee.org/develop/regauth/oui/oui.txt&#34;&gt;IEEE分配的OUI&lt;/a&gt;，&lt;a href=&#34;http://standards.ieee.org/develop/regauth/grpmac/public.html&#34;&gt;组播地址完整列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;广播&lt;code&gt;FF-FF-FF-FF-FF-FF&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;交换机的工作机制&lt;br&gt;
交换机根据源MAC地址进行学习，构建CAM表项。收到数据帧根据目的MAC，查找CAM表项，如果匹配直接进行转发，否则进行泛洪。&lt;br&gt;
MAC地址表的老化时间：300秒&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三层网络层&#34;&gt;三层：网络层&lt;/h2&gt;
&lt;h3 id=&#34;ip&#34;&gt;IP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;IP报文格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586683555901.png&#34; alt=&#34;IP报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;特殊的IP地址
&lt;ol&gt;
&lt;li&gt;默认路由：0.0.0.0/32&lt;/li&gt;
&lt;li&gt;环回地址：127.0.0.0/8&lt;/li&gt;
&lt;li&gt;DHCP获取失败产生的地址（Windows）：169.254.0.0/16&lt;/li&gt;
&lt;li&gt;广播地址：255.255.255.255&lt;/li&gt;
&lt;li&gt;定向广播（即子网内广播）：网段192.168.10.0/24内的广播地址为192.168.10.255&lt;/li&gt;
&lt;li&gt;DHCP请求报文的源地址：0.0.0.0/32&lt;/li&gt;
&lt;li&gt;私有地址：A类-10.0.0.0-10.255.255.255；B类-172.16.0.0-172.31.255.255；C类-192.168.0.0-192.168.255.255&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;arprarp反向arp&#34;&gt;ARP/RARP(反向ARP)&lt;/h3&gt;
&lt;p&gt;严格来讲属于2.5层&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ARP报文格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586687019846.png&#34; alt=&#34;ARP报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;MAC地址表和ARP表的区别&lt;/strong&gt;？MAC地址表，老化时间300s(5m)，二层转发，接口和MAC关联；ARP地址表：老化时间1200s(20m)，IP和MAC关联&lt;br&gt;
&lt;strong&gt;交换机的一个接口是否可以关联多个MAC&lt;/strong&gt;？可以。交换机A接口1连接交换机B接口2，交换机B上连接n台设备，此时交换机A的接口1可以学习到交换机B上连接的那n台设备的mac地址&lt;br&gt;
&lt;strong&gt;交换机的多个接口是否可以关联一个MAC&lt;/strong&gt;？不可以。否则mac地址震荡(flapping)&lt;br&gt;
&lt;strong&gt;总结&lt;/strong&gt;：一个接口对应多个mac，一个mac只能对应一个接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;ARP分类
&lt;ol&gt;
&lt;li&gt;免费ARP：用来检测IP地址冲突；在VRRP时使用（在主机没有配置网关时）；通过让网关定期发送免费ARP来防护MAC地址欺骗；通过定期发送免费ARP报文来防止ARP表项的老化。华为设备首先发送 Arp Request报文，思科首先发送Arp Reply报文，如果收到响应，则IP地址冲突&lt;/li&gt;
&lt;li&gt;ARP代理：局域网中，终端没有配置网关的情况下，请求的目标地址在路由器或者交换机的路由表中，则由路由器或者交换机代替目标地址作为应答。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;icmp&#34;&gt;ICMP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;报文格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586869806360.png&#34; alt=&#34;ICMP报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;ICMP重定向&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586870449526.png&#34; alt=&#34;ICMP重定向&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在同一个局域网中，网关和数据的下一跳在同一个网段中，从该接口收到的数据要从该接口再发送出去&lt;br&gt;
解决次优路径问题，ICMP报文中类型为5，代码为0&lt;/li&gt;
&lt;li&gt;tracert和traceroute区别&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;traceroute是Linux场景。发送的是UDP报文，端口号大于30000。第一个报文端口是33434，ttl=1；第一个报文端口是33435，ttl=2；......未到达目的之前回应的ICMP传输期间生存为0报文，达到目的主机之后，目的主机回应端口不可达&lt;/li&gt;
&lt;li&gt;tracert是Windows场景。发送的是ICMP request报文（请求回显），第一次报文ttl=1,第二次报文为ttl=2,......未到达目的之前回应的ICMP传输期间生存为0报文，达到目的主机之后，目的主机回应回显应答报文&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四层传输层&#34;&gt;四层：传输层&lt;/h2&gt;
&lt;h3 id=&#34;tcp&#34;&gt;TCP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;报文格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586789606098.png&#34; alt=&#34;TCP报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;3次握手&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586789787744.png&#34; alt=&#34;3次握手&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;第1次握手&lt;/strong&gt;：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）&lt;br&gt;
&lt;strong&gt;第2次握手&lt;/strong&gt;：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态&lt;br&gt;
&lt;strong&gt;第3次握手&lt;/strong&gt;：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手&lt;/li&gt;
&lt;li&gt;4次挥手&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586790128740.png&#34; alt=&#34;4次挥手&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;第1次挥手&lt;/strong&gt;：客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。&lt;br&gt;
&lt;strong&gt;第2次挥手&lt;/strong&gt;：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。&lt;br&gt;
&lt;strong&gt;第3次挥手&lt;/strong&gt;：服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。&lt;br&gt;
&lt;strong&gt;第4次挥手&lt;/strong&gt;：客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。&lt;/li&gt;
&lt;li&gt;常见问题
&lt;ol&gt;
&lt;li&gt;为什么连接的时候是三次握手，关闭的时候却是四次握手？&lt;br&gt;
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，&amp;quot;你发的FIN报文我收到了&amp;quot;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。&lt;/li&gt;
&lt;li&gt;为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？&lt;br&gt;
虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。&lt;/li&gt;
&lt;li&gt;为什么不能用两次握手进行连接？&lt;br&gt;
3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。&lt;/li&gt;
&lt;li&gt;如果已经建立了连接，但是客户端突然出现故障了怎么办？&lt;br&gt;
TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;udp&#34;&gt;UDP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;报文格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586790595378.png&#34; alt=&#34;UDP报文格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;数据传输过程&#34;&gt;数据传输过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1586869107436.png&#34; alt=&#34;数据传输过程&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;第一阶段：判断新浪网是否在同一网段&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果在同一网段，直接进行2层转发&lt;/li&gt;
&lt;li&gt;如果不在一个网段，则需要进行3层转发（进入第二阶段）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;第二阶段：查找网关&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果本地有网关的mac，直接封装数据发送至网关（进入第三阶段）&lt;/li&gt;
&lt;li&gt;如果本地没有网关mac，&lt;br&gt;
则会发送ARP请求(源IP为PC1的IP,源mac为PC1的mac,目的IP为AR1-g0/0/0的IP,目的mac为全F),&lt;br&gt;
网关回复ARP请求(源IP为AR1的IP,源mac为AR1-g0/0/0的mac,目的IP为PC1的IP,目的mac为PC1的mac),&lt;br&gt;
PC1封装数据发送至网关(源IP为PC1的IP,源MAC为PC1的mac,目的IP为server的IP,目的mac为AR1-g0/0/0的mac),&lt;br&gt;
（进入第三阶段）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;第三阶段：数据传输&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;网关已经设置NAT：&lt;br&gt;
AR1如果有AR2的mac直接封装数据发送，否则进行ARP。&lt;br&gt;
数据封装发送（源IP为AR1-g0/0/1的IP，源mac为AR1-g0/0/1的mac,目的IP为新浪服务器IP，目的mac为AR2-g0/0/1的mac）&lt;br&gt;
（进入第四阶段）&lt;/li&gt;
&lt;li&gt;网关没有设置NAT：&lt;br&gt;
AR1如果有AR2的mac直接封装数据发送，否则进行ARP。&lt;br&gt;
数据封装发送（源IP为PC1的IP，源mac为AR1-g0/0/1的mac,目的IP为新浪服务器IP，目的mac为AR2-g0/0/1的mac）&lt;br&gt;
（进入第四阶段）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;第四阶段：数据到达服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;AR3到AR4,AR4至SW1,SW1至新浪服务器之间的数据传输源目IP不变，但是mac地址为传输段两端的mac&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;五层应用层&#34;&gt;五层：应用层&lt;/h2&gt;
&lt;h3 id=&#34;rip&#34;&gt;RIP&lt;/h3&gt;
&lt;h4 id=&#34;rip的计时器&#34;&gt;RIP的计时器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;更新定时器：30s，会更新本地路由表给邻居&lt;/li&gt;
&lt;li&gt;老化定时器：180s，如果180s没有收到邻居发送过来的更新报文，会认为该路由失效（不可达，但不删除）&lt;/li&gt;
&lt;li&gt;垃圾收集定时器：120s，在路由标记为无效后不会立刻从路由表中删除，只是会标记为不可达，再经过I垃圾收集定时器才会从路由表中删除&lt;/li&gt;
&lt;li&gt;抑制定时器：华为默认0&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;其他rip相关知识&#34;&gt;其他RIP相关知识&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;RIP的16跳即不可达&lt;/li&gt;
&lt;li&gt;RIP是UDP协议承载的，端口号是520&lt;/li&gt;
&lt;li&gt;RIP两种报文传播方式：广播和组播（地址224.0.0.9）&lt;/li&gt;
&lt;li&gt;RIP的防环：
&lt;ul&gt;
&lt;li&gt;水平分割：从一个接口收到的路由不会再从该接口发送出去&lt;/li&gt;
&lt;li&gt;毒性反转：从一个接口收到的路由，会从该接口发送会去，但是跳数改为16&lt;/li&gt;
&lt;li&gt;触发更新：只要路由信息发生变化，就立刻更新出去&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ftp协议&#34;&gt;FTP协议&lt;/h2&gt;
&lt;p&gt;端口：21（控制）和20（主动模式数据传输）&lt;/p&gt;
&lt;h3 id=&#34;工作方式&#34;&gt;工作方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主动模式：PORT方式，Standard。首先客户端主动与服务器的21端口建立连接，然后服务器使用任意端口主动连接客户端的20端口。&lt;/li&gt;
&lt;li&gt;被动模式：PASV方式，Passive。首先客户端主动与服务器的21端口建立连接，然后服务器随机开放一个端口（&amp;gt;1023），通知客户端来连接本端口，最后客户端去连接那个端口进行数据传输。&lt;code&gt;如果客户端与服务器中间有防火墙，建议服务器使用被动模式&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;路由协议&#34;&gt;路由协议&lt;/h2&gt;
&lt;h3 id=&#34;路由协议的分类&#34;&gt;路由协议的分类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;按照工作的范围：
&lt;ul&gt;
&lt;li&gt;IGP内部网关协议：RIP、OSPF、ISIS、EIGRP（思科）&lt;/li&gt;
&lt;li&gt;EGP外部网关协议：BGP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按照工作原理：
&lt;ul&gt;
&lt;li&gt;距离矢量：RIP（贝尔曼斯特算法）、EIGRP（弥散修正算法DUAL）、BGP（路径矢量算法，一跳为一个AS）&lt;/li&gt;
&lt;li&gt;链路状态：OSPF（SPF，迪杰科斯特拉算法）、ISIS（SPF算法）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;按照更新时是否携带掩码：
&lt;ul&gt;
&lt;li&gt;有类（不带掩码，使用默认的ABC类）：RIPv1&lt;/li&gt;
&lt;li&gt;无类（带掩码）：RIPv2、OSPF、ISIS、EIGRP、BGP等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;静态路由和默认路由的区别&#34;&gt;静态路由和默认路由的区别&lt;/h3&gt;
&lt;p&gt;默认路由是静态路由的一种，默认路由是0.0.0.0 0.0.0.0。&lt;br&gt;
&lt;code&gt;思科的管理距离==华为的优先级&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;静态路由配置&#34;&gt;静态路由配置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;指明&lt;strong&gt;下一跳&lt;/strong&gt;：意为着目标网络本地不可达，请求的是下一跳的地址**（在以太网中配置下一跳）**&lt;/li&gt;
&lt;li&gt;指明&lt;strong&gt;出接口&lt;/strong&gt;：意为着目标网络本地可达，请求的是出接口的地址**（在PPP链路中配置出接口）**&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;迭代路由递归路由&#34;&gt;迭代路由（递归路由）&lt;/h3&gt;
&lt;p&gt;对于需要迭代的路由，其下一跳不在路由器直连的网段内。在转发时，必须将此非直连下一跳地址做一次或多次迭代处理，以找出一个直连的下一跳地址，从而进行二层寻径。使用迭代的路由可以是静态路由、BGP路由。路由迭代功能可以使路由表项比较灵活，不依赖于特定的接口。缺省情况下，BGP协议学到的路由和手工配置的路由都支持迭代功能。&lt;/p&gt;
&lt;h3 id=&#34;rib和fib&#34;&gt;RIB和FIB&lt;/h3&gt;
&lt;p&gt;RIB：路由信息数据库&lt;br&gt;
FIB：转发信息数据库&lt;/p&gt;
&lt;h4 id=&#34;不同设备上rib和fib的区别&#34;&gt;不同设备上RIB和FIB的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;框式设备：FIB和RIB分离。SPU，主控板卡，控制层面，必须配置，一般两块作为主备，负责构建RIB，形成FIB，将FIB下发到每个LPU；LPU，业务板卡，转发层面，可以不配置&lt;/li&gt;
&lt;li&gt;盒式设备：RIB和FIB在同一台设备上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;负载分担和负载均衡&#34;&gt;负载分担和负载均衡&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;负载均衡：n条链路同发同收，每条链路承载1/n&lt;/li&gt;
&lt;li&gt;负载分担：n条链路按照比例进行分担，例如带宽大的负载大，带宽小的负载小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;路由的选路&#34;&gt;路由的选路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;从不同协议学习到同一条路由，该如何选路？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;华为路由协议有两种优先级：外部优先级和内部优先级&lt;/li&gt;
&lt;li&gt;外部：比较优先级，越小越优；优先级相同，会比较内部优先级，越小越优（&lt;strong&gt;华为设备只能改外部优先级(preference)，内部优先级无法更改&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;路由协议的优先级：
&lt;ul&gt;
&lt;li&gt;外部：直连（0）、OSPF（10）、ISIS（15）、静态（60）、RIP（100）、OSPF AES和OSPF NSSA（150）、IBGP和EBGP（255）&lt;/li&gt;
&lt;li&gt;内部：直连（0）、OSPF（10）、ISIS Level1（15）、ISIS Level2（18）、EBGP（20）、静态（60）、RIP（100）、OSPF AES和OSPF NSSA（150）、IBGP（200）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如果去往目标网络在本地有多条路由可以匹配，如何选路？&lt;br&gt;
最长匹配原则：掩码越精细越好，如果都不匹配则会优选默认路由&lt;/li&gt;
&lt;li&gt;如果从同一协议不同接口学习到同一路由，该如何选路？&lt;br&gt;
会比较开销值，越小越优；如果开销值相等，都加入路由表，进行负载均衡&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;零散知识点&#34;&gt;零散知识点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;VLAN&lt;br&gt;
VLAN：隔离广播域&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586956460368.png&#34; alt=&#34;Vlan帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;三种生成树&lt;br&gt;
802.1D传统生成树STP(对应思科的PVST+，每个VLAN一棵树)&lt;br&gt;
802.1w快速生成树RSTP（对应思科RPST+）&lt;br&gt;
802.1s多实例生成树MSTP&lt;br&gt;
VBST（仅仅华为交换机，为了与思科交换机进行对接）&lt;/li&gt;
&lt;li&gt;Eth-trunk（链路聚合）&lt;br&gt;
华为有两种：normal(手工)、LACP&lt;br&gt;
思科有两种：PAGP（私有）、LACP&lt;/li&gt;
&lt;li&gt;VRRP升级版&lt;br&gt;
思科是HSRP，华为为GLBP&lt;/li&gt;
&lt;li&gt;VRRP和Eth-trunk的区别&lt;br&gt;
&lt;code&gt;vrrp主要是备份；eth-trunk主要是负载&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Vrrp利用率低。两条上联线路正常的话只用一条，而eth-trunkl两条都跑流量&lt;/li&gt;
&lt;li&gt;vrrp需要配合STP，所以需要一定的收敛时间&lt;/li&gt;
&lt;li&gt;管理维护方便，做eth-trunk一般核心交换机都采用集群方式，相当于一台设备，所以配置管理方便&lt;/li&gt;
&lt;li&gt;做集群，两台核心交换机之间的互联带宽更高&lt;/li&gt;
&lt;li&gt;做集群，主备交换机切换时间很短&lt;/li&gt;
&lt;li&gt;使用场景区分：有二台核心，要和接入做双机热备，但不支持堆叠或集群，这时候只能用VRRP+STP了，不是用Eth-Trunk。如果核心支持堆叠或集群的话，这时候核心和接入就做Eth-Trunk了，而不用VRRP了，因为核心堆叠后就成一台设备了，二台设备之间的双链路，肯定用Eth-Trunk更好。&lt;/li&gt;
&lt;/ul&gt;
">01 NA回顾（2020.0411）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/win7-nei-cun-bu-neng-read/"" data-c="
          &lt;p&gt;解决方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用组合快捷键&lt;code&gt;win+r&lt;/code&gt;打开运行窗口，输入&lt;code&gt;cmd&lt;/code&gt;回车确认打开运行窗口&lt;/li&gt;
&lt;li&gt;在打开的命令窗口中输入&lt;code&gt;for %1 in (%windir%\system32\*.dll) do regsvr32.exe /s %1&lt;/code&gt;回车确认&lt;/li&gt;
&lt;/ol&gt;
">win7内存不能read</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/centos7-she-zhi-dang-qian-yun-xing-ji-bie-he-mo-ren-yun-xing-ji-bie/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%B9%E7%82%B9&#34;&gt;特点&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;配置文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#systemd%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%8D%95%E4%BD%8Dunit%E5%88%86%E7%B1%BB&#34;&gt;systemd的服务单位unit分类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8systemctl%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1&#34;&gt;使用systemctl管理服务&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8D%95%E4%B8%80%E6%9C%8D%E5%8A%A1service%E7%9A%84%E5%90%AF%E5%8A%A8-%E8%87%AA%E5%90%AF-%E5%85%B3%E9%97%AD-%E7%8A%B6%E6%80%81%E6%9F%A5%E7%9C%8B&#34;&gt;单一服务(service)的启动、自启、关闭、状态查看&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E8%AF%BB&#34;&gt;命令格式和参数解读&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F&#34;&gt;命令格式：&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#status%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0%E8%A7%A3%E8%AF%BB&#34;&gt;status输出参数解读&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#loaded%E8%A1%8C&#34;&gt;Loaded行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#active%E8%A1%8C&#34;&gt;Active行&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%9F%A5%E7%9C%8B%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%89%80%E6%9C%89%E6%9C%8D%E5%8A%A1&#34;&gt;查看系统上所有服务&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E8%AF%BB-2&#34;&gt;命令格式和参数解读&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F-2&#34;&gt;命令格式：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AE%A1%E7%90%86%E4%B8%8D%E5%90%8C%E7%9A%84%E6%93%8D%E4%BD%9C%E7%8E%AF%E5%A2%83target&#34;&gt;管理不同的操作环境(target)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8target%E4%BB%8B%E7%BB%8D&#34;&gt;常用target介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E5%92%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E8%AF%BB-3&#34;&gt;命令格式和参数解读&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F-3&#34;&gt;命令格式：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E6%9E%90%E5%90%84%E6%9C%8D%E5%8A%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BE%9D%E8%B5%96%E6%80%A7&#34;&gt;分析各服务之间的依赖性&lt;/a&gt;&lt;br&gt;
*
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F-4&#34;&gt;命令格式：&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8Esystemd%E7%9A%84daemon%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95%E7%AE%80%E4%BB%8B&#34;&gt;与systemd的daemon运行过程相关目录简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%85%B3%E9%97%AD%E7%BD%91%E7%BB%9C%E6%9C%8D%E5%8A%A1&#34;&gt;关闭网络服务&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#systemctl%E9%92%88%E5%AF%B9service%E7%B1%BB%E5%9E%8B%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;systemctl针对.service类型的配置文件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E7%9B%AE%E5%BD%95&#34;&gt;配置文件相关目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%AE%BE%E7%BD%AE%E9%A1%B9%E7%9B%AE&#34;&gt;配置文件的设置项目&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-2&#34;&gt;配置文件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BB%A5sshd%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%BA%E4%BE%8B&#34;&gt;以sshd配置文件为例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%89%E5%A4%A7%E9%A1%B9%E7%9B%AE%E8%AF%B4%E6%98%8E&#34;&gt;三大项目说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%AE%BE%E7%BD%AE%E8%A7%84%E5%88%99&#34;&gt;设置规则&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%82%E6%95%B0%E8%A7%A3%E9%87%8A&#34;&gt;参数解释&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#unit%E5%8F%82%E6%95%B0&#34;&gt;[Unit]参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#service%E5%8F%82%E6%95%B0&#34;&gt;[Service]参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#install%E5%8F%82%E6%95%B0&#34;&gt;[Install]参数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#systemctl%E9%92%88%E5%AF%B9timer%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&#34;&gt;systemctl针对timer的配置文件&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BC%98%E5%8A%BF&#34;&gt;优势&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8%E8%A6%81%E6%B1%82&#34;&gt;使用要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE&#34;&gt;配置&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BD%8D%E7%BD%AE&#34;&gt;配置文件位置&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8F%82%E6%95%B0&#34;&gt;配置文件参数&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#oncalendar%E7%9A%84%E6%97%B6%E9%97%B4&#34;&gt;OnCalendar的时间&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F&#34;&gt;基本格式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%B8%E7%94%A8%E7%9A%84%E9%97%B4%E9%9A%94%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D&#34;&gt;常用的间隔时间单位&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B&#34;&gt;使用举例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%8B%B1%E6%96%87%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%A3%E8%AF%AD%E5%8C%96%E6%97%A5%E6%9C%9F&#34;&gt;英文常用的口语化日期&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E5%88%B6%E5%AE%9E%E4%BE%8B&#34;&gt;配制实例&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BE%AA%E7%8E%AF%E8%BF%90%E8%A1%8C&#34;&gt;循环运行&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A6%81%E6%B1%82&#34;&gt;要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E5%88%B6%E6%96%87%E4%BB%B6&#34;&gt;配制文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%BA%E5%AE%9A%E6%97%A5%E6%9C%9F%E8%BF%90%E8%A1%8C&#34;&gt;固定日期运行&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A6%81%E6%B1%82-2&#34;&gt;要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%85%8D%E5%88%B6%E6%96%87%E4%BB%B6-2&#34;&gt;配制文件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;特点&#34;&gt;特点&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;并行处理所有服务，加速开机流程&lt;/li&gt;
&lt;li&gt;一经要求就相应的on-demand启动模式&lt;/li&gt;
&lt;li&gt;服务依赖性的自我检查&lt;/li&gt;
&lt;li&gt;依daemon功能分类&lt;/li&gt;
&lt;li&gt;将多个daemons集合为一个群组&lt;/li&gt;
&lt;li&gt;向下兼容 就有的init服务脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;配置文件&#34;&gt;配置文件&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;/usr/lib/systemd/system/：（优先级：低）每个服务最主要的启动脚本设置**（自定义启动服务脚本目录）**&lt;/li&gt;
&lt;li&gt;/run/systemd/system/：（优先级：中）系统执行过程中所产生的的服务脚本，这些脚本的优先级要比&lt;code&gt;/usr/lib/systemd/system/&lt;/code&gt;高&lt;/li&gt;
&lt;li&gt;/etc/systemd/system/：（优先级：高）管理员主机系统要求所建立的服务脚本，执行的优先级又比&lt;code&gt;/run/systemd/system/&lt;/code&gt;高&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;systemd的服务单位unit分类&#34;&gt;systemd的服务单位unit分类&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;.service&lt;/strong&gt;：一般服务类型，主要是系统服务，包括服务器本身所需要的的本地服务以及网络服务等，经常被使用到的服务大多数是此类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.socket&lt;/strong&gt;：内部数据程序交换socket服务，主要是IPC的传输信息socket文件功能。这种类型的服务通常在监控信息传递的socket文件中，当通过此socket文件传递信息要链接服务时，就根据当时的状态将该用户的要求传送到对应的daemon，若daemon尚未启动，则启动该daemon后再传送用户的要求。使用socket类型的服务一般较少用到，一般用于本地服务，例如图形界面的很多软件都是通过socket来进行本机程序数据交换的操作。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.target&lt;/strong&gt;：执行环境类型，其实是一群unit的集合。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.mount和.automount&lt;/strong&gt;：文件挂载相关的服务，例如来自网络的自动挂载、NFS文件系统挂载与文件系统相关性比较高的进程管理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.path&lt;/strong&gt;：检测特定文件或目录类型，某些服务需要检测某些特定的目录来提供队列服务，例如打印服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;.timer&lt;/strong&gt;：循环执行的服务，有点类似anacrontab。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;使用systemctl管理服务&#34;&gt;使用systemctl管理服务&lt;/h1&gt;
&lt;h2 id=&#34;单一服务service的启动-自启-关闭-状态查看&#34;&gt;单一服务(service)的启动、自启、关闭、状态查看&lt;/h2&gt;
&lt;h3 id=&#34;命令格式和参数解读&#34;&gt;命令格式和参数解读&lt;/h3&gt;
&lt;h4 id=&#34;命令格式&#34;&gt;命令格式：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;systemctl [command] [unit]&lt;/code&gt;&lt;br&gt;
command包含以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;start：启动unit&lt;/li&gt;
&lt;li&gt;stop：关闭unit&lt;/li&gt;
&lt;li&gt;restart：重新启动unit&lt;/li&gt;
&lt;li&gt;reload：不关闭unit的情况下，重新加载配置文件&lt;/li&gt;
&lt;li&gt;enable：设置下次开机时，自启动unit&lt;/li&gt;
&lt;li&gt;disable：取消开机自启动unit&lt;/li&gt;
&lt;li&gt;status：查看该unit的状态&lt;/li&gt;
&lt;li&gt;is-active：查看该unit是否在运行&lt;/li&gt;
&lt;li&gt;is-enable：查看该unit是否开机自启动&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;status输出参数解读&#34;&gt;status输出参数解读&lt;/h4&gt;
&lt;h5 id=&#34;loaded行&#34;&gt;Loaded行&lt;/h5&gt;
&lt;p&gt;显示开机是否自启动，enabled为自启动，否则不自启&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;enabled：unit开机被启动&lt;/li&gt;
&lt;li&gt;disabled：unit开机时不启动&lt;/li&gt;
&lt;li&gt;static：该unit不可以enable，即不可以自启动，但是可以被其他enabled的unit来唤醒，即依赖属性的服务&lt;/li&gt;
&lt;li&gt;mask：无法启动，该服务被注销（不是删除），可以通过systemctl unmask改回默认状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;active行&#34;&gt;Active行&lt;/h5&gt;
&lt;p&gt;显示unit目前的运行状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;active（running）：unit正在运行&lt;/li&gt;
&lt;li&gt;active（exited）：unit仅执行一次就结束，目前没有任何进程在系统中执行&lt;/li&gt;
&lt;li&gt;active（waiting）：unit正在执行中，不过需要等待触发事件发生才能继续执行&lt;/li&gt;
&lt;li&gt;inactive（dead）：unit未在运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;查看系统上所有服务&#34;&gt;查看系统上所有服务&lt;/h2&gt;
&lt;h3 id=&#34;命令格式和参数解读-2&#34;&gt;命令格式和参数解读&lt;/h3&gt;
&lt;h4 id=&#34;命令格式-2&#34;&gt;命令格式：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;systemctl [command] [--typr=TYPE] [-all]&lt;/code&gt;&lt;br&gt;
command包含以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list-units：依据unit显示目前启动的unit，若加上“-all”才会列出没启动的&lt;/li&gt;
&lt;li&gt;list-units-files：依据/usr/lib/systemd/system内的文件，将所有文件列表说明&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;TYPE包含以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;之前列出的unit类型，包含service、socket、target等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;管理不同的操作环境target&#34;&gt;管理不同的操作环境(target)&lt;/h2&gt;
&lt;h3 id=&#34;常用target介绍&#34;&gt;常用target介绍&lt;/h3&gt;
&lt;p&gt;Centos7中默认情况下有26个target（使用命令&lt;code&gt;systemctl list-units --type=target --all&lt;/code&gt;查看），而跟操作界面相关性比较高的target有下面几个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;graphical.target：图形界面模式，命令行+图形界面，已经包含multi-user.target&lt;/li&gt;
&lt;li&gt;multi-user.target：多用户模式，纯命令行模式&lt;/li&gt;
&lt;li&gt;rescue.target：恢复模式，在无法使用root登录的情况下，systemd在启动时会多加一个额外的临时系统，可以取得root权限来维护系统，但是此模式下需要使用chroot来取得原有的系统&lt;/li&gt;
&lt;li&gt;emergency.target：紧急恢复模式，无法使用rescue.target情况下，还需要使用root登录，可以尝试使用此模式&lt;/li&gt;
&lt;li&gt;shutdown.target：关机模式&lt;/li&gt;
&lt;li&gt;getty.target：修改配置文件来改变tty的数量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;命令格式和参数解读-3&#34;&gt;命令格式和参数解读&lt;/h3&gt;
&lt;h4 id=&#34;命令格式-3&#34;&gt;命令格式：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;systemctl [command] [unit.target]&lt;/code&gt;&lt;br&gt;
command包含以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;get-default：获取目前的target&lt;/li&gt;
&lt;li&gt;set-default：设置默认的target&lt;/li&gt;
&lt;li&gt;isolate：切换到某个target&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;切换操作模式的简单指令：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;systemctl poweroff：关机&lt;/li&gt;
&lt;li&gt;systemctl reboot：重启&lt;/li&gt;
&lt;li&gt;systemctl suspend：挂起，将系统的状态数据保存在内存中，然后关闭系统的大部分硬件，实际上并未关机，使用开机按钮唤醒，唤醒速度较快&lt;/li&gt;
&lt;li&gt;systemctl hibernate：休眠，将系统的状态数据保存在硬盘中，然后关闭系统，使用开机按钮唤醒，唤醒速度较慢&lt;/li&gt;
&lt;li&gt;systemctl rescue：恢复模式&lt;/li&gt;
&lt;li&gt;systemctl emergency：紧急恢复模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分析各服务之间的依赖性&#34;&gt;分析各服务之间的依赖性&lt;/h2&gt;
&lt;h4 id=&#34;命令格式-4&#34;&gt;命令格式：&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;systemctl list-dependencies [unit] [--reverse]&lt;/code&gt;&lt;br&gt;
参数解释：--reverse 反向追踪谁使用这个unit&lt;/p&gt;
&lt;h2 id=&#34;与systemd的daemon运行过程相关目录简介&#34;&gt;与systemd的daemon运行过程相关目录简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;/usr/lib/systemd/system/：官方软件默认的启动脚本存放位置，此处尽量不要修改，如果需要修改，请到目录/etc/systemd/system/&lt;/li&gt;
&lt;li&gt;/run/systemd/system/：系统执行过程中产生的服务脚本，优先级高于/usr/lib/systemd/system/&lt;/li&gt;
&lt;li&gt;/etc/systemd/system/：管理员依据主机系统需要所建立的脚本，优先级比/run/systemd/system/还高&lt;/li&gt;
&lt;li&gt;/etc/sysconfig/*：几乎所有的服务都会将初始化的一些选项设置写入到这个目录&lt;/li&gt;
&lt;li&gt;/var/lib/：一些会产生数据的服务都会将产生的数据写入到此目录中&lt;/li&gt;
&lt;li&gt;/run/：放置很多daemon的缓存，包括lock文件和pid文件等&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关闭网络服务&#34;&gt;关闭网络服务&lt;/h2&gt;
&lt;p&gt;关闭网络设备发现服务：avahi-daemon&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;netstat -tulnp
systemctl list-unit -all | grep avahi-daemon
systemctl stop avahi-daemon.service
systemctl stop avahi-daemon.socket
systemctl disable avahi-daemon.service avahi-daemon.socket
netstat -tulnp
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;systemctl针对service类型的配置文件&#34;&gt;systemctl针对.service类型的配置文件&lt;/h1&gt;
&lt;h2 id=&#34;配置文件相关目录&#34;&gt;配置文件相关目录&lt;/h2&gt;
&lt;p&gt;以vsftpd服务为例：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/usr/lib/systemd/system/vsftpd.service：官方发布的默认配置文件&lt;/li&gt;
&lt;li&gt;/etc/systemd/system/vsftpd.service.d/custom.conf：在/etc/systemd/system下面建立与配置文件相同文件名的目录，但是加上.d的扩展名，然后在该目录下建立配置文件即可，配置文件的扩展名最好是.conf。在这个目录下的文件会&lt;code&gt;累加其他设置&lt;/code&gt;到 /usr/lib/systemd/system/vsftpd.service中&lt;/li&gt;
&lt;li&gt;/etc/systemd/system/vsftpd.service.wants/*：此目录中的文件为链接文件，设置依赖服务的链接，意思是启动vsftpd.service之后，最好加上该目录下建议的服务&lt;/li&gt;
&lt;li&gt;/etc/systemd/system/vsftpd.service.requires/*：此目录中的文件为链接文件，设置依赖服务的链接，意思是启动vsftpd.service之前，需要事先启动该目录下的服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置文件的设置项目&#34;&gt;配置文件的设置项目&lt;/h2&gt;
&lt;h3 id=&#34;配置文件-2&#34;&gt;配置文件&lt;/h3&gt;
&lt;h4 id=&#34;以sshd配置文件为例&#34;&gt;以sshd配置文件为例&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;more /usr/lib/systemd/system/sshd.service
    [Unit]    # 这个项目与此unit的解释、执行服务依赖性有关
    Description=OpenSSH server daemon
    Documentation=man:sshd(8) man:sshd_config(5)
    After=network.target sshd-keygen.service
    Wants=sshd-keygen.service

    [Service]   # 这个项目与实际执行的命令参数有关
    Type=notify
    EnvironmentFile=/etc/sysconfig/sshd
    ExecStart=/usr/sbin/sshd -D $OPTIONS
    ExecReload=/bin/kill -HUP $MAINPID
    KillMode=process
    Restart=on-failure
    RestartSec=42s

    [Install]   # 这个项目说明此unit要挂载到哪个target下面
    WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;三大项目说明&#34;&gt;三大项目说明&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;[Unit]：unit本身的说明，以及与其他依赖daemon的设置，包括在什么服务之后才启动此unit之类的设置值&lt;/li&gt;
&lt;li&gt;[Service][Socket][Timer][Mount][Path]：不同的unit类型需要使用相对应的设置设置项目。sshd.service需要使用[Service]来设置。此项目主要用来规范服务启动脚本、环境配置文件名、重新启动的方式等等&lt;/li&gt;
&lt;li&gt;[Install]：这个项目说明将此unit安装到哪个target里面&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设置规则&#34;&gt;设置规则&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;设置项目通常是可以重复的，例如可以在配置文件中设置两个“After”，不过后面的设置会替换前面的，因此，如果想要设置归零，直接使用“After=”&lt;/li&gt;
&lt;li&gt;如果设置参数需要有【是/否】的项目（布尔值），可以使用【1/0】、【yes/no】、【true/false】、【on/off】&lt;/li&gt;
&lt;li&gt;空白行、以#或;开头的行，都代表注释&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;参数解释&#34;&gt;参数解释&lt;/h3&gt;
&lt;h4 id=&#34;unit参数&#34;&gt;[Unit]参数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Description：当使用systemctl list-units时，输出给管理员看的建议说明。使用systemctl status时输出的此服务的说明也是这个项目&lt;/li&gt;
&lt;li&gt;Documentation：这个项目在提供管理员能够进行进一步的文件查询的功能，提供的文件可以是以下类型
&lt;ul&gt;
&lt;li&gt;Documentation=http://www....&lt;/li&gt;
&lt;li&gt;Documentation=man:sshd(8)&lt;/li&gt;
&lt;li&gt;Documentation=file:/etc/ssh/sshd_config&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;After：此unit在哪个daemon启动之后才启动，仅是说明服务启动的顺序，并没有强制要求里面的服务一定要启动之后才启动此unit。这个与Requires的设置有差异&lt;/li&gt;
&lt;li&gt;Before：与After意义相反，是在什么服务启动前最好启动这个服务的意思，仅是规范服务启动的顺序，并非强制要求&lt;/li&gt;
&lt;li&gt;Requires：设置依赖服务，此服务启动之后才能启动本unit，否则不启动本unit&lt;/li&gt;
&lt;li&gt;Wants：与Requires含义相反，此unit之后最好还要启动什么服务，主要是希望建立让用户比较好操作的环境，但是本参数的服务没有启动并不影响本unit&lt;/li&gt;
&lt;li&gt;Conflicts：冲突的服务，如果此参数的服务已经启动，那么本unit不可启动；如果本unit已经启动，那么此参数之后的服务不能再启动&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;service参数&#34;&gt;[Service]参数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Type：说明此daemon的启动方式，会影响到ExecStart，有以下几种类型：
&lt;ul&gt;
&lt;li&gt;simple：默认值，这个daemon主要由ExecStart接的命令来启动，启动后常驻于内存&lt;/li&gt;
&lt;li&gt;forking：由ExecStart启动的程序通过spawns扩展出其他子程序来作为此daemon的主要服务，原生的父进程在启动之后会终止运行，大多数传统的unit采用此方式，例如httpd&lt;/li&gt;
&lt;li&gt;oneshot：与simple类似，不过这个进程在工作完毕之后就关闭，不会常驻于内存&lt;/li&gt;
&lt;li&gt;dbus：与simple类似，但这个daemon必须要在获取一个D-Bus的名称后才会继续运行，因此设置此项目是需要设置“BusName=”&lt;/li&gt;
&lt;li&gt;idle：与simple类似，执行这个daemon必须要所有的工作都顺利执行完毕后才会执行，一般是开机后半段执行的服务&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;EnvironmentFile：指定启动脚本的环境配置文件&lt;/li&gt;
&lt;li&gt;ExecStart：实际执行此daemon的命令或脚本程序。可以使用ExecStartPre或者ExecStartPost两个设置项目来在启动服务前后，进行额外的命令操作。命令串仅接受【命令 参数 参数......】的格式，不接受&amp;gt;、&amp;gt;&amp;gt;、|、&amp;amp;等特殊字符，很多的bash语法也不支持，因此最好写入命令脚本中。如果要支持完整的bash语法，可以使用Type=oneshot&lt;/li&gt;
&lt;li&gt;ExecStop：与systemctl stop的执行有关&lt;/li&gt;
&lt;li&gt;ExecReload：与systemctl reload的执行有关&lt;/li&gt;
&lt;li&gt;Restart：当设置Restart=1时，则当此daemon服务终止后，会再次启动此服务，即这个服务会源源不断的产生，除非使用systemctl强制将此服务关闭&lt;/li&gt;
&lt;li&gt;RemainAfterExit：当设置RemainAfterExit=1时，则当这个daemon所属的所有程序都终止之后，此服务会再尝试启动，这对于Type=oneshot的服务很有帮助。&lt;/li&gt;
&lt;li&gt;TimeoutSec：若这个服务在启动或者关闭时，因为某些缘故无法顺利“正常启动或者结束”的情况下，则需要等待多久才进入“强制结束”的状态&lt;/li&gt;
&lt;li&gt;KillMode：可以是process、contril-group、none。&lt;strong&gt;process&lt;/strong&gt;：daemon终止时只会终止主要程序，即ExecStart的那串指令；&lt;strong&gt;contril-group&lt;/strong&gt;：此daemon所产生的的其他contril-group的程序都会被关闭；&lt;strong&gt;none&lt;/strong&gt;：没有程序会被关闭&lt;/li&gt;
&lt;li&gt;RestartSec：与ReStart有点相关，如果这个服务被关闭，然后需要重新启动，大概需要sleep多少时间再重新启动，默认是100ms&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;install参数&#34;&gt;[Install]参数&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;WantedBy：这个设置后面接的大部分是*.target类型的unit。通常情况下为multi-user.target&lt;/li&gt;
&lt;li&gt;Also：当目前这个unit本身被enable时，also后面接的unit也需要enbale&lt;/li&gt;
&lt;li&gt;Alias：进行一个链接别名的作用，和命令alias作用类似&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;systemctl针对timer的配置文件&#34;&gt;systemctl针对timer的配置文件&lt;/h1&gt;
&lt;h2 id=&#34;优势&#34;&gt;优势&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;相对于crond最小的单位到分，systemd 是可以到秒甚至是毫秒&lt;/li&gt;
&lt;li&gt;由于所有的systemd的服务产生的信息都会被纪录（log），因此比crond在debug上面要更清楚方便的多&lt;/li&gt;
&lt;li&gt;各项timer的工作可以跟systemd的服务相结合&lt;/li&gt;
&lt;li&gt;各项timer的工作可以跟control group（cgroup，用来取代/etc/secure/limit.conf的功能）结合，来限制该工作的资源利用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用要求&#34;&gt;使用要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;系统的timer.target一定要启动&lt;/li&gt;
&lt;li&gt;要有个sname.service的服务存在（sname是你自己指定的名称）&lt;/li&gt;
&lt;li&gt;要有个sname.timer的时间启动服务存在&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;h3 id=&#34;配置文件位置&#34;&gt;配置文件位置&lt;/h3&gt;
&lt;p&gt;在/etc/systemd/system下面去创建*.timer的配置文件&lt;/p&gt;
&lt;h3 id=&#34;配置文件参数&#34;&gt;配置文件参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;OnActiveSec：当timers.target启动多久之后才执行这个unit&lt;/li&gt;
&lt;li&gt;OnBootSec：当开机完成后多久之后才执行&lt;/li&gt;
&lt;li&gt;OnStartupSec：当systemd第一次启动之后过多久才执行&lt;/li&gt;
&lt;li&gt;OnUnitActiveSec：这个timer配置文件所管理的那个unit服务在最后一次启动后，隔多久后再执行一次的意思&lt;/li&gt;
&lt;li&gt;OnUnitInactiveSec：这个timer配置文件所管理的那个unit服务在最后一次停止后，隔多久再执行一次的意思&lt;/li&gt;
&lt;li&gt;OnCalendar：使用实际时间（非循环时间）的方式来启动服务的意思&lt;/li&gt;
&lt;li&gt;Unit：一般来说不太需要设置，因此如同上面刚刚提到的，基本上我们设置都是sname.server + sname.timer，那如果你的sname并不相同时，那在 .timer的文件中，就得要指定是哪一个 service unit&lt;/li&gt;
&lt;li&gt;Persistent：当使用OnCalendar的设置时，指定该功能要不要持续进行的意思。通常是设置为yes&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;oncalendar的时间&#34;&gt;OnCalendar的时间&lt;/h4&gt;
&lt;h5 id=&#34;基本格式&#34;&gt;基本格式&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;语法：英文星期名称  YYYY-MM-DD HH:MM:SS&lt;/li&gt;
&lt;li&gt;举例：Thu                2020-04-16 21:34:25&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;常用的间隔时间单位&#34;&gt;常用的间隔时间单位&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;us或usec：微秒&lt;/li&gt;
&lt;li&gt;ms或msec：毫秒&lt;/li&gt;
&lt;li&gt;s, sec, second, seconds：秒&lt;/li&gt;
&lt;li&gt;m, min, minute, minutes：分&lt;/li&gt;
&lt;li&gt;h, hr, hour, hours：时&lt;/li&gt;
&lt;li&gt;d, day, days：日&lt;/li&gt;
&lt;li&gt;w, week, weeks：周&lt;/li&gt;
&lt;li&gt;month, months：月&lt;/li&gt;
&lt;li&gt;y, year, years：年&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;使用举例&#34;&gt;使用举例&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;隔3小时：3h或3hr或3hours&lt;/li&gt;
&lt;li&gt;隔300分钟过10秒：10s 300m&lt;/li&gt;
&lt;li&gt;隔5天又100分钟：100m 5day&lt;br&gt;
&lt;code&gt;通常英文的写法，小单位写前面，大单位写后面～所以先秒、再分、再小时、再天数等&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;英文常用的口语化日期&#34;&gt;英文常用的口语化日期&lt;/h5&gt;
&lt;p&gt;now、today、tomorrow、hourly、daily、weekly、monthly、+3h10m、2015-08-16&lt;/p&gt;
&lt;h2 id=&#34;配制实例&#34;&gt;配制实例&lt;/h2&gt;
&lt;h3 id=&#34;循环运行&#34;&gt;循环运行&lt;/h3&gt;
&lt;h4 id=&#34;要求&#34;&gt;要求&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;开机后2小时开始执行一次这个backup.service&lt;/li&gt;
&lt;li&gt;自从第一次执行后，未来每两天要执行一次backup.service&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;配制文件&#34;&gt;配制文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/systemd/system/backup.timer
	[Unit]
	Description=backup my server timer
	[Timer]
	OnBootSec=2hrs
	OnUnitActiveSec=2days
	[Install]
	WantedBy=multi-user.target
	# 只要这样设置就够了！储存离开吧！
systemctl daemon-reload
systemctl enable backup.timer
systemctl restart backup.timer
systemctl list-unit-files|grep backup
	backup.service disabled # 这个不需要启动！只要 enable backup.timer 即可！
	backup.timer enabled
systemctl show timers.target
	ConditionTimestamp=Thu 2015-08-13 14:31:11 CST # timer 这个 unit 启动的时间！
systemctl show backup.service
	ExecMainExitTimestamp=Thu 2015-08-13 14:50:19 CST # backup.service 上次执行的时间
systemctl show backup.timer
	NextElapseUSecMonotonic=2d 19min 11.540653s # 下一次执行距离 timers.target 的时间
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;固定日期运行&#34;&gt;固定日期运行&lt;/h3&gt;
&lt;h4 id=&#34;要求-2&#34;&gt;要求&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;星期天凌晨2点运行这个备份程序一遍&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;配制文件-2&#34;&gt;配制文件&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/systemd/system/backup2.timer
	[Unit]
	Description=backup my server timer2
	[Timer]
	OnCalendar=Sun *-*-* 02:00:00
	Persistent=true
	Unit=backup.service
	[Install]
	WantedBy=multi-user.target
systemctl daemon-reload
systemctl enable backup2.timer
systemctl start backup2.timer
systemctl show backup2.timer
	NextElapseUSecRealtime=45y 7month 1w 6d 10h 30min
&lt;/code&gt;&lt;/pre&gt;
">Centos7 systemd整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/18-hcia-zong-he-shi-jian/"" data-c="
          &lt;h1 id=&#34;企业网实践拓扑&#34;&gt;企业网实践拓扑&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1586446429500.png&#34; alt=&#34;企业网实践拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;规划说明&#34;&gt;规划说明&lt;/h2&gt;
&lt;p&gt;AS1（包含R1、SW1、SW2、SW3）为企业主园区网络，AS2为企业分支网络，云部分代表互联网设备8.8.8.8。完成AS1和AS2基本的网络功能，可以访问互联网8.8.8.8以及通过GRE VPN使得位于两个AS的终端实现跨广域网的通信。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;架构设计&#34;&gt;架构设计&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;AS1中，R1作为企业网关出口，负责接入互联网8.8.8.8，以及和R3的VPN互联，同事作为AS1内部的核心路由器。&lt;/li&gt;
&lt;li&gt;SW1和SW2作为AS1的汇聚层交换机，其上的Vlanif接口如路由拓扑所示，SW3作为接入层的交换机。&lt;/li&gt;
&lt;li&gt;AS2中，R3作为该分支网络的网关出口，SW4作为接入2层交换机，连接终端和路由器。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在两个AS中，每个AS最多出现一条静态路由。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h1 id=&#34;配置&#34;&gt;配置&lt;/h1&gt;
&lt;h2 id=&#34;交换网络部分&#34;&gt;交换网络部分&lt;/h2&gt;
&lt;h3 id=&#34;vlan的规划和接入&#34;&gt;VLAN的规划和接入&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;交换机接口&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;所属VLAN&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sw1-g0/0/1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;vlan11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sw2-g0/0/2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;vlan12&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sw3-g0/0/10&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;vlan8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sw3-g0/0/11&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;vlan9&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sw3-g0/0/12&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;vlan10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sw4-g0/0/1&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;vlan20&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sw4-g0/0/2&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;vlan30&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;在AS1中的交换机上创建VLAN8/9/10/11/12/99&lt;/li&gt;
&lt;li&gt;在AS2中的交换机上创建VLAN20/30&lt;/li&gt;
&lt;li&gt;按照表中将接口划入vlan&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1
vlan batch 8 9 10 11 12 99
int g0/0/1
port link-type access
port default vlan 11
# sw2
vlan batch 8 9 10 11 12 99
int g0/0/2
port link-type access
port default vlan 12
# sw3
vlan batch 8 9 10 11 12 99
int g0/0/10
port link-type access
port default vlan 8
int g0/0/11
port link-type access
port default vlan 9
int g0/0/12
port link-type access
port default vlan 10
# sw4
vlan batch 20 30
int g0/0/1
port link-type access
port default vlan 20
int g0/0/2
port link-type access
port default vlan 30
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;实施trunk封装&#34;&gt;实施Trunk封装&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AS1内交换机的互联接口实施标准封装格式的Trunk链路&lt;/li&gt;
&lt;li&gt;AS1内所有Trunk上允许除了VLAN1之外的所有VLAN通过，且所有VLAN的流量必须携带Tag&lt;/li&gt;
&lt;li&gt;AS2内的交换机上实施Trunk，&lt;strong&gt;安全起见仅仅允许对应的VLAN通过&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1
int g0/0/3
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
int g0/0/5
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
int g0/0/6
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
# sw2
int g0/0/1
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
int g0/0/5
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
int g0/0/6
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
# sw3
int g0/0/1
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
int g0/0/3
port link-type trunk
port trunk allow-pass vlan all
undo port trunk allow-pass vlan 1
#sw4
int g0/0/10
port link-type trunk
port trunk allow-pass vlan 20 30
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;实施生成树协议stp&#34;&gt;实施生成树协议STP&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AS1和AS2内实施802.1s(MSTP)的生成树（华为设备默认为MSTP）&lt;/li&gt;
&lt;li&gt;sw1在实例(instance)1中具有成为vlan8/10/11的根的最大的可能性，同时sw1是其他vlan（9/12/99）的备份根&lt;/li&gt;
&lt;li&gt;sw2反之，即成为vlan8/10/11的备份根，成为其他vlan（9/12/99）的主根&lt;/li&gt;
&lt;li&gt;区域名为ender，修订版本号为1&lt;/li&gt;
&lt;li&gt;sw1/2/3上，仅使用一条命令，使得连接终端的接口可以快速进入转发状态&lt;/li&gt;
&lt;li&gt;sw4的&lt;strong&gt;接口下&lt;/strong&gt;配置命令，使得连接其他设备的接口快速进入转发状态&lt;/li&gt;
&lt;li&gt;为了保护交换网络，在接入层交换机（sw3/4）上，一旦收到非法的BPDU则关闭接口&lt;br&gt;
&lt;code&gt;实例instance，即将多个vlan绑定成一个组&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1\sw2\sw3
stp region-configuration
region-name ender
revision-level 1
instance 1 vlan 8 10 11
instance 2 vlan 9 12 99
active region-configuration 
# sw1
stp instance 1 priority 0  # 或者stp instance 1 root primary
stp instance 2 root secondary
# sw2
stp instance 1 root secondary
stp instance 2 root primary
# sw1\sw2\sw3
stp edged-port default
# sw4
int g0/0/1
stp edged-port enable
int g0/0/2
stp edged-port enable
int g0/0/10 #此接口如果不配置边缘端口，出现断网等情况，还会经过Listen等状态，导致恢复过慢
stp edged-port enable
# sw4
stp bpdu-protection
# sw3，需要将上连接口的边缘端口关闭
stp bpdu-protection
int g0/0/1
stp edged-port disable
shutdown
undo shutdown
int g0/0/3
stp edged-port disable
shutdown
undo shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;实施以太链路聚合&#34;&gt;实施以太链路聚合&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为了保证汇聚交换机之间拥有足够的带宽，在汇聚交换机之间实施手工模式（华为默认此模式）的以太链路聚合&lt;/li&gt;
&lt;li&gt;以太链路聚合使用基于源目IP的负载分担方式（华为默认此方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1/sw2
clear configuration int g0/0/5
y
clear configuration int g0/0/6
y
int eth-trunk 12
trunkport g 0/0/5 to 0/0/6
port link-type trunk
port trunk allow vlan all
undo port trunk allow vlan 1
int g0/0/5
un shut
int g0/0/6
un shut
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;2层网络向3层网络过渡&#34;&gt;2层网络向3层网络过渡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在所有路由器上配置IP地址，保证路由器之间、路由器和交换机之间的直连IP地址通信&lt;/li&gt;
&lt;li&gt;在所有交换机上配置IP地址，保证路由器之间、路由器和交换机之间的直连IP地址通信&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
int g0/0/0 
ip addr 202.100.1.1 30
int g0/0/1
ip addr 10.1.11.1 29
int g0/0/2
ip addr 10.1.12.1 29
int s1/0/0
ip addr 12.1.1.1 30
# R2
int g0/0/0
ip addr 202.100.1.2 30
int g0/0/1
ip addr 202.100.1.6 30
int s1/0/0
ip addr 12.1.1.2 30
# R3 
int g0/0/1 
ip addr 202.100.1.5 30
int g0/0/0.20
dot1q termination vid 20
arp broadcast enable
ip addr 10.1.20.30 27
int g0/0/0.30
dot1q termination vid 30
arp broadcast enable
ip addr 10.1.30.30 27
# sw1
int vlanif 11
ip addr 10.1.11.2 29
int vlanif 8
ip addr 10.1.10.13 28
int vlanif 9
ip addr 10.1.10.28 28
int vlanif 10
ip addr 10.1.10.45 28
# sw2
int vlanif 12
ip addr 10.1.12.2 29
int vlanif 8
ip addr 10.1.10.12 28
int vlanif 9
ip addr 10.1.10.29 28
int vlanif 10
ip addr 10.1.10.44 28
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;路由部分&#34;&gt;路由部分&lt;/h2&gt;
&lt;h3 id=&#34;搭建as2内部网络&#34;&gt;搭建AS2内部网络&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;配置pc3的IP地址和正确的网关&lt;/li&gt;
&lt;li&gt;配置s2的IP和正确的网关&lt;/li&gt;
&lt;li&gt;配置R3，保证pc3和s2通信&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# pc3
ip:10.1.20.1 mask:255.255.255.224 gateway:10.1.20.30
ping 10.1.20.30
ping 10.1.30.30
ping 10.1.30.1
# s2
ip:10.1.30.1 mask:255.255.255.224 gateway:10.1.30.30
ping 10.1.30.30
ping 10.1.20.30
ping 10.1.20.1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;搭建as1内部网络&#34;&gt;搭建AS1内部网络&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AS1内部实施OSPF多区域（area0和area1）网络，进程号为110&lt;/li&gt;
&lt;li&gt;配置设备的OSPF路由器ID，分别为0.0.0.1,0.0.0.2,0.0.0.3&lt;/li&gt;
&lt;li&gt;R1的环回接口0（地址11.1.1.1/32）运行在区域0&lt;/li&gt;
&lt;li&gt;AS1内其他接口都运行在area1中&lt;/li&gt;
&lt;li&gt;确保AS1内所有主机（包含11.1.1.1）相互之间实现通信&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
ospf 110 router-id 0.0.0.1
area 0
area 1
q
int lo0
ip addr 11.1.1.1 32
ospf enable 110 area 0
int g0/0/1
ospf enable 110 area 1
int g0/0/2
ospf enable 110 area 1
# sw1
ospf 110 router-id 0.0.0.2
area 1
int vlanif 8
ospf enable 110 area 1
int vlanif 9
ospf enable 110 area 1
int vlanif 10
ospf enable 110 area 1
int vlanif 11
ospf enable 110 area 1
# sw2
ospf 110 router-id 0.0.0.3
area 1
int vlanif 8
ospf enable 110 area 1
int vlanif 9
ospf enable 110 area 1
int vlanif 10
ospf enable 110 area 1
int vlanif 12
ospf enable 110 area 1
# 验证R1/sw2/sw3
dis ospf int  # 查看端口
dis ip rou pro ospf  #查看路由
dis ospf peer bri # 查看邻居
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;网络边界的实施&#34;&gt;网络边界的实施&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AS1的网关设备配置2条默认路由，下一跳为运营商地址，请使用以太链路作为主路径&lt;/li&gt;
&lt;li&gt;AS3的网关设备配置默认路由，下一跳为运营商地址&lt;/li&gt;
&lt;li&gt;保证R1、R3可以和8.8.8.8(R2的lo0接口)通信&lt;/li&gt;
&lt;li&gt;保证R1和R3可以相互通信&lt;/li&gt;
&lt;li&gt;确保pc1和pc3可以发送数据到8.8.8.8（此时还无法ping通）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
ip route-static 0.0.0.0 0 202.100.1.2 preference 59
ip route-static 0.0.0.0 0 12.1.1.2
ospf 110
default-route-advertise
# R3
ip route-static 0.0.0.0 0 202.100.1.6
# R2
int lo0
ip addr 8.8.8.8 32
# 此时如果想要观察到相应现象，需要在R2上开启debug，然后使用pc2和sw1开始ping（ping不通的原因为运营商处没有到企业网中的路由）
# R2
terminal debugging
debugging ip icmp
# 关闭debug命令：undo terminal debugging
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;总部和分支的网络通信&#34;&gt;总部和分支的网络通信&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AS1和AS2之间实施IP协议47，两个网关设备的地址配置为10.1.13.1/30和10.1.13.2/30&lt;/li&gt;
&lt;li&gt;保证两个隧道地址可以实现通信&lt;/li&gt;
&lt;li&gt;R1配置BGP，AS号码为1；R3配置BGP，AS号码为2，使用隧道地址建立eBGP邻居&lt;/li&gt;
&lt;li&gt;在R1上产生来自AS1内部的BGP路由，这些路由的起源代码为？&lt;/li&gt;
&lt;li&gt;在R3上产生AS2的BGP路由，这些路由的起源代码为i&lt;/li&gt;
&lt;li&gt;在BGP实施完毕之后，保证所有的PC和服务器之间可以通信&lt;br&gt;
&lt;code&gt;i代表起源igp，E代表起源eBGP，？代表未知（一般通过重分发进来的），&amp;gt;表示最优路由，*表示有效的路由。例如：100i，表示路由经过的最近一个AS是AS100，后面的i表示这条路由是通过Network方式学习到的。路由选路规则 i&amp;gt;E&amp;gt;?&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
int tunnel 0/0/0
tunnel-protocol gre
source 202.100.1.1
destination 202.100.1.5
ip addr 10.1.13.1 30
q
bgp 1
peer 10.1.13.2 as-number 2
import-route ospf 110
# R3
int tunnel 0/0/0
tunnel-protocol gre
source 202.100.1.5
destination 202.100.1.1
ip addr 10.1.13.2 30
q
bgp 2
peer 10.1.13.1 as-number 1
network 10.1.20.0 27
network 10.1.30.0 27
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;互联网接入和网络安全&#34;&gt;互联网接入和网络安全&lt;/h2&gt;
&lt;h3 id=&#34;vrrp协议&#34;&gt;VRRP协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SW1响应vlan8、10中的终端的ARP请求，作为vlan9的backup&lt;/li&gt;
&lt;li&gt;SW2响应vlan9中的终端的ARP请求，作为vlan8、10的backup&lt;/li&gt;
&lt;li&gt;Master设备都追踪上行链路，如果失败则进行主备切换&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw1
int vlan 8
vrrp vrid 8 virtual-ip 10.1.10.14
vrrp vrid 8 priority 109
vrrp vrid 8 track interface g0/0/1 reduced 10  # 上行链路追踪，如果失效，则优先级减低10。或者vrrp vrid 8 track interface vlan 11 reduced 10
int vlan 9
vrrp vrid 9 virtual-ip 10.1.10.30
int vlan 10
vrrp vrid 10 virtual-ip 10.1.10.46 
vrrp vrid 10 priority 109
vrrp vrid 10 track interface g0/0/1 reduced 10
# sw2
int vlan 8
vrrp vrid 8 virtual-ip 10.1.10.14
int vlan 9
vrrp vrid 9 virtual-ip 10.1.10.30
vrrp vrid 9 priority 109
vrrp vrid 9 track interface g0/0/1 reduced 10
int vlan 10
vrrp vrid 10 virtual-ip 10.1.10.46
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;接入层交换机调整&#34;&gt;接入层交换机调整&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sw3的管理IP：vlan99=10.1.99.99/24，sw2：vlan99=10.1.99.254/24，使sw3仅可以被telnet协议远程管理&lt;/li&gt;
&lt;li&gt;使用端口号为23的协议进行远程管理，sw3仅仅允许10.1.0.0/16和202.100.1.0/30的网络进行管理&lt;/li&gt;
&lt;li&gt;管理sw3的用户名为huawei，密码为huawei123，无法通过配置直接看到该密码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw3
int vlanif 99
ip addr 10.1.99.99 24
ip route-static 0.0.0.0 0 10.1.99.254   # sw3（2层交换机，不能开启ospf）
q
acl 2010
rule 10 permint source 10.1.0.0 0.0.255.255
rule 20 permint source 202.100.1.0 0.0.0.3
q
aaa
local-user huawei password cipher huawei123
local-user huawei privilege level 15
q
user-interface vty 0 4
protocol inbound telnet
acl 2010 inbound
authentication-mode aaa
# sw2
int vlanif 99
ip addr 10.1.99.254 24
ospf enable 110 area 1
# 分别使用sw2和R1进行连接测试
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;sw3的安全措施&#34;&gt;SW3的安全措施&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;为了防止客户私自接入其他非授权设备，在接入设备sw3做相应的实施&lt;/li&gt;
&lt;li&gt;接口最多允许接入2台设备&lt;/li&gt;
&lt;li&gt;如果出现违规行为，并不关闭接口（华为默认，默认模式为restrict丢弃并告警，protect模式为丢弃报文，shutdown模式为关闭端口，&lt;code&gt;port-security protect-action restrict&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;安全MAC必须以sticky的方式实施，用来方便排除故障&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# sw3
int g0/0/10 
port-security enable
port-security max-mac-num 2
port-security protect-action restrict
port-security mac-address sticky
int g0/0/11
port-security enable
port-security max-mac-num 2
port-security protect-action restrict
port-security mac-address sticky
int g0/0/12
port-security enable
port-security max-mac-num 2
port-security protect-action restrict
port-security mac-address sticky
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;nat接入互联网&#34;&gt;NAT接入互联网&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;业务网络vlan8\9\10的用户可以访问互联网&lt;/li&gt;
&lt;li&gt;互联网设备可以远程通过telnet 1234端口来管理sw3&lt;/li&gt;
&lt;li&gt;远程管理成功，必须显示管理日志（一次性行为）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R1
acl 2001
rule 5 permit source 10.1.10.0 0.0.0.15
rule 10 permit source 10.1.10.16 0.0.0.15
rule 15 permit source 10.1.10.32 0.0.0.15
int g0/0/0
nat outbound 2001
nat server protocol tcp global current-interface 1234 inside 10.1.99.99 23
# R2
telnet 202.100.1.1 1234
terminal monitor
&lt;/code&gt;&lt;/pre&gt;
">18 HCIE企业网综合实践初级（2020.0406-0411）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/shu-mei-pai-kai-fa-gpioji-yu-guan-fang-xi-tong/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E8%BF%9C%E7%A8%8B&#34;&gt;系统安装以及远程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h1 id=&#34;系统安装以及远程&#34;&gt;系统安装以及远程&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;将系统镜像写入SD卡之后，需要在其根目录下创建ssh文件，否则无法ssh远程连接。&lt;/li&gt;
&lt;li&gt;ssh远程连接：用户名pi，密码raspberry&lt;/li&gt;
&lt;li&gt;获取root权限，并使用root登录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sudo passwd root    # 之后输入密码
sudo nano /etc/ssh/sshd_config
    PermitRootLogin yes #值更改为yes
    ctrl+o保存--&amp;gt;enter写入源文件--&amp;gt;ctrl+x退出
sudo systemctl restart sshd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;此时可以使用ssh远程root用户&lt;/code&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;更换官方apt源为阿里apt源，并更新系统&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;nano /etc/apt/sources.list
   #  将原来的deb.......和deb-src......两行注释掉
   # 或者直接在这两行修改
    deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free rpi
    deb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free rpi
    ctrl+o--&amp;gt;enter--&amp;gt;ctrl+x
apt-get update
apt-get upgrade -y
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;安装rdpd服务，使用windows自带远程桌面进行连接&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;apt-get install xrdp
apt-get install tightvncserver
systemctl enable xrdp
systemctl start xrdp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;此时可以直接使用win10自带远程连接树莓派&lt;/code&gt;&lt;/p&gt;
">树莓派开发GPIO（基于官方系统）（待补充.......）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/17-jiao-huan-ji-chan-pin-xian-20200405/"" data-c="
          &lt;h1 id=&#34;产品选型&#34;&gt;产品选型&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;园区网（企业网）产品&lt;br&gt;
交换机、路由器、防火墙、无线&lt;/li&gt;
&lt;li&gt;DC（数据中心）产品&lt;br&gt;
交换机&lt;/li&gt;
&lt;li&gt;SP（运营商）产品&lt;br&gt;
交换机、路由器&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;思科&#34;&gt;思科&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;思科企业网交换机生态体系1&lt;br&gt;
Catalyst系列9000交换机（9200/9300/9400/9500）&lt;br&gt;
IOS XE系统&lt;br&gt;
G：千兆交换机&lt;br&gt;
TT：千兆上连端口是Rj45&lt;br&gt;
TC：千兆上连端口是两用的，可以Rj45，也可以在其上加模块&lt;br&gt;
TS：有千兆扩展卡槽&lt;br&gt;
T：没有千兆扩展卡槽&lt;br&gt;
E：增强型的三层&lt;br&gt;
S：标准的三层&lt;br&gt;
DC：直流电源供电&lt;br&gt;
L：LAN Base Image&lt;/li&gt;
&lt;li&gt;思科企业网交换机生态体系2&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586017762654.png&#34; alt=&#34;思科企业网交换机生态体系2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;思科企业网交换机生态体系3&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586017911178.png&#34; alt=&#34;思科企业网交换机生态体系3&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;思科企业网交换机生态体系4&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586017994088.png&#34; alt=&#34;思科企业网交换机生态体系4&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;思科企业网交换机生态体系5&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586017998430.png&#34; alt=&#34;思科企业网交换机生态体系5&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;华为&#34;&gt;华为&lt;/h1&gt;
&lt;p&gt;交换机系列介绍&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586070690284.png&#34; alt=&#34;交换机系列介绍&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;思科华为产品线对比&#34;&gt;思科华为产品线对比&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1586071315883.png&#34; alt=&#34;思科华为产品线对比&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;sdn&#34;&gt;SDN&lt;/h1&gt;
&lt;h2 id=&#34;历史&#34;&gt;历史&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;2006，OpenFlow概念，基于此给网络带来可编程的特性&lt;/li&gt;
&lt;li&gt;2008，SDN&lt;/li&gt;
&lt;li&gt;2011，ONF组织成立&lt;/li&gt;
&lt;li&gt;2012，vmvare收购Nicira，宣布SDN的商用方案正式进军数据中心网络&lt;/li&gt;
&lt;li&gt;2013，OpenDaylight项目作为Linux基金会项目成立，谷歌发布了基于SDN的广域网解决方案B4&lt;/li&gt;
&lt;li&gt;2014，思科部分开源ACI的南向协议OpFlex&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sdn相关标准组织&#34;&gt;SDN相关标准组织&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;白盒机构，ONF即开放组织基金会&lt;/li&gt;
&lt;li&gt;IETF互联网工程任务组&lt;/li&gt;
&lt;li&gt;OpenDaylight，是Linux基金会负责管理的开源项目&lt;/li&gt;
&lt;li&gt;ITU-T和ETSI欧洲电信标准协会&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sdn驱动力&#34;&gt;SDN驱动力&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;适应虚拟化技术&lt;/li&gt;
&lt;li&gt;开放式框架&lt;/li&gt;
&lt;li&gt;可编程的网络&lt;/li&gt;
&lt;li&gt;自动部署和运维&lt;/li&gt;
&lt;li&gt;关键益处：面向业务、可定制、更敏捷、更简单&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;sd-wan魔力象限&#34;&gt;SD-WAN魔力象限&lt;/h2&gt;
&lt;p&gt;Leaders：VMware、Cisco、Silver Peak&lt;/p&gt;
&lt;h2 id=&#34;企业网和数据中心网络需求&#34;&gt;企业网和数据中心网络需求&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1586076991444.png&#34; alt=&#34;企业网和数据中心网络需求&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;核心技术&#34;&gt;核心技术&lt;/h2&gt;
&lt;p&gt;通过将网络设备控制平面与数据平面分离开来，从而实现了网络流量的灵活控制，为核心网络和应用的创新提供良好的平台&lt;/p&gt;
&lt;h2 id=&#34;主要技术路线&#34;&gt;主要技术路线&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1586078061693.png&#34; alt=&#34;主要技术路线&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;不同线路的sdn&#34;&gt;不同线路的SDN&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1586079770686.png&#34; alt=&#34;不同线路的SDN&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">17 交换机产品线（2020.0405）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/16-acl-de-ying-yong-he-nat-ji-zhu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;ACL访问控制列表&lt;br&gt;
1.1 ACL概述&lt;br&gt;
访问控制列表，定义一系列规则，涉笔根据这些规则对数据包进行分类处理，一种古老的防火墙，只有两种动作：&lt;strong&gt;丢弃或允许通过&lt;/strong&gt;&lt;br&gt;
ACl应用于接口上，对每个接口的出入双向分别过滤，仅当数据包经过/到达一个接口时才能被此接口的此方向的ACL过滤。&lt;br&gt;
&lt;code&gt;ACL规则配置的序号一般要空几个，防止之后需要在中间插入规则，序号一般为5的倍数，5、10、15......&lt;/code&gt;&lt;br&gt;
1.2 通配符掩码（不是反掩码）&lt;br&gt;
和IP地址结合使用，用来描述一个地址范围。通配符掩码和子网掩码相似，但是含义不同。0表示对应位需要比较（即网络位，不能改变），1表示对应位不进行比较（即主机位，可以随意改变）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585840791827.png&#34; alt=&#34;通配符掩码&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.3 ACL的分类&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585842002363.png&#34; alt=&#34;ACL的分类&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.4 工作流程和设置要求&lt;br&gt;
逐条匹配，命中则处理，如果未命中，则匹配最后一条规则（默认规则）。&lt;br&gt;
匹配顺序就是ACL中规则的优先级，&lt;strong&gt;越精准&lt;/strong&gt;的流量和范围应该配置&lt;strong&gt;更小的序号/规则&lt;/strong&gt;。&lt;br&gt;
尽可能在&lt;strong&gt;靠近数据源&lt;/strong&gt;的路由器接口上配置ACl，以减少不必要的陆良转发/设备处理。&lt;strong&gt;高级ACl&lt;/strong&gt;：应该在靠近被过滤的接口上应用ACl，尽早阻止不必要的流量进入网络；&lt;strong&gt;基本ACL&lt;/strong&gt;：过于靠近被过滤源的基本ACL可能阻止该源访问合法目的，应该在不影响其其他合法访问的前提下，尽可能使ACl靠近被过滤的源。&lt;br&gt;
&lt;code&gt;思科：默认最后一条隐藏规则为deny,因此在配置思科设备之后，要保证其他流量能正常通过，需要在配置完最后一条规则之后再追加一条：xx permit any。&lt;/code&gt;&lt;br&gt;
&lt;code&gt;华为：应用在接口下，默认最后一条隐藏规则为permit；应用在用户视图下（telnet\ssh等），默认最后一条规则为deny。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;NAT网络地址转换&lt;br&gt;
NAT提供私有地址到公有地址的转换，隐藏内部地址（安全），一般部署在连接内网和外网的网关设备上。&lt;br&gt;
2.1 &lt;strong&gt;常见NAT分类&lt;/strong&gt;：&lt;br&gt;
a. 静态NAT（IP--IP，1对1，基本不用）,&lt;br&gt;
b. 动态NAT（IP--IP，多对多，即多个非固定的静态NAT，基本不用）；&lt;br&gt;
c. 思科PAT端口地址转换&lt;strong&gt;OR&lt;/strong&gt;华为EasyIP（IP:port--IP:port，1对多，常用）&lt;br&gt;
d. NetServer（NAT服务器，NAPT，网络地址端口转换）==思科静态端口转换（IP:port--IP:port，1对多，常用）&lt;br&gt;
2.2 Easy IP&lt;br&gt;
NAT设备直接使用出接口的IP地址作为转换后的原地址，不需要预先配置地址池，适用于拨号接入Internet或者动态获取IP地址的场合。&lt;br&gt;
&lt;strong&gt;EasyIP允许将多个内部地址映射到网关出接口地址上的不同端口。&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实施步骤&lt;/strong&gt;：定义一个acl，作用是定义哪些主机可以被转换，只有被转换的主机才可以访问互联网，不被定义的不能访问， 然后在出接口（连接外网的接口）应用EasyIP，将出接口的IP地址作为转换后的源地址。&lt;br&gt;
作用：公网地址和端口的复用&lt;br&gt;
&lt;code&gt;从inside到outside，必须先路由再NAT，存在对应的路由表是前提，如果没有路由表，无法达到相应目的地址&lt;/code&gt;&lt;br&gt;
2.3 NAT服务器&lt;br&gt;
网络地址端口转换NAPT允许多个内部地址映射到同一个公有地址的不同端口（基于端口的转换），属于多对一的地址转换。&lt;br&gt;
允许服务器既能被内部访问，也能被外部访问。&lt;br&gt;
转换某个特定的协议或者端口，用于把服务器提供的服务映射到公网。&lt;/li&gt;
&lt;li&gt;OSPF静态默认路由下放&lt;br&gt;
&lt;strong&gt;华为:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;ospf 10&lt;/code&gt;&lt;br&gt;
&lt;code&gt;default-route-advertise [always]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;思科:&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;router ospf 110&lt;/code&gt;&lt;br&gt;
&lt;code&gt;default-information originate [always]&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;带不带always的区别:&lt;/strong&gt;&lt;br&gt;
不带always（常用，防止浪费R1的带宽），则R1上的默认静态路由删除之后，下面的交换机的默认静态路由也删除；&lt;br&gt;
带always，则R1上的默认路由删除之后，下面的交换机的默认路由不删除&lt;/li&gt;
&lt;li&gt;Qos基础&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;对关键业务作出保证，对非重要流量或者恶意流量进行监管，带宽和时延是重要的品质参数。&lt;/li&gt;
&lt;li&gt;QoS的5大任务：分类标记、拥塞避免、拥塞管理、&lt;strong&gt;限速&lt;/strong&gt;和链路效率&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.......................................接口上配置基本ACL
# 禁止pc1所在网段和pc2访问AR1上的11.11.11.11
# 禁止pc1所在网段和pc2访问AS2自治域
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# R1
ip access-list standard 1  # 进入标准规则1视图
5 deny 10.1.10.1 0.0.0.15 # 序号5：拒绝IP10.1.10.1/28
10 deny host 10.1.10.17
15 permit any  # 允许其他流量，包含ospf等路由协议
int e0/1
ip access-group 1 in  # 在入方向上应用规则1
int tunnel 0
ip access-group 1 out # 针对去往AS2的流量
# 验证
# R1
show access-list  #查看规则
# pc1
ping 11.11.11.11
ping 10.1.20.1


# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# R1
acl 2000
rule 5 deny source 10.1.10.0 0.0.0.15
rule 10 deny source 10.1.10.17 0
int g0/0/1
traffic-filter inbound acl 2000
int tunnel 0/0/0
traffic-filter outbound acl 2000
# 测试
# pc1
ping 11.11.11.11
ping 10.1.20.1
# pc2 
ping 11.11.11.11
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.......................................接口上配置高级ACL
# 禁止pc1访问client1
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# R1
undo acl 200  # 删除之前的规则，并在pc1和pc2上进行ping测试
int g0/0/1 
undo traffic-filter inbound
int tunnel 0/0/0
undo traffic-filter outbound
acl 3000    # 配置高级规则
rule deny ip source 10.1.10.1 0 destination 10.1.20.1 0
int g0/0/1
traffic-filter inbound acl 3000
# 测试
# pc1
ping 10.1.20.1 # 不通
ping 10.1.30.1 # 通
# pc2
ping 10.1.20.1 # 通
ping 10.1.30.1 # 通

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# 禁止pc2主机pingR1和AS2
ip accell-list extended 100
5 deny icmp 10.1.10.17 0.0.0.0 any
10 permit ip any any
int e0/1
ip access-group 1 in
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ...................................ACL在VTY下的应用（只允许特定的人员远程管理设备）
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# 只允许sw2使用telnet远程R1
# R1
acl 2000
rule permint source 10.1.12.2 0
user-interface vty 0 4
acl 2000 inbound
# 测试
# sw1
telnet 10.1.12.1  # 可以
# sw2
telnet 10.1.11.1   # 不可以
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 实施本实验之前删除所有的ACL配置
# .....................................华为EasyIP实施
# 使得pc1和pc2所在网段访问8.8.8.8
# R1
acl 2000
rule permit source 10.1.10.0 0.0.0.15
rule permit source 10.1.10.16 0.0.0.15
int g0/0/0
nat outbound 2000  # EasyIP 虽然配置完毕，但是无法ping通，原因为sw1上没有8.8.8.8的路由
# sw1
# ip route-static 0.0.0.0 0 10.1.11.1  # 设置sw1的默认静态路由（R1下面交换机比较少）
# 或者在R1上OSPF下放默认路由（适合R1下面有多台交换机的情况）
# R1
ospf 10
default-route-advertise
# 测试
# R1
dis nat outbound
dis nat session all
# pc1和pc2
ping 8.8.8.8


# .....................................思科实施PAT
int e0/0
ip nat outside #定义该接口为外部接口
int e0/1
ip nat inside
int e0/2
ip nat inside
exit
ip access-list standard 2
5 permit  10.1.10.0 0.0.0.15
10 permit  10.1.10.16 0.0.0.15
exit
ip nat inside source list 2 interface e0/0 overload
router ospf 110
default-information originate
# 测试
# R1
show access-lists
show ip nat translations
# pc1和pc2
ping 8.8.8.8
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;华为EasyIP抓包查看&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1586008492804.png&#34; alt=&#34;华为EasyIP&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ...................................华为NAPT（NAT服务器，NatServer）实施
# 使R3能够telnet连接sw1
# sw1，开启telnet
user-interface vty 0 4
set authenticatopn password cipher hcia
user privilege level 15
# R1
int g0/0/0
nat server protocol tcp global current-interface 23  inside 10.1.11.2 23  # 或者nat server protocol tcp global current-interface telnet  inside 10.1.11.2 23
# 测试
# R3
telnet 202.100.1.1


# ........................................思科静态NAT端口转换实施
# sw1
line vty 0 4 
password hcia
login
transport input telnet
exit
enable password hcia
# R1
ip nat inside source static tcp 10.1.11.2 23 202.100.1.1 2323
# 测试
# R3
telnet 202.100.1.1 2323
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ..............................................基本的监管限速
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
#R1
access-list 100 permit ip host 10.1.10.1 any    # pc1到任意设备的流量
class-map match-all C1 
match access-group 100 # 流分类工作命中ACL100的流量
policy-map P1 
class C1 
police cir 8000 # 定义监管机制，即期望的带宽，此处采用最小的带宽8000bps，即8kbps
int e0/1
ip address 10.1.11.1 255.255.255.248
service-policy input P1 # 监管用在入方向
# 测试
#R1
show policy-map int e0/1
# pc1
ping 11.11.11.11 size 1000


# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# R1
acl name QoS 3998
rule 10 permit ip source 10.1.10.16 0.0.0.15 
q
traffic classifier C1 operator or 
if-match acl Qos
q
traffic behavior Police 
car cir 8 cbs 1504 pbs 2504 green pass yellow pass red discard # 定义期望带宽为8k,其他的参数自动计算
statistic enable # 开启状态监测，便于检查
q
traffic policy Police 
classifier C1 behavior Police  
int g0/0/1
traffic-policy Police inbound
# 测试
#R1
dis traffic policy statistics int g0/0/1 inbound
# sw1
ping -s 1000 -a 10.1.10.30 11.11.11.11
&lt;/code&gt;&lt;/pre&gt;
">16 ACL的应用和NAT技术</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/15-bgp-he-gre/"" data-c="
          &lt;ol&gt;
&lt;li&gt;GRE隧道&lt;br&gt;
GRE（通用路由封装）隧道，IP协议47，也是一种VPN，但默认不提供加密，允许路由协议在隧道上运行。&lt;br&gt;
实施前提：两端能够相互通信&lt;/li&gt;
&lt;li&gt;BGP&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;BGP边界网关协议，在AS间提供无环路的路由信息交换，BGP着重于&lt;strong&gt;控制路由的传播和选择最优的路由（13种选择方式）&lt;/strong&gt;，互联网的基石&lt;/li&gt;
&lt;li&gt;应用层协议，TCP的179端口，单播传输路由&lt;/li&gt;
&lt;li&gt;分类：按照运行方式分为eBGP（External/Exterior BGP）和iBGP（Internal/Interior BGP），即&lt;strong&gt;两种邻居关系&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;eBGP&lt;/strong&gt;：运行于不同AS之间的BGP称为eBGP，为了防止AS间产生环路，当BGP设备接收eBGP对等体发送的路由时，会将带有本地AS号的路由丢弃。&lt;br&gt;
&lt;strong&gt;iBGP&lt;/strong&gt;：运行于同一AS内部的BGP称为iBGP，为了防止AS内产生环路，BGP设备不将从iBGP对等体学到的路由通告给其他iBGP对等体，并与所有iBGP对等体建立全连接，为了解决iBGP对等体的连接数量太多的问题，BGP设计了路由反射器和BGP联盟。&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/qq_38265137/article/details/80439561&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;路由产生两种方式：
&lt;ul&gt;
&lt;li&gt;network宣告：起源为i，手动宣告某些网段，适合网段比较少的情况&lt;/li&gt;
&lt;li&gt;import路由引入（华为）\redistribute重新分配（思科）：起源为?(incomplete,不完整的)，即从别的协议中引入的路由，适合网段比较多的情况&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;BGP路由产生的条件：必须为路由表中真实存在的网段&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#................................GRE的实施（R1至R3之间）
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# 保证R1至R3通信
# R3
int g0/0/1
ip addr 202.100.1.5 30
ip route-static 0.0.0.0 0 202.100.1.6  # R1的静态默认路由已经在之前的实验中配置过
# R2
int g0/0/1
ip addr 202.100.1.6 30
# GRE的隧道建立
# R1
int tunnel 0/0/0
tunnel-protocol gre
source 202.100.1.1
destination 202.100.1.5
ip address 13.1.1.1 30  # 隧道地址
# R3
int tunnel 0/0/0
tunnel-protocol gre
source 202.100.1.5
destination 202.100.1.1
ip address 13.1.1.2 30
# 测试
# R3
ping 13.1.1.1  # ping的同时抓包

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# R3
int e0/1
ip addr 202.100.1.5 30
ip route 0.0.0.0 0 202.100.1.6
# R2
int e0/1
ip addr 202.100.1.6 30
# R1
int tunnel 0
tunnel source 202.100.1.1
tunnel destination 202.100.1.5
ip addr 13.1.1.1 30
# R3
int tunnel 0
tunnel source 202.100.1.5
tunnel destination 202.100.1.1
ip addr 13.1.1.2 30
# 测试
# R3
ping 13.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#................................eBGP的实施（AR1和AR3之间建立邻居）
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# R1
bgp 1  #  1为本地AS号码
router-id 1.1.1.1   #  路由器标识符routerid
peer 13.1.1.2 as-number 2  # 远端的邻居IP和AS号
import-route ospf 10 # 引入ospf的路由，10为ospf的进程号
# R3
bgp 2
router-id 2.2.2.2
peer 13.1.1.1 as-number 1
network 10.1.20.0 27  # network宣告路由
network 10.1.30.0 27
# 验证
# sw1/sw2
dis bgp peer  # 查看邻居
dis bgp rou  # 查看路由
dis ip rou pro bgp
#&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;此时AS1和AS2中的PC还无法通信，主要是sw2和sw3上无路由，此时需要实施双向重分布&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
# R1
ospf 10
import-route bgp
#此时两个自治域可以实现通信
# pc1
ping 10.1.20.1
ping 10.1.30.1
# sw1
dis ip rou


# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# R1
router bgp 1
bgp router-id 1.1.1.1
neighbor 13.1.1.2 remote-as 2
redistribute ospf 110   # 之前ospf的进程号为110
router ospf 110  # ospf重分布bgp的路由
redistribute bgp 1 subnets
# R3
router bgp 2
bgp router-id 2.2.2.2
neighbor 13.1.1.1 remote-as 1
router bgp 2
network 10.1.20.0 mask 255.255.255.224
network 10.1.30.0 mask 255.255.255.224
# 测试
show ip bgp summary
show ip bgp
show ip rou bgp
&lt;/code&gt;&lt;/pre&gt;
">15 BGP和GRE</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/14-ospfkai-fang-zui-duan-lu-jing-you-xian-gai-nian-he-duo-qu-yu-shi-shi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;概述&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;基于链路状态的路由协议，&lt;strong&gt;设计上就保证了无环路&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;支持区域划分，区域内部的路由器使用SPF最短路径算法保证区域内部无环路，利用区域间的连接规则保证区域之间无路由环路&lt;/li&gt;
&lt;li&gt;支持触发更新，快速检测和通告自治系统内的拓扑变化&lt;/li&gt;
&lt;li&gt;解决网络扩容带来的问题。可将每个自治系统划分多个区域，并限制每个区域的范围，适合大中型网络&lt;/li&gt;
&lt;li&gt;可以提供认证&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ospf最重要的区域称为backbone骨干区域area0，可以划分多个区域，支持大型网络&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;标识和区域&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RouterID，32位，唯一标识自治系统内的路由器，&lt;strong&gt;强烈建议为每台运行的OSPF的路由器手动配置一个RouterID&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;ospf支持将一组网段组合在一起，这样的一个组合称为一个区域，分为骨干区域和普通区域。划分区域可以缩小路由器的LSDB规模，减少网络流量。&lt;/li&gt;
&lt;li&gt;ospf的进程号仅对本机有意义，routerid同区域必须唯一，否则无法建立邻居关系&lt;/li&gt;
&lt;li&gt;ABR：区域边界路由器，将普通区域与骨干区域连接在一起。ASBR：自治系统边界路由器，位于OSPF自主系统和非OSPF网络之间&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;网络类型和DR、BDR&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ospf中的以太网的网络类型是广播类型&lt;/li&gt;
&lt;li&gt;DR和BDR，&lt;a href=&#34;https://feiqiongjun.github.io/post/19-shi-shi-dong-tai-lu-you-xie-yi-ospf-xie-yi/&#34;&gt;详情请见【19】实施动态路由协议OSPF协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DR和BDR选举&lt;/strong&gt;：当OSPF中选举DR和BDR时首先查看路由器的优先级，&lt;strong&gt;优先级大者当选DR，其次是BDR&lt;/strong&gt;；如果优先级相同则根据RouterID的大小来选举，RouterID大者当选。RouterID在不指定的情况下会由loopback接口数值最高的IP地址来做，当没有loopback接口时则由物理接口数值最高的IP来做&lt;/li&gt;
&lt;li&gt;DR和BDR选举只是在接口类型为广播或NBMA时会产生（就是说非广播类的点对点和点对多点的接口类型是不选举DR和BDR的）&lt;code&gt;选举时间默认为40秒，过了选举期，不支持抢占&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;状态机&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762454080.png&#34; alt=&#34;ospf-状态机&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
所有设备都需要和DR、BDR构建邻接关系，只和DR、BDR交互LSDB，剩下的其他路由器俩俩都是邻居(2-way)状态，不交换路由表 。&lt;br&gt;
&lt;strong&gt;&lt;code&gt;EVE思科模拟器配置成功之后，测试不成功，但是配置无问题，此时需要关闭cef，命令为no ip cef(关闭快速交换,使用进程交换)&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;两台路由器，一个接口区域0，一个接口区域1，不能正常建立OSPF邻居关系&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; # .............................OSPF 
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# R1
# 设置环回口地址，作为一台连接到R1的主机使用
int loopback 0
ip address 11.11.11.11 32
q
# 此时pc1无法ping通11.11.11.11，原因是sw1上无到11.11.11.11的路由，同时默认静态路由也没有配置
# 开始配置ospf
ospf 10  router-id 11.11.11.11  # 创建ospf进程，10为进程号，可自定义
area 0  # 创建area0，然后在area0中创建area1
area 1
q
int loopback 0  # 将之前配置的回环接口宣告进ospf进程10的area0中
ospf enable 10 area 0
int g0/0/1  # 将接口g0/0/1和g0/0/2宣告进ospf进程10的area0中
ospf enable 10 area 1
int g0/0/2
ospf enable 10 area 1

# sw1，开启ospf进程并创建area1（sw1和sw2需要在vlan下面宣告地址）
ospf 10 router-id 10.11.11.11
area 1
int vlan 8 
ospf enable 10 area 1
int vlan 9
ospf enable 10 area 1
int vlan 10
ospf enable 10 area 1
int vlan 11
ospf enable 10 area 1
# sw2，开启ospf进程并创建area1
ospf 10 router-id 10.22.22.22
area 1
int vlan 8 
ospf enable 10 area 1
int vlan 9
ospf enable 10 area 1
int vlan 10
ospf enable 10 area 1
int vlan 12
ospf enable 10 area 1

# 验证
# R1
ping 10.1.11.2
ping 10.1.12.2
dis ospf int    #  查看ospf宣告的接口
# sw1和sw2
dis ospf int 
ping 11.11.11.11
# R1\sw1\sw2，查看邻居关系
dis ospf peer brief
# sw1/sw2，验证路由表
dis ip rou pro ospf
# pc1\pc2\server1访问11.11.11.11
ping 11.11.11.11
# &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;如果ospf的routerid配置错误导致不生效，先ctrl+z，然后执行reset ospf process重启ospf进程&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;


# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# 配置ospf
# R1
int lo0
ip addr 11.11.11.11 32
router ospf 110 
route-id 11.11.11.11
int lo0 
ip ospf 110 area0
int range ethernet 0/1-2
ip ospf 110 area1
# sw1
route ospf 110 
route-id 10.11.11.11
int vlan 8-11
ip ospf 110 area 1
# sw2
route ospf 110 
route-id 10.22.22.22
int vlan 8-12
ip ospf 110 area 1

# 验证ospf
# R1/SW1/SW2
show ip ospf int bri  # 查看ospf的宣告的接口
show ip ospf neighbor  # 查看ospf的邻居关系
# sw1/sw2
show ip route ospf   # 查看路由表
# pc1/pc2/server1
ping 11.11.11.11
# &amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;如果ospf的routerid配置错误导致不生效，先ctrl+z，然后执行clear ip ospf process重启ospf进程&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
">14 OSPF(开放最短路径优先)概念和多区域实施</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/13-lu-you-yuan-li-he-xie-yi-shi-shi-ospfjing-tai-lu-you/"" data-c="
          &lt;ol&gt;
&lt;li&gt;路由器&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;路由器（以及三层交换机）具有最基本的&lt;strong&gt;决策功能&lt;/strong&gt;（路由决策依据路由表RIB，路由是指导IP报文发送的路径信息，如果没有目标地址的路由，只能丢弃）和&lt;strong&gt;转发功能&lt;/strong&gt;（转发引擎，按照路由把数据转发到对应的接口或者线路上去）【先决策后转发】&lt;/li&gt;
&lt;li&gt;种类：直连路由、静态路由和动态路由（RIP、EIGRP、OSPF、IS-IS、BGP）&lt;/li&gt;
&lt;li&gt;度量值（Metric）:表示到达这条路由所指目的地址的代价（cost，开销）。通常影响路由度量值的因素有线路延迟、带宽、线路使用率、线路可信度、跳数、最大传输单元。不同路由协议参考的因素不同：静态路由为固定值0，ospf依据带宽，rip依据跳数，is-is依据10的累加(缺省度量为10)，eigrp和bgp为综合度量。&lt;/li&gt;
&lt;li&gt;优先级：不同协议比较优劣的一个标准（同一路由多种协议竞争路由表的标准）。优先级0-255，可配置范围为1-255，越小越优先，优先级最高的路由被添加进路由表。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762342822.png&#34; alt=&#34;各厂商的优先级AD&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;问题：有一条路由，该路由会如何放入路由表呢？&lt;br&gt;
前提：必须是同一条路由（10.1.1.1/32和10.1.1.0/24不是同一条路由）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.如果从多个协议（方式）得到该路由，首先需要使用优先级或者管理距离来比较，优先级值数据越小越优先（如果2种协议的优先级相同，比如华为设备上OSPF的优先级改为了10，静态路由也改为了10，此时会比较协议最原始的优先级即内部优先级，OSPF的10优于静态的60，所以终选OSPF）&lt;br&gt;
2.如果已经确定了某种路由来放入路由表，接下来会比较该路由协议多条路径中综合度量值较小的放入路由表&lt;br&gt;
3.还需要注意同一种路由协议可能会具有路由优先级（OSPF、BGP和中间系统到中间系统协议），比如OE1（不比较开销值）一定会优于OE2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;静态路由&lt;br&gt;
广泛应用于企业网的边缘，静态路由中最常用的方式为静态默认路由&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;优势：不需要报文的支持，实施简单，小型的网络，精准的控制路由&lt;/li&gt;
&lt;li&gt;劣势：不会自动调整，实施过多会造成排错的困扰，无法支持大型网络，扩展性比较差&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;结合ARP以及讲解流量转发&lt;br&gt;
3.1 直连路由和静态路由的区别&lt;br&gt;
**直连路由：**直连路由是由链路层协议发现的，一般指去往路由器的接口地址所在网段的路径，直连路由无需手工配置，只要接口配置了网络协议地址同时管理状态、物理状态和链路协议均为UP时，路由器能够自动感知该链路存在，接口上配置的IP网段地址会自动出现在路由表中且与接口关联，并动态随接口状态变化在路由表中自动出现或消失。&lt;br&gt;
**静态路由：**静态路由是由网络管理员根据网络拓扑，使用命令在路由器上配置的路由，这些静态路由信息指导报文发送，静态路由方式也无需路由器进行计算，但它完全依赖于网络管理员的手动配置。默认路由是一种特殊的静态路由,网络管理管理员手工配置了默认路由后，当路由表中与目的地址之间没有匹配的表项时路由器将把数据包发送给默认网关。&lt;br&gt;
**区别：**直连路由只能使用于直接相连的路由器端口，非直连的路由器端口是没有直连路由的。静态路由信息在缺省情况下是私有的，不会传递给其他的路由器。当然，网络管理员也可通过对路由器设置使之成为共享的。网络管理员易于清楚地了解网络的拓扑结构，便于设置正确的路由信息。静态路由一般适用于较简单的网络环境。&lt;br&gt;
3.2 数据转发流程&lt;br&gt;
&lt;strong&gt;&lt;code&gt;（本实验中配置静态路由使用的不是下一跳，而是出接口，其他配置和静态路由配置一样）&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ARP表：：源发现目的不是同一网络，此时需要发送到达自身网关的ARP（目的IP和目的MAC的映射，&lt;strong&gt;基本ARP&lt;/strong&gt;）请求（源自自身，目的是全F的广播，封装网关的MAC），拥有该IP的设备会单播回送一个响应（含有对应的MAC）；&lt;strong&gt;免费ARP&lt;/strong&gt;，请求自身IP对应的MAC（广播），如果得到回应，那么说明IP地址冲突；&lt;strong&gt;代理ARP&lt;/strong&gt;（思科默认开启，华为默认关闭，此试验需要早g0/0/0上&lt;code&gt;arp-proxy enable&lt;/code&gt;），一个中间设备代理目的IP回送IP对应的MAC。ARP的2层帧不能跨越网络，所以在每个IP子网MAC地址都是重写，而源目IP不变化。&lt;a href=&#34;https://www.jianshu.com/p/2a1928570a1c&#34;&gt;&lt;code&gt;关于ARP，参考预习&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MAC地址表：：和交换机的转发原理有关（收到广播帧或者未知单播帧会泛洪）&lt;/li&gt;
&lt;li&gt;路由表：：查找路由表，发送数据到达目标地址（也会有ARP查询）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;静态默认路由和浮动路由&lt;br&gt;
4.1 静态默认路由&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;默认路由0.0.0.0/0，目的网络是任意、掩码也是任意，代表所有未知网络。（已知网络是指明细(deitail)路由）&lt;/li&gt;
&lt;li&gt;转发原则：最长匹配原则，找到一条最精准到达目标地址的路由（即同一网络中最精准的网段）。&lt;/li&gt;
&lt;li&gt;实施：&lt;code&gt;华为：ip route-static 0.0.0.0 0 g0/0/0 202.100.1.2；思科：ip route 0.0.0.0 0 e0/0 202.100.1.2&lt;/code&gt;；配置路由优先级&lt;code&gt;华为：ip route-static 0.0.0.0 0 g0/0/0 202.100.1.2 preference 59；思科：ip route 0.0.0.0 0 e0/0 202.100.1.2 5&lt;/code&gt;【如果指配置出接口而不配置出口IP&lt;code&gt;ip route 0.0.0.0 0 e0/0（不推荐如此配置）&lt;/code&gt;，则会出现“错误的配置，影响性能”（PPPoE除外）】&lt;br&gt;
4.2 浮动路由&lt;br&gt;
&lt;code&gt;实施下面的命令之前需要去掉之前设置的8.8.8.8的路由&amp;quot;undo ip route-static 8.8.8.8 32&amp;quot;，同时需要给串行接口配置IP&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;两条默认路由--负载均衡（ECMP，等价开销多路径）：&lt;br&gt;
第1条高速接口，接口和地址必须都配置：&lt;code&gt;ip route-static 0.0.0.0 0 g0/0/0 202.100.1.2&lt;/code&gt;；&lt;br&gt;
第2条串行接口，可以只配置接口（备用）：&lt;code&gt;ip route-static 0.0.0.0 0 s1/0/0&lt;/code&gt;。&lt;br&gt;
验证:&lt;code&gt;dis ip routing-table protocol static&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762368245.png&#34; alt=&#34;浮动路由-负载均衡&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;两条默认路由--主备，高速线路为主，串行线路为备：&lt;br&gt;
华为设备静态路由优先值默认为60，通过修改优先值来影响路由是否写入路由表。&lt;br&gt;
第1条高速接口，（主）接口和地址必须都配置：&lt;code&gt;ip route-static 0.0.0.0 0 g0/0/0 202.100.1.2&lt;/code&gt;；&lt;br&gt;
第2条串行接口，（备）可以只配置接口：&lt;code&gt;ip route-static 0.0.0.0 0 s1/0/0 preference 61&lt;/code&gt;。&lt;br&gt;
验证:&lt;br&gt;
&lt;code&gt;dis ip rou pro sta&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ping 8.8.8.8&lt;/code&gt;&lt;br&gt;
&lt;code&gt;关闭接口g0/0/0：int g0/0/0 &amp;amp;&amp;amp; shutdown&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ping 8.8.8.8&lt;/code&gt;&lt;br&gt;
![浮动路由-主备线路]&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762381999.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;黑洞路由&lt;br&gt;
配置黑洞路由后，相应网段数据被丢弃&lt;br&gt;
例如：&lt;code&gt;ip route-static 8.8.8.8 32 null 0&lt;/code&gt;，则去往8.8.8.8的数据被丢弃&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# .....................................静态路由
# R1去访问互联网上的8.8.8.8（R2的loopback0的地址）
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# R2
int loop 0
ip addr 8.8.8.8 32
int g0/0/0
un ip addr 202.100.1.2 25 #去掉之前测试的地址
ip addr 202.100.1.2 30
# R1
int g0/0/0
un ip addr 202.100.1.1 25 #去掉之前测试的地址
ip addr 202.100.1.1 30
ping 202.100.1.2   # 测试直连路由能够通信之后才能进行下面的步骤
ip route-static 8.8.8.8 32 202.100.1.2
dis ip routing-table # 查看路由表
dis ip routing-table protocol static
ping 8.8.8.8  # 测试通信，发送用的静态路由，接收用的是直连路由
&lt;/code&gt;&lt;/pre&gt;
">13 路由原理和协议实施（ospf、静态路由）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/12-vrrpgong-you-de-wang-guan-rong-yu-bei-fen-xie-yi/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;路由器和交换机的区别&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;物理形态&lt;/strong&gt;：芯片、接口&lt;br&gt;
&lt;strong&gt;转发原理&lt;/strong&gt;：交换机的转发原理（MAC地址表）、路由器的转发原理（路由表RIB）&lt;br&gt;
&lt;strong&gt;产品定位&lt;/strong&gt;：网关角度（NAT功能，GRE隧道，IPSEC VPN功能，MPLS VPN）；DC交换机（M-LAG&amp;amp;VPN、堆叠、SVF）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;基本概述&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;能够在不改变组网的情况下，将多台路由器虚拟成一个虚拟路由备份（热备），通过配置虚拟路由的的IP地址为默认网关，实现网关的备份&lt;/li&gt;
&lt;li&gt;VRRPv2仅适应IPv4网络，VRRPv3适应IPv4和IPv6网络&lt;/li&gt;
&lt;li&gt;报文：只有一种报文，Advertisement报文，其目的IP地址时224.0.0.18，目的MAC地址是01-00-5e-00-00-12，协议号为112，属于3层协议。（常见组播地址：224.0.0.5--allSPF；224.0.0.6--allDR；224.0.0.9--RIP；224.0.0.10--EIGRP；224.0.0.18--VRRP）&lt;/li&gt;
&lt;li&gt;Master路由器承担转发报文认为的VRRP设备；Backup设备只有在Master设备故障之后才能Mater，承担转发任务&lt;/li&gt;
&lt;li&gt;Master路由器和Backup设备的组ID必须相同，原因为主设备用虚拟MAC相应ARP请求。虚拟mac为0000.5e00.01xx，其中xx为组ID。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;主设备（Master路由器）选取原则&lt;br&gt;
&lt;strong&gt;思科&lt;/strong&gt;：优先级数值较大者优先（默认优先级为100，可以配置1-254，优先级255不能配置(真实IP=虚拟IP)）----&amp;gt; 真实IP较大的优先&lt;br&gt;
&lt;strong&gt;华为&lt;/strong&gt;：优先级相同的情况下，先配置的设备会成为Master&lt;br&gt;
&lt;strong&gt;&lt;code&gt;【STP的根设备==VRRP的Master，否则会造成2层的次优转发】&lt;/code&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ........................sw1、sw2和AR1进行通信
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# sw1
int vlan 11
ip address 10.1.11.2 29
int g0/0/1
port default vlan 11
# sw2
int vlan 12
ip address 10.1.12.2 29
int g0/0/2
port link-type access
port default vlan 12
# AR1
int g0/0/2
ip address 10.1.12.1 29
int g0/0/1
ip address 10.1.11.1 29

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# sw1
int e0/1
switchport access vlan 11
int vlan 11
no shutdown
ip address 10.1.11.2 29
# sw2
int e0/2
switchport mode access
switchport access vlan 12
int vlan 12
no shutdown
ip address 10.1.12.2 29
# AR1
int e0/2
ip address 10.1.12.1 29
int e0/1
ip address 10.1.11.1 29
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ....................................配置VRRP
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# sw1（主，master）
# 为了防止两个主交换机的错误，先测试连通性，ping 10.1.10.12
int vlan 8
vrrp 8 ip 10.1.10.14 # 8为组ID，可以随意设置，但一般情况下与vlan相同，10.1.10.14为虚拟IP
vrrp 8 priority 110
int vlan 9
vrrp 9 ip 10.1.10.30
int vlan 10
vrrp 10 ip 10.1.10.46
vrrp 10 priority 110
do sh vrrp brief  #查看
# sw2（备，backup）
int vlan 8
vrrp 8 ip 10.1.10.14
int vlan 9
vrrp 9 ip 10.1.10.30
vrrp 9 priority 110
int vlan 10
vrrp 10 ip 10.1.10.46
# 将pc1的网关设置为10.1.10.14，进行ping 10.1.10.14测试
# 查看路由 traceroute 10.1.10.14 numeric
# 查看arp表：show arp
# 查看vrrp：sh vrrp，

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# sw1/sw2
int vlan 8
vrrp vrid 8 virtual-ip 10.1.10.14
int vlan 9
vrrp vrid 9 virtual-ip 10.1.10.30
int vlan 10
vrrp vrid 10 virtual-ip 10.1.10.46
# sw1
int vlan 8
vrrp vrid 8 priority 110
int vlan 10
vrrp vrid 10 priority 110
# sw2
int vlan 9
vrrp vrid 9 priority 110
# 查看 dis vrrp brief
# pc1：tracert 10.1.10.14
# sw1修改vrrp优先级，使其成为Master
# int vlan 8
# vrrp vrid 8 priority 110

# 由于华为设备的STP无法实现负载均衡的配置（MSTP可以实现），导致vlan9的次优转发，
# 即走pc2---sw3---sw1---sw2---R1这条路由，
# 根本原因是STP导致sw3的g0/0/1接口变为了AP，
# 若想解决次优转发问题，需要以下配置
# 即让所有的数据都走sw1(vlan8\9\10的Master均为sw1)
# sw2 
int vlan 9
undo vrrp vrid 9 priority
# sw1
int vlan9 
vrrp vrid 9 priority 110
&lt;/code&gt;&lt;/pre&gt;
">12 VRRP（公有的网关冗余备份协议）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/11-yi-tai-lian-lu-ju-he-he-vlan-jian-lu-you/"" data-c="
          &lt;ol&gt;
&lt;li&gt;链路聚合&lt;br&gt;
将一组物理接口捆绑在一起作为一个逻辑接口来增加带宽的一种方法，又称多接口负载均衡组或链路聚合组（标准协议为802.3ad）。通过在两台设备之间建立链路聚合组，可以提供更高的通讯带宽和更高的可靠性。链路聚合作用：&lt;strong&gt;增加链路带宽；提供链路可靠性；在一定位置上消除STP&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;链路聚合分类&lt;br&gt;
2.1 &lt;strong&gt;静态聚合&lt;/strong&gt;：双方系统间不使用聚合协议来协商链路信息。&lt;br&gt;
2.2 &lt;strong&gt;动态聚合&lt;/strong&gt;：链路聚合控制协议LACP (802.3ad)。双方系统间使用聚合协议来协商链路信息。&lt;br&gt;
2.3 &lt;strong&gt;思科私有的PAgP协议&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;链路聚合的一般条件&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;成员接口必须是同一类型（相同的G口、相同的快速以太口等）&lt;/li&gt;
&lt;li&gt;两端物理接口的数量、速率、双工方式、流量配置必须一致&lt;/li&gt;
&lt;li&gt;VLAN的端口模式相同，本征VLAN和允许的VLAN在trunk上需要相同&lt;/li&gt;
&lt;li&gt;如果是access接口，需要接入相同的VLAN&lt;/li&gt;
&lt;li&gt;&lt;em&gt;华为设备必须为缺省的hybrid类型接口&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;通常最多包含8个成员接口&lt;/li&gt;
&lt;li&gt;不能嵌套，即成员接口不能是Eth-Trunk（网络聚合）&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;(了解)交换机核心堆叠和接入堆叠&lt;br&gt;
思科：VSS；华为：CSS；华三：IRF。&lt;/li&gt;
&lt;li&gt;Vlan间路由&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;交换机的转发行为：泛洪、转发、丢弃&lt;/li&gt;
&lt;li&gt;交换机在2层的转发决策表：MAC地址表&lt;/li&gt;
&lt;li&gt;路由器的3层转发决策表：路由表（&lt;em&gt;让不同子网间的设备通信&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;ARP表是封装以太帧需要的一个表（IP-&amp;gt;MAC的对应，和直连通信相关）&lt;/li&gt;
&lt;li&gt;Vlan间路由必须通过具备3层路由功能的设备完成&lt;br&gt;
5.1  VLAN间通信的解决方案&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由器的单臂路由&lt;/strong&gt;：节省端口数和设备接口；链路复用，单点故障的出现容易引发拥塞（不常用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;3层交换机VLAN接口/交换机虚拟接口&lt;/strong&gt;：华为VLANIF==思科SVI，本质是给VLAN一个IP地址，&lt;em&gt;该IP为该接口下设备的网关&lt;/em&gt;。三层交换机内置的三层路由转发引擎执行路由功能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不具备扩展功能的交换机的3层接口功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;路由器的多臂路由（不推荐）&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ..............................................链路聚合
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# sw1
conf t
int range e1/2 - 3  # 选择接口e1/2和e1/3
shutdown  # 必须在接口关闭的状态下实施
channel-group 12 mode on # 12为此链路聚合的名字（两端不必一致，但是推荐相同，方便管理），on为静态聚合模式
# sw2
conf t
int range e1/2 - 3
shutdown  
channel-group 12 mode on
# 验证
show etherchannel summary
show spanning-tree vlan 8  #  可以看到虚拟接口，开销值也相应变小
show run int port-channel 12  # 查看接口信息

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# sw1/sw2 清空需要聚合的接口的配置
clear configuration int g0/0/5
clear configuration int g0/0/6
# sw1/sw2 创建链路聚合
int Eth-Trunk 12  # 创建逻辑接口
trunkport GigabitEthernet 0/0/5 to 0/0/6
# sw1/sw2 配置vlan
int Eth-Trunk 12
port link-type trunk
port trunk allow-pass vlan all
# sw1/sw2 重新启动端口
shutdown
undo shutdown
# 检查
q
dis port vlan active
dis eth-trunk 12
dis int eth-trunk 12
display stp brief
display stp int eth-trunk 12
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.........................单臂路由（直连路由）
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# sw4
vlan batch 20 30
int g0/0/1
port link-type access
port default vlan 20
stp edged-port enable
int g0/0/2
port link-type access
port default vlan 30
stp edged-port enable
int g0/0/10
port link-type trunk
port trunk allow-pass vlan all
# AR3，使用逻辑子接口
int g0/0/0.20
dot1q termination vid 20
ip address 10.1.20.30 255.255.255.224
arp broadcast enable   # 允许arp广播
int g0/0/0.30
dot1q termination vid 30
ip address 10.1.30.30 255.255.255.224
arp broadcast enable 
# 配置Client1和Server2
# Client1：IP 10.1.20.1/255.255.255.224 Gateway 10.1.20.30
# Server2：IP 10.1.30.1/255.255.255.224 Gateway 10.1.30.30
# 测试自己的网关---测试对方的网关---此时连接server2

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# sw4
vlan 20,30
conf t
int e0/1
switchport mode access
switchport access vlan 20
spanning-tree portfast edge
int e0/2
switchport mode access
switchport access vlan 30
spanning-tree portfast edge
int e0/0
switchport trunk encapsulation dot1q
switchport mode trunk
# AR3，使用逻辑子接口
int e0/0
no shutdown
int e0/0.20  # 配置子接口
encapsulation dot1q  20 # 配置封装模式，为了能够识别带tag的报文
ip address 10.1.20.30 255.255.255.224
exit
int e0/0.30
encapsulation dot1q  30 
ip address 10.1.30.30 255.255.255.224
# 配置Client1和Server2
# Client1：IP 10.1.20.1/255.255.255.224 Gateway 10.1.20.30
# Server2：IP 10.1.30.1/255.255.255.224 Gateway 10.1.30.30
# 如果使用路由器替代终端，则需要关闭路由功能no ip routing
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.........................3层交换机VLAN接口/交换机虚拟接口
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科SVI
# sw1
ip routing # 真机默认不开启
int vlan 8
no shutdown
ip address 10.1.10.13 255.255.255.240
int vlan 9
no shutdown
ip address 10.1.10.28 255.255.255.240
int vlan 10
no shutdown
ip address 10.1.10.45 255.255.255.240
# sw2 
ip routing
int vlan 8
no shutdown
ip address 10.1.10.12 255.255.255.240
int vlan 9
no shutdown
ip address 10.1.10.29 255.255.255.240
int vlan 10
no shutdown
ip address 10.1.10.44 255.255.255.240
# 测试
# sw2 : ping 10.1.10.13；ping 10.1.10.28；ping 10.1.10.45；ping 10.1.10.1
# sw1 : ping 10.1.10.1；ping 10.1.10.17
# 查看接口和路由验证

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为VLANIF
# sw1
undo int vlan 1 # 用不到vlan1，可以关闭
int vlan 8
ip address 10.1.10.13 255.255.255.240
int vlan 9
ip address 10.1.10.28 255.255.255.240
int vlan 10
ip address 10.1.10.45 255.255.255.240
# sw2 
undo int vlan 1 
int vlan 8
ip address 10.1.10.12 255.255.255.240
int vlan 9
ip address 10.1.10.29 255.255.255.240
int vlan 10
ip address 10.1.10.44 255.255.255.240
# 测试
# sw2 : ping 10.1.10.13；ping 10.1.10.28；ping 10.1.10.45；ping 10.1.10.1
# sw1 : ping 10.1.10.1；ping 10.1.10.17
# 查看接口和路由验证
&lt;/code&gt;&lt;/pre&gt;
">11 以太链路聚合和Vlan间路由</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/10-biao-zhun-sheng-cheng-shu-stpgen-she-bei-diao-zheng/"" data-c="
          &lt;ol&gt;
&lt;li&gt;STP的应用场景&lt;br&gt;
&lt;code&gt;生成树永远跟接口MAC无关；生成树的弱点是太依赖时间&lt;/code&gt;&lt;br&gt;
交换机之间通过多条链路互连时，虽然能够提升网络可靠性，但同时也会带来2层环路问题且以太帧不具备防环机制，导致&lt;strong&gt;广播风暴、MAC地址表震荡、重复帧拷贝&lt;/strong&gt;，而STP就是在有冗余的交换网络下避免环路。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;广播风暴&lt;/strong&gt;：根据交换机的转发原则，如果交换机从一个端口接收到的是一个广播帧，或者是一个目的mac地址未知的单播帧，则会将这个帧向除源端口之外的所有其他端口转发，如果交换网络中有环路，则这个帧会被无限转发，导致广播风暴，网络中充斥着重复的数据帧。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mac地址表震荡&lt;/strong&gt;：一个Mac地址在某一时刻只能从一个端口学习到，那么环路会导致mac地址表震荡，即一个Mac地址在短时间内在不同的接口间切换。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;主要作用&lt;br&gt;
&lt;strong&gt;消除环路&lt;/strong&gt;：在逻辑上而非物理上，通过**阻断（华为Discarding；思科Block）**冗余链路来消除网络中可能存在的环路。&lt;br&gt;
&lt;strong&gt;链路备份&lt;/strong&gt;：当活动路径发生故障时，激活备份链路，及时恢复网络的连通性。&lt;/li&gt;
&lt;li&gt;工作原理&lt;br&gt;
3.1 &lt;strong&gt;三大原则：&lt;strong&gt;交换网络&lt;/strong&gt;有且只有一个&lt;/strong&gt;根交换机；每个非根设备上&lt;strong&gt;有且只有一个&lt;/strong&gt;根端口；每个链路上&lt;strong&gt;有且只有一个&lt;/strong&gt;指定端口&lt;br&gt;
3.2 &lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;
交换网络选举一个根桥（皇帝RB）；&lt;br&gt;
每个非根交换机选举一个根端口（太守RP，接收皇帝的命令，角色为ROOT，状态为转发Forwarding）；&lt;br&gt;
每个链路上选举一个指定端口（钦差DP，转达皇帝的命令，角色为DESI，状态为转发Forwarding）；&lt;br&gt;
阻塞非根、非指定端口（AP庶民，物理上工作逻辑上阻塞，角色为ALTE，状态为转发Discarding）；&lt;br&gt;
BPDU桥接信息单元（圣旨，发送2s/次）。&lt;br&gt;
3.3 **理解：**有根端口的一定不是根桥（即没有根端口的一定是根桥），其根端口的对端设备可能为根桥&lt;/li&gt;
&lt;li&gt;STP选举&lt;br&gt;
STP在常规设备上默认开启。&lt;br&gt;
**配置BPDU包含以下重要信息：**根桥ID（RootID）；根路径开销（RootPathCost）；指定桥ID（DesignatedBridgeID）；指定端口ID（DesignatedPortID）。&lt;br&gt;
每台设备的各个端口在初始时生成以自己为根桥（RB）的配置消息，向外发送自己的配置信息（起初都认为自己是皇帝）。网桥收敛后，根桥向外发送配置BPDU，其他的设备对该配置BPDU进行转发。&lt;br&gt;
4.1 根设备（RB）选举&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;BridgeID（桥ID，BID，查看&lt;code&gt;思科：show spanning-tree vlan 8；华为：dis stp&lt;/code&gt;）由两部分组成：&lt;strong&gt;优先级（默认32768）和交换机的MAC（不是接口Mac，而是背板Mac&lt;code&gt;思科：show spanning-tree bridge id；华为：dis stp的第一行CIST Bridge的值&lt;/code&gt;）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**选举规则：**优先级值最小的----&amp;gt;Mac最小的&lt;/li&gt;
&lt;li&gt;从管理角度一定是修改优先级去左右根的选举，&lt;strong&gt;根设备一般在核心交换机上，必须修改优先级去控制。最常见的实施是互为主备，即sw1为vlan8\10\11的RB和vlan1\9\12\99的BackupRB，sw2为vlan8\10\11的RB和vlan1\9\12\99的BackupRB&lt;/strong&gt;。修改优先级&lt;code&gt;思科：spanning-tree vlan 8,10,11 priority 4096；华为：stp priority 4096（华为只能针对所有vlan设置，不能针对某一部分vlan）&lt;/code&gt;，优先级的值只能为4096的倍数，0为最高优先级（一般只有RB设为0，BackupRB设置为4096）。&lt;br&gt;
4.2 根端口（RP）选举&lt;/li&gt;
&lt;li&gt;PortID（端口ID，PID，由端口优先级(默认128)和序号组成）&lt;/li&gt;
&lt;li&gt;RPC(RootPathCost，到根桥的开销，Dot1q标准下的PortCost默认为20000)&lt;/li&gt;
&lt;li&gt;**选举规则：**RPC最小的----&amp;gt;&lt;strong&gt;对端&lt;/strong&gt;的桥ID最小的----&amp;gt;&lt;strong&gt;对端&lt;/strong&gt;的端口ID最小的----&amp;gt;&lt;strong&gt;本端&lt;/strong&gt;的端口序号最小的&lt;/li&gt;
&lt;li&gt;修改端口的开销（cost）值&lt;code&gt;思科：spanning-tree vlan 8 cost 10&lt;/code&gt;；修改端口的优先级&lt;code&gt;思科：int e1/3 spanning-tree vlan 10 port-priority 64 (只能是64的倍数，0\64\128\192)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;举例
&lt;ul&gt;
&lt;li&gt;通过比较&amp;quot;对端的桥ID&amp;quot;，选择交换机的&amp;quot;接口1&amp;quot;为根端口&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762628379.png&#34; alt=&#34;通过比较&amp;quot;对端的桥ID&amp;quot;，选择交换机的&amp;quot;接口1&amp;quot;为根端口&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;通过比较&amp;quot;对端的端口ID&amp;quot;，选择交换机X的&amp;quot;接口3&amp;quot;为根端口&lt;br&gt;
![通过比较&amp;quot;对端的端口ID&amp;quot;，选择交换机X的&amp;quot;接口3&amp;quot;为根端口]&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762645946.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;多规则使用&lt;br&gt;
SWB的接口2：规则3，对端的端口ID&lt;br&gt;
SWC的接口1：规则1，RPC&lt;br&gt;
SWD的接口5：规则2，对端的桥ID&lt;br&gt;
SWE的接口1：规则4，本端的端口序号&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762203856.png&#34; alt=&#34;多规则使用&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4.3 指定端口选举&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;**选举规则：**RPC最小的----&amp;gt;&lt;strong&gt;本端&lt;/strong&gt;的桥ID最小的----&amp;gt;&lt;strong&gt;本端&lt;/strong&gt;的端口ID最小的(除非交换机的两个接口相连，否则一般不到这一步)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;STP的模式&lt;br&gt;
升级过程：802.1D---&amp;gt;802.1w---&amp;gt;802.1s&lt;br&gt;
思科和华为设备对接需要使用MSTP。华为默认模式为MSTP，修改为STP&lt;code&gt;stp mode stp&lt;/code&gt;；思科设备默认为pvst，修改为pvst&lt;code&gt;spanning-tree mode pvst&lt;/code&gt;。&lt;strong&gt;现实工作中建议使用mstp。&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762192110.png&#34; alt=&#34;STP的模式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
补充：华为设备还有两种模式：VBST（每个vlan的stp，一般华为交换机即可见到）、V-STP(虚拟stp，数据中心的CE交换机上可见)&lt;/li&gt;
&lt;li&gt;标准STP的5个端口状态&lt;br&gt;
6.1 标准STP的5个端口状态&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Disabled，禁用状态，即不处理和转发BPDU，也不转发用户流量&lt;/li&gt;
&lt;li&gt;Blocking（Discarding），阻塞状态，仅仅接收和处理BPDU，不转发BPDU，也不转发用户流量，&lt;strong&gt;此状态是预备端口的最终状态&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Listening，侦听状态，转发BPDU报文，不转发用户流量&lt;/li&gt;
&lt;li&gt;Learning，学习状态，根据收到的用户流量构建MAC地址表，不转发用户流量，&lt;strong&gt;此状态是为了防止临时环路&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Forwarding，转发状态，即可转发用户流量，也可转发BPDU报文，只有&lt;strong&gt;根端口或者指定端口&lt;/strong&gt;才能进入此状态&lt;br&gt;
6.2 5个端口状态的转换&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762176846.png&#34; alt=&#34;标准STP的5个端口状态的转换&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;STP的时间&lt;br&gt;
HelloTime=2s，BPDU的发送间隔&lt;br&gt;
MaxAge=20s，最大生存时间，即BPDU失效的时间&lt;br&gt;
ForwardDelay=15s，转发时延，端口状态转换的时间间隔&lt;/li&gt;
&lt;li&gt;边缘端口&lt;br&gt;
与终端相连的端口（access或者trunk）不需要参与生成树的计算，这些端口参与计算会影响网络拓扑收敛的速度（转发时延，即直接跳过端口状态Listening和Learning，直达Forwarding），而且这些端口的状态改变也可能引起网络的震荡，导致用户流量中断。&lt;br&gt;
&lt;strong&gt;思科配置边缘端口：&lt;/strong&gt;&lt;code&gt;spanning-tree portfast edge default&lt;/code&gt;，把&lt;strong&gt;所有access接口&lt;/strong&gt;配置为边缘端口&lt;br&gt;
&lt;strong&gt;华为配置边缘端口：&lt;/strong&gt;&lt;code&gt;stp edged-port default&lt;/code&gt;，把&lt;strong&gt;所有接口&lt;/strong&gt;配置为边缘端口。如果对端连接的是交换机，不建议配置边缘端口。最常用是将接口配置边缘端口&lt;code&gt;stp edged-port enable（接口视图中配置）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;BPDU保护&lt;br&gt;
边缘端口收到BPDU报文之后会失去其边缘端口属性。为防止攻击者仿造BPDU报文导致边缘端口属性变成非边缘端口，或者保护STP的边界，可配置交换设备的BPDU保护功能。&lt;br&gt;
配置BPDU保护功能之后，如果边缘端口收到BPDU报文，边缘端口就会被error-down，边缘端口属性不变。&lt;br&gt;
&lt;strong&gt;思科：&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;全局配置&lt;code&gt;spanning-tree bpduguard enable&lt;/code&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;和思科全局的边缘端口联动（仅仅作用于边缘端口）&lt;code&gt;spanning-tree portfast edge bpduguard default&lt;/code&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;接口配置（接口实施BPDU保护，改接口无所谓是否为边缘端口，都会shutdown失效）&lt;code&gt;spanning-tree portfast edge trunk(配成边缘端口)&lt;/code&gt;--&amp;gt;&lt;code&gt;spanning-tree bpduguard enable&lt;/code&gt;&lt;/em&gt;&lt;br&gt;
&lt;em&gt;在思科的接口下配置BPDU保护，该接口可以不是边缘端口&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;华为：&lt;/strong&gt;&lt;br&gt;
&lt;em&gt;只有全局配置（只针对边缘端口生效，只要边缘端口收到BPDU就会关闭）&lt;code&gt;stp bpdu-protection&lt;/code&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;STP优化&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;调整STP的模式&lt;/li&gt;
&lt;li&gt;调整STP的根&lt;/li&gt;
&lt;li&gt;配置边缘端口（端口快速，节省30s时间，根据实际情况配置全局或者单独的接口）&lt;/li&gt;
&lt;li&gt;配置BPDU保护&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ..............................................演示环路导致的广播风暴
# sw1
int g0/0/5
port link-type trunk
port trunk allow-pass vlan all
int g0/0/1
port default vlan 8
port trunk allow-pass vlan all
undo stp  enable # 关闭生成树

# sw2
int g0/0/5
port link-type trunk
port trunk allow-pass vlan all
vlan batch 8 to 12 99
undo stp  enable

# sw3
int g0/0/1 
undo shutdown
undo stp  enable

# R1
dis arp # 查看arp表
reset arp all # 清空arp表，开始抓包
ping 10.1.10.1

# sw1,sw2，sw3
stp enable # 开启生成树，恢复生产环境
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# .................................................华为交换机上STP的实施和优化
# 1.调整STP的模式；2.调整STP的根；3.配置边缘端口（端口快速）；4.配置BPDU保护
# ！！！！思科建议使用全局的边缘端口和全局的BPDU保护
# ！！！！华为实施全局边缘端口之后，需要将trunk端口将全局边缘端口中去除，然后实施全局的BPDU保护
# sw1\2\3上STP模式的修改
stp mode stp
# 调整优先级，将sw1作为RB，sw2作为备份RB
# sw1
stp priority 0
# sw2 
stp priority 4096
# 查看接口优先级
display stp int g0/0/1 # 查看变量Port Priority的值
# sw3配置边缘端口
# stp edged-port default #全局开启边缘端口
# undo stp edged-port default
int g0/0/10
stp edged-port enable
int g0/0/11
stp edged-port enable
int g0/0/12
stp edged-port enable
 # 查看是否为边缘端口
dis stp int g0/0/10 # 查看变量Port Edged的值，如果Active=enabled则为边缘端口
# sw3配置全局的BPDU保护
stp bpdu-protection
# sw3的接口3和1配置为非边缘端口，即将trunk从全局的边缘端口去除
int g0/0/3
stp edged-port disable
shutdown
undo shutdown
int g0/0/1
stp edged-port disable
shutdown
undo shutdown
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;两个直连的路由器无法通信，如何排除故障？&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由下至上：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**1. 检查物理层：**比如接口指示灯是否闪亮，检查光纤是否工作或者网线是否正常（目测法）。如果有故障，可以使用替换法解决；否则进行下一步。&lt;br&gt;
**2. 检查数据链路层：**通过sh int xx或者dis int xx，查看2层协议是否工作，以及封装协议是否一致（比如ppp、hdlc等）。如果协议上和管理上都是工作的，进行下一步。&lt;br&gt;
**3. 检查网络层：**通过IP验证是否为同一子网。假设是同一子网，要特别关心ARP（IP和Mac的对应），如果没有ARP，关心路由器之间是否有交换机进行联通，如果有交换机则需要查看交换机的STP状态、交换机Mac地址表等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
">10 标准生成树STP（根设备调整）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/09-ben-zheng-vlanpvidhe-hun-za-mo-shi/"" data-c="
          &lt;p&gt;&lt;code&gt;终端默认不识别tag，即无法识别带有VlanID的数据&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;本征VLAN的解决方案&lt;br&gt;
&lt;code&gt;不同Vlan之间不能够通信，不然就违背了vlan在2层隔离的本意，现在能够通信了，主要原因是trunk链路上的本征Vlan不携带Tag&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;主动方案&lt;/strong&gt;：使本征Vlan携带tag（思科设备）&lt;br&gt;
&lt;strong&gt;被动方案&lt;/strong&gt;：将本征Vlan修改为一个特定的Vlan或者没有业务的Vlan（该Vlan下没有用户），而不使用Vlan1（华为设备（思科设备也可以使用本方案），华为的trunk总是有PVID Vlan的，总有出现不带tag的情况，所以只能使用无业务的vlan）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# 使得本征Vlan仍然携带tag
conf t
vlan dot1q  tag native  # 此时属于vlan8和vlan9的不再能够通信

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# sw1
int g0/0/3
port trunk pvid vlan 99
# sw3
int g0/0/3
port trunk pvid vlan 99

# 终端连接trunk接口实现通信
# 将接口的PVID修改为vlanid
# sw3
int g0/0/10
port default vlan 1
port link-type trunk
port trunk pvid vlan 8
port trunk allow-pass vlan 8
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;混杂模式的实施&lt;br&gt;
pc1、pc2、pc3均可以与R1通信，但是pc1、pc2、pc3之间不可以通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#..........................................配置华为的混杂模式
# 清空之前的配置
# sw3
int g0/0/10
port trunk pvid vlan 1
undo port trunk allow-pass vlan 8
port link-type hybrid
int g0/0/11
port default vlan 1
port link-type hybrid
int g0/0/12
port default vlan 1
port link-type hybrid
int g0/0/3
port trunk pvid vlan 1
undo port trunk allow-pass vlan 2 to 4094
port link-type hybrid
# sw1
int g0/0/3
port trunk pvid vlan 1
undo port trunk allow-pass vlan 2 to 4094
port link-type hybrid
int g0/0/1
port default vlan 1
port link-type hybrid

# 设置交换机sw1和sw3互联链路（所有链路均携带tag）
# port hybrid pvid / tagged / untagged  分别为入方向增加tag / 出方向携带tag / 出方向删除tag
# sw1
int g0/0/3
port hybrid tagged vlan all
# sw3
int g0/0/3
port hybrid tagged vlan all

# 设置sw3和pc之间的连接
# sw3
int g0/0/10
port hybrid pvid vlan 8
port hybrid untagged vlan 8 11
int g0/0/11
port hybrid pvid vlan 9
port hybrid untagged vlan 9 11
int g0/0/12
port hybrid pvid vlan 10
port hybrid untagged vlan 10 11

# 设置sw1和R1之间的连接
# sw1
int g0/0/1
port hybrid untagged vlan 8 to 11
port hybrid pvid vlan 11

# 如果想要实现pc1和pc2之间通信
# sw3
int g0/0/10
port hybrid untagged vlan 8 9 11
int g0/0/11
port hybrid untagged vlan 8 9 11
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Vlan的端口类型的最佳实践&lt;br&gt;
Trunk用于交换机互联；Access用于终端接入；局部可以混用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# sw3和终端之间相连使用access
int g0/0/10
undo port hybrid untagged vlan 8 to 9 11
undo port hybrid pvid vlan
port link-type access
port default vlan 8
int g0/0/11
undo port hybrid untagged vlan 8 to 9 11
undo port hybrid pvid vlan
port link-type access
port default vlan 9
int g0/0/12
undo port hybrid untagged vlan 10 to 11
undo port hybrid pvid vlan
port link-type access
port default vlan 10

# sw1和sw3之间的互联
# sw3
int g0/0/3
undo port hybrid tagged vlan 1 to 4094
port hybrid vlan 1
port link-type trunk
port trunk allow-pass vlan all
# sw1
int g0/0/3
undo port hybrid tagged vlan 1 to 4094
port hybrid vlan 1
port link-type trunk
port trunk allow-pass vlan all
int g0/0/1
undo port hybrid untagged vlan 8 to 11
port hybrid pvid vlan 1
port link-type access
port default vlan 11
&lt;/code&gt;&lt;/pre&gt;
">09 本征VLAN（PVID）和混杂模式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/08-shi-shi-vlan-he-vlan-de-jie-ru-trunk-he-ben-di-vlan/"" data-c="
          &lt;ol&gt;
&lt;li&gt;Vlan基础&lt;br&gt;
1.1 共享式以太网中，所有的终端主机都处于同一个冲突域中，局域网中的所有接入终端共享总线的带宽（半双工）。交换式以太网中，交换机的每个接口处于独立的冲突域中，终端主机独占接口带宽（2层转发表）。&lt;br&gt;
1.2 路由器或者三层交换机三层接口处于独立的广播域中，终端主机发出的广播帧在三层接口被终止 （广播域）。&lt;code&gt;vlan1，特殊vlan，默认vlan（所有接口默认都属于vlan1），不能删除，尽量避免使用vlan1。&lt;/code&gt;&lt;br&gt;
1.3 Vlan，虚拟局域网，是将一个物理的局域网在逻辑上划分为多个广播域的技术，通过在交换机上配置vlan，可以实现在同一个vlan内的用户进行二层互访，而不同vlan之间的用户被二层隔离。既能够隔离广播域，又能够提升网络安全性。Vlan不是为了隔离用户，而是为了让用户可以通信的同时完成管理。&lt;code&gt;一个vlan是一个广播域，vlan内部的主机可以直接在二层相互通信，而vlan间的主机通信可以通过三层（vlan间路由）通信。&lt;/code&gt;&lt;br&gt;
1.4 创建vlan&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# SW1,SW2,SW3
vlan 8,9,10,11,12,99
show vlan brief
# 删除vlan18
no vlan 18

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# SW1,SW2,SW3
vlan batch 8 9 10 11 12 99 # 或者vlan batch 8 to 12 99
dis vlan summary
# 删除vlan18
undo vlan 18
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Access模式&lt;br&gt;
2.1 帧格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762055771.png&#34; alt=&#34;Vlan帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
交换机处理不同VLAN的帧，需要通过VlanID（Tag）去区分。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Priority：3bit，表示帧的优先级，取值0~7，值越大优先级越高。当交换机阻塞时，优先发送优先级高的数据帧&lt;/li&gt;
&lt;li&gt;VlanID：12bit，可用值为1~4094&lt;br&gt;
2.2 链路类型（接口类型）和链路类型的选择&lt;br&gt;
一般情况下，用户主机和交换机之间的链路为接入模式，交换机与交换机之间的链路为干道链路。华为和华三设备上的hybrid混杂模式可以灵活的使用VlanID。&lt;/li&gt;
&lt;li&gt;**access（接入）：**独享模式，只能允许唯一的VlanID帧通过本接口。在流量的入方向上，收到untagged（不带VlanID标签），交换机将强制加上该接口的PVID；在流量的出方向上，必须从允许通过的接口上转发出去，同时去掉帧的tag，&lt;strong&gt;access端口发往对端设备的以太帧永远是不带标签的&lt;/strong&gt;。优点，Vlan内流量独占链路；缺点，随着Vlan数目增加，占用的接口随之增加。&lt;/li&gt;
&lt;li&gt;**trunk（干道）：**共享模式，允许多个vlan流量在同一链路上转发，trunk上可以转发不同的vlan的帧，通过帧中的tag指定vlan流量的归属。trunk接口收到帧时，如果该帧不包含tag，将打上接口的PVID（本征VLAN，默认vlan1）,如果该帧包含tag，则不改变任何标识；trunk接口发送帧时，&lt;strong&gt;该帧的vlanid在trunk的允许发送列表中（不在列表中的不发送）&lt;/strong&gt;，如果与接口的PVID相同则剥离tag之后发送（本征vlan或者发送个客户端PC，工作原理类似access模式），否则直接发送（透传）。&lt;/li&gt;
&lt;li&gt;**dot1q-tunnel（QinQ，干道中的干道）：**trunk模式的标准为dot1q&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;private-vlan（思科，私有vlan）&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**hybrid（华为，混杂模式）：**在入方向增加一个PVID（类似access），在出方向允许多个Vlan的数据帧转发出去并移除多个PVID。华为设备接口的默认模式，即可以连接终端，也可以连接交换机。hybrid接口可以以tagged或者Untagged方式加入Vlan。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#......................................................实施Access和Trunk模式
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# Access模式
# sw3，将10-12接口划入vlan8，同时pc1的IP为10.1.10.1/28、pc2的IP为10.1.10.2/28、pc3的IP为10.1.10.2/28（255.255.255.240）
int g0/0/10 
port link-type access
port default vlan 8
int g0/0/11
port link-type access
port default vlan 9
int g0/0/12
port link-type access
port default vlan 8
dis port vlan active  # 查看vlan情况
# 实现PC1和R1通信
# 方案一：沿途所有接口均接入vlan8
# sw3
int g0/0/3
port link-type access
port default vlan 8
# sw1
int g0/0/3
port link-type access
port default vlan 8
int g0/0/1
port link-type access
port default vlan 8
# AR1
int g0/0/1
ip address 10.1.10.4 255.255.255.240
# 方案二：将sw3的接口3和10改为vlan9
# sw3（此实验需要关闭sw2，原因是stp）
int g0/0/3
port default vlan 9
int g0/0/10
port default vlan 9

# Trunk模式
# 实现PC1和R1通信
# 华为接口修改为trunk模式之前需要先将接口恢复为vlan1，否则无法修改
# 方案一：交换机sw1和sw3之间的数据帧携带tag（透传）
# sw1
int g0/0/3
port default vlan 1 
port link-type trunk
port trunk allow-pass vlan all  # 允许vlan1-4094通过
int g0/0/1
port default vlan 8
# sw3
clear configuration int g0/0/3
int g0/0/3
port link-type trunk
undo shutdown
port trunk allow-pass vlan all
int g0/0/10
port default vlan 8
# 方案二：交换机sw1和sw3之间的数据帧不携带tag（非透传，本征vlan）
# 将方案一中的sw1和sw3的交换机互联接口设置本征vlan为vlan8
# sw1，设置本征vlan
int g0/0/3
port trunk pvid vlan 8
# sw3
int g0/0/3
port trunk pvid vlan 8
# 实现vlan10和vlan8通信（违背了vlan在2层隔离的本意，这不是我们想要看到的）
# sw3
int g0/0/3
port trunk pvid vlan 10
int g0/0/10
port trunk pvid vlan 10



# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科（部分实验）
# access
int e0/0
switchport mode access
switchport access vlan 8
int e0/1
switchport mode access
switchport access vlan 8
int e0/2
switchport mode access
switchport access vlan 8

# trunk
# sw1
int e0/3
switchport trunk encapsulation dot1q
switchport mode trunk
do sh run i # 查看本接口配置
# sw3 
int e0/3
switchport trunk encapsulation dot1q  # 交换机接口的封装模式为dot1q（思科某些交换机除了支持dot1q，还支持思科自身的ISL，所以需要先指定工作标准）
switchport mode trunk
show int trunk  #  思科默认允许所有vlan通过trunk 
# 设置本征vlan（实现vlan8和vlan9的通信，违背了vlan在2层隔离的本意，这不是我们想要看到的）
# sw1
int e0/1
switchport trunk native vlan 8
int e0/3
switchport trunk native vlan 8
# sw3
int e0/3
switchport trunk native vlan 9
int e0/0
switchport access vlan 9
&lt;/code&gt;&lt;/pre&gt;
">08 实施Vlan和Vlan的接入、Trunk和本地Vlan</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/07-ren-shi-he-guan-li-jiao-huan-ji-de-mac-di-zhi-biao/"" data-c="
          &lt;ol&gt;
&lt;li&gt;网络操作系统&lt;br&gt;
华为VRP；思科IOS；华三Comware，均采用Linux内核&lt;br&gt;
1.1 华为和华三设备命令视图&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;用户视图：设备启动后的缺省视图，可查看启动后基本运行状态和统计信息&lt;code&gt;（Ctrl+z从任意视图回到此视图）&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;系统视图：配置系统全局通用参数&lt;/li&gt;
&lt;li&gt;路由协议视图：配置路由协议参数的视图&lt;/li&gt;
&lt;li&gt;接口视图：配置接口参数的视图&lt;/li&gt;
&lt;li&gt;用户界面视图：配置登录设备的各个用户属性的视图&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761816334.png&#34; alt=&#34;华为和华三设备各视图之间的关系&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.2 思科设备命令视图&lt;br&gt;
用户模式&lt;code&gt;（Ctrl+c从任意视图回到此视图）&lt;/code&gt;、特权模式、接口视图、用户界面视图等等&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761842096.png&#34; alt=&#34;思科设备各视图之间的关系&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;常用命令小结&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令作用&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;华为和华三&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;思科&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看设备硬件信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;display esn&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;show inventory&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看版本信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dis version&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sh version&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看当前配置&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dis current-configuration (或者ctrl+g)&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sh running-config&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示接口信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dis interface&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sh interface&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示接口IP状态和配置信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dis ip interface brief&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sh ip interface brief&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示系统运行统计信息&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dis diagnostic-informaion&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sh diagnostic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;查看历史命令&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;dis history-command&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;sh history&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;管道符&lt;br&gt;
思科设备：begin(开头)，include(包含)，exclude(排除)，section(某一配置的完整内容)&lt;br&gt;
华为设备：include，begin，exclude，configuration和section(华为设备此命令前不需要管道符，类似思科设备上的section&lt;code&gt;dis current-configuration configuration aaa&lt;/code&gt;)&lt;br&gt;
增强现实能力(即一次性显示所有输出内容，不分页)：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 华为设备
user-interface con 0
screen-length 0

# 思科设备
terminal length 0  # 一次性调整
line con 0  # 永久性调整
length 0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;快捷键（终端软件CRT）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761876989.png&#34; alt=&#34;快捷键&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如何设置华为设备中的密码为：huawei@12?4（键入字符?，&lt;code&gt;使用ctrl+t&lt;/code&gt;）&lt;br&gt;
如何设置思科设备中的密码为：cisco@12?4（键入字符?，&lt;code&gt;先ctrl+v，后shift+?&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;网络设备文件管理系统&lt;br&gt;
目录操作&lt;br&gt;
&lt;code&gt;pwd&lt;/code&gt;：查看当前目录&lt;br&gt;
&lt;code&gt;dir&lt;/code&gt;：显示当前目录下文件信息&lt;br&gt;
&lt;code&gt;more&lt;/code&gt;：查看文本文件的具体内容&lt;br&gt;
&lt;code&gt;cd ..&lt;/code&gt;：退到上级目录&lt;br&gt;
文件操作&lt;br&gt;
&lt;code&gt;cd&lt;/code&gt;：修改用户当前界面的工作目录&lt;br&gt;
&lt;code&gt;mkdir&lt;/code&gt;：创建目录&lt;br&gt;
&lt;code&gt;rmdir&lt;/code&gt;：删除目录&lt;br&gt;
存储设备操作&lt;br&gt;
&lt;code&gt;copy&lt;/code&gt;：复制文件&lt;br&gt;
&lt;code&gt;move&lt;/code&gt;：移动文件&lt;br&gt;
&lt;code&gt;rename&lt;/code&gt;：重命名文件&lt;br&gt;
保存配置&lt;br&gt;
&lt;code&gt;思科&lt;/code&gt;：write&lt;br&gt;
&lt;code&gt;华为&lt;/code&gt;：save&lt;br&gt;
清空设备所有配置&lt;br&gt;
&lt;code&gt;华为&lt;/code&gt;：reset saved-configuration，重启的时候第一个问题为n，第二个为y&lt;br&gt;
&lt;code&gt;思科&lt;/code&gt;：write erase  或者  erase startup-config&lt;br&gt;
重启设备&lt;br&gt;
&lt;code&gt;华为&lt;/code&gt;：reboot&lt;br&gt;
&lt;code&gt;思科&lt;/code&gt;：reload&lt;/li&gt;
&lt;li&gt;清空华为设备密码&lt;br&gt;
首先用console线连接交换机和主机，打开终端，然后重启交换机，然后在终端上会显示很多东西，当出现下面红框内的话是，按CTRL+B。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761893482.png&#34; alt=&#34;清空密码1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
输入BOOTROM的密码：Admin@huawei.com。&lt;br&gt;
&lt;code&gt;盒式交换机的某些款型支持使用快捷键“Ctrl+E”进入BootROM主菜单，请根据设备的界面提示操作;盒式交换机在V100R006C03之前的版本，BootROM默认密码为huawei；在V100R006C03及其之后的版本，默认密码为Admin@huawei.com；框式交换机在V100R006C03之前的版本，BootROM默认密码为9300；在V100R006C03及其之后的版本，默认密码为Admin@huawei.com。&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761904589.png&#34; alt=&#34;清空密码2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
出现下图内容后，选择“7. Clear password for console user”，在底部光标出输入“7”。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761915720.png&#34; alt=&#34;清空密码3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
出现下图内容后，选择“1. Boot with default mode”，在底部光标出输入“1”。&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761925798.png&#34; alt=&#34;清空密码4&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
稍等片刻即可完成，此时交换机是没有密码的，接下来通过命令给交换机增加密码，确保交换机的安全性。&lt;/li&gt;
&lt;/ol&gt;
">07 认识和管理交换机的mac地址表与交换机密码清除</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/06-iptcp-bao-wen/"" data-c="
          &lt;ol&gt;
&lt;li&gt;IP&lt;br&gt;
1.1 以太2型：目的Mac+源Mac+TYPE+数据部分&lt;br&gt;
1.2 IP头部：&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585762569097.png&#34; alt=&#34;IP头部&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;Version&lt;/strong&gt;：版本，为IPv4&lt;br&gt;
&lt;strong&gt;IHL&lt;/strong&gt;：头部长度（一般情况下为20字节标准头部，如果有扩展，则为60字节）&lt;br&gt;
&lt;strong&gt;DSCP&lt;/strong&gt;：差分服务代码点，可以为不同的流量设置不同的服务级别&lt;br&gt;
&lt;strong&gt;Total Length&lt;/strong&gt;：IP报文总长度（头部+数据）&lt;br&gt;
&lt;strong&gt;Identification&lt;/strong&gt;：标识是否为同一会话&lt;br&gt;
&lt;strong&gt;Flags&lt;/strong&gt;：分片标志。3层可以分片，MTU最大传输单元默认为1500。但有些应用不允许分片，例如http、qq。设置不允许分片的1500字节的报文：思科设备（思科可以通信）&lt;code&gt;ping 202.100.1.2 size 1500 df-bit&lt;/code&gt;；华为设备（华为无法通信，因为-s不是设置的总报文长度，而是数据部分的长度，若要通信需要改为1472(1500-20字节头部-8字节icmp头部)）&lt;code&gt;ping -s 1500 -f 202.100.1.2&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;Offset&lt;/strong&gt;：偏移量。&lt;br&gt;
&lt;strong&gt;TTL&lt;/strong&gt;：生存时间，数值为0时，IP报文被丢弃，每经过一个网络TTL减1。非常重要的IP报文的防环机制。&lt;br&gt;
&lt;strong&gt;Protocol&lt;/strong&gt;：IP报文承载的协议类型，TCP为6，UDP为17，ICMP为1&lt;br&gt;
&lt;strong&gt;Options&lt;/strong&gt;：扩展项，一般不用。使用举例&lt;code&gt;记录路由：ping -r 202.100.1.2&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 华为设备调整MTU
int g0/0/0
mtu 1600
# 思科设备调整MTU
int s1/0
mtu 4072
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;华为设备上FTP实施&lt;br&gt;
文件传输协议，主要用于设备的系统升级&lt;br&gt;
华为设备升级使用FTP，而思科设备使用TFTP&lt;br&gt;
华为VRP系统即可以作为FTP客户端，也可以作为服务端&lt;br&gt;
FTP的2个端口20/tcp(数据传输)和21/tcp(命令传输)，FTP存在主动模式(port)和被动模式(pasv)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# R2开启ftp服务
ftp server enable  # 开启ftp服务
aaa
local-user hcia password cipher hciapwd  # 添加用户名和密码
local-user hcia service-type ftp  # 该用户服务于ftp
local-user hcia privilege level 15  # 设置用户级别
local-user hcia ftp-directory flash:  # 设置ftp的目录，注意flash后面需要冒号
q
dis tcp status # 查看tcp链接状态
# R1测试
ftp 202.100.1.2  #输入用户名和密码
ls # 查看所有文件
get &amp;quot;文件名称&amp;quot;  # 从服务器下载文件
put &amp;quot;文件名称&amp;quot;  # 上传文件到服务器
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;TCP&lt;br&gt;
传输层不能分片，因为没有对应字段的支持&lt;br&gt;
查看tcp状态（五元组）&lt;code&gt;dis tcp status&lt;/code&gt;，通过五元组可以确定一条会话。&lt;br&gt;
tcp报文的开销比较大（头部复杂，占用字节较多）；udp报文开销比较小。&lt;br&gt;
使用目的端口号来区分不同的服务。&lt;br&gt;
3.1 TCP的封装格式：&lt;br&gt;
&lt;code&gt;端口号大的一端主动发起连接&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761707257.png&#34; alt=&#34;TCP的封装格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;32位序列号，数据段标记，用于到目的端对到达包的重组&lt;/li&gt;
&lt;li&gt;32位确认号，对发送端的确认信息，告诉发送端这个序号之前的数据段都收到了&lt;/li&gt;
&lt;li&gt;URG，紧急指针有效位，与16位的紧急指针配合使用&lt;/li&gt;
&lt;li&gt;ACK，确认序列号有效位，表明该数据包包含确认信息&lt;/li&gt;
&lt;li&gt;PSH，通知接收端立即将数据提交给用户进程，不在缓存中停留，等待更多的数据&lt;/li&gt;
&lt;li&gt;RST，为1时，请求重新建立TCP连接&lt;/li&gt;
&lt;li&gt;SYN位，请求建立TCP会话的一个标识&lt;/li&gt;
&lt;li&gt;FIN，为1时，数据发送完毕，请求断开连接&lt;/li&gt;
&lt;li&gt;16位窗口大小，滑动窗口大小，指名本地可接收数据的字节数&lt;/li&gt;
&lt;li&gt;可选项：4字节/个，常用可选项举例：MSS，最大报文段长度，默认是1460=1500-20-20），用于企业网关通过PPPoE连接互联网后，需要调整MSS才能去正常访问WEB应用（故障：能ping通外网，但是WEB极慢或者打不开）。&lt;br&gt;
3.2 3次握手和4次断开&lt;br&gt;
3次握手：&lt;strong&gt;a到b&lt;/strong&gt;的SYN----&amp;gt;&lt;strong&gt;b到a&lt;/strong&gt;的SYN和ACK----&amp;gt;&lt;strong&gt;a到b&lt;/strong&gt;的ACK&lt;br&gt;
4次断开：&lt;strong&gt;a到b&lt;/strong&gt;FIN(可能包含PSH\ACK)----&amp;gt;&lt;strong&gt;b到a&lt;/strong&gt;ACK----&amp;gt;&lt;strong&gt;b到a&lt;/strong&gt;FIN(可能包含PSH\ACK)----&amp;gt;&lt;strong&gt;a到b&lt;/strong&gt;ACK&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;UDP&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761726332.png&#34; alt=&#34;UDP头部&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
华为和华三设备只能最为TFTP的客户端，从服务器获取文件。&lt;br&gt;
使用UDP协议下的TFTP协议（端口号69）&lt;strong&gt;备份（升级）思科IOS的一个实验（模拟器无法实施此实验）&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# TFTPD64工具，配置PC开启TFTP服务
# 配置交换机或者路由器IP地址之后，实现PC和交换设备之间的通信
# 备份
copy flash:c3560....bin tftp:  # 将镜像文件备份到tftp服务器，输入tftp服务器地址（PC地址）
# 升级
copy  tftp:  flash:update.zip # 输入tftp服务地址，然后输入文件名称
boot system update.zip # 设定新的启动文件，即更新
# 将思科设备的TFTP服务端打开
tftp-server flash:
&lt;/code&gt;&lt;/pre&gt;
">06 IP/TCP报文</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/05-shi-shi-ssh-guan-li-wang-luo-she-bei/"" data-c="
          &lt;ol&gt;
&lt;li&gt;VLSM（可变长子网掩码）&lt;br&gt;
网络中的子网的子网掩码长度不相同&lt;/li&gt;
&lt;li&gt;网关&lt;br&gt;
主机的数据去往其他网络，就把数据发到网关（特别重要的ARP请求），然后由网关去查找路由。网关的地址一般是同一网络的最大（254）的或者最小（1）的可用IP。&lt;br&gt;
纯二层交换机进行远程管理时，如果没有默认网关无法管理。&lt;/li&gt;
&lt;li&gt;CIDR（无类路间路由）&lt;br&gt;
消除自然分类地址和子网划分的界限（超网）；将网络前缀相同的连续IP地址组成CIDR地址块；支持强化地址汇聚（&lt;strong&gt;划分子网时增加掩码长度，而汇聚则是减少掩码长度&lt;/strong&gt;）；无类域间路由协议包含RIPv2、EIGRP、OSPF、IS-IS、BGP&lt;/li&gt;
&lt;li&gt;常见TCP\UDP端口&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761635266.png&#34; alt=&#34;常见TCP\UDP端口&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;在R1和R2之间实施ssh&lt;br&gt;
&lt;code&gt;模拟器中的交换机无法实施ssh&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#.....................................配置SSH
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# R2（开启ssh服务）
en
conf t
int e0/0
ip address 202.100.1.2 255.255.255.128
exit
username hcia password hciapwd  # 创建用户名和密码
ip domain name hcia.com  # 设置域名
crypto key generate rsa  # 产生密钥，使用1024位（768位以上）
ip ssh version 2 # 【此命令非必需】因为上一步已经开始ssh
line vty 0 4 
login local  # 通过本地认证登录
transport input ssh  # 允许ssh登录vty
exit
terminal monitor # 显示远程连接日志

# R1
en
conf t
int e0/0
ip address 202.100.1.1 255.255.255.128
ping 202.100.1.2
ssh -l hcia 202.100.1.2  # 远程登录，输入密码


# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# R2
system-view
int g0/0/0
ip address 202.100.1.2 25
q
aaa
local-user hcia password cipher hciapwd  # 创建本地用户以及密码
local-user hcia service-type ssh  # 该用户服务于ssh协议
local-user hcia privilege level 15  # 设置用户级别
q
ssh user hcia authentication-type password # 使用密码认证
rsa local-key-pair create  # 【此命令非必需】本地创建密钥，如果使用密码认证，则不必要产生密钥
stelnet server enable  # 开启ssh服务
user-interface vty 0 4
authentication-mode aaa  # 认证方式改为aaa
protocol inbound ssh  # 设置使用ssh管理

# R1
system-view
int g0/0/0
ip address 202.100.1.1 25
ping 202.100.1.2
ssh client first-time enable  # 第一次使用ssh客户端需要执行此命令
stelnet 202.100.1.2  # 输入用户名hcia，密码hciapwd
&lt;/code&gt;&lt;/pre&gt;
">05 实施SSH管理网络设备</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/04-ip-zi-wang-gui-hua-yi-ji-yan-zheng-dan-bo-zu-bo-he-guang-bo-cdp-he-lldp/"" data-c="
          &lt;ol&gt;
&lt;li&gt;LLDP&lt;br&gt;
链路层发现协议，公有协议&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 华为设备，默认没有开启
# 开启lldp
lldp enable
dis lldp neighbor brief
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;CDP&lt;br&gt;
思科发现协议，私有协议，默认开启，二层协议，封装在802.3中&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;show cdp neighbors
# 关闭整体cdp
no cdp run
# 关闭单个接口的cdp
int e0/1
no cdp enable
# 开启lldp
conf t
lldp run
show lldp neighbors
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;修改接口属性&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
# 修改接口为全双工(线两端接口均需要修改)
int e0/1
duplex full
show int e0/1

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
# 修改接口为半双工
# 先关闭自动协商
int g0/0/1
undo negotiation auto
duplex half
dis int g0/0/1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;交换行为和MAC地址表&lt;br&gt;
交换机上转发数据帧的行为，决策依据是Mac地址表&lt;br&gt;
4.1 转发行为分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;泛洪Flooding&lt;br&gt;
如果Mac地址表为空或者没有某Mac地址表项，或者交换机收到广播帧/组播帧的时候，会把帧发往除了接受该帧之外的其他所有接口&lt;/li&gt;
&lt;li&gt;转发Forwarding（单播）&lt;br&gt;
在Mac地址表中有明确的目的Mac地址的表项&lt;/li&gt;
&lt;li&gt;丢弃Discarding&lt;br&gt;
Mac地址表中没有目的Mac地址表项，且无法学习到&lt;br&gt;
4.2 Mac地址表&lt;br&gt;
重要准则：同一时刻，某个MAC地址只能从1个接口学习到，不能频繁从多个接口学到，否则叫做Mac地址震荡&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
show mac address-table
show run int vlan 1 # 查看vlan1配置
# 查看老化时间，默认300秒，不建议修改
show mac address-table aging-time
# 配置静态mac地址表
mac address-table static a.a.a vlan 1 interface e0/2

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
display mac-address
dis cu int vlan 1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;IP基础&lt;br&gt;
5.1 特点：无连接协议（只有TCP是有连接）；结构化编址，用于寻址和转发；尽力而为的逐跳转发；与媒介无关，但可以适应多种链路。&lt;br&gt;
5.2 掩码（mask）用于区分网络部分和主机部分，由连续的0和1组成（&lt;strong&gt;0和1必须连续&lt;/strong&gt;），1的部分代表网络，0的部分代表主机。&lt;br&gt;
5.3 分类：ABC类用于单播，D类用于组播，E类不实用。&lt;br&gt;
&lt;code&gt;A类地址默认掩码255.0.0.0，B类地址默认掩码255.255.0.0，C类地址默认掩码 255.255.255.0&lt;/code&gt;&lt;br&gt;
A类：网络位8b，0.0.0.0-127.255.255.255，例如10.1.2.3/24仍然属于A类网络&lt;br&gt;
B类：网络位16b，128.0.0.0-191.255.255.255&lt;br&gt;
C类：网络位24b，192.0.0.0-223.255.255.255&lt;br&gt;
D类：组播地址，224.0.0.0-239.255.255.255&lt;br&gt;
E类：保留，240.0.0.0-255.255.255.255&lt;br&gt;
&lt;code&gt;NET ,ABCDE的有类网络，即上述分类网络；subnet，即子网，一个大的网络划分成小的网络&lt;/code&gt;&lt;br&gt;
5.4 一些重要的特殊地址&lt;br&gt;
**0.0.0.0：**DHCP协议中没有客户端获得地址时的特殊地址；默认路由（0.0.0.0/0）中的网络部分&lt;br&gt;
**255.255.255.255：**全局广播地址&lt;br&gt;
**主机部分全部为1：**某个网络的广播地址（定向广播地址）&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761567149.png&#34; alt=&#34;一些重要的特殊地址&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;子网&lt;br&gt;
**优势：**较小的网络易于管理；将会减少没必要的广播流量；能够更加容易运用网络安全策略；网络掩码由固定长度变为随机长度；子网掩码中的1代表网络，0代表主机&lt;br&gt;
在直连网络中，192.168.5.139/25（192.168.5.128/25）和192.168.5.254/24（192.168.5.0/24）可以通信，因为139这个地址属于后面那个网络中；192.168.5.1/24和192.168.5.139不能通信。&lt;br&gt;
&lt;code&gt;任何不给掩码的地址都是耍流氓&lt;/code&gt;&lt;br&gt;
&lt;strong&gt;10.1.1.0可以配置成IP，只需要掩码正确，比如10.1.1.0/23&lt;/strong&gt;&lt;br&gt;
**借用地址：**32位掩码的地址（例如2.2.2.2/32）为主机路由，通常情况下可以配置在环回接口（loopback），不能配置到物理接口上。31位掩码的地址可以配置到物理接口上，但是用处不大。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 查看路由表
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;思科
show ip route 

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;华为
display ip routing-table
&lt;/code&gt;&lt;/pre&gt;
">04 IP子网规划以及验证单播、组播和广播（CDP和LLDP）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/03-tong-guo-wireshark-ren-shi-wang-luo-tong-guo-bao-wen-li-jie-tcpip/"" data-c="
          &lt;ol&gt;
&lt;li&gt;单端口高速以太网：G--&amp;gt;10G--&amp;gt;25G--&amp;gt;40G--&amp;gt;100G--&amp;gt;200G--&amp;gt;400G&lt;/li&gt;
&lt;li&gt;以太网介质：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;RF（射频线）&lt;/li&gt;
&lt;li&gt;同轴电缆&lt;/li&gt;
&lt;li&gt;双绞线：5类为百兆，6类为千兆，7类为万兆&lt;/li&gt;
&lt;li&gt;光纤
&lt;ul&gt;
&lt;li&gt;分类：&lt;br&gt;
多模光纤（mm，橘色或者蓝色，传输距离通常在千米以内，波长为850nm，光模块拉环为黑色的）&lt;br&gt;
单模光纤（sm，黄色，传输距离远，波长为1550/1310nm，光模块拉环为蓝色的）&lt;/li&gt;
&lt;li&gt;光模块：SFP和SPF+为千兆，XFP为万兆，QSFP为100G（体积更大）。&lt;br&gt;
SX：850nm，短距离光模块（&amp;lt;10km），一般适合多模光纤&lt;br&gt;
LX：1310nm，传输距离&amp;lt;25km，适合单模光纤&lt;br&gt;
ZX：1550nm，传输距离80km，适合单模光纤&lt;br&gt;
LH：超长距离光模块，25-70km，如果距离小于35km，则需要在LH之间加衰减器，以防止LH模块损坏&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;以太帧物理地址：Mac，通常认为该地址唯一且不可改变。共48位（二进制），前24位为OUI组织机构代码，后24位为组织内部来分配的。&lt;/li&gt;
&lt;li&gt;2层的单播、组播和广播&lt;br&gt;
第一字节的第8比特表示地址类型&lt;br&gt;
单播mac：类型字节为0，表示目的mac为此mac地址的帧都是发送到某个唯一的目的mac&lt;br&gt;
组播mac：类型字节为1，经典组播mac：01005E&lt;br&gt;
广播mac：全1&lt;/li&gt;
&lt;li&gt;以太封装和MAC地址表&lt;br&gt;
5.1 两种格式的以太帧头部：&lt;br&gt;
&lt;code&gt;当以太2型里面的“类型”或者802.3里面的“长度”字段 大于等于1536(0x0600)则为以太2型，小于等于1500（0x05DC）则为802.3&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;以太2型（用户、业务流量）：目的mac+源mac+类型+数据&lt;/li&gt;
&lt;li&gt;802.3（协议的控制）：目的mac+源mac+长度+LLC子层和MAC子层+数据&lt;br&gt;
5.2 MAC地址表&lt;br&gt;
mac地址表是2层（交换机）转发表&lt;br&gt;
mac地址震荡（漂移）：一个终端的mac地址同一时间只能从一个接口学习到，一个接口学习到的mac地址在同一个vlan中的另一个接口上也学习到，&lt;strong&gt;后学习到的mac地址表覆盖原来的表项&lt;/strong&gt;，甚至出现反复，将严重影响业务转发。&lt;code&gt;mac地址表震荡一般意味着网络中出现环路，形成广播风暴或者Vlan划分错误等。&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ---------------------华为
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;查看mac地址表
# SW1
int vlanif 1
ip address 10.1.11.2 255.255.255.248
# AR1 
int g0/0/1
ip address 10.1.11.1 255.255.255.248
ping 10.1.11.2
dis mac-add # 查看mac地址表
#-----------------------------------------------------------------------------------------------------------------
# ---------------------思科
# sw1
int vlan 1
no shutdown
ip address10.1.11.2 255.255.255.248
# AR1
int e0/1
no shutdown 
ip address10.1.11.1 255.255.255.248
exit
ping 10.1.11.2
show mac address-table
&lt;/code&gt;&lt;/pre&gt;
">03 通过wireshark认识网络（通过报文理解TCP/IP）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/02-shi-shi-ji-chu-de-ip-di-zhi-he-yuan-cheng-guan-li-telnet/"" data-c="
          &lt;ol&gt;
&lt;li&gt;OSI参考模型&lt;br&gt;
&lt;code&gt;不能以设备讨论层次，而是以协议讨论层次&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;层级&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;单位&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;比特/01&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Frame/帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Packet/包&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;Segment/段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;会话层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PDU/协议数据单元&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;表示层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PDU/协议数据单元&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;PDU/协议数据单元&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;TCP/IP模型&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;层级&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;对应OSI层级&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络接口层/链路层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;物理层、数据链路层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;互联网层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;网络层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;传输层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;会话层、表示层、应用层&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;telnet远程管理设备&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ---------------------思科
# 配置接口的IP地址
# R1
en
conf t
int e0/0
no shutdown  # 思科设备接口默认关闭
ip address 202.100.1.1 255.255.255.252
# R2
en
conf t
int e0/0
no shutdown  # 思科设备接口默认关闭
ip address 202.100.1.2 255.255.255.252
ping 202.100.1.1

# 开启telnet
# 远程登陆了第一个密码为telnet密码，第二个为特权模式密码
# R2
enable
enable password enhcia  # 设置特权模式密码
conf t
line vty 0 4
login  #允许登录
password  hcia
transport input all #允许所有远程管理协议来登录
int e0/0
ip address 202.100.1.2 255.255.255.252
#--------------------------------------------------------------------------------------------------------
# ---------------------华为
# 接口默认开启
# 配置IP
# R1
system-view
int g0/0/0
ip address 202.100.1.1 255.255.255.252
# R2
system-view
int g0/0/0
ip address 202.100.1.2 30
ping 202.100.1.1
# 配置远程登录
#R2
user-interface vty 0 4
authentication-mode password hcia  # 路由器设备在此之后输入密码
user privilege level 3  # 配置用户级别，默认是0
# R1测试
telnet 202.100.12
&lt;/code&gt;&lt;/pre&gt;
">02 实施基础的IP地址和远程管理（Telnet）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/01-si-ke-hua-wei-hua-san-3-chong-mo-ni-qi-de-an-zhuang-he-shi-yong/"" data-c="
          &lt;ol&gt;
&lt;li&gt;EVE安装&lt;br&gt;
从课前资料中下载0-eve文件夹全部内容&lt;br&gt;
----&amp;gt;使用VMwareWorkstations打开其中的&lt;strong&gt;QYT_EVE.ovf&lt;/strong&gt;（固定IP为&lt;strong&gt;192.168.110.110&lt;/strong&gt;）文件&lt;br&gt;
----&amp;gt;最终要的是调整网卡，需要使虚拟机和PC通信，将网络适配器调整为自定义下面的&lt;strong&gt;VMnet1(仅主机模式)&lt;/strong&gt;&lt;br&gt;
----&amp;gt;修改PC虚拟网卡&lt;strong&gt;VMnet1&lt;/strong&gt;的IP地址为&lt;strong&gt;192.168.110.111（只要不是192.168.110.110即可）&lt;/strong&gt;&lt;br&gt;
----&amp;gt;启动，web用户名：admin，密码：eve&lt;br&gt;
----&amp;gt;导入拓扑：close lab----import----选择QYTCNA_20180920.zip----upload----勾选----open&lt;/li&gt;
&lt;li&gt;eNSP安装&lt;br&gt;
安装VirtualBox-5.1.26&lt;br&gt;
----&amp;gt;安装wireshark&lt;br&gt;
----&amp;gt;安装eNS&lt;br&gt;
----&amp;gt;注册设备&lt;br&gt;
----&amp;gt;导入拓扑QCNA.topo&lt;br&gt;
&lt;code&gt;【注意】1.不要使用阉割版系统，使用企业版或者旗舰版；2.禁止使用ghost系统；3.关闭防火墙；4.卸载任何系统管家或者垃圾清理软件&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585983117059.png&#34; alt=&#34;本课程使用的路由拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;常用网络设备：路由器、交换机、防火墙、AC(无线)控制器&lt;/li&gt;
&lt;li&gt;SecureCRT&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;安装：SecureCRT下载之后解压----双击里面的注册表文件2.reg----正常使用&lt;/li&gt;
&lt;li&gt;使用技巧：
&lt;ul&gt;
&lt;li&gt;telnet会话“强制每次一行”&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585761416603.png&#34; alt=&#34;telnet01&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;锁定会话（&lt;strong&gt;记录所有的重要信息，证据来源&lt;/strong&gt;）&lt;br&gt;
文件----会话日志----选择保存文件位置&lt;/li&gt;
&lt;li&gt;快捷键&lt;br&gt;
&lt;code&gt;ctrl+tab&lt;/code&gt;：下一个标签&lt;br&gt;
&lt;code&gt;ctrl+shift+tab&lt;/code&gt;：上一个标签&lt;br&gt;
&lt;code&gt;alt+数字&lt;/code&gt;：快速切换到某个标签&lt;br&gt;
&lt;code&gt;ctrl+f4&lt;/code&gt;：快速关闭当前标签&lt;br&gt;
&lt;code&gt;ctrl+（c或者inter）（或者选中之后点击鼠标左键）&lt;/code&gt;：复制当前内容&lt;br&gt;
&lt;code&gt;shift+insert（或者点击鼠标右键）&lt;/code&gt;：粘贴当前选中内容&lt;br&gt;
&lt;code&gt;ctrl+z&lt;/code&gt;：退出配置模式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;网络设备管理方式&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;console本地管理：权限高、初始化配置、命令行实施，注意不要插到业务接口，大部分设备com口默认的波特率为9600&lt;/li&gt;
&lt;li&gt;专有的以太网管理接口MGMT：带内管理（管理流量和管理流量在一个链路上）和带外管理（专有的MGMT接口，只有管理流量）&lt;/li&gt;
&lt;li&gt;远程管理telnet或者ssh：telnet，明文管理、方便快捷、安全性较差，即vty；ssh，密文管理、安全性好、速度快&lt;/li&gt;
&lt;li&gt;web方式&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;网工必备&lt;br&gt;
CRT、串口线（console--usb）&lt;/li&gt;
&lt;li&gt;Console认证&lt;br&gt;
思科设备：enable 进入特权模式；conf t 进入配置模式&lt;br&gt;
华为设备：system-view 进入系统视图&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ---------------------思科
enable
conf t
line console 0 # 进入consloe接口
password hcia # 设置console密码为hcia
login # 开关命令，即通过console登录的时候需要密码验证
show line # 验证是否使用console（CTY）登录的
#-----------------------------------------------------------------------------------------------------------
# ---------------------华为
system-view
user-interface console 0
authentication-mode password # 设置认证模式为密码认证，路由器在此步需要输入密码
set authentication password cipher hcia
display users # 验证
&lt;/code&gt;&lt;/pre&gt;
">01 思科、华为、华三3种模拟器的安装和使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/00-xian-hua-zhi-ye-gui-hua/"" data-c="
          &lt;ol&gt;
&lt;li&gt;思科SDN线路&lt;br&gt;
1.1 DC级别的产品，ACI&lt;br&gt;
1.2 企业级产品，DNAC（DNA）&lt;br&gt;
1.3 广域网产品，SDWAN-VIPTELA&lt;/li&gt;
&lt;li&gt;华为SDN线路&lt;br&gt;
2.1 DC级别的产品，DCN控制器&lt;br&gt;
2.2 企业级产品，Campus控制器&lt;br&gt;
3.2 广域网产品，Cloud控制器&lt;/li&gt;
&lt;li&gt;华为认证大概学习时间&lt;br&gt;
HCIA：1.3个月&lt;br&gt;
HCIP：2.5个月&lt;br&gt;
HCIE：2.5个月&lt;/li&gt;
&lt;li&gt;跳槽时机&lt;br&gt;
学不到知识、挣不到钱、职位上不去&lt;/li&gt;
&lt;li&gt;职位&lt;br&gt;
售后工程师----售后转售前或销售----转技术经理----去甲方做爸爸----在乙方做企管----在运营商做大拿----在二三线城市做大神&lt;/li&gt;
&lt;li&gt;重点&lt;br&gt;
&lt;strong&gt;学历、证书、项目经验&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
">00 闲话职业规划（2020.0311）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/38-shi-shi-hua-wei-she-bei-shang-de-ipsec-vpn/"" data-c="
          &lt;ol&gt;
&lt;li&gt;基本的模式：&lt;br&gt;
1.1 隧道模式，IPSec会另外生成一个新的IP报头，并封装在AH或ESP之前&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585760562793.png&#34; alt=&#34;IPSecVPN隧道模式&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.2 传输模式，AH或ESP报头位于IP报头和传输层报头之间&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585760572570.png&#34; alt=&#34;IPSecVPN传输模式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;架构：&lt;br&gt;
IPSec不是一个单独的协议，它通过AH（基本不用）和ESP这两个安全协议来实现IP数据包的安全传送。&lt;br&gt;
IKE协议提供密钥协商，建立和维护安全联盟SA等服务。&lt;/li&gt;
&lt;li&gt;安全联盟SA：&lt;br&gt;
安全联盟定义了IPSec对等体间将使用的数据封装模式、认证和加密算法、密钥等参数。&lt;br&gt;
安全联盟是单向的，两个对等体之间的双向通信，至少需要两个SA。&lt;/li&gt;
&lt;li&gt;建立SA的方式（两种）：&lt;br&gt;
4.1 手工方式：安全联盟所需的全部信息都必须手工配置。手工方式建立安全联盟比较复杂，但优点是可以不依赖IKE而单独实现IPSec功能。当对等体设备数量较少时，或是在小型静态环境中，手工配置SA是可行的。&lt;br&gt;
4.2 IKE动态协商方式：只需要通信对等体间配置好IKE协商参数，由IKE自动协商来创建和维护SA。动态协商方式建立安全联盟相对简单些。对于中、大型的动态网络环境中，推荐使用IKE协商建立SA。&lt;/li&gt;
&lt;li&gt;配置步骤&lt;br&gt;
5.1 具体步骤：&lt;br&gt;
配置网络可达（路由） --&amp;gt; 配置ACL识别兴趣流（仅VPN流量） --&amp;gt; 创建安全提议（加密算法、认证、完整性校验等，两端策略必须相同）--&amp;gt; 创建安全策略（对用户流量处理） --&amp;gt; 应用安全策略&lt;br&gt;
5.2 加解密点（PC8&amp;lt;--&amp;gt;AR3）：a.到达对端加解密点（直连）；b.到达本端的通信点（直连）；c.到达对端的通信点（静态默认路由）&lt;br&gt;
5.3 IPSec的SPD(安全策略选择器，即acl)、提议（proposal）、IPSec策略&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;配置隧道模式
#### 配置路由
# AR2
int g0/0/1
ip address 10.1.2.254 24
ip route-static 0.0.0.0 0.0.0.0 202.100.1.254
# AR3：配置IP
int g0/0/0
ip address 10.1.1.250 24
# 使用pc8测试
ping 10.1.1.250

#### 配置acl
# AR1
acl 3000
description vpn
rule 10 permit ip source 10.1.1.0 0.0.0.255 destination 10.1.2.0 0.0.0.255
q
# AR2
acl 3000
description vpn
rule 5 permit ip source 10.1.2.0 0.0.0.255 destination 10.1.1.0 0.0.0.255
q

#### 配置提议
# AR1
ipsec proposal hcia
esp authentication-algorithm sha1  # 认证算法
esp encryption-algorithm des # 加密算法
# AR2，配置必须与AR1相同
ipsec proposal hcia
esp authentication-algorithm sha1
esp encryption-algorithm des
# 查看配置
dis ipsec proposal

# 配置策略
# AR1
ipsec policy hcia-vpn 10  manual   # 序列号为10，这个只需要AR1和AR2保持一致即可
security acl 3000
proposal hcia
tunnel remote 202.100.1.1
tunnel local 202.100.1.254
sa spi inbound esp 54321
sa spi outbound esp 12345
sa string-key outbound esp simple huawei
sa string-key inbound esp simple huawei
# AR2
ipsec policy hcia-vpn 10  manual
security acl 3000
proposal hcia
tunnel remote 202.100.1.254
tunnel local 202.100.1.1
sa spi inbound esp 12345
sa spi outbound esp 54321
sa string-key outbound esp simple huawei
sa string-key inbound esp simple huawei

# 出接口应用
# AR1，如果是虚拟接口，则需要在虚拟接口上使用
int g0/0/0 
ipsec policy hcia-vpn
# AR2
int g0/0/0 
ipsec policy hcia-vpn

# 测试
# 使用pc8 ping10.1.1.250 ，在AR2的g0/0/0上抓包
dis ipsec sa  # 查看ipsec策略情况
dis ipsec statistics esp  # 查看项“Outpacket count”，不断地ping，此值不断增加
&lt;/code&gt;&lt;/pre&gt;
">【38】实施华为设备上的IPSEC VPN（2020.0309）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/37-san-ceng-vlan-jian-lu-you-shi-shi/"" data-c="
          &lt;pre&gt;&lt;code&gt;# 华为路由器恢复出厂设置
reset saved-configuration
reboot
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二层和三层的融合，不同的vlan的主机间的通信需要使用路由表。&lt;br&gt;
二层交换机和路由器在&lt;strong&gt;功能上的集成&lt;/strong&gt;构成了&lt;strong&gt;三层交换机&lt;/strong&gt;，三层交换机在功能上实现了vlan的划分、vlan内部的二层交换和vlan间路由的功能。&lt;br&gt;
VLAN缺点：隔离了各个vlan之间的任何流量，分属不同vlan的用户不能相互通信。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VLAN间路由&lt;br&gt;
1.1 单臂路由（子接口）&lt;br&gt;
交换机连接路由器的接口采用trunk模式，一个链路可以承载多个vlan的流量，使得pc和自身的网关在同一个网络（vlan）,然后网关设备通过直连路由通信。&lt;br&gt;
路由器如何识别vlan的流量：a. 子接口；b. 子接口下配置VlanID&lt;br&gt;
1.2 vlan接口（SVI，交换虚拟接口）&lt;br&gt;
1.3 多臂路由（物理接口）&lt;br&gt;
交换机采用access模式，使得PC和自身的网关在同一个网络（vlan），然后网关设备通过直连路由通信。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 单臂路由
# SW1接入主机PC的配置：创建vlan，并设置access模式
vlan batch 10 20
int g0/0/10
description ConnectToPc1
port link-type access
port default vlan 10
int g0/0/11
description ConnectToPc2
port link-type access
port default vlan 20
# SW1实施交换机的上连接口（交换机与路由器的接口）的配置
int g0/0/2
port link-type trunk
port trunk allow-pass vlan 1 10 20
# AR1实施路由器子接口
int g0/0/2.10
dot1q termination vid 10 # 封装子接口的VlanID为10，用来识别来自trunk的vlan10的流量
ip address 10.1.1.254 24
arp broadcast enable # 允许arp广播通过（默认不允许arp广播通过该子接口）
int g0/0/2.20
dot1q termination vid 20
ip address 10.1.2.254 24
arp broadcast enable # 允许arp广播通过

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 配置三层交换
# 配置交换机sw1
vlan batch 10 20
int g0/0/10
port link-type access
port default vlan 10
int vlanif 10
ip address 10.1.1.254 24
int g0/0/11
port link-type access
port default vlan 20
int vlanif 20
ip address 10.1.2.254 24
# pc5测试：使用主机pc5去ping主机pc6
ping 10.1.2.20
&lt;/code&gt;&lt;/pre&gt;
">【37】三层VLAN间路由实施</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/36-hua-wei-acl-ji-ben-gui-ze-he-yan-shi/"" data-c="
          &lt;p&gt;访问控制列表ACL，定义一系列不同的规则（permit或者deny），实现对网络访问行为的控制、限制网络流量、提高网络性能、防止网络攻击等。&lt;br&gt;
每个ACL可以包含多个规则，&lt;strong&gt;华为ACL默认是允许所有流量通过，但是思科是拒绝所有流量通过&lt;/strong&gt;。&lt;br&gt;
&lt;code&gt;ACL规则中的通配符掩码的0代表不允许变化，1代表忽略（即无所谓，任意变化）&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分类&lt;br&gt;
1.1 基本ACL&lt;br&gt;
2000-2999，匹配源IP地址&lt;br&gt;
1.2 高级ACL&lt;br&gt;
3000-3999，匹配源IP地址、目的IP地址、源端口、目的端口&lt;br&gt;
1.3 二层ACL&lt;br&gt;
4000-4999，匹配源Mac、目的Mac、以太帧协议类型&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看所有的规则
dis acl all

# 对AR1接口g0/0/2应用ACL2001
acl 2001
rule deny source 10.1.1.250 0 
q
int g0/0/2
traffic-filter inbound acl 2001
# 在AR3上使用ping 10.1.1.254验证，发现已经无法ping通
# 在pc5上使用ping 10.1.1.254验证，发现可以ping通

# 高级ACL配置
acl 3000
# 不允许局域网192.168.1.0/24内所有主机访问主机172.16.10.1的21/tcp端口（FTP）
rule deny tcp source 192.168.1.0 0.0.255 destination 172.16.10.1 0 destination-port eq 21
# 不允许局域网192.168.2.0/24内所有主机访问主机172.16.10.2
rule deny tcp source 192.168.2.0 0.0.255 destination 172.16.10.2 0 
rule permit ip # 高级规则需要显示配置所有流量通过，基本规则则是默认所有流量通过
&lt;/code&gt;&lt;/pre&gt;
">【36】华为ACL基本规则和演示</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/35-shi-shi-hua-wei-she-bei-shang-de-easy-ip/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# EasyIP实现
# &amp;gt;&amp;gt; 配置AR1
acl 2000 
description NAT #给规则添加描述
# rule 11 permit source 10.1.1.0 0.0.0.255 # 0.0.0.255为反掩码，代表10.1.1.0/24这个网段都可以转换
rule 10 permit source 10.1.1.250 0 # 只允许10.1.1.250这个地址被转换
dis th 
int dial1
nat outbound 2000 # 2000为acl的索引值

# &amp;gt;&amp;gt;验证
# AR1上查看
dis nat outbound # 查看配置情况
# AR3
ping 202.100.1.1
# AR1
dis acl 2000 # 查看规则命中情况（模拟器可能不出现匹配次数）,可以通过抓包查看，icmp通信双方为202.100.1.254--202.100.1.1，而不是10.1.1.250--202.100.1.1
&lt;/code&gt;&lt;/pre&gt;
">【35】实施华为设备上的Easy IP</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/34-shi-shi-hua-wei-she-bei-shang-de-nat-fu-wu-qi/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# NAT服务器实施
# 虚拟接口下实现 AR1
# 实现：202.100.1.254:2323转换成10.1.1.250:23(telnet)

# &amp;gt;&amp;gt;配置路由器AR3
int g0/0/0  
ip addr 10.1.1.250 24
q
ip route-static 0.0.0.0 0.0.0.0 10.1.1.254

# &amp;gt;&amp;gt;配置AR2
ip route-static 0.0.0.0 0 202.100.1.254 # AR3首先需要有路由表去往202.100.1.254，如果没有路由，则数据包会被丢弃

 # &amp;gt;&amp;gt;配置路由器AR1
int g0/0/2
ip address 10.1.1.254 24
ping 10.1.1.250 # 测试是否能够与AR3通信
int dialer 1
undo nat static global 202.100.1.251 inside 10.1.1.250 #删除之前的静态nat
nat server protocol tcp global 202.100.1.251 2323 inside 10.1.1.250 23
q
dis nat server  # 查看net服务器配置

# &amp;gt;&amp;gt;配置AR3
# 开启认证服务，方便后面使用telnet连接测试
user-interface vty 0 4
set authentication password cipher huawei

#  &amp;gt;&amp;gt;测试是否成功
# 在AR2 上使用telnet测试连接AR3
telnet 202.100.1.251 2323  # 输入密码huawei，telnet命令不能在系统视图运行
# 在AR1上查看会话情况
dis nat session protocol tcp
# 在AR3上查看tcp的状态
dis tcp status
&lt;/code&gt;&lt;/pre&gt;
">【34】实施华为设备上的NAT服务器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/33-hua-wei-nat-ji-ben-chang-jing-jiang-jie/"" data-c="
          &lt;p&gt;网络地址转换，主要用于实现位于内部网络的主机访问外部网络的功能，一般部署在连接内网和外网的网关设备上。&lt;br&gt;
&lt;code&gt;不要依赖ping来验证。标准是IP地址是否成功的做了转换&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态NAT**（IP--IP）**&lt;br&gt;
静态NAT实现私有地址和公有地址的一对一映射，一个公网IP只会分配给唯一且固定的内网主机。&lt;br&gt;
**不常用原因：**整个唯一的公网地址全部被占用，全部的端口只能被一个主机使用，即整个IP协议栈全部做了转换。&lt;/li&gt;
&lt;li&gt;动态NAT**（IP--IP）**&lt;br&gt;
动态NAT基于地址池来实现私有地址和公有地址的转换。&lt;br&gt;
每台主机都会分配到地址池中的一个唯一地址。当不需要此连接时，对应的地址映射将会被删除。当网关收到回复报文后，会根据之前的映射再次进行转换之后转发给对应主机。&lt;br&gt;
动态NAT地址池中的地址用尽以后，只能等待被占用的公用IP被释放后，其他主机才能使用它来访问公网。&lt;br&gt;
简单理解：多个非固定的静态NAT&lt;/li&gt;
&lt;li&gt;NAT服务器（常用）&lt;strong&gt;（IP:port--IP:port）&lt;/strong&gt;&lt;br&gt;
网络地址端口转换NAPT允许多个内部地址映射到&lt;strong&gt;同一个公有地址&lt;/strong&gt;的不同端口（基于端口的转换），属于多对一的地址转换。&lt;br&gt;
允许服务器既能被内部访问，也能被外部访问。&lt;br&gt;
转换某个特定的协议或者端口，用于把服务器提供的服务映射到公网。&lt;/li&gt;
&lt;li&gt;EasyIP（常用）&lt;strong&gt;（IP:port--IP:port）&lt;/strong&gt;&lt;br&gt;
EasyIP允许将多个内部地址映射到网关出接口地址上的不同端口。&lt;br&gt;
实施步骤：定义一个acl，作用是定义哪些主机可以被转换，只有被转换的主机才可以访问互联网，不被定义的不能访问， 然后在出接口（连接外网的接口）应用EasyIP&lt;br&gt;
作用：公网地址和端口的复用&lt;br&gt;
ACL分类：2000-2999为基本acl，3000-3999为高级acl，4000-4999为二层acl&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;静态NAT实施
# 物理接口下配置
interface g0/0/0
ip addr 192.168.1.254 24
int s0/0/1
ip addr 200.10.10.2 24
nat static global 202.10.10.1 inside 192.168.1.1 # 注意：此处不要使用物理接口地址，而必须使用同一网段的其他地址
nat static global 202.10.10.2 inside 192..168.1.2

# 虚拟接口下配置AR1
int dialer 1
nat static global 202.100.1.251 inside 10.1.1.250  # 此处公网地址不能为此接口获取到的公网地址（202.100.1.254），需要使用同网段其他公网地址
# 查看是否转换成功
dis ip routing-table  # 会看到一个协议类型为Unr的路由表，优先级为64
dis nat static

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;动态NAT实施
nat address-group 1 200.10.10.1 200.10.10.200
acl 2000
rule 5 permit source 192.168.1.0 0.0.0.255
q
int s1/0/0
nat outbound 2000 address-group 1 no-pat
&lt;/code&gt;&lt;/pre&gt;
">【33】华为NAT基本场景讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/32-pppoe-de-you-hua/"" data-c="
          &lt;ol&gt;
&lt;li&gt;MTU(最大传输单元)和MSS(最大报文段长度)&lt;br&gt;
主要原因是增加两个报头：PPPoE(6字节)和PPP(2字节)的报头&lt;br&gt;
PPPoe侧接口MTU值为1492字节，当从这个接口上发送的三层转发报文大于MTU值且报文&lt;strong&gt;设置为不可分片&lt;/strong&gt;时就会导致报文无法发送出去，出现用户上网&lt;strong&gt;网速慢&lt;/strong&gt;的情形。&lt;br&gt;
可以在&lt;strong&gt;拨号口下&lt;/strong&gt;配置&lt;code&gt;tcp adjust-mss&lt;/code&gt;**(推荐配置1200)**命令修改TCP协商阶段协商出的MSS大小，使报文长度小于拨号口的MTU值，保证报文的正常处理，解决上网速度慢的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;客户端AR1配置
int dialer 1
tcp adjust-mss 1200
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;DNS&lt;br&gt;
配置PPPoE客户端接收服务端分配的DNS服务器地址，配置命令可同时选择&lt;strong&gt;以下两条命令或者其中一条：&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ppp ipcp dns request&lt;/code&gt;：在dialer视图中配置PPPoE客户端主动向PPPoE服务端请求dns服务器地址。缺省情况下，禁止PPPoE客户端主动向PPPoE服务端请求dns服务器地址。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ppp ipcp dns admin-any&lt;/code&gt;：在dialer视图中配置PPPoE客户端被动的接收PPPoE服务端分配的dns服务器地址。缺省情况下，PPPoE客户端不会被动的接收PPPoE服务端分配的dns服务器地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;客户端AR1配置
int dialer 1
ppp ipcp dns request
ppp ipcp dns admit-any
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;静态默认路由&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;客户端AR1配置
# 由于dialer 1接口是一个PPP接口，所有可以采用以下IP配置
ip route-static 0.0.0.0 0.0.0.0 dialer 1
&lt;/code&gt;&lt;/pre&gt;
">【32】PPPoE的优化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/31-pppoe-li-lun-he-ji-ben-shi-shi/"" data-c="
          &lt;p&gt;PPPoE协议通过在以太网上提供点到点的连接，建立PPP会话，使得以太网中的主机能够连接到远端的宽带接入服务器。PPPoE具备适用范围广、安全性高、计费方便等特点。目前比较流行的宽带接入方式ADSL（DSL，数字用户线路；xDSL，x表示不同种类的数字用户线路技术），ADSL是非对称DSL技术，使用的是PPPoE协议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PPPoE报文&lt;br&gt;
PPPoE报文使用Ethernet格式来进行封装&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585760251712.png&#34; alt=&#34;PPPoE报文&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.1 Type&lt;br&gt;
表示协议类型字段，当值为0x8863时表示承载的是PPPoE发现阶段的报文。当值为0x8864时表示承载的是PPPoE会话阶段的报文。&lt;br&gt;
1.2 PPPoE字段中的各个字段解释如下&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Ver：表示PPPoE版本号，值为0x01。&lt;/li&gt;
&lt;li&gt;Type：表示类型，值为0x01。&lt;/li&gt;
&lt;li&gt;Code：表示PPPoE报文类型，不同取值标识不同的PPPoE报文类型。&lt;/li&gt;
&lt;li&gt;Session ID：PPPoE会话ID，与以太网SMAC和DMAC一起定义了一个PPPoE会话。&lt;/li&gt;
&lt;li&gt;Length：表示PPPoE报文的Payload长度，不包括以太网头部和PPPoE头部的长度。&lt;br&gt;
1.3 PPPoE协议报文&lt;/li&gt;
&lt;li&gt;PADI：发现初始报文。目的MAC地址是一个广播地址，Code字段为0x09，Session ID字段为0x0000&lt;/li&gt;
&lt;li&gt;PADO：发现提供报文。目的地址是发送PADI报文的客户端MAC地址，Code字段为0x07，Session ID字段为0x0000&lt;/li&gt;
&lt;li&gt;PADR：发现请求报文。目的地址是选中的服务器的MAC地址，Code字段为0x19，Session ID字段为0x0000&lt;/li&gt;
&lt;li&gt;PADS：发现会话确认报文。目的地址是PPPoE客户端的MAC地址，Code字段为0x65，Session ID字段是PPPoE服务器为本PPPoE会话产生的Session ID&lt;/li&gt;
&lt;li&gt;PADT：发现终止报文。目的MAC地址为单播地址，Session ID为希望关闭的连接的Session ID&lt;br&gt;
1.4 PPPoE会话建立过程&lt;/li&gt;
&lt;li&gt;发现阶段：获取对方以太网地址，以及确定唯一的PPPoE会话&lt;/li&gt;
&lt;li&gt;会话阶段：包含两部分，ppp协商阶段和ppp报文传输阶段（LCP、认证、NCP）&lt;/li&gt;
&lt;li&gt;会话终结阶段：会话建立以后的任意时刻，发送报文结束PPPoE会话&lt;br&gt;
&lt;code&gt;【客户端】通过广播发送PADI报文来发现接入服务器 --&amp;gt; 所有PPPoE【服务器】收到PADI报文后，将客户端请求的服务与自己能够提供的服务进行比较，如果可以提供服务，则回复PADO报文 --&amp;gt; PPPoE【客户端】最先收到的PADO报文对应的PPPoE服务器，并单播发送一个PADR报文 --&amp;gt; PPPoE【服务器】生成唯一的会话ID，并发送PADS报文给客户端，会话建立成功 --&amp;gt; 传输PPP数据 --&amp;gt; PPPoE【客户端】向服务端发送PADT，结束会话&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585760318923.png&#34; alt=&#34;PPPoE会话建立过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
1.5 PPPoE实施过程（采用chap认证）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;服务端AR2配置
# 设置全局认证的用户名和密码
aaa
local-user hcia password cipher huawei
local-user hcia service-type ppp
q
# 配置地址池，用于分发地址
ip pool hciaippool1
network 202.100.1.0 mask 255.255.255.0
dns-list 114.114.114.114  8.8.8.8   # pppoe客户端获得的dns服务器
# 配置虚拟模板和调用模板
interface virtual-template 1
ip address 202.100.1.1 255.255.255.0  # 华为设备从最高的IP开始分配地址，所以尽量配置号码小的地址
remote address pool hciaippool1  #配置客户端获取地址的方式
ppp authentication-mode chap
int g0/0/0  # 接口与虚拟模板绑定
pppoe-server bind virtual-template 1

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;客户端AR1配置
dialer-rule #配置拨号接口
dialer-rule 1 ip permit # 允许所有IP报文转发
quit
interface dialer 1
dialer user agenttest # 该用户名不用于认证，是标识作用和dialer绑定
dialer-group 1 #将接口置于一个拨号访问组
dialer bundle 1 #指定Dialer接口使用的Dialer bundle。设备通过Dialer bundle将物理接口与拨号接口关联起来。
ppp chap user hcia
ppp chap password cipher huawei
ip address ppp-negotiate  # 从对端服务器获取地址
q
int g0/0/0 # 物理接口和逻辑接口绑定
pppoe-client dial-bundle-number 1 

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 验证
# 重点：逻辑接口是工作的，物理接口是down的
dis ip int bri
display pppoe-client session summary
&lt;/code&gt;&lt;/pre&gt;
">【31】PPPoE理论和基本实施</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/29-30-ppp-xie-yi-he-papchap-ren-zheng-shi-shi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;HDLC，高级数据链路控制，是面向比特的链路层协议，即二层协议，帧结构：信息帧、监控帧、无编号帧&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在华为设备上默认封装了PPP协议（2层）
# 启用hdlc，需要在网线连接的两个接口上都做
int s1/0/0 
dis th
link-protocol hdlc 
# 串行接口通过PPP协议进行通信，一端IP为100.100.100.100/24，另一端IP为12.1.1.2/24
int s1/0/0 #AR2
ip addr 100.100.100.100 24
int s1/0/0 #AR1
ip addr 12.1.1.2 24
ping 100.100.100.100
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;PPP，点到点链路层协议，不需要arp解析，主要用于全双工的同异步链路上进行点到点的数据传输。&lt;br&gt;
不需要mac地址封装，只需要把报文发到该链路上，与双方IP是否在同一个网段无关。&lt;br&gt;
PPP工作后就会在本设备得到一条对端的32位主机路由。&lt;br&gt;
2.1 PPP的两大基本组件&lt;br&gt;
LCP（链路控制协议）：用来建立、拆除和监控PPP数据链路&lt;br&gt;
NCP（网络层控制协议）：用于对不同的网络层协议进行连接建立和参数协商&lt;br&gt;
2.2 PPP链路建立过程&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585760171686.png&#34; alt=&#34;PPP链路建立过程&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
2.3 LCP报文&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;Configure-Request（配置请求）：链路层协商过程中发送的第一个报文，该报文表明点对点双方开始进行链路层参数的协商。&lt;/li&gt;
&lt;li&gt;Configure-Ack（配置响应）：收到对端发来的Configure-Request报文，如果参数取值完全接受，则以此报文响应。&lt;/li&gt;
&lt;li&gt;Configure-Nak（配置不响应）：收到对端发来的Configure-Request报文，如果参数取值&lt;strong&gt;不被本端认可&lt;/strong&gt;，则发送此报文并且携带本端可接受的配置参数。&lt;/li&gt;
&lt;li&gt;Configure-Reject（配置拒绝）：收到对端发来的Configure-Request报文，如果本端&lt;strong&gt;不能识别&lt;/strong&gt;对端发送的Configure-Request中的某些参数，则发送此报文并且携带那些本端不能认别的配置参数。&lt;br&gt;
2.4 LCP协商参数&lt;/li&gt;
&lt;li&gt;最大接收单元MRU，PPP数据帧中Information字段和Padding字段的总长度，默认1500字节&lt;/li&gt;
&lt;li&gt;认证协议，认证对端使用的认证协议，默认不认证&lt;/li&gt;
&lt;li&gt;魔术字，魔术字为一个随机产生的数字，用于检测ppp链路环路，&lt;strong&gt;如果收到的LCP报文中的魔术字和本端产生的魔术字相同，则认为链路有环路&lt;/strong&gt;，默认启用&lt;br&gt;
2.5 认证方式&lt;/li&gt;
&lt;li&gt;PAP：密码认证协议，明文，常用&lt;/li&gt;
&lt;li&gt;CHAP：挑战握手认证协，比PAP优秀，可防止DDOS攻击，不发送密码，而是发送MD5值，3次握手协议(认证方向被认证方发起挑战报文--&amp;gt;被认证方发送响应报文--&amp;gt;成功或者失败PPP接入)&lt;/li&gt;
&lt;li&gt;MS-CHAP：思科和微软共同开发的挑战握手认证协&lt;/li&gt;
&lt;li&gt;PPP的认证还可以借助AAA（授权、认证、统计）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 通过AAA来认证PPP
aaa
local-user test password cipher huawei
local-user test service-type ppp

# 通过PAP来认证PPP
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;认证方AR2
aaa   
local-user test password cipher huawei
local-user test service-type ppp
int s1/0/0
link-protocol ppp
ppp authentication-mode pap
ip address 12.1.1.2 24
shutdown 
undo shutdown
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;被认证方AR1
int s1/0/0
link-protocol ppp
ppp pap local-user test password cipher huawei
ip address 100.100.100.100 24
# 查看是否得到对端地址的32位主机路由
dis ip routing-table protocol direct
ping 12.1.1.2

# 通过CHAP来认证PPP
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;认证方AR2
aaa   
local-user test2 password cipher huawei123
local-user test2 service-type ppp
int s1/0/0
link-protocol ppp
ppp authentication-mode chap
ip address 12.1.1.2 24
shutdown 
undo shutdown
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;被认证方AR1
int s1/0/0 
link-protocol ppp
ppp chap user test2
ppp chap password cipher huawei123
ip address 100.100.100.100 24
q
q
debugging ppp chap all
# 查看是否得到对端地址的32位主机路由
dis ip routing-table protocol direct
ping 12.1.1.2
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1585760203416.png&#34; alt=&#34;下面几节课都会用到的路由拓扑&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">【29-30】PPP协议和PAP、CHAP认证实施</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/27-jiao-huan-ji-sheng-cheng-shu-de-shi-shi/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 影响根路由器选择
# 修改生成树模式为stp。可选stp、rstp、mstp
stp mode stp
# 修改桥优先级BP，必须是4096的倍数，可以用0，且0有最大可能性成为根
stp priority 4096
# 使用stp root命令快速修改指定优先级
stp root primary  # 将优先级改为0
stp root secondary   # 将优先级改为4096
#&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 影响根端口选择
# 配置路径开销（一般不需要修改此参数）,可选dot1d-1998、dot1t（默认）、legacy
stp pathcost-standard dot1t
# 修改接口的cost值，影响RP根端口的选举
int g0/0/1
stp cost 2000
&lt;/code&gt;&lt;/pre&gt;
">【27】交换机生成树的实施</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/25-26-jiao-huan-ji-sheng-cheng-shu-yuan-li/"" data-c="
          &lt;ol&gt;
&lt;li&gt;&lt;strong&gt;生成树的选举-选举根网桥RB&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;先选举桥优先级比较小的，较小的优先；如果优先级相同，则选择mac地址小的优先&lt;/code&gt;&lt;br&gt;
每台交换机启动STP后，都认为自己是根网桥&lt;br&gt;
交换机之间通过发送BPDU（网桥协议数据单元）报文来进行一系列的选举&lt;br&gt;
通过比较桥ID（BridgeID，BID）来进行选举，桥ID主要有两部分组成：桥优先级（BridgePriority，默认为32768）、桥ID（BridgeSystemID，背板的mac地址，无法改变，一个设备只有一个）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成树的选举-选取根端口RP&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;选择（排除根设备）根路径开销（RPC，root path cost）最小的；如果根路径开销相同，则选择对端设备的BridgeID小的；如果对端设备的BridgeID再相同，则选择对端设备的端口ID小的；如果对端设备的端口ID相同，则需要选择自身端口ID小的&lt;/code&gt;&lt;br&gt;
非跟交换机在选举根端口时分别依据该端口的根路径开销，对端BID、对端PID和本端的PID&lt;br&gt;
端口ID组成：端口优先级、序号&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生成树的选举-选举指定端口DP&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;选择RPC较小的；端口所在设备的BID；端口ID&lt;/code&gt;&lt;br&gt;
指定端口（DP）作用：发送或者中继根设备发送的BPDU&lt;br&gt;
在每个链路上选举&lt;br&gt;
通常情况下，根设备上的所有端口都是指定端口&lt;br&gt;
备用端口AP虽然不转发数据包，但是能够接收BPDU&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看设备BridgeID（CIST Root/ERPC）
dis stp | i IRPC
# 或者
display bridge mac-address
# 修改桥优先级，越小越优先
stp priority 4096
# 查看端口int g0/0/1的根路径开销RPC
dis stp int g0/0/1 | i Dot1T
# 查看端口ID
dis stp int g0/0/1 | i Designated       #  &amp;quot;/&amp;quot;后面那个128.x，其中128（默认）为优先级，x为序号
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://fqj-web.github.io/post-images/1585760064651.png&#34; alt=&#34;&amp;quot;dis stp | i IRPC&amp;quot;命令结果&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;32768：桥优先级&lt;br&gt;
4c1f-cc9b-346e：桥ID&lt;br&gt;
0：根路径开销&lt;/p&gt;
&lt;/blockquote&gt;
">【25-26】交换机生成树原理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/24-jiao-huan-ji-sheng-cheng-shu-chang-jing-he-yin-fa-de-wen-ti/"" data-c="
          &lt;p&gt;STP，spanning-tree&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用场景&lt;br&gt;
在一个二层的以太网中，存在物理冗余的情况下，在逻辑上防止环路的发生。&lt;/li&gt;
&lt;li&gt;环路表现&lt;br&gt;
2.1 广播风暴&lt;br&gt;
2.2 mac地址表的震荡（access或trunk划分错误也会导致此问题）&lt;br&gt;
2.3 以太帧的重复拷贝&lt;/li&gt;
&lt;li&gt;STP的原理&lt;br&gt;
&lt;code&gt;华为设备默认开启MSTP&lt;/code&gt;&lt;br&gt;
在整个交换交换网络有且只有一个根交换机（root）&lt;br&gt;
在每个设备上有且只有一个根端口（root port）&lt;br&gt;
在每个链路（segment）上有且只有一个指定端口（design port）&lt;br&gt;
除了根端口和指定端口，其他端口为逻辑上拥塞的替代端口&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看stp详细信息和简要信息
dis stp
dis stp brief
# 在全局模式下更改生成树的模式为MSTP
stp mode mstp
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;关键术语&lt;br&gt;
&lt;code&gt;3中端口角色，3种生成树模式，5种端口状态&lt;/code&gt;&lt;br&gt;
4.1 STP中Role端口的角色&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;ALTE 非指定(替代)端口AP（拥塞状态）&lt;/li&gt;
&lt;li&gt;DESI 指定端口DP（转发状态）&lt;/li&gt;
&lt;li&gt;ROOT 根端口RP（转发状态）&lt;br&gt;
4.2 生成树的端口状态STP State&lt;/li&gt;
&lt;li&gt;转发（Forwarding），即FWD，端口既可转发用户流量也可转发BPDU报文，只有根端口或指定端口才能进入Forwarding状态&lt;/li&gt;
&lt;li&gt;阻塞（Blocking 或 丢弃状态，Discarding），即BLK，端口仅仅能接收并处理BPDU，不能转发BPDU，也不能转发用户流量，此状态是预备端口的最终状态&lt;/li&gt;
&lt;li&gt;禁用（Disabled），即DIS（属于过渡过程），端口处于关闭状态，既不处理和转发BPDU报文，也不转发用户流量&lt;/li&gt;
&lt;li&gt;侦听（Listening），即LIS（属于过渡过程），华为设备上无法看到，端口可以转发BPDU报文，但不能转发用户流量&lt;/li&gt;
&lt;li&gt;学习（Learning），即LRN（属于过渡过程），端口可根据收到的用户流量构建MAC地址表，但不转发用户流量，增加Learning状态是为了防止临时环路&lt;br&gt;
&lt;code&gt;传统生成树依赖时间进行端口状态的改变，每2秒钟由根设备发送BPDU，每个转发时延（forwarding delay）为15秒。这些时间可以通过命令dis stp查看，其中config Times这行中展示了发送BPDU报文间隔、转发时间等。如果发生了拓扑变化，mac地址表的刷新时间变为一个转发时延，即15秒。&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585759841085.png&#34; alt=&#34;端口状态转换可能原因&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4.3 STP模式：&lt;/li&gt;
&lt;li&gt;传统生成树(802.1D)：思科设备上默认开启的传统生成树（效果较差），PVST+&lt;/li&gt;
&lt;li&gt;快速生成树(RSTP，802.1w)：Rapid PVST+（RSTP）&lt;/li&gt;
&lt;li&gt;多实例生成树(MSTP，802.1s)：华为设备默认开启，MSTP&lt;/li&gt;
&lt;/ul&gt;
">【24】交换机生成树场景和引发的问题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/23-jiao-huan-ji-shi-shi-hybrid-mo-shi-hun-za-mo-shi/"" data-c="
          &lt;p&gt;&lt;code&gt;可以用于主机与交换机之间，也可以用于交换机与交换机之间的链路&lt;/code&gt;&lt;br&gt;
在交换机互联的接口上可以以trunk（TAG）的方式处理frame，在连接PC的接口上可以以access（PVID）的方式处理frame。&lt;br&gt;
配置port hybrid tagged vlan &amp;quot;vlan-id&amp;quot;命令后，接口发送该vlanid的数据帧时，不剥离帧中的Tag，直接发送。&lt;br&gt;
配置port hybrid untagged vlan &amp;quot;vlan-id&amp;quot;命令后，接口发送该vlanid的数据帧时，会将帧中的Tag剥离之后再发送出去。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用hybrid模式实现不同vlan之间通信&lt;br&gt;
（pc1发pc2的vlanid为2，pc2发pc1的vlanid为100；pc3发pc2的vlanid为3，pc2发pc3的vlanid为100；pc1和pc3不能通信）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;sw1
int g0/0/10   # sw1该接口的入流量增加pvid=2
port default vlan 1 #需要修改回默认vlan,否则无法修改接口类型
port link-type hybrid
port hybrid pvid vlan 2
port hybrid untagged vlan 2 100 # sw1该接口出流量去掉vlanid 2和100，还原以太帧发送给pc

int g0/0/11  # sw1该接口的入流量增加pvid=3
port default vlan 1 
port link-type hybrid
port hybrid pvid vlan 3
port hybrid untagged vlan 3 100  # sw1该接口出流量去掉vlanid 3和100，还原以太帧发送给pc

clear configuration int g0/0/1  # sw1该接口允许所有vlan数据通过
int g0/0/1
undo shutdown
port link-type hybrid
port hybrid tagged vlan all

# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;sw2
clear configuration int g0/0/1  # sw1该接口允许所有vlan数据通过
int g0/0/1
undo shutdown
port link-type hybrid
port hybrid tagged vlan all

int g0/0/10 #该接口的出流量去掉vlanid 2 3 100，增加pvid为100
port default vlan 1
port link-type hybrid
port hybrid untagged vlan 2 3 100
port hybrid pvid vlan 100
&lt;/code&gt;&lt;/pre&gt;
">【23】交换机实施Hybrid模式（混杂模式）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/22-jiao-huan-ji-shi-shi-trunk-mo-shi-gan-lu-mo-shi-jiang-jie/"" data-c="
          &lt;p&gt;&lt;code&gt;一般用于交换机与交换机之间的链路，共享模式&lt;/code&gt;&lt;br&gt;
当trunk收到不包含tag的帧，则打上端口的pvid，否则不变。当trunk发送帧时，&lt;strong&gt;该帧的VlanID需要在trunk的允许发送列表中&lt;/strong&gt;，如果帧的vlanid和该接口pvid相同，则剥离tag发送，否则保留发送。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实施sw1和sw2的trunk链路，允许多个vlan通过&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 修改接口为trunk模式，并允许所有vlan通过
# 华为设备不允许直接将接口改为trunk模式，解决方法如下
# 方法一：将接口恢复成原始模式 “clear conf int g0/0/1”
# 方法二：先还原接口的默认vlan(即vlan1)，再修改为trunk模式
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;SW1
int g0/0/1
clear conf int g0/0/1
int g0/0/1
undo shundown
port link-type trunk
port trunk allow-pass vlan all
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;SW2
int g0/0/1
port default vlan 1
port link-type tru
port trunk allow-pass vlan all
# 移除某个接口允许通过的vlan
undo port trunk allow-pass vlan 3
# 修改端口默认vlanid（由1改为10）
int g0/0/1
port trunk pvid vlan 10
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;trunk的PVID的工作模式&lt;br&gt;
&lt;code&gt;类似于access的在流量的入方向上增加PVID；在出方向去掉PVID，同时不增加tag，默认为1&lt;/code&gt;&lt;br&gt;
实现两台交换机下，不同vlan之间的通信&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;sw1
int g0/0/1
port trunk pvid vlan 10
int g0/0/10
port default vlan 10

#&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;sw2
int g0/0/1
port trunk pvid vlan 100
int g0/0/10
port default vlan 100
&lt;/code&gt;&lt;/pre&gt;
">【22】交换机实施Trunk模式（干路模式）讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/21-jiao-huan-ji-shi-shi-access-mo-shi-jie-ru-mo-shi-pei-zhi-jiang-jie/"" data-c="
          &lt;p&gt;![拓扑结构]&lt;img src=&#34;https://fqj-web.github.io/post-images/1585759735365.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;一般用于用户主机（终端设备）与交换机之间的链路，独享模式&lt;/code&gt;&lt;br&gt;
PVID(port vlan ID,1-4094)，VlanID作为识别流量的重要工具。&lt;br&gt;
Access端口在收到数据后会添加VlanTag，VlanID和端口的PVID相同。Access端口在转发数据前会移除VlanTag。（即在流量的access接口入方向增加PVID，在流量access接口的出方向去掉PVID，还原成原始的以太帧）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同一交换机（sw1）中的同一个vlan（vlan2）实现通信&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 创建vlan2(在lsw1)
vlan 2
# 进入vlan2后创建描述报文
description HCNA
# 批量创建vlan（SW1~3均执行）
vlan batch 2 3 10 100
# 进入接口10，默认接口类型为Hybrid（混杂模式）
int g0/0/10
# 查看所有接口的vlan信息（接口链路类型）
dis port vlan active
# 修改接口的链路类型为access模式
port link-type access
# 修改接口默认的VlanID（即该接口数据哪一个Vlan）为vlan 2（在流量的入方向上增加pvid为2，载流量的出方向上去掉pvid2）
port default vlan 2
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;在不同交换机相同vlan之间通过access实现通信&lt;br&gt;
&lt;code&gt;对比正在运行的配置和已经保存的配置的区别：compare configuration&lt;/code&gt;&lt;br&gt;
在交换机之间划分到相同的vlan即可&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;SW1：修改接口g0/0/1的模式为access，vlanid为10
int g0/0/1
port link-type access
port default vlan 10
int g0/0/10
port link-type access
port default vlan 10
# &amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;SW2：与SW1相同配置
int g0/0/1
port link-type access
port default vlan 10
int g0/0/10
port link-type access
port default vlan 10
# 查看stp协议情况
# 如果sw1和sw2中的所涉及到的端口出现“alte 替代端口”情况，则需要执行“stp priority 4096”配置它的桥优先级 (缺省情况下交换机的桥优先级是32768)，否则无法通信
dis stp brief
&lt;/code&gt;&lt;/pre&gt;
">【21】交换机实施Access模式（接入模式）配置讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/20-yi-tai-wang-jiao-huan-ji-chu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;交换机的转发行为&lt;br&gt;
1.1 泛洪flooding&lt;br&gt;
无mac地址表时&lt;br&gt;
1.2 转发forwarding&lt;br&gt;
有mac地址表时&lt;br&gt;
1.3 丢弃discarding&lt;/li&gt;
&lt;li&gt;透明桥接&lt;br&gt;
用于以太网，不更改数据帧的内容，也不作为数据帧的源和目的地，连接起来的网段好像在一条透明的管道中一样。&lt;/li&gt;
&lt;li&gt;VLAN&lt;br&gt;
虚拟局域网，是将一个物理的局域网在逻辑上划分成多个广播域的技术。&lt;br&gt;
不是为了隔离，为了更好的通信，更好的实施、管理。&lt;br&gt;
3.1 帧格式&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585759654701.png&#34; alt=&#34;VLAN帧格式&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看mac地址列表
dis mac-address
# 查看mac地址表的老化时间(默认300秒)
dis mac-address aging-time
# 配置mac地址表的老化时间
mac-address aging-time 1000
&lt;/code&gt;&lt;/pre&gt;
">【20】以太网交换基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/19-shi-shi-dong-tai-lu-you-xie-yi-ospf-xie-yi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;原理&lt;br&gt;
初始化，形成邻居 ----&amp;gt; LSA(链路状态通告)泛洪 ----&amp;gt; 生成LSDB(链路状态数据库) ----&amp;gt; SPF(最短路径优先)算法 ----&amp;gt; 最短路径树 ----&amp;gt; 路由计算 ----&amp;gt; 路由计算 ----&amp;gt;  路由表&lt;/li&gt;
&lt;li&gt;ospf的3张表&lt;br&gt;
2.1 邻居（邻接）表&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看邻居表，加brief显示简要信息
display ospf peer brief
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.2 数据库表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看数据库
display ospf lsdb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.3 路由表&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看通过ospf生成的路由表
display ip routing-table protocol ospf
# 或者
display ospf routing
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;ospf的5种报文&lt;br&gt;
3.1 Hello 报文&lt;br&gt;
发现、建立和维护邻居关系的报文&lt;br&gt;
3.2 DD（Database Description）报文（DBD报文）&lt;br&gt;
数据库描述报文&lt;br&gt;
3.3 LSR（LSA Request）报文&lt;br&gt;
3.4 LSU（LSA Update）报文&lt;br&gt;
3.5 LSACK（Link State Acknowledgment）报文&lt;/li&gt;
&lt;li&gt;其他内容&lt;br&gt;
4.1 邻居和邻接的区别&lt;br&gt;
邻居关系是指，当双方收到对方的hello报文的时候，报文里面的参数（hello time.dead interval , area id.authentication ,mask 等）一致的时候，并且邻居关系为2-way的时候，这个就可以成为是建立了邻居关系，但是还不是邻接关系。&lt;br&gt;
邻接关系是指在建立的邻居关系之后继续发送DD，LSR，LSU等报文，最终双方的LSDB达到同步之后，邻居状态为FULL时，才成为邻接关系。&lt;br&gt;
详细内容可以参考下面两个链接：&lt;br&gt;
&lt;a href=&#34;https://blog.51cto.com/liufei888/2073094&#34;&gt;https://blog.51cto.com/liufei888/2073094&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://blog.csdn.net/watchen/article/details/14643459&#34;&gt;https://blog.csdn.net/watchen/article/details/14643459&lt;/a&gt;&lt;br&gt;
4.2 目的IP：&lt;br&gt;
224.0.0.5-----allspf router，SPF设备组播组&lt;br&gt;
224.0.0.6-----alldr router，DR设备组播组&lt;br&gt;
4.3 RID&lt;br&gt;
Route ID，在OSPF中是作为路由器唯一标识的，ipv4格式。&lt;br&gt;
当OSPF中选举DR和BDR时首先查看路由器的优先级，优先级大者当选DR，其次是BDR；如果优先级相同则根据route-id的大小来选举，route-id大者当选。route-id在不指定的情况下会由loopback接口数值最高的IP地址来做，当没有loopback接口时则由物理接口数值最高的IP来做。而DR和BDR选举只是在接口类型为广播或NBMA时会产生（就是说非广播类的点对点和点对多点的接口类型是不选举DR和BDR的）。所以route-id更多的是作为路由器标识的作用。是否配置route-id和如何配置route-id都取决于你的需求（有的时候配置不配置都无关紧要）。&lt;br&gt;
4.4 ospf大致流程&lt;br&gt;
邻居发现----数据库同步（exstart、exchange）----建立完全邻接关系&lt;br&gt;
4.5 DR（Designated Router）和BDR（Backup Designated Router）区别&lt;br&gt;
DR与BDR并没有任何本质与功能的区别，BDR就是DR的备份。&lt;br&gt;
DR和BDR是基于链路的，不是基于设备的，可以没有BDR，但是一定要有DR。&lt;br&gt;
所有设备都需要和DR、BDR构建邻接关系，只和DR、BDR交互LSDB，剩下的其他路由器俩俩都是邻居(2-way)状态 。&lt;br&gt;
**作用：**减少LSA的泛洪。DR可以减少广播型网络中的邻接关系数量。&lt;br&gt;
**选举DR和BDR的规则为：**比较接口优先级选举优先级最高的成为DR，优先级数字越大，表示优先级越高，被选为DR的几率就越大，次优先级的为BDR，优先级范围是0~255，默认为1，优先级为0表示没有资格选举DR和BDR。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;时间要素，在选举期间，OSPF的DR和BDR不具备抢占性，&lt;code&gt;即过了选举期，即便优先级再高也无法抢占DR和BDR&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;基于hello报文中的优先级，越大越优先&lt;/li&gt;
&lt;li&gt;如果优先级相同，选择路由器ID（RouteID，RID）比较大的&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 调整路由器中ospf的优先级
interface g0/0/0
ospf
ospf dr-priority 0 # 0则没有资格选举为DR和BDR，数字越大优先级越高
interface g0/0/1
ospf
ospf dr-priority 100
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;4.6 OSPF开销&lt;br&gt;
计算公式为：带宽参考值/带宽，可以使用&lt;code&gt;bandwidth-reference&lt;/code&gt;命令来设置带宽参考值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 设置带宽参考值
ospf
bandwidth-reference 10000
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;ospf配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ospf route-id 1.1.1.1
area 0
network 192.168.1.0 24
&lt;/code&gt;&lt;/pre&gt;
">【19】实施动态路由协议OSPF协议</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/17-dong-tai-lu-you-xie-yi-ripv2-de-shi-shi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;RIPv1和RIPv2不兼容，可以通过修改接口下的收发RIP包的版本来达到兼容，但最好的方法是都配置为版本2&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 修改RIP版本为v2，可以在接口下面改，也可以在系统视图中该，接口的优先级高于系统视图
int g0/0/0
dis th # 查看当前RIP版本
dis ip rou pro rip # 查看当前rip路由信息
undo rip version # 删除接口当前的rip版本

# 修改接口RIP协议的度量值cost(协议中为metricin)，默认为1，这个值不能超过15，否则路由不可达，导致路由消失
rip metricin 2  # 入方向设为2
rip metricout 3  # 出方向设为3

# 全局配置
rip #进入rip进程
version 2

# 配置接口禁止发送RIP报文（和静默端口有点相似）
int g0/0/0
undo rip output

# 静默端口（抑制端口），配置g0/0/0接口为抑制状态，用来更新自己的路由表，而不发RIP报文
# 此命令的优先级要高于rip input和rip outpt
# 可以用于完全连接PC的接口以及环回接口
rip
silent-interface g0/0/0
# 常用的方式是先静默所有接口，再单播指定接口，通过peer指定邻居路由
rip
silent-interface all
peer 10.0.14.1 # 相邻路由器地址(手动指定邻居，进行单播更新)
# 相邻路由器配置
silent-interface s2/0/0 # 静默与上面路由器直连的接口
peer 10.0.14.4 # 指定上面那个路由器地址
# 在第一台路由器上查看rip更新情况
terminal debug
debugging rip 1 pa
&lt;/code&gt;&lt;/pre&gt;
">【17】动态路由协议RIPv2的实施</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/28-jiao-huan-ji-shi-shi-ripv1/"" data-c="
          &lt;p&gt;RIP，路由信息协议，属于距离矢量协议，易于维护，适合于小型网络，最大15跳（16跳不可达），使用UDP协议的520目标端口，优先级为100&lt;br&gt;
作用：构建、维护、更新路由信息&lt;br&gt;
RIP的开销为跳数，一跳则cost为1，两跳则cost为2，......&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;两种报文&lt;br&gt;
1.1 Request请求（只有在rip启动或者路由变化的时候发送此报文）&lt;br&gt;
1.2 Response响应&lt;/li&gt;
&lt;li&gt;工作原理&lt;br&gt;
路由器运行rip之后，首先会发送路由更新请求，收到请求的路由器会发送自己的rip路由进行相应，形成rip数据库。网络稳定后，路由器会周期性的发送路由更新信息（响应报文），30秒发送一次。&lt;/li&gt;
&lt;li&gt;问题：R1（10.0.1.1/24）上运行ripv1得到的是10.0.2.0/24的路由，而不是10.0.0.0/8的路由？&lt;br&gt;
发送路由更新的接口的地址是10.0.123.0(主类前缀为10.0.0.0/8)，发送出去的路由（10.0.2.0/24）。如果主类前缀相同，那么发送明细路由（10.0.2.0/24），如果主类前缀不同，则发送主类即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 默认是Ripv1，进入rip配置模式
rip
dis th # 查看当前信息
# 关闭ripv1
undo rip 1
# 重新配置
rip
network 10.0.0.0 # vrp的命令格式就必须是主类网络，像10.0.2.0就不行。在IGP中network有两层含义：a 在一个范围内使能RIP协议；b 该范围内的网络被通告到RIP中，方便其他设备学习该路由
network 22.0.0.0 
network 192.168.1.0  #主类网络IP地址分类（主类网络，即：A类 B类 C类 D类 E类）
# 修改为版本2
rip
ver 2
# 查看邻居是否友好协商
dis rip 1 neighbor
# 查看rip数据库
dis rip 1 database
# 查看rip1的发送的报文（需要等待一段时间才能看到）
debugging rip 1 send
undo debugging all # 结束查看报文
# 关闭自动汇总
undo summary
&lt;/code&gt;&lt;/pre&gt;
">【28】交换机实施RIPv1</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/15-hua-wei-shi-shi-jing-tai-fu-dong-lu-you-dai-li-arp-he-jing-tai-mo-ren-lu-you/"" data-c="
          &lt;ol&gt;
&lt;li&gt;浮动静态路由&lt;br&gt;
在存在多条线路的情况下使得数据只从一个链路上转发（优先级最高的那条），即路由表中只有一个下一条，其他线路作为备份链路，只有主链路失效时，备份链路才会被放入路由表。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看rip路由
dis ip rou protocol rip
# 修改静态路由优先级(0~255，越小约优先)
ip route-static 10.0.4.0 255.255.255.0 Serial 2/0/0 preference 20
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;默认路由（缺省路由）&lt;br&gt;
default route为0.0.0.0/0，即最不精准但可以使用的路由&lt;/li&gt;
&lt;li&gt;代理arp&lt;br&gt;
默认不开启。不建议使用，因为arp有老化时间，并且arp属于广播协议。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 开启代理arp
int g0/0/0
arp-proxy enable
&lt;/code&gt;&lt;/pre&gt;
">【15】华为实施静态浮动路由、代理ARP和静态默认路由</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/14-hua-wei-shi-shi-jing-tai-lu-you-jiang-jie/"" data-c="
          &lt;ol&gt;
&lt;li&gt;静态路由需要管理员手动配置和维护的路由&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585759325632.png&#34; alt=&#34;静态路由配置&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 添加静态路由的格式：ip route-static 网络前缀 掩码 下一条或者设备接口
# “下一条”的方案（推荐方式）
ip route-static 192.168.1.0 255.255.255.0 10.0.12.1
# “出接口”的方案(ATM、FR不能使用此方法，不通用，不推荐使用此方式)
ip route-static 192.168.1.0 255.255.255.0 Serial 1/0/0
# 上两种方案结合
ip route-static 192.168.1.0 24 10.0.12.1 Serial 1/0/0
# 查看路由表（包含协议）
display ip routing-table protocol static
# 开启debug模式，ApingB，则B开启，可以在B上看到接收的报文
debugging ip icmp
terminal debugging
# 指定接口ping 
ping -a &amp;quot;本机ip&amp;quot; &amp;quot;要ping的地址&amp;quot;
# 筛选路由 （简写：dis cu | i ip route ）
display current-configuration | include ip route
&lt;/code&gt;&lt;/pre&gt;
">【14】华为实施静态路由讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/13-hua-wei-ipv4-lu-you-yuan-li-jiang-jie/"" data-c="
          &lt;ol&gt;
&lt;li&gt;路由器两个基本功能：&lt;br&gt;
1.1 决策(RIB)&lt;br&gt;
1.2 转发(FIB)&lt;/li&gt;
&lt;li&gt;AS号码私有段为64512~65535&lt;/li&gt;
&lt;li&gt;路由表（控制层面）不一定和报文转发在同一个路径上&lt;/li&gt;
&lt;li&gt;路由分类&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;接口工作，得到的是直连路由(Direct)&lt;/li&gt;
&lt;li&gt;管理员手工添加得到静态路由&lt;/li&gt;
&lt;li&gt;通过动态路由协议得到路由表(例如RIP)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;路由的原则&lt;br&gt;
5.1 最长匹配原则&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 例如：
a. 0.0.0.0/0
b. 10.2.1.0/24
c. 10.2.1.1/32
d. 100.1.1.0/24
- 去往10.2.1.100的选择b
- 去往10.2.1.1的选择c
- 去往100.1.2.1的选择a
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.2 路由协议的优先级（AD，管理距离）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 路由协议的优先级是本设备做出决策的依据
# 优先级，数值小的优先
- 直连=0
- 静态=60（思科=1）
- RIP=100
- ospf内部=10（思科=110）
- ospf外部=150（ASE，思科没有该参数）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;5.3 不同的协议有不同的度量方法，在同一个协议内部度量值比较小的优先&lt;br&gt;
6. 路由负载均衡（ECMP）&lt;br&gt;
FIB，由于负载均衡不等于数据包转发平分，而是通过数据流的五元组hash值进行分配，如果hash值不变则路径不变，所以负载均衡不是流量平分&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看FIB
display fib
# 查看路由表
display ip routing-table
&amp;gt; R-relay：中继，代表下一跳设备不是本设备的直连，需要做路由更迭才可以到达
&amp;gt; D-download to file：装载到路由表
&lt;/code&gt;&lt;/pre&gt;
">【13】华为IPv4路由原理讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/12-hua-wei-vrp-xi-tong-guan-li/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 指定下次启动的系统文件
startup system-software &amp;quot;文件名&amp;quot;
# 重启
reboot
# 查看系统是否修改成功
display startup 
&lt;/code&gt;&lt;/pre&gt;
">【12】华为VRP系统管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/11-hua-wei-vrp-ping-tai-shi-shi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;命令行视图：&lt;br&gt;
用户视图 ：查看运行状态或其他参数&lt;br&gt;
--&amp;gt; 系统视图（system-view）：配置设备的系统参数等&lt;br&gt;
--&amp;gt; 接口视图（interface GigabitEthernet0/0/0等） ：配置接口参数&lt;br&gt;
--&amp;gt; 协议视图（ospf、bgp、isis等）：配置路由协议&lt;/li&gt;
&lt;li&gt;常用快捷键&lt;br&gt;
&lt;strong&gt;VRP快捷键&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;ctrl+a/e&lt;/code&gt;：把光标移动到当前命令行最前端/后端&lt;br&gt;
&lt;code&gt;ctrl+c&lt;/code&gt;：停止当前命令行的运行&lt;br&gt;
&lt;code&gt;ctrl+z&lt;/code&gt;：回到用户视图&lt;br&gt;
&lt;code&gt;ctrl+]&lt;/code&gt;：终止当前连接或切换连接&lt;br&gt;
&lt;strong&gt;CRT快捷键&lt;/strong&gt;&lt;br&gt;
&lt;code&gt;ctrl+tab&lt;/code&gt;：下一个标签&lt;br&gt;
&lt;code&gt;ctrl+shift+tab&lt;/code&gt;：前一个标签&lt;br&gt;
&lt;code&gt;alt+&amp;quot;数字&amp;quot;&lt;/code&gt;：直接到达第&amp;quot;数字&amp;quot;个标签&lt;/li&gt;
&lt;li&gt;配置标题消息&lt;br&gt;
header login：配置在用户登录前显示的标题消息&lt;br&gt;
header shell：配置在用户登录后显示的标题消息&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 命令行配置
system-view
header login information &amp;quot;welcome to huawei certification&amp;quot;
header shell information &amp;quot;Please don&#39;t reboot the device!&amp;quot;
# 从文件加载标题信息
header login file 文件名称
header shell file 文件名称
# 查看当前配置信息
display current-configuration
# 管道符筛选
# begin：开头；count：统计；exclude：不包括；include：包括
display current-configuration | include header
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;命令等级（用户等级）&lt;br&gt;
4.1 访问级&lt;br&gt;
用户等级0，命令等级0&lt;br&gt;
4.2 监控级&lt;br&gt;
用户等级1，命令等级0-1&lt;br&gt;
4.3 配置级&lt;br&gt;
用户等级2，命令等级0-2&lt;br&gt;
4.4 管理级&lt;br&gt;
用户等级3-15，命令等级0-3&lt;/li&gt;
&lt;li&gt;用户界面&lt;br&gt;
5.1 类型：Console(编号0，只有1个)；VTY(编号0-4,5个)&lt;br&gt;
5.2 配置命令
&lt;blockquote&gt;
&lt;p&gt;idle-timeout：设置超时时间，默认10分钟&lt;br&gt;
screen-length：设置指定终端屏幕的临时显示行数，0不显示，即一屏显示的行数&lt;br&gt;
history-command max-size ：设置历史命令缓冲区大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 设置认证方式
user-interface vty 0 4
set authentication password cipher huawei
# 配置可以同时登录到设备的VTY类型用户界面的最大个数，如果为0，则任何用户都不能通过telnet或者ssh登录到路由器
user-interface maximum-vty &amp;quot;同时登录的个数&amp;quot;
# 在sw2登录sw1可以查看之前的header login 和header shell
# 查看用户
display users
# 设置用户级别，默认是0
user-interface vty 0 4
user privilege level 2
# sw2重新登录sw1进行测试
telnet 10.1.1.1
# 通过sw2进入sw1的系统视图
system-view
# 设置超时时间sw1，设置为1分30秒
user-interface vty 0 4
idle-timeout 1 30
# 设置历史命令缓冲区为100
history-command max-size 100
# 设置一屏显示100行
screen-length 100
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;文件系统管理命令&lt;br&gt;
&lt;code&gt;类似Linux&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;save 保存【用户模式】&lt;/li&gt;
&lt;li&gt;pwd 查看当前目录&lt;/li&gt;
&lt;li&gt;dir 查看当前目录下文件信息&lt;/li&gt;
&lt;li&gt;more 查看文件内容&lt;/li&gt;
&lt;li&gt;cd 修改当前工作目录&lt;/li&gt;
&lt;li&gt;mkdir 创建新目录&lt;/li&gt;
&lt;li&gt;rmdir 删除目录&lt;/li&gt;
&lt;li&gt;copy 复制文件&lt;/li&gt;
&lt;li&gt;move 移动文件&lt;/li&gt;
&lt;li&gt;rename 重命名文件&lt;/li&gt;
&lt;li&gt;delete/unreserved 删除/永久删除文件&lt;/li&gt;
&lt;li&gt;undelete 恢复删除的文件&lt;/li&gt;
&lt;li&gt;reset recycle-bin 彻底删除回收站的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;配置文件查询&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;display current-configuration 显示当前配置文件&lt;/li&gt;
&lt;li&gt;display saved-configuration 显示当前保存的配置&lt;/li&gt;
&lt;li&gt;display startup 查看系统启动配置参数&lt;/li&gt;
&lt;li&gt;startup patch 加载补丁文件&lt;/li&gt;
&lt;li&gt;startup saved-configuration 修改下次开机加载的配置文件&lt;/li&gt;
&lt;li&gt;startup system-software 修改下次开机加载的软件（系统）&lt;/li&gt;
&lt;/ul&gt;
">【11】华为VRP平台实施 </a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/10-yi-tai-wang-arp-ji-chu/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 查看arp列表
display arp
# 开启代理arp，华为设备默认不开启proxy arp
interface GigabitEthernet0/0/0
arp-proxy enable
&lt;/code&gt;&lt;/pre&gt;
">【10】以太网ARP基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/09-yi-tai-wang-ji-chu-ji-icmp-ji-chu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;ARP，把逻辑地址（IP）映射成实际物理地址（MAC），华为设备ARP表项的老化超时时间缺省为1200秒&lt;/li&gt;
&lt;li&gt;ARP分类：&lt;br&gt;
基本ARP&lt;br&gt;
代理ARP（位于不同网络的网络设备在不配置网关的情况下，能够通过ARP代理实现相互通信）&lt;br&gt;
免费ARP（用来检测IP地址冲突）&lt;/li&gt;
&lt;/ol&gt;
">【09】以太网基础及ICMP基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/08-yi-tai-wang-ip-tou-bu-gai-shu-he-vrp-xiang-guan-jiang-jie/"" data-c="
          &lt;p&gt;ICMP，发出报文采用udp,端口大于30000，一般是33434开始；返回端口不可达报文（type=3,code=3）记录了节点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 添加静态路由
# R1
ip route-static 23.1.1.0 24 GigabitEthernet0/0/0 12.1.1.2
ping 23.1.1.2
# R3
ip route-static 12.1.1.0 24 GigabitEthernet0/0/1 23.1.1.2
ping 12.1.1.2
# 路由追踪
tracert 23.1.1.3
# 删除路由
undo ip route-static 12.1.1.0 24 GigabitEthernet0/0/0 23.1.1.2
&lt;/code&gt;&lt;/pre&gt;
">【08】以太网IP头部概述和VRP相关讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/07-yi-tai-ipv4-zi-wang-hua-fen-jiang-jie/"" data-c="
          &lt;p&gt;TTL作用：IP中的防环机制。IP报文每经过一个网段，TTL值减1，如果TTL=0，则丢弃。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# console登录和认证(密码设置为huawei)
user-interface con0 
authentication-mode password
set authentication password cipher huawei
&lt;/code&gt;&lt;/pre&gt;
">【07】以太IPv4子网划分讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/06-yi-tai-wang-ipv4-ji-chu-he-fen-lei/"" data-c="
          &lt;ol&gt;
&lt;li&gt;掩码的作用：区分网络和主机。网络地址为主机位全部为0，广播地址为主机位全部为1，这两个IP为网络地址的两头，都不可分给主机使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; # 查看华为设备上的路由表，路由表中的地址全为目的IP
display ip routing-table
# 手动添加127网段之外的环回地址
interface LoopBack 0
ip address 1.1.1.1 32
q
display ip routing-table
ping 1.1.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;IPv4分类：&lt;br&gt;
A类：网络位8b，0.0.0.0-127.255.255.255&lt;br&gt;
B类：网络位16b，128.0.0.0-191.255.255.255&lt;br&gt;
C类：网络位24b，192.0.0.0-223.255.255.255&lt;br&gt;
D类：组播地址，224.0.0.0-239.255.255.255&lt;br&gt;
E类：保留，240.0.0.0-255.255.255.255&lt;br&gt;
&lt;code&gt;NET ,ABCDE的有类网络，即上述分类网络；subnet，即子网，一个大的网络划分成小的网络&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;特殊地址（RFC1918）&lt;br&gt;
3.1 私有地址范围：（无法在公网路由，局域网内可重复使用）&lt;br&gt;
10.0.0.0-10.255.255.255，172.16.0.0~172.31.255.255，192.168.0.0-192.168.255.255&lt;br&gt;
3.2 特殊地址：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;127.0.0.0-127.255.255.255&lt;/strong&gt;：主机环回地址&lt;br&gt;
&lt;strong&gt;0.0.0.0&lt;/strong&gt;：网络设备未获取地址之前的源地址，如果DHCP未获得地址，会分配为169.254.x.x临时地址&lt;br&gt;
&lt;strong&gt;255.255.255.255&lt;/strong&gt;：本地广播地址，是0.0.0.0的广播地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;划分子网方法&lt;br&gt;
4.1 根据需要的子网数目来确定子网位数，但是要确保每个子网的IP地址数目大于等于主机数。&lt;br&gt;
优点：简单；缺点：每个子网的实际主机数不同，但分配的IP地址数目相同，可能浪费IP&lt;br&gt;
4.2 根据每个子网的主机数目来确定主机位数，然后确定子网位数。&lt;br&gt;
优点：比较充分的利用IP；缺点：复杂&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;x=子网位数&lt;br&gt;
y=主机位数&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;子网数目=2^x&lt;br&gt;
主机数目=2^y-2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;CIDR：无类域间路由，突破传统IP地址的分类边界，将路由表中的若干条路由汇聚为一条路由。例如可以将10.24.0.0/24、10.24.1.0/24、10.24.2.0/24、10.24.3.0/24这4个地址汇聚成一个10.24.0.0/22&lt;/li&gt;
&lt;/ol&gt;
">【06】以太网IPv4基础和分类</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/05-yi-tai-wang-ip-wang-luo-ji-chu-he-ftp-jiang-jie/"" data-c="
          &lt;ol&gt;
&lt;li&gt;IP头部，长度20-60B，固定20B&lt;/li&gt;
&lt;li&gt;IP编址，分为网络部分和主机部分&lt;/li&gt;
&lt;li&gt;VRP的FTP应用&lt;br&gt;
&lt;code&gt;VRP，通用路由平台，Huawei Versatile Routing Platform Sofaware，可通过display version查看版本&lt;/code&gt;&lt;br&gt;
3.1 FTP&lt;br&gt;
连接控制端口21，数据传输端口20。ARG3系列路由器既可以做FTP客户端也可以做FTP服务端&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 开启ftp服务
ftp server enable
# 开启aaa：认证、授权、统计
##    设置用户名(Enter，不区分大小写)和密码(huawei)
aaa
local-user Enter password simple huawei
##    设置用户权限，最大的权限15级
local-user Ender privilege level 15
##    共享的文件夹为flash，路由器的硬盘
local-user Enter ftp-directory flash:
##    用户服务(协议)设置，用于ftp服务(协议)
local-user Enter service-type ftp
# 查看ftp服务器状态
display ftp-server
# 保存当前交换机的配置为文件
save sw2.zip
# 测试
# sw1退出系统视图之后，ftp10.1.1.2进行登录测试
# get sw2.zip获取sw2.zip文件
# q退出ftp，dir查看当前目录内容
&lt;/code&gt;&lt;/pre&gt;
">【05】以太网IP网络基础和FTP讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/04-ehternet-ji-chu-jiang-jie/"" data-c="
          &lt;ol&gt;
&lt;li&gt;以太网帧最常用的两种封装格式：&lt;br&gt;
&lt;code&gt;如果类型大于1536是Ethernet II封装，小于1500则是Ethernet 802.3封装&lt;/code&gt;&lt;br&gt;
1.1 Ethernet II：&lt;br&gt;
目的mac[6]--源mac[6]--&lt;strong&gt;类型[2]&lt;/strong&gt;--数据[46-1500]--校验码[4]&lt;br&gt;
14字节头部&lt;br&gt;
1.2 Ethernet 802.3：&lt;br&gt;
目的mac[6]--源mac[6]--&lt;strong&gt;长度[2]--LLC逻辑链路控制子层[3]--SNAP(机构代码[3]+类型[2])&lt;/strong&gt;--数据[38-1492]--校验码[4]&lt;br&gt;
20字节头部&lt;/li&gt;
&lt;li&gt;Mac分类：&lt;br&gt;
&lt;code&gt;第一字节的第8比特表示地址类型&lt;/code&gt;&lt;br&gt;
2.1 单播mac：类型字节为0。表示目的mac为此mac地址的帧都是发送到某个唯一的目的mac。&lt;br&gt;
2.2 组播mac：类型字节为1。经典组播mac：01005E。&lt;br&gt;
2.3 广播mac：全1。&lt;/li&gt;
&lt;/ol&gt;
">【04】Ehternet基础讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/03-wang-luo-ge-chong-fen-ceng-jie-gou-jiang-jie/"" data-c="
          &lt;p&gt;管理vlan（VRP操作）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#  创建vlan1
interface vlanif 1
# 设置管理地址
ip address 10.1.1.1 24
&lt;/code&gt;&lt;/pre&gt;
">【03】网络各种分层结构讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/02-wang-luo-ji-ben-guan-li-ji-mo-ni-qi-shi-yong/"" data-c="
          &lt;ol&gt;
&lt;li&gt;光纤：单模适合远距离传输，多模适合近距离传输&lt;/li&gt;
&lt;li&gt;使用eNSP软件注意事项：&lt;br&gt;
2.1关掉Windows的防火墙&lt;br&gt;
2.2 别安装没有必要的软件，例如防火墙或者杀毒&lt;br&gt;
2.3 少运行不必要的软件，例如VPN软件&lt;br&gt;
2.4 注册。如果注册失败，则需要关闭ensp后，将用户个人文件夹下面的文件夹.VirtualBox彻底删除，重新注册，注册成功之后重启ensp&lt;/li&gt;
&lt;li&gt;CRT连接交换机使用Tab无法补全命令解决方法&lt;br&gt;
断开会话 --&amp;gt; 右键选中该打开的会话标签 --&amp;gt; 会话选项 --&amp;gt; 连接 --&amp;gt; Telnet --&amp;gt; 勾选“强制每次一个字符模式”&lt;/li&gt;
&lt;li&gt;华为设备的端口默认是up的，但是协议是down，即物理上工作的，但网络上不工作&lt;/li&gt;
&lt;li&gt;交换机配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 进入系统配置视图
system-view
# 配置交换机名称为R1
sysname R1
# 进入端口GigabitEthernet0/0/0的配置界面
interface GigabitEthernet0/0/0
# 配置本端口的IP（配置完IP之后，协议默认变为up）
ip address 10.1.1.1 24
# 启用端口，默认开启，此步可以省略
undo shutdown
# 显示当前配置
dis th
# 退出配置本端口
q
# 开启虚拟终端管理
user-interface vty 0 4
# 设置认证，密码为huawei
set authentication password cipher huawei
# 显示当前配置
dis th
# 退回系统配置视图
q
# 使用R2设备进行远程R1进行测试（只能连接，不能配置）
# 不能在系统配置视图中，否则无法连接
telnet 10.1.1.1
&lt;/code&gt;&lt;/pre&gt;
">【02】网络基本管理及模拟器使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/01-wang-luo-zheng-ti-jia-gou-jiang-jie/"" data-c="
          &lt;p&gt;企业网络架构：终端 --&amp;gt; 接入层 --&amp;gt; 汇聚层 --&amp;gt; 核心层 --&amp;gt; 服务器集群&lt;/p&gt;
">【01】网络整体架构讲解（2020.0218）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/zabbix_faq/"" data-c="
          &lt;h1 id=&#34;zabbix-server端&#34;&gt;zabbix server端&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;server端出现错误&lt;code&gt;symbol uncompress, version libmysqlclient_18 not defined in file libmysqlclient.so.18 with link time reference&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;解决方法：&lt;br&gt;
查看需要的动态链接库：ldd /usr/local/zabbix/sbin/zabbix_server&lt;br&gt;
我的环境需要执行的指令：cp /usr/local/mysql/lib/libmysqlclient.so.18 /lib64/libmysqlclient.so.18&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;zabbix-client端&#34;&gt;zabbix client端&lt;/h1&gt;
&lt;h2 id=&#34;windows&#34;&gt;windows&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;客户端配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 日志文件
LogFile=C:\Program Files\Zabbix Agent\zabbix_agentd.log
# 获取监控数据最长时间
Timeout=30
# server端地址（被动）
Server=11.36.250.253
# server端地址（主动）
ServerActive=11.36.250.253
# 主机名称
Hostname=T5-xxxxxx
# 子配置文件存放目录
Include=C:\Program Files\Zabbix Agent\zabbix_agentd.conf.d\*.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;子配置文件存放目录&lt;br&gt;
配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;UserParameter=dir.size[*],python &amp;quot;C:\Program Files\Zabbix Agent\zabbix_agentd.conf.d\dir.size.py&amp;quot; $1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;获取监控数据脚本&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;import os,sys
dirsize=os.popen(&amp;quot;&amp;quot;&amp;quot;dir /a /s \&amp;quot;{dirabs}\&amp;quot; | findstr \&amp;quot;个文件\&amp;quot;&amp;quot;&amp;quot;&amp;quot;.format(dirabs=sys.argv[1])).readlines()[-1].split(&amp;quot;个文件&amp;quot;)[1].split(&amp;quot;字节&amp;quot;)[0].replace(&amp;quot;,&amp;quot;,&amp;quot;&amp;quot;).strip()
print(dirsize)
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;其他获取监控参数的脚本&#34;&gt;其他获取监控参数的脚本&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;获取进程&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import psutil,sys
def CheckProcess(prodessname):
    pl=psutil.pids()
    for pid in pl:
        if psutil.Process(pid).name()==prodessname:
            return pid

prodessname=sys.argv[1]
if isinstance(CheckProcess(prodessname),int):
    print(&amp;quot;True&amp;quot;)
else:
    print(&amp;quot;False&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
">43_Zabbix_FAQ</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/42_zabbix-de-api-chuang-jian-jian-kong-zhu-ji/"" data-c="
          &lt;h3 id=&#34;api添加主机组和主机zabbix_addgrouphostpy&#34;&gt;api添加主机组和主机zabbix_addgrouphost.py&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import zabbix_base
# 获取token
token=zabbix_base.get_token()

# 添加主机组
groupname=&amp;quot;python_add_group&amp;quot;
data = {
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;method&amp;quot;: &amp;quot;hostgroup.create&amp;quot;,
    &amp;quot;params&amp;quot;: {
        &amp;quot;name&amp;quot;:groupname,
    },
    &amp;quot;auth&amp;quot;:token,
    &amp;quot;id&amp;quot;: 1
}
result=zabbix_base.zabbix_api_common(data)
print(result)

# 添加主机
hostname=&amp;quot;python_add_host&amp;quot;
hostip=&amp;quot;192.168.3.222&amp;quot;
groupid=&amp;quot;19&amp;quot; # 使用zabbix_group.py获取到主机组check_mysql的groupid为20
templateid=&amp;quot;10342&amp;quot; # 模板check_mysql的id
data = {
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;method&amp;quot;: &amp;quot;host.create&amp;quot;,
    &amp;quot;params&amp;quot;: {
        &amp;quot;host&amp;quot;: hostname,
        &amp;quot;interfaces&amp;quot;: [
            {
                &amp;quot;type&amp;quot;: 1,
                &amp;quot;main&amp;quot;: 1,
                &amp;quot;useip&amp;quot;: 1,
                &amp;quot;ip&amp;quot;: hostip,
                &amp;quot;dns&amp;quot;: &amp;quot;&amp;quot;,
                &amp;quot;port&amp;quot;: &amp;quot;10050&amp;quot;
            }
        ],
        &amp;quot;groups&amp;quot;: [
            {
                &amp;quot;groupid&amp;quot;: groupid
            }
        ],
        &amp;quot;templates&amp;quot;: [
            {
                &amp;quot;templateid&amp;quot;: templateid
            }
        ]
    },
    &amp;quot;auth&amp;quot;: token,
    &amp;quot;id&amp;quot;: 1
}
result=zabbix_base.zabbix_api_common(data)
print(result)

&lt;/code&gt;&lt;/pre&gt;
">42_zabbix的api创建监控主机</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/41_zabbix-de-api-huo-qu-mo-ban-xin-xi/"" data-c="
          &lt;h3 id=&#34;获取模板信息zabbix_templatepy&#34;&gt;获取模板信息zabbix_template.py&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import zabbix_base
# 获取token
token=zabbix_base.get_token()

# 获取模板
data = {
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;method&amp;quot;: &amp;quot;template.get&amp;quot;,
    &amp;quot;params&amp;quot;: {
        &amp;quot;output&amp;quot;: [&amp;quot;host&amp;quot;],
    },
    &amp;quot;auth&amp;quot;:token,
    &amp;quot;id&amp;quot;: 1
}
result=zabbix_base.zabbix_api_common(data)
print(&amp;quot;获取模板::&amp;quot;,result[&#39;result&#39;],&amp;quot;\n\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
">41_zabbix的api获取模板信息</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/40_zabbix-de-api-huo-qu-zhu-ji-xin-xi/"" data-c="
          &lt;h3 id=&#34;zabbix-api获取主机组-主机等信息zabbix_grouppy&#34;&gt;zabbix api获取主机组、主机等信息zabbix_group.py&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import zabbix_base
# 获取token
token=zabbix_base.get_token()

# 获取全部主机组
data = {
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;method&amp;quot;: &amp;quot;hostgroup.get&amp;quot;,
    &amp;quot;params&amp;quot;: {
        &amp;quot;output&amp;quot;: &amp;quot;extend&amp;quot;,
    },
    &amp;quot;auth&amp;quot;:token,
    &amp;quot;id&amp;quot;: 0
}
result=zabbix_base.zabbix_api_common(data)
print(&amp;quot;获取全部主机组::&amp;quot;,result[&#39;result&#39;],&amp;quot;\n\n&amp;quot;)

# 获取指定主机组
data = {
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;method&amp;quot;: &amp;quot;hostgroup.get&amp;quot;,
    &amp;quot;params&amp;quot;: {
        &amp;quot;filter&amp;quot;:{
            &amp;quot;name&amp;quot;:[&amp;quot;www&amp;quot;]
        }
    },
    &amp;quot;auth&amp;quot;:token,
    &amp;quot;id&amp;quot;: 0
}
result=zabbix_base.zabbix_api_common(data)
print(&amp;quot;获取指定主机组::&amp;quot;,result[&#39;result&#39;],&amp;quot;\n\n&amp;quot;)

# 查询主机组以及主机组信息
data = {
    &amp;quot;jsonrpc&amp;quot;: &amp;quot;2.0&amp;quot;,
    &amp;quot;method&amp;quot;: &amp;quot;hostgroup.get&amp;quot;,
    &amp;quot;params&amp;quot;: {
        &amp;quot;output&amp;quot;: [&amp;quot;groupid&amp;quot;,&amp;quot;name&amp;quot;],
        &amp;quot;selectHost&amp;quot;:[&amp;quot;host&amp;quot;],
    },
    &amp;quot;auth&amp;quot;:token,
    &amp;quot;id&amp;quot;: 0
}
result=zabbix_base.zabbix_api_common(data)
print(&amp;quot;查询主机组以及主机组信息::&amp;quot;,result[&#39;result&#39;],&amp;quot;\n\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
">40_zabbix的api获取主机信息</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/39_zabbix-de-api-ren-zheng-shi-zhan/"" data-c="
          &lt;h3 id=&#34;zabbix-api&#34;&gt;zabbix api&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix具有丰富的api功能&lt;/li&gt;
&lt;li&gt;可通过api添加主机组、主机、获取监控数据&lt;/li&gt;
&lt;li&gt;使用python操作zabbix&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;api使用教程&#34;&gt;api使用教程&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.zabbix.com/documentation/4.0/zh/manual/api&#34;&gt;https://www.zabbix.com/documentation/4.0/zh/manual/api&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;登录认证说明zabbix_basepy&#34;&gt;登录认证说明zabbix_base.py&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import json
from urllib import request
def zabbix_api_common(data):
  zabbix_url=&amp;quot;http://192.168.3.111/zabbix/api_jsonrpc.php&amp;quot;
  zabbix_header={&amp;quot;Content-Type&amp;quot;:&amp;quot;application/json&amp;quot;}
  data = json.dumps(data).encode(&amp;quot;utf-8&amp;quot;)
  req = request.Request(zabbix_url, headers=zabbix_header, data=data)
  result = request.urlopen(req).read()
  return json.loads(result)

def get_token():
  zabbix_user=&amp;quot;Admin&amp;quot;
  zabbix_pass=&amp;quot;123456&amp;quot;
  data={
    &amp;quot;jsonrpc&amp;quot;:&amp;quot;2.0&amp;quot;,
    &amp;quot;method&amp;quot;:&amp;quot;user.login&amp;quot;,
    &amp;quot;params&amp;quot;:{
      &amp;quot;user&amp;quot;:zabbix_user,
      &amp;quot;password&amp;quot;:zabbix_pass
    },
  &amp;quot;id&amp;quot;:0
  }
  result=zabbix_api_common(data)
  # 登录结果说明：
  # b&#39;{&amp;quot;jsonrpc&amp;quot;:&amp;quot;2.0&amp;quot;,&amp;quot;result&amp;quot;:&amp;quot;3fa39886a18f81254e1bf4793a8da1b4&amp;quot;,&amp;quot;id&amp;quot;:0}&#39;
  # result的值为token，可据此创建主机等操作
  return result[&#39;result&#39;]

if __name__==&amp;quot;__main__&amp;quot;:
  token=get_token()
  print(token)
&lt;/code&gt;&lt;/pre&gt;
">39_zabbix的api认证实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/38_zabbix-jian-kong-mysql-zhu-cong-tong-bu/"" data-c="
          &lt;h3 id=&#34;mysql主从监控的必要性&#34;&gt;mysql主从监控的必要性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;如果发生主从同步异常，业务会出问题&lt;/li&gt;
&lt;li&gt;如果从库是用来备份的，会导致数据丢失&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mysql主从同步监控说明&#34;&gt;mysql主从同步监控说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;mysql提供show slave status\G来监控mysql主从同步&lt;/li&gt;
&lt;li&gt;Slave IO Running可以查看从库的IO进程是否正常，IO进程用于同步二进制日志&lt;/li&gt;
&lt;li&gt;Slave SQL Running可以观察从库的SQL进程是否正常，SQL进程用于执行二进制日志&lt;/li&gt;
&lt;li&gt;Seconds Behind Master代表主从同步的延时时间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主从监控权限用户的创建&#34;&gt;主从监控权限用户的创建&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -pzabbixpwd -h 127.0.0.1
grant usage,replication client on *.* to &#39;monitor&#39;@&#39;127.0.0.1&#39; identified by &#39;monitorpwd&#39;;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;监控mysql主从的shell脚本&#34;&gt;监控mysql主从的shell脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/tmp/check_mysql_slave.sh &amp;lt;&amp;lt;EOF
key=\$1
port=\$2
mysql -umonitor -pmonitorpwd -h 127.0.0.1 -P\$port -e &#39;show slave status\G&#39; | grep &amp;quot;\$key\s&amp;quot; | awk &#39;{print \$2}&#39; 2&amp;gt;/dev/null
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;脚本测试&#34;&gt;脚本测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sh /tmp/check_mysql_slave.sh &amp;quot;Slave SQL Running&amp;quot; 3306
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix自定义key监控mysql主从&#34;&gt;zabbix自定义key监控mysql主从&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/local/zabbix/etc/zabbix_agentd.conf.d/check_mysql_slave.conf &amp;lt;&amp;lt;EOF
UserParameter=mysql.slave.status[*],sh /tmp/check_mysql_slave.sh
EOF
pkill zabbix_agentd
zabbix_agentd
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;创建监控模板&#34;&gt;创建监控模板&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql.slave.status[Slave_IO_Running,3306]
mysql.slave.status[Slave_SQL_Running,3306]
mysql.slave.status[Seconds_Behind_Master,3306]
# 也可以使用自动发现
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;定义解决器expression来判断主从同步是否异常&#34;&gt;定义解决器(Expression)来判断主从同步是否异常&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;两个状态都要为YES：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{Template Mysql Slave Status:mysql.slave.status[Slave_IO_Running,3306].str(Yes)}=0 or {Template Mysql Slave Status:mysql.slave.status[Slave_SQL_Running,3306].str(Yes)}=0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;延时不能超过100：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{Template Mysql Slave Status:mysql.slave.status[Seconds_Behind_Master,3306].last()}&amp;lt;100
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;自动发现&#34;&gt;自动发现&lt;/h3&gt;
&lt;p&gt;尝试使用自动发现监控mysql主从状态，最重要的是自动发现端口&lt;/p&gt;
">38_zabbix监控mysql主从同步</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/37_zabbix-zi-dong-fa-xian-jian-kong-mysql/"" data-c="
          &lt;h3 id=&#34;为什么要自动发现&#34;&gt;为什么要自动发现?&lt;/h3&gt;
&lt;p&gt;mysql可能监听不同的端口，可能一台服务器有多个mysql实例监听多个端口&lt;/p&gt;
&lt;h3 id=&#34;mysql自动发现脚本&#34;&gt;mysql自动发现脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/tmp/discovrey_mysql.py &amp;lt;&amp;lt;EOF
# -*-coding:utf-8 -*-
try:
  import json
except:
  import simplejson as json
import commands
(status,output)=commands.getstatusoutput(&amp;quot;&amp;quot;&amp;quot;sudo netstat -tlnp | grep &#39;mysqld&#39; | awk &#39;{print \$4}&#39; | awk -F&#39;:&#39; &#39;{print \$2}&#39; | sort -u&amp;quot;&amp;quot;&amp;quot;)
outputs=output.split(&#39;\n&#39;)
result=[]
for one in outputs:
  result.append({&amp;quot;{#ONE}&amp;quot;:one})
print(json.dumps({&#39;data&#39;:result},sort_keys=True,indent=4))
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;给用户zabbix添加sudo权限&#34;&gt;给用户zabbix添加sudo权限&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;&amp;gt;/etc/sudoers &amp;lt;&amp;lt;EOF
zabbix ALL = NOPASSWD:/bin/netstat
Defaults:zabbix !requiretty
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix自定义key配置&#34;&gt;zabbix自定义key配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/local/zabbix/etc/zabbix_agentd.conf.d/discovery_mysql.conf &amp;lt;&amp;lt;EOF
UserParameter=mysql.discovery,python /tmp/discovrey_mysql.py
EOF
pkill zabbix_agentd
zabbix_agentd
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测试能否获取值&#34;&gt;测试能否获取值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zabbix_get -s 127.0.0.1 -k mysql.discovery
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用自动发现监控mysql&#34;&gt;使用自动发现监控mysql&lt;/h3&gt;
">37_zabbix自动发现监控mysql</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/36_zabbix-zi-ding-yi-key-jian-kong-mysql/"" data-c="
          &lt;h3 id=&#34;mysql的基础监控&#34;&gt;mysql的基础监控&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程存活&lt;/li&gt;
&lt;li&gt;检测端口&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mysql的高级监控说明&#34;&gt;mysql的高级监控说明&lt;/h3&gt;
&lt;p&gt;mysql提供&lt;code&gt;show global status&lt;/code&gt;可以实现对mysql的高级监控。高级监控包含监控mysql连接数、增删改查数、流量等&lt;/p&gt;
&lt;h3 id=&#34;开通最小权限用户&#34;&gt;开通最小权限用户&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grant usage on *.* to &#39;monitor&#39;@&#39;127.0.0.1&#39; identified by &#39;monitorpwd&#39;;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;监控命令详解&#34;&gt;监控命令详解&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -umonitor -h 127.0.0.1 -pmonitorpwd -e &#39;show global status&#39;
# Threads_connected：连接数
# Com_select：查询总量
# Com_insert：插入总量
# Com_update：更新总量
# Com_delete：删除总量
# Bytes_received：流入总流量
# Bytes_sent：流出总流量
# Slow_queries：慢查询总量
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;监控脚本&#34;&gt;监控脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/tmp/check_mysql.sh &amp;lt;&amp;lt;EOF
key=\$1
port=\$2
mysql -umonitor -pmonitorpwd -h 127.0.0.1 -P\$port -e &#39;show global status&#39; 2&amp;gt;/dev/null | grep &amp;quot;\$key\s&amp;quot; | awk &#39;{print \$2}&#39;
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;脚本测试&#34;&gt;脚本测试&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sh /tmp/check_mysql.sh Threads_connected
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix自定义key配置&#34;&gt;Zabbix自定义key配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/local/zabbix/etc/zabbix_agentd.conf.d/check_mysql.conf &amp;lt;&amp;lt;EOF
UserParameter=mysql.status[*],sh /tmp/check_mysql.sh \$1 \$2 2&amp;gt;/dev/null
EOF
pkill zabbix_agentd
zabbix_agentd
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;测试是否能够获取值&#34;&gt;测试是否能够获取值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zabbix_get -s 127.0.0.1 -k mysql.status[Threads_connected]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用模板去监控mysql&#34;&gt;使用模板去监控mysql&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql.status[Threads_connected,3306]
mysql.status[Com_select,3306]
mysql.status[Com_insert,3306]
mysql.status[Com_update,3306]
mysql.status[Com_delete,3306]
mysql.status[Bytes_received,3306]
mysql.status[Bytes_sent,3306]
mysql.status[Slow_queries,3306]
&lt;/code&gt;&lt;/pre&gt;
">36_zabbix自定义key监控mysql</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/35_grafana-bian-liang-gao-ji-gong-neng/"" data-c="
          &lt;h3 id=&#34;grafana展现zabbix数据&#34;&gt;grafana展现zabbix数据&lt;/h3&gt;
&lt;p&gt;单台服务器的流量比较好展现，但多台服务器的流量需要手动创建图形比较麻烦，grafana的变量功能让我们可以选择展现哪台服务器的流量&lt;/p&gt;
&lt;h3 id=&#34;zabbix添加监控项目的顺序&#34;&gt;zabbix添加监控项目的顺序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;主机组&lt;/li&gt;
&lt;li&gt;主机&lt;/li&gt;
&lt;li&gt;应用集（可选）&lt;/li&gt;
&lt;li&gt;监控项目（指定应用集）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grafana变量的使用&#34;&gt;grafana变量的使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;主机组的变量：group:*&lt;/li&gt;
&lt;li&gt;主机变量：host:$group.*&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grafana变量的使用-2&#34;&gt;grafana变量的使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;流量图中使用模板，可以随意观察某台主机的流量&lt;/li&gt;
&lt;li&gt;CPU利用率使用模板，可以随意观察某台主机的CPU利用率&lt;/li&gt;
&lt;/ol&gt;
">35_grafana变量高级功能</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/34_grafana-du-qu-zabbix-shu-ju-zhan-xian/"" data-c="
          &lt;h3 id=&#34;grafana配置zabbix数据源&#34;&gt;grafana配置zabbix数据源&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix数据源地址：&lt;a href=&#34;http://192.168.3.111/zabbix/api_jsonrpc.php&#34;&gt;http://192.168.3.111/zabbix/api_jsonrpc.php&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;选择zabbix版本&lt;/li&gt;
&lt;li&gt;配置zabbix用户名和密码&lt;/li&gt;
&lt;li&gt;添加数据源成功会有提示&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grafana面板中添加图形&#34;&gt;grafana面板中添加图形&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CPU负载和时间&lt;/li&gt;
&lt;li&gt;服务器流量&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grafana面板&#34;&gt;grafana面板&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;grafana面板中添加单一状态&lt;/li&gt;
&lt;li&gt;grafana添加zabbix告警&lt;/li&gt;
&lt;/ol&gt;
">34_grafana读取zabbix数据展现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/33_grafana-jian-dan-shi-yong-he-cha-jian-an-zhuang/"" data-c="
          &lt;h3 id=&#34;grafana的使用&#34;&gt;grafana的使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需要先创建dashboard，然后再添加图形&lt;/li&gt;
&lt;li&gt;每次操作都需要save&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grafana数据源介绍&#34;&gt;grafana数据源介绍&lt;/h3&gt;
&lt;p&gt;默认不支持从zabbix读取数据，需要安装插件&lt;/p&gt;
&lt;h3 id=&#34;grafana安装zabbix插件&#34;&gt;grafana安装zabbix插件&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;grafana-cli plugins list-remote
grafana-cli plugins list-remote | grep -i zabbix
grafana-cli plugins install alexanderzobnin-zabbix-app
# 插件安装有时候比较慢，可以下载离线的zabbix插件，解压放到/var/lib/grafana/plugins中
# https://grafana.com/api/plugins/alexanderzobnin-zabbix-app/versions/3.10.5/download
systemctl restart grafana-server
# 开启插件
plugins----apps----zabbix----enable
&lt;/code&gt;&lt;/pre&gt;
">33_grafana简单使用和插件安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/32_grafana-jian-jie-yu-an-zhuang/"" data-c="
          &lt;h3 id=&#34;zabbix图形&#34;&gt;zabbix图形&lt;/h3&gt;
&lt;p&gt;需要创建，组合比较麻烦&lt;/p&gt;
&lt;h3 id=&#34;grafana简介&#34;&gt;grafana简介&lt;/h3&gt;
&lt;p&gt;自身并不存储数据，数据从其他地方获取，需要配置数据源；支持从zabbix中获取数据；优化图形展示，可以用来做监控大屏&lt;/p&gt;
&lt;h3 id=&#34;实战环境&#34;&gt;实战环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix server：192.168.3.111&lt;/li&gt;
&lt;li&gt;grafana：192.168.115&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grafana安装&#34;&gt;grafana安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;wget https://dl.grafana.com/oss/release/grafana-6.6.0-1.x86_64.rpm
yum -y localinstall grafana-6.6.0-1.x86_64.rpm
systemctl enable grafana-server
systemctl start grafana-server
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程 ps auxf | grep grafana&lt;/li&gt;
&lt;li&gt;端口 netstat -tulnp | grep grafana&lt;/li&gt;
&lt;li&gt;日志 tail -f /var/log/grafana/grafana.log&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;grafana访问&#34;&gt;grafana访问&lt;/h3&gt;
&lt;p&gt;192.168.3.112:3000&lt;br&gt;
默认用户名和密码：admin&lt;/p&gt;
">32_grafana简介与安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/31_zabbix-de-snmp-zi-dong-fa-xian-shi-zhan/"" data-c="
          &lt;h3 id=&#34;为什么需要自动发现&#34;&gt;为什么需要自动发现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;交换机网口过多，逐个添加网口监控比较麻烦&lt;/li&gt;
&lt;li&gt;OID值比较难记&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;使用snmp的自动发现&#34;&gt;使用snmp的自动发现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;snmp自动发现自动添加索引变量：{#SNMPINDEX}&lt;/li&gt;
&lt;li&gt;discovery[{#IFDESCR},1.3.6.1.2.1.2.2.1.2]&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix使用自动发现监控网卡状态和流量&#34;&gt;zabbix使用自动发现监控网卡状态和流量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;ifDescr：discovery[{#IFDESCR},1.3.6.1.2.1.2.2.1.2]
ifOperStatus：1.3.6.1.2.1.2.2.1.8.{#SNMPINDEX}
ifHCInOctets：1.3.6.1.2.1.31.1.1.1.6.{#SNMPINDEX}
ifHCOutOctets：1.3.6.1.2.1.31.1.1.1.10.{#SNMPINDEX}
&lt;/code&gt;&lt;/pre&gt;
">31_zabbix的snmp自动发现实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/30_zabbix-shi-yong-snmp-jian-kong-shi-zhan/"" data-c="
          &lt;p&gt;使用snmp接口监控服务器与监控交换机类似，默认使用161端口&lt;/p&gt;
&lt;h3 id=&#34;snmp密码修改community修改&#34;&gt;snmp密码修改（community修改）&lt;/h3&gt;
&lt;p&gt;管理--&amp;gt;一般--&amp;gt;宏定义--&amp;gt;{$SNMP_COMMUNITY}=snmppwd&lt;/p&gt;
&lt;h3 id=&#34;snmp监控添加&#34;&gt;snmp监控添加&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;最后面的.2代表监控第2块网卡&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ifDescr：
snmpwalk -v 2c -c snmppwd 192.168.3.179 1.3.6.1.2.1.2.2.1.2.2
# ifOperStatus：
snmpwalk -v 2c -c snmppwd 192.168.3.179 1.3.6.1.2.1.2.2.1.8.2
# ifType：
snmpwalk -v 2c -c snmppwd 192.168.3.179 1.3.6.1.2.1.2.2.1.3.2
# ifHCInOctets：
snmpwalk -v 2c -c snmppwd 192.168.3.179 1.3.6.1.2.1.31.1.1.1.6.2
# ifHCOutOctets：
snmpwalk -v 2c -c snmppwd 192.168.3.179 1.3.6.1.2.1.31.1.1.1.10.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;SNMP community的值为{$SNMP_COMMUNITY}&lt;/code&gt;&lt;/p&gt;
">30_zabbix使用SNMP监控实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/29_snmp-de-oid-he-mib/"" data-c="
          &lt;h3 id=&#34;snmp的监控基于oid&#34;&gt;snmp的监控基于OID&lt;/h3&gt;
&lt;p&gt;OID，对象标识符，由数字组成，比较难记忆，&lt;a href=&#34;https://blog.51cto.com/6300167/2379305&#34;&gt;常用OID和MIB对应关系表&lt;/a&gt;&lt;br&gt;
下面是OID简单树图&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585757970571.png&#34; alt=&#34;2020-02-02_060934.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用oid获取监控信息&#34;&gt;使用OID获取监控信息&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;snmpwalk -v 2c -c snmppwd 192.168.3.179 .1.3.6.1.4.1.2021.10.1.3  
#监控cpu负载
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;snmpwalk -v 2c -c snmppwd 192.168.3.179 .1.3.6.1.2.1.2  
#监控网卡信息
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;snmp基于OID，OID树图的理解有助于权限的开通&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;oid的难点&#34;&gt;OID的难点&lt;/h3&gt;
&lt;p&gt;数字比较难记，但实际访问却是基于IP的，实际监控是基于OID的&lt;/p&gt;
&lt;h3 id=&#34;mib库&#34;&gt;MIB库&lt;/h3&gt;
&lt;p&gt;MIB，管理信息库。由于OID难记，产生了MIB，类似DNS服务器，将IP和域名对应上。MIB库有多个。&lt;/p&gt;
&lt;h3 id=&#34;使用mib名字获取监控信息&#34;&gt;使用MIB名字获取监控信息&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;snmpwalk -v 2c -c snmppwd 192.168.3.179 MIB名称&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;laLoad # cpu负载&lt;/li&gt;
&lt;li&gt;ifDescr # 网口名字&lt;/li&gt;
&lt;li&gt;ifOperStatus # 网口开启状态&lt;/li&gt;
&lt;li&gt;ifHCOutOctets # 网口出的总流量（单位：bps）&lt;/li&gt;
&lt;li&gt;ifHCInOctets # 网口入的总流量&lt;br&gt;
&lt;code&gt;!!!网卡流量监控注意，建议使用64位的去监控，32位(去掉if后面的HC)的比较容易溢出!!!&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
">29_snmp的OID和MIB</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/28_snmp-fu-wu-qi-de-an-zhuang/"" data-c="
          &lt;h3 id=&#34;snmp简介&#34;&gt;snmp简介&lt;/h3&gt;
&lt;p&gt;简单网络管理协议，方便我们监控服务器、交换机、路由器等&lt;/p&gt;
&lt;h3 id=&#34;snmp监控实战说明&#34;&gt;snmp监控实战说明&lt;/h3&gt;
&lt;p&gt;监控Linux、Windows服务器建议使用agent，网络设备一般使用snmp，监控网络接口存活以及网络接口流量&lt;/p&gt;
&lt;h3 id=&#34;使用snmp监控说明&#34;&gt;使用snmp监控说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;被监控服务器需要安装snmp服务。 路由器、交换机可以开启snmp服务，需要自己设置snmp的密码&lt;/li&gt;
&lt;li&gt;zabbix server需要通过snmp客户端协议去监控&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;snmp的版本&#34;&gt;snmp的版本&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;v1基于community进行控制访问&lt;/li&gt;
&lt;li&gt;v2c也是基于community进行控制访问，但比v1增强了部分功能（实验中使用）&lt;/li&gt;
&lt;li&gt;v3加强了认证&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实战环境&#34;&gt;实战环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix server服务器：192.168.3.111&lt;/li&gt;
&lt;li&gt;被监控服务器：192.168.3.179（register）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;centos7-snmp安装&#34;&gt;centos7 snmp安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#server 和 被监控端都需要安装
yum install -y net-snmp net-snmp-utils
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;snmp的配置及详解&#34;&gt;snmp的配置及详解&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/etc/snmp/snmpd.conf &amp;lt;&amp;lt;EOF
com2sec notConfigUser default snmppwd
group notConfigGroup v1 notConfigUser
group notConfigGroup v2c notConfigUser
view systemview included .1.3.6.1
access notConfigGroup &amp;quot;&amp;quot; any noauth exact systemview none none
syslocation hangzhou
syscontact module@hangzhou.com
dontLogTCPWrappersConnects yes
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;详解&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 用户名（notConfigUser）、访问用户白名单（default代表所有ip访问）、community密码（snmppwd）
com2sec notConfigUser default snmppwd
# 组名（notConfigGroup）、snmp版本、用户名
group notConfigGroup v1 notConfigUser
group notConfigGroup v2c notConfigUser
# 视图名称（systemview）、包含（incl/excl）、subtree（OID数字表示）
view systemview included .1.3.6.1
# 组名、内容、snmp版本（any所有）、认证等级、systemview读权限、无写权限、无trapper权限
access notConfigGroup &amp;quot;&amp;quot; any noauth exact systemview none none
syslocation hangzhou
syscontact module@hangzhou.com
dontLogTCPWrappersConnects yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;snmp开启与验证&#34;&gt;snmp开启与验证&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;开启&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;systemctl enable snmpd
systemctl start snmpd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;验证&lt;br&gt;
2.1 进程 ps auxf | grep snmp&lt;br&gt;
2.2 端口 netstat -tulnp | grep snmp&lt;/li&gt;
&lt;/ol&gt;
">28_snmp服务器的安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/27_zabbix-zhu-ji-zi-dong-zhu-ce/"" data-c="
          &lt;h3 id=&#34;主机自动发现和自定注册区别&#34;&gt;主机自动发现和自定注册区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;自动发现主机名设置比较麻烦，配置也相对麻烦&lt;/li&gt;
&lt;li&gt;自动注册相对来说比自动发现好用，使用自动注册，添加主机的时候主机名使用agent配置的Hostname&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主机自动注册的流程&#34;&gt;主机自动注册的流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix agent需要配置ServerActive&lt;/li&gt;
&lt;li&gt;zabbix客户端把自己的元数据提供给zabbix服务器或者proxy服务器&lt;/li&gt;
&lt;li&gt;zabbix服务器添加动作，当收到元数据时候自动添加主机、链接模板等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix客户端配置&#34;&gt;zabbix客户端配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HostMetadataItem是自动注册比自动发现多出的配置，作为该主机的标识上报server或者proxy&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/local/zabbix/etc/zabbix_agentd.conf &amp;lt;&amp;lt;EOF
PidFile=/usr/local/zabbix/zabbix_agentd.pid
LogFile=/usr/local/zabbix/zabbix_agentd.log
Hostname=auto_register
Server=192.168.3.111
ServerActive=192.168.3.111
UnsafeUserParameters=1 
Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf
HostMetadataItem=system.hostname
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix-web上添加动作&#34;&gt;zabbix web上添加动作&lt;/h3&gt;
&lt;p&gt;事件源选择自动注册--创建动作--元数据条件编写，操作添加主机、指定主机名、链接模板&lt;/p&gt;
">27_zabbix主机自动注册</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/26_zabbix-zhu-ji-zi-dong-fa-xian/"" data-c="
          &lt;h3 id=&#34;为什么要主机自动发现和自动注册&#34;&gt;为什么要主机自动发现和自动注册&lt;/h3&gt;
&lt;p&gt;手动添加主机比较麻烦，且需要填写主机IP，应用模板等，主机自动发现和自动注册能够帮我们自动监控服务器&lt;/p&gt;
&lt;h3 id=&#34;zabbix自动发现实战&#34;&gt;zabbix自动发现实战&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix添加自动发现&lt;/li&gt;
&lt;li&gt;创建动作，在动作上指定自动发现的规则&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;自动发现的建议&#34;&gt;自动发现的建议&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用zabbix agent去自动发现，也就是只有部署了zabbix客户端的才能被发现&lt;/li&gt;
&lt;li&gt;使用的自动发现key建议为system.uname&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;编辑自动发现动作&#34;&gt;编辑自动发现动作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;发现后自动添加到主机群组&lt;/li&gt;
&lt;li&gt;发现Down后自动移除主机（一般不建议使用，主机Down之后需要人工处理）&lt;/li&gt;
&lt;/ol&gt;
">26_zabbix主机自动发现</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/25_zabbix-fen-bu-shi-jian-kong-linux/"" data-c="
          &lt;h3 id=&#34;实战环境&#34;&gt;实战环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix server服务器：192.168.3.111&lt;/li&gt;
&lt;li&gt;zabbix proxy服务器（分布式服务器）：192.168.3.150&lt;/li&gt;
&lt;li&gt;proxy监控的agent：192.168.3.151&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;客户端agent的配置&#34;&gt;客户端agent的配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;gt;/usr/local/zabbix/etc/zabbix_agentd.conf &amp;lt;&amp;lt;EOF
PidFile=/usr/local/zabbix/zabbix_agentd.pid
LogFile=/usr/local/zabbix/zabbix_agentd.log
Hostname=www_003
Server=192.168.3.150
ServerActive=192.168.3.150
UnsafeUserParameters=1 
Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;添加多台agent主机&#34;&gt;添加多台agent主机&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用分布式监控&lt;/li&gt;
&lt;li&gt;使用linux模板&lt;/li&gt;
&lt;/ol&gt;
">25_zabbix分布式监控Linux</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/24_zabbix-fen-bu-shi-proxy-bian-yi-an-zhuang/"" data-c="
          &lt;h3 id=&#34;实战环境&#34;&gt;实战环境&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix server服务器：192.168.3.111&lt;/li&gt;
&lt;li&gt;zabbix agent服务器（本实验不涉及）：192168.3.199、192.168.3.198&lt;/li&gt;
&lt;li&gt;zabbix proxy服务器（分布式服务器）：192.168.3.150&lt;/li&gt;
&lt;li&gt;proxy监控的agent：192.168.3.151&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;分布式架构&#34;&gt;分布式架构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix server --&amp;gt; zabbix proxy --&amp;gt; zabbix agent&lt;/li&gt;
&lt;li&gt;zabbix agent的白名单要配置proxy的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;分布式服务器安装zabbix-proxy&#34;&gt;分布式服务器安装zabbix proxy&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;安装mysql，缓存监控数据&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y mariadb-server mariadb mariadb-devel
systemctl restart mariadb
systemctl enable mariadb
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;安装zabbix proxy&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y tar gcc make gcc-c++ net-snmp-devel libxml2-devel libcurl-devel pcre-devel libevent libevent-devel
useradd -s /sbin/nologin zabbix
cd /usr/local/src
wget &amp;quot;https://nchc.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/4.4.4/zabbix-4.4.4.tar.gz&amp;quot;
tar -zxvf zabbix-4.4.4.tar.gz
cd zabbix-4.4.4
./configure --prefix=/usr/local/zabbix --enable-proxy --enable-agent --with-mysql --with-net-snmp --with-libcurl --with-libxml2
make &amp;amp;&amp;amp; make install
chown zabbix:zabbix -R /usr/local/zabbix
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;初始化数据库&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -uroot -h 127.0.0.1
  create database zabbix character set utf8 collate utf8_bin;
  grant all privileges on zabbix.* to &#39;zabbix&#39;@&#39;127.0.0.1&#39; identified by &#39;zabbixpwd&#39;;
  set names utf8;
  use zabbix;
  source /usr/local/src/zabbix-4.4.4/database/mysql/schema.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;环境变量&#34;&gt;环境变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=$PATH:/usr/local/zabbix/sbin:/usr/local/zabbix/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;proxy配置&#34;&gt;proxy配置&lt;/h3&gt;
&lt;p&gt;Hostname为zabbix proxy服务器的名称，Server为zabbix server的IP地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;cat &amp;gt;/usr/local/zabbix/etc/zabbix_proxy.conf &amp;lt;&amp;lt;EOF
Hostname=proxy_3
Server=192.168.3.111
LogFile=/usr/local/zabbix/zabbix_proxy.log
DBHost=127.0.0.1
DBName=zabbix
DBUser=zabbix
DBPassword=zabbixpwd
DBPort=3306
ConfigFrequency=60
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;启动 zabbix_proxy&lt;/li&gt;
&lt;li&gt;进程 ps auxf | grep zabbix&lt;/li&gt;
&lt;li&gt;端口 netstat -tulnp | grep zabbix&lt;/li&gt;
&lt;li&gt;日志 tail -f /usr/local/zabbix/zabbix_proxy.log&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix-server的web端配置&#34;&gt;zabbix server的web端配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;管理--agent程序代理(一般采用主动式)&lt;/li&gt;
&lt;li&gt;观察最近出现的时间，没有超过60s（配置文件中ConfigFrequency=60规定的时间，即配置刷新时间）就证明proxy添加正常&lt;/li&gt;
&lt;/ol&gt;
">24_zabbix分布式proxy编译安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/23_zabbix-jian-kong-windows-shi-zhan/"" data-c="
          &lt;h3 id=&#34;zabbix_get获取windows信息&#34;&gt;zabbix_get获取windows信息&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zabbix_get -s 192.168.3.108 -k system.uname
zabbix_get -s 192.168.3.108 -k vm.memory.size[free]
zabbix_get -s 192.168.3.108 -k vfs.fs.size[c:,pfree]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;windows防火墙开放10050端口&#34;&gt;windows防火墙开放10050端口&lt;/h3&gt;
&lt;p&gt;win+r--firewall.cpl--高级设置--入站规则--新建规则--端口--10050--允许连接--所有&lt;/p&gt;
">23_zabbix监控windows实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/22_windows7-an-zhuang-zabbix-ke-hu-duan/"" data-c="
          &lt;h3 id=&#34;zabbix监控windows环境说明&#34;&gt;zabbix监控windows环境说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix serverIP，被监控windows的ip&lt;/li&gt;
&lt;li&gt;官网下载zabbix agent的windows版本，分为绿色版和安装板，安装&lt;/li&gt;
&lt;li&gt;编辑配置文件&lt;br&gt;
&lt;code&gt;默认安装路径为C:\Program Files\Zabbix Agent&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;编辑配置文件C:\Program Files\Zabbix Agent\zabbix_agentd.conf&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LogFile=C:\Program Files\Zabbix Agent\zabbix_agentd.log&lt;br&gt;
Timeout=30&lt;br&gt;
Server=192.168.3.111&lt;br&gt;
ServerActive=192.168.3.111(如果不用主动式，此行可以不写或者写成127.0.0.1)&lt;br&gt;
Hostname=WIN10_1903&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;cmd中执行命令注册为服务&lt;br&gt;
在安装目录中打开cmd，执行以下命令：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;.\zabbix_agentd.exe --config zabbix_agentd.conf --install
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;cmd运行&lt;br&gt;
5.1 打开服务管理器：win+r，输入services.msc，找到刚注册的服务zabbix_agentd，是否开启，启动类型是否为自动&lt;br&gt;
5.2 查看监控端口（powershell） netstat -an | grep 10050&lt;br&gt;
5.3 查看日志&lt;/li&gt;
&lt;/ol&gt;
">22_windows7安装zabbix客户端</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/21_zabbix-zi-ding-yi-key-jian-kong-linux/"" data-c="
          &lt;h3 id=&#34;zabbix自定义key监控&#34;&gt;zabbix自定义key监控&lt;/h3&gt;
&lt;p&gt;zabbix agent提供很多监控信息，但是如果有需求，自带的监控项无法满足我们的需求&lt;/p&gt;
&lt;h3 id=&#34;自定义key说明&#34;&gt;自定义key说明&lt;/h3&gt;
&lt;p&gt;所有语言，只要能运行然后返回结果即可。运维常用语言：shell、python。&lt;/p&gt;
&lt;h3 id=&#34;自定义key&#34;&gt;自定义key&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;使用自定义shell脚本监控内存，一般脚本只需要输出数字即可&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无参数定义key&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/tmp/memavailable.sh &amp;lt;&amp;lt;EOF
free -m | grep &#39;Mem:&#39; | awk &#39;{print \$NF}&#39;
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;有参数定义key&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/tmp/mem.sh &amp;lt;&amp;lt;EOF
case &amp;quot;\$1&amp;quot; in
&amp;quot;available&amp;quot;) free -m | grep &amp;quot;Mem:&amp;quot; | awk &#39;{print \$NF}&#39;;;
&amp;quot;total&amp;quot;) free -m | grep &amp;quot;Mem:&amp;quot; | awk &#39;{print \$2}&#39;;;
&amp;quot;used&amp;quot;) free -m | grep &amp;quot;Mem:&amp;quot; | awk &#39;{print \$3}&#39;;;
*) echo &amp;quot;not supported!!&amp;quot;;;
esac
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix自定义key的配置&#34;&gt;zabbix自定义key的配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;配置文件和脚本均在agent上，配置完成后重启agent&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置文件路径在配置文件/usr/local/zabbix/etc/zabbix_agentd.conf(zabbix agent)中查找Include的值
# 在自定义key的脚本存储在zabbix agent上
cat &amp;gt;/usr/local/zabbix/etc/zabbix_agentd.conf.d/mem.conf &amp;lt;&amp;lt;EOF
UserParameter=mem.available,sh /tmp/memavailable.sh
UserParameter=mem.check[*],sh /tmp/mem.sh \$1
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;网页上添加监控&#34;&gt;网页上添加监控&lt;/h3&gt;
&lt;p&gt;键值直接使用/usr/local/zabbix/etc/zabbix_agentd.conf.d/mem.conf配置文件中定义的，参数使用脚本中的，其他的和使用系统提供的key格式相同&lt;/p&gt;
">21_zabbix自定义key监控Linux</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/20_zabbix-shi-yong-mo-ban-jian-kong-linux/"" data-c="
          &lt;h3 id=&#34;两种模板&#34;&gt;两种模板&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;系统自带模板，例如Template OS Linux等等，可根据需求自行调整，模板中还带有自动发现功能&lt;/li&gt;
&lt;li&gt;自定义模板&lt;/li&gt;
&lt;/ol&gt;
">20_zabbix使用模板监控Linux</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/19_zabbix-ke-hu-duan-de-zhu-dong-shi-yu-bei-dong-shi/"" data-c="
          &lt;h3 id=&#34;zabbix客户端的两种方式&#34;&gt;zabbix客户端的两种方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;被动式（默认方式）&lt;br&gt;
zabbix服务器主动去被监控的服务器收集信息，类似zabbix_get&lt;/li&gt;
&lt;li&gt;主动式（建议使用方式 agent active）&lt;br&gt;
zabbix agent-&amp;gt;zabbix server，agent获取主动式需要汇报的key和时间间隔，采集数据上传给zabbix server。&lt;code&gt;此模式节省zabbix server资源&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主动式监控添加使用条件比较多&#34;&gt;主动式监控添加&lt;code&gt;使用条件比较多&lt;/code&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需要主机名一致&lt;/li&gt;
&lt;li&gt;需要zabbix server的10051端口开放&lt;/li&gt;
&lt;li&gt;添加被动式监控&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;查看主动式监控&#34;&gt;查看主动式监控&lt;/h3&gt;
&lt;p&gt;重启agent后进行抓包&lt;/p&gt;
">19_zabbix客户端的主动式与被动式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/18_zabbix-jian-kong-cpunei-cun-ci-pan-liu-liang/"" data-c="
          &lt;h3 id=&#34;zabbix_get服务端&#34;&gt;zabbix_get&lt;code&gt;服务端&lt;/code&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix提供一个zabbix_get工具，可以跟zabbix agent通讯获取监控信息&lt;/li&gt;
&lt;li&gt;使用方式：zabbix_get -s &amp;quot;IP&amp;quot; -k &amp;quot;key&amp;quot;&lt;br&gt;
&lt;code&gt;例如：zabbix_get -s 192.168.3.199 -k system.uname&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;zabbix agent 查看所有监控项目(&lt;strong&gt;key&lt;/strong&gt;)：zabbix_agentd -p&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;监控cpukey值&#34;&gt;监控cpu（key值）&lt;/h3&gt;
&lt;h4 id=&#34;负载&#34;&gt;负载&lt;/h4&gt;
&lt;p&gt;system.cpu.load[all,avg1]  #Float型&lt;br&gt;
system.cpu.load[all,avg5]  #Float型&lt;br&gt;
system.cpu.load[all,avg15]  #Float型&lt;/p&gt;
&lt;h4 id=&#34;使用和空闲&#34;&gt;使用和空闲&lt;/h4&gt;
&lt;p&gt;system.cpu.util[,iowait,]  #Float型&lt;br&gt;
system.cpu.util[,system,]  #Float型&lt;br&gt;
system.cpu.util[,user,]  #Float型&lt;br&gt;
system.cpu.util[,idle,]  #Float型&lt;/p&gt;
&lt;h3 id=&#34;监控内存key值&#34;&gt;监控内存（key值）&lt;/h3&gt;
&lt;h4 id=&#34;剩余bufferscached实际上也是剩余的&#34;&gt;剩余(buffers\cached实际上也是剩余的)&lt;/h4&gt;
&lt;p&gt;vm.memory.size[available]&lt;/p&gt;
&lt;h3 id=&#34;监控磁盘&#34;&gt;监控磁盘&lt;/h3&gt;
&lt;p&gt;名称：Disk pfree on $1&lt;br&gt;
名称：inode pfree on $1&lt;br&gt;
vfs.fs.size[/,pfree]  #Float型&lt;br&gt;
vfs.fs.inode[/,pfree]  #Float型&lt;/p&gt;
&lt;h3 id=&#34;监控流量&#34;&gt;监控流量&lt;/h3&gt;
&lt;p&gt;net.if.in[eth0]  #整型（每秒速率），默认返回字节数，需要&lt;em&gt;8&lt;br&gt;
net.if.out[eth0]  #整型（每秒速率），默认返回字节数，需要&lt;/em&gt;8&lt;br&gt;
&lt;strong&gt;&lt;code&gt;shell计算流量&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;onetime=$(ifconfig | grep eth0 -A 6 | grep &#39;RX packets&#39; | awk &#39;{print $5}&#39;)
sleep 30
twotime=$(ifconfig | grep eth0 -A 6 | grep &#39;RX packets&#39; | awk &#39;{print $5}&#39;)
echo &amp;quot;incoming traffic is $((($twotime-$onetime)/30*8))bps&amp;quot;

onetime=$(ifconfig | grep eth0 -A 6 | grep &#39;TX packets&#39; | awk &#39;{print $5}&#39;)
sleep 30
twotime=$(ifconfig | grep eth0 -A 6 | grep &#39;TX packets&#39; | awk &#39;{print $5}&#39;)
echo &amp;quot;outing traffic is $((($twotime-$onetime)/30*8))bps&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
">18_zabbix监控cpu、内存、磁盘、流量</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/17_linux-xia-zabbix-ke-hu-duan-bian-yi-an-zhuang/"" data-c="
          &lt;h3 id=&#34;监控项目的多种方式&#34;&gt;监控项目的多种方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;simple check：被监控的服务器无需安装客户端，如ping、端口检测之类&lt;/li&gt;
&lt;li&gt;zabbix agent：被动式监控服务器&lt;/li&gt;
&lt;li&gt;zabbix agent（active）：主动式监控服务器&lt;/li&gt;
&lt;li&gt;snmp check：使用snmp协议去获取监控信息&lt;/li&gt;
&lt;li&gt;zabbix trapper：主动式监控&lt;/li&gt;
&lt;li&gt;External check：zabbix server上可编写监控脚本&lt;/li&gt;
&lt;li&gt;Jmx agent：监控java进程&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;实战环境&#34;&gt;实战环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;zabbix server：192.168.3.111&lt;/li&gt;
&lt;li&gt;被监控服务器：192.168.3.199（www_001）,192.168.3.198（www_002）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;客户端监控优势对比简单监控&#34;&gt;客户端监控优势（对比简单监控）&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;能获得更多的服务器信息，例如cpu、内存等&lt;/li&gt;
&lt;li&gt;zabbix客户端内置了很多key，方便我们监控基本硬件信息&lt;/li&gt;
&lt;li&gt;zabbix客户端能够自定义监控，方便我们监控部署的应用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix-agent编译安装&#34;&gt;zabbix agent编译安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y gcc gcc-c++ make pcre-devel
useradd -s /sbin/nologin zabbix
cd /usr/local/src
wget &amp;quot;https://nchc.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/4.4.4/zabbix-4.4.4.tar.gz&amp;quot;
tar -zxvf zabbix-4.4.4.tar.gz
cd zabbix-4.4.4
./configure --prefix=/usr/local/zabbix --enable-agent
make &amp;amp;&amp;amp; make install
chown zabbix:zabbix -R /usr/local/zabbix
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;环境变量&#34;&gt;环境变量&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=$PATH:/usr/local/zabbix/sbin:/usr/local/zabbix/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix-agent配置&#34;&gt;zabbix agent配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Hostname建议跟web端配置相同，同时建议与被监控服务器系统主机名相同（设置主机名hostnamectl set-hostname www_001）&lt;/code&gt;&lt;br&gt;
&lt;code&gt;Server(被动式，允许serverIP来访问我)和ServerActive（主动式，将数据上传给serverIP）上配置的是zabbix server的ip&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cat &amp;gt;/usr/local/zabbix/etc/zabbix_agentd.conf &amp;lt;&amp;lt;EOF
PidFile=/usr/local/zabbix/zabbix_agentd.pid
LogFile=/usr/local/zabbix/zabbix_agentd.log
Hostname=www_00
Server=192.168.3.111
ServerActive=192.168.3.111
UnsafeUserParameters=1 
Include=/usr/local/zabbix/etc/zabbix_agentd.conf.d/*.conf
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix-agent启动&#34;&gt;zabbix agent启动&lt;/h3&gt;
&lt;p&gt;mkdir /usr/local/zabbix/etc/zabbix_agentd.conf.d&lt;br&gt;
zabbix_agentd&lt;/p&gt;
&lt;h3 id=&#34;验证zabbix-agent是否成功启动&#34;&gt;验证zabbix agent是否成功启动&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;日志 tail -f /usr/local/zabbix/zabbix_agentd.log&lt;/li&gt;
&lt;li&gt;进程 ps auxf | grep zabbix&lt;/li&gt;
&lt;li&gt;端口(10050) netstat -tulnp | grep zabbix&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;使用systemctl管理zabbix_agentd&#34;&gt;使用systemctl管理zabbix_agentd&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/zabbix_agentd.service &amp;lt;&amp;lt;EOF
[Unit]
Description=zabbix_agentd
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/php/sbin/zabbix_agentd
[Install]
WantedBy=multi-user.target
EOF
&lt;/code&gt;&lt;/pre&gt;
">17_Linux下zabbix客户端编译安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/16_-ding-ding-gao-jing-shi-zhan/"" data-c="
          &lt;h3 id=&#34;钉钉企业的地址&#34;&gt;钉钉企业的地址&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://oa.dingtalk.com/&#34;&gt;企业钉钉&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;登录企业钉钉&#34;&gt;登录企业钉钉&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通讯录管理里面的userid在发钉钉的时候需要用到&lt;/li&gt;
&lt;li&gt;工作台里可以自建应用&lt;/li&gt;
&lt;li&gt;微应用管理可以管理应用&lt;/li&gt;
&lt;li&gt;开发账号管理可以查看密码信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;发钉钉告警的脚本加执行权限chmod-ax-zabbix_ddpy&#34;&gt;发钉钉告警的脚本（加执行权限chmod a+x zabbix_dd.py）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
# -*- coding:utf-8 -*-
# zabbix_dd.py
import json,sys,urllib2

appkey=&amp;quot;xxx&amp;quot;
appsecret=&amp;quot;xxx&amp;quot; 
agentid=&amp;quot;xxx&amp;quot; 
touser=sys.argv[1]
content=sys.argv[2] 

token_url=&#39;https://oapi.dingtalk.com/gettoken?corpid=&#39;+appkey+&#39;&amp;amp;corpsecret=&#39;+appsecret
tokenresponse=urllib2.urlopen(tokenurl)
tokenresult=json.loads(tokenresponse.read().decode(&#39;utf-8&#39;))
token=tokenresult[&#39;access_token&#39;]
sendurl=&#39;https://oapi.dingtalk.com/message/send?access_token&#39;+token
headers={
  &#39;Content_Type&#39;:&#39;application/json&#39;
}
main_content={
  &amp;quot;touser&amp;quot;:touser,
  &amp;quot;toparty&amp;quot;:&amp;quot;&amp;quot;,
  &amp;quot;agentid&amp;quot;:agentid,
  &amp;quot;msgtype&amp;quot;:&amp;quot;text&amp;quot;,
  &amp;quot;text&amp;quot;:{
    &amp;quot;content&amp;quot;:content,
  }
}
main_content=json.dumps(main_content)
req=urllib2.Request(sendurl,headers=headers)
response=urllib2.urlopen(req,main_content.encode(&amp;quot;utf-8&amp;quot;))
print(response.read().decode(&amp;quot;utf-8&amp;quot;))

&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;测试脚本：/usr/local/zabbix/alertscripts/zabbix_dd.py &#39;chiss&#39; &#39;disk using &amp;gt; 90%&#39;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;zabbix钉钉告警配置步骤&#34;&gt;zabbix钉钉告警配置步骤&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;类似微信告警&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写一个钉钉告警脚本&lt;/li&gt;
&lt;li&gt;报警媒介添加钉钉告警&lt;/li&gt;
&lt;li&gt;用户设置报警媒介&lt;/li&gt;
&lt;li&gt;创建触发动作&lt;/li&gt;
&lt;/ol&gt;
">16_钉钉告警实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/15_-wei-xin-gao-jing-shi-zhan/"" data-c="
          &lt;h3 id=&#34;企业微信地址个人可注册&#34;&gt;企业微信地址，个人可注册&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://work.weixin.qq.com/&#34;&gt;企业微信&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;登录企业微信&#34;&gt;登录企业微信&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;企业-&amp;gt;微工作台里可以直接微信关注，无需下载企业微信&lt;/li&gt;
&lt;li&gt;通讯录里的账号在发微信脚本中要用到&lt;/li&gt;
&lt;li&gt;应用于与小程序可创建应用&lt;/li&gt;
&lt;li&gt;发微信的python脚本（加执行权限chmod a+x zabbix_wx.py）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
# -*- coding:utf-8 -*-
# zabbix_wx.py
import json
import sys
import urllib,urllib2

agentid=&amp;quot;xxx&amp;quot; #自建应用的AgentId
corpid=&amp;quot;xxx&amp;quot; #公司的id，在我的企业--企业ID
corpsecret=&amp;quot;xxx&amp;quot; #AgentId下面的Secret密码
 
#get token
gettoken_url=&#39;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=&#39;+corpid+&#39;&amp;amp;corpsecret=&#39;+corpsecret
token_file=urllib2.urlopen(gettoken_url)
token_data=token_file.read().decode(&#39;utf-8&#39;)
token_json=json.loads(token_data)
my_token=token_json[&#39;access_token&#39;]

#send wechart
touser=sys.argv[1] #many user:&#39;zhangsan|wangwu|lisi&#39;
content=sys.argv[2] #content
post_content={
  &amp;quot;touser&amp;quot;:touser,
  &amp;quot;agentid&amp;quot;:agentid,
  &amp;quot;msgtype&amp;quot;:&amp;quot;text&amp;quot;,
  &amp;quot;text&amp;quot;:{
    &amp;quot;content&amp;quot;:content,
  }
}
json_content=json.dumps(post_content)
url = &#39;https://https://qyapi.weixin.qq.com/cgi-bin/message/sent?access_token=&#39;+my_token
response=urllib2.urlopen(url,json_content)
print(response.read().decode(&amp;quot;utf-8&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;测试脚本：&lt;code&gt;/usr/local/zabbix/alertscripts/zabbix_wx.py &#39;chiss&#39; &#39;disk using &amp;gt; 90%&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;zabbix微信告警配置步骤&#34;&gt;zabbix微信告警配置步骤&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;类似邮件告警&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写一个微信告警脚本&lt;/li&gt;
&lt;li&gt;报警媒介添加微信告警&lt;/li&gt;
&lt;li&gt;用户设置报警媒介&lt;/li&gt;
&lt;li&gt;创建触发动作&lt;/li&gt;
&lt;/ol&gt;
">15_微信告警实战</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/14_-gao-jing-nei-rong-zi-ding-yi-he-gao-jing-yi-zhi/"" data-c="
          &lt;h3 id=&#34;主题-内容定义&#34;&gt;主题、内容定义&lt;/h3&gt;
&lt;p&gt;(邮件标题或内容中)&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主机名变量：{HOST.NAME1}&lt;/li&gt;
&lt;li&gt;主机IP变量：{HOST.IP1}&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;延迟告警&#34;&gt;延迟告警&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;一般来说不会有问题马上发送警告，例如检测80端口&lt;/li&gt;
&lt;li&gt;定义持续时间&lt;/li&gt;
&lt;li&gt;定义step（操作细节--步骤，3-3代表2分钟，4-4代表3分钟...）&lt;/li&gt;
&lt;/ol&gt;
">14_告警内容自定义和告警抑制</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/13_zabbix-you-jian-gao-jing/"" data-c="
          &lt;h3 id=&#34;zabbix告警&#34;&gt;zabbix告警&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;网页上能直接看到触发器告警&lt;/li&gt;
&lt;li&gt;一般不能直接看网页，所以触发器触发后我们要发送邮件、微信、钉钉等通知我们&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix告警原理&#34;&gt;zabbix告警原理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;触发器触发后，可以配置对应的动作&lt;/li&gt;
&lt;li&gt;在动作里可以发邮件、微信、钉钉、短信等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;告警脚本&#34;&gt;告警脚本&lt;/h3&gt;
&lt;p&gt;脚本位置可见配置文件：/usr/local/zabbix/etc/zabbix_server.conf&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;LogFile=/url/local/zabbix/zabbix_server.log
DBHost=127.0.0.1
DBName=zabbix
DBUser=zabbix
DBPassword=zabbixpwd
DBPort=3306
Timeout=30
AlertScriptsPath=/usr/local/zabbix/alertscripts  #告警脚本存放位置
ExternalScripts=/usr/local/zabbix/externalscripts
LogSlowQueries=300
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;发邮件建议&#34;&gt;发邮件建议&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;服务器往外的25端口一般被云厂商禁止，所以建议使用465端口发送加密邮件&lt;/li&gt;
&lt;li&gt;qq邮箱、163邮箱需要配置开启smtp&lt;/li&gt;
&lt;li&gt;发邮件的python脚本（加执行权限chmod a+x zabbix_sendmail.py）&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#!/usr/bin/python
# -*- coding:utf-8 -*-
# zabbix_sendmail.py
from email.mime.text import MIMEText
from email.header import Header
from smtplib import SMTP_SSL
import sys
smtpaddr = &#39;smtp.qq.com&#39;
myemail = &#39;2289521489@qq.com&#39;
# password = &#39;邮箱授权码&#39;
#####下面两行功能和上面一行相同
f = open(&#39;/usr/local/zabbix/.passwd&#39;,&#39;r&#39;)
password = f.readline().strip()
#####
recvmail=sys.argv[1] #多个邮箱之间使用英文逗号隔开
subject=sys.argv[2] #邮件主题
content=sys.argv[3] #邮件内容
msg = MIMEText(&amp;quot;&amp;quot;&amp;quot;%s&amp;quot;&amp;quot;&amp;quot;%(content),&amp;quot;plain&amp;quot;,&amp;quot;utf-8&amp;quot;)
msg[&#39;Subject&#39;] = Header(subject,&#39;utf-8&#39;).encode()
msg[&#39;From&#39;] = myemail
msg[&#39;To&#39;] = recvmail
try:
  smtp = SMTP_SSL(smtpaddr) #使用465端口发送加密邮件
  smtp.login(myemail,password)
  smtp.sendmail(myemail,recvmail.split(&amp;quot;,&amp;quot;),msg.as_string())
  smtp.quit()
  print(&amp;quot;success&amp;quot;)
except Exception as e:
  print(&amp;quot;fail:&amp;quot;+str(e))
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;测试脚本：&lt;code&gt;/usr/local/zabbix/alertscripts/zabbix_sendmail.py 773033929@qq.com &#39;zabbix disk&#39; &#39;disk &amp;gt; 90%&#39;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;zabbix邮件告警配置&#34;&gt;zabbix邮件告警配置&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;写一个邮件告警脚本&lt;/li&gt;
&lt;li&gt;报警媒介添加邮件告警&lt;/li&gt;
&lt;li&gt;用户设置报警媒介&lt;/li&gt;
&lt;li&gt;创建触发器动作&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;报警媒介添加邮件告警&#34;&gt;报警媒介添加邮件告警&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;自定义脚本&lt;/li&gt;
&lt;li&gt;脚本名称： zabbix_sendmail.py&lt;/li&gt;
&lt;li&gt;脚本需要三个参数:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{ALERT.SENDTO} #收件邮箱
{ALERT.SUBJECT} #主题
{ALERT.MESSAGE} # 内容
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;用户添加报警媒介&#34;&gt;用户添加报警媒介&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;类型选择邮件告警&lt;/li&gt;
&lt;li&gt;触发器有多种触发，从信息到灾难，可定义接收哪种类型的告警&lt;/li&gt;
&lt;li&gt;用户需要对服务器可读&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;创建触发器动作&#34;&gt;创建触发器动作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;动作有多种事件源，告警的选择触发器&lt;/li&gt;
&lt;li&gt;邮件主题定义：{ALERT.SUBJECT}&lt;/li&gt;
&lt;li&gt;邮件内容定义：{ALERT.MESSAGE}&lt;/li&gt;
&lt;li&gt;操作添加发送邮件告警&lt;/li&gt;
&lt;li&gt;恢复添加发送邮件告警&lt;/li&gt;
&lt;/ol&gt;
">13_zabbix邮件告警</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/12_zabbix-yong-hu-guan-li/"" data-c="
          &lt;h3 id=&#34;zabbix用户注意&#34;&gt;zabbix用户注意&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;默认的guest一定要禁用&lt;/li&gt;
&lt;li&gt;Admin的默认密码一定要修改&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix创建用户的流程&#34;&gt;zabbix创建用户的流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建用户组&lt;/li&gt;
&lt;li&gt;设置用户组权限，权限必须在用户组设置&lt;/li&gt;
&lt;li&gt;创建用户，属于某一个用户组&lt;/li&gt;
&lt;li&gt;使用新建的用户登录zabbix&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;新建用户权限注意&#34;&gt;新建用户权限注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;如果要让某个用户收到某台服务器的告警，则这个用户对这台服务器要有可读权限&lt;/li&gt;
&lt;/ul&gt;
">12_zabbix用户管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/11_zabbix-mo-ban-shi-yong/"" data-c="
          &lt;h3 id=&#34;模板的重要&#34;&gt;模板的重要&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;手动添加监控比较麻烦，需要监控项--图形--触发器，例如有100台服务器需要检查81端口&lt;/li&gt;
&lt;li&gt;修改监控比较麻烦，例如100台服务器81改成82&lt;/li&gt;
&lt;li&gt;使用模板可以解决以上两个问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;两种模板&#34;&gt;两种模板&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;系统自带模板。&lt;/li&gt;
&lt;li&gt;自定义模板&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;自定义模板的使用&#34;&gt;自定义模板的使用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建模板，模板属于某一个主机组&lt;/li&gt;
&lt;li&gt;在模板中创建监控项目&lt;/li&gt;
&lt;li&gt;在模板中创建图形、触发器&lt;/li&gt;
&lt;li&gt;创建监控主机时指定模板&lt;/li&gt;
&lt;li&gt;更新模板的监控项目，所有使用模板的都会自动更改&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;建议&#34;&gt;建议&lt;/h3&gt;
&lt;p&gt;监控的时候都使用模板，修改比较方便&lt;/p&gt;
">11_zabbix模板使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/10_zabbix-tian-jia-jian-kong-tu-xing-he-hong-fa-qi/"" data-c="
          &lt;p&gt;无需建立图形，在最新数据里面也是可以查看图形&lt;/p&gt;
&lt;h3 id=&#34;图形建立&#34;&gt;图形建立&lt;/h3&gt;
&lt;p&gt;可以自己创建图形&lt;/p&gt;
&lt;h3 id=&#34;图形的查看&#34;&gt;图形的查看&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;搜索查看的图形&lt;/li&gt;
&lt;li&gt;监控--图形   中可以看到图形&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;触发器添加&#34;&gt;触发器添加&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;未分类&lt;/li&gt;
&lt;li&gt;信息&lt;/li&gt;
&lt;li&gt;警告&lt;/li&gt;
&lt;li&gt;一般严重&lt;/li&gt;
&lt;li&gt;严重&lt;/li&gt;
&lt;li&gt;灾难&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;触发器的常用条件&#34;&gt;触发器的常用条件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数值条件。可定义大于、小于、等于、不等于等等&lt;/li&gt;
&lt;li&gt;有无数据条件&lt;/li&gt;
&lt;li&gt;最新获取的值和之前的值进行比较&lt;/li&gt;
&lt;/ol&gt;
">10_zabbix添加监控图形和触发器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/09_zabbix-tian-jia-jian-dan-jian-kong-xiang-mu/"" data-c="
          &lt;h3 id=&#34;zabbix监控的添加顺序&#34;&gt;zabbix监控的添加顺序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;添加主机组&lt;/li&gt;
&lt;li&gt;添加主机&lt;/li&gt;
&lt;li&gt;添加监控项目&lt;/li&gt;
&lt;li&gt;根据监控项目可添加图形或者触发器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;监控的key和值&#34;&gt;监控的key和值&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix添加监控需要定义key&lt;/li&gt;
&lt;li&gt;通过key去获取监控的值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;简单监控项目添加实战&#34;&gt;简单监控项目添加实战&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ping检测，存活和丢包检测 yum install fping -y&lt;/li&gt;
&lt;li&gt;检查tcp端口22&lt;/li&gt;
&lt;li&gt;查看监控值&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;理论内容&#34;&gt;理论内容&lt;/h3&gt;
&lt;h4 id=&#34;多种监控方式添加&#34;&gt;多种监控方式添加&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;simple check：被监控的服务器无需安装客户端，如ping、端口检测之类&lt;/li&gt;
&lt;li&gt;zabbix agent：被动式监控服务器&lt;/li&gt;
&lt;li&gt;zabbix agent（active）：主动式监控服务器&lt;/li&gt;
&lt;li&gt;snmp check：使用snmp协议去获取监控信息&lt;/li&gt;
&lt;li&gt;zabbix trapper：主动式监控&lt;/li&gt;
&lt;li&gt;External check：zabbix server上可编写监控脚本&lt;/li&gt;
&lt;li&gt;Jmx agent：监控java进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;值的类型&#34;&gt;值的类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;无符号整型，自然数。例如监控端口是否存活，存活返回1，不存活返货0&lt;/li&gt;
&lt;li&gt;浮点型，值可以为负数、小数。例如监控cpu的idle值&lt;/li&gt;
&lt;li&gt;character，字符串，最大255个字节&lt;/li&gt;
&lt;li&gt;Text，字符串，无限制&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;application应用集&#34;&gt;application应用集&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;多个类型相同的监控项目可以定义一个应用集&lt;/li&gt;
&lt;li&gt;icmp存活、icmp丢包我们都可以把它归为icmp应用集&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;监控项目不支持说明&#34;&gt;监控项目不支持说明&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;遇到不支持情况，例如填写的不存在的key&lt;/li&gt;
&lt;li&gt;上面所说的不支持的请情况，默认需要等待10分钟才回再去检测（更改默认等待时间：管理--一般--选择“其他”--刷新不支持的项目）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;添加监控&#34;&gt;添加监控&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;可以使用变量的方式&lt;/li&gt;
&lt;li&gt;可以使用克隆快速添加监控项目&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;注意&#34;&gt;注意&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;变量方式&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;名称：check port $1 $3&lt;br&gt;
键值：net.tcp.service[tcp,192.168.3.199,80]&lt;br&gt;
最后显示为“check port tcp 80”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;键值如果使用默认值，则需要将该值的位置留空&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;默认监控192.168.3.199，则键值：net.tcp.service[tcp,,80]&lt;/p&gt;
&lt;/blockquote&gt;
">09_zabbix添加简单监控项目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/08_zabbix-tian-jia-zhu-ji-jian-kong/"" data-c="
          &lt;h3 id=&#34;实战环境&#34;&gt;实战环境&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;zabbix server：192.168.3.111&lt;/li&gt;
&lt;li&gt;被监控服务器：192.168.3.199（www001）,192.168.3.198（www002）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;zabbix监控的添加顺序&#34;&gt;zabbix监控的添加顺序&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;添加主机组&lt;/li&gt;
&lt;li&gt;添加主机&lt;/li&gt;
&lt;li&gt;添加监控项目&lt;/li&gt;
&lt;li&gt;根据监控项目可添加图形或者触发器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;监控需求&#34;&gt;监控需求&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;监控主机是否存活&lt;/li&gt;
&lt;li&gt;监控主机的端口是否能通&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;添加主机实战&#34;&gt;添加主机实战&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建主机组&lt;/li&gt;
&lt;li&gt;主机名&lt;/li&gt;
&lt;li&gt;主机所属主机组&lt;/li&gt;
&lt;li&gt;主机ip--&amp;gt;最重要的是IP，可以是网络设备ip，windows的ip或linux的ip&lt;br&gt;
克隆添加主机、自动注册添加主机等&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;主机添加多种接口&#34;&gt;主机添加多种接口&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;agent：zabbix提供一个agent客户端，可装在linux、windows等&lt;/li&gt;
&lt;li&gt;snmp：使用snmp协议去监控服务器、交换机、路由器&lt;/li&gt;
&lt;li&gt;jmx：方便监控Java进程&lt;/li&gt;
&lt;li&gt;ipmi：监控硬件信息&lt;/li&gt;
&lt;/ol&gt;
">08_zabbix添加主机监控</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/07_zabbix4-4-wang-ye-han-hua-he-luan-ma-chu-li/"" data-c="
          &lt;h3 id=&#34;zabbix网页默认使用中文&#34;&gt;zabbix网页默认使用中文&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;建议直接使用中文&lt;/li&gt;
&lt;li&gt;把Admin用户改成中文的&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix默认的字段问题&#34;&gt;zabbix默认的字段问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;中文会有部分乱码的情况&lt;/li&gt;
&lt;li&gt;监测-&amp;gt;图形里的监控图形会有乱码的产生&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;解决zabbix部分乱码&#34;&gt;解决zabbix部分乱码&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;windows系统中c:\Windows\Fonts\msyh.ttc的微软雅黑字体&lt;/li&gt;
&lt;li&gt;将后缀ttc改为ttf之后上传字体到目录/usr/local/nginx/html/zabbix/assets/fonts/&lt;/li&gt;
&lt;li&gt;zabbix网页的字体配置修改/usr/local/nginx/html/zabbix/include/defines.inc.php中的&#39;ZBX_GRAPH_FONT_NAME&#39;，默认是DejaVuSans字体，改成msyh微软雅黑&lt;/li&gt;
&lt;li&gt;验证中文是否正常&lt;/li&gt;
&lt;/ol&gt;
">07_zabbix4-4网页汉化和乱码处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/06_zabbix4-4-ban-ben-bian-yi-an-zhuang/"" data-c="
          &lt;h3 id=&#34;zabbix的部署原理&#34;&gt;zabbix的部署原理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix server需要把监控数据入sql数据库，所以需要mysql环境&lt;/li&gt;
&lt;li&gt;zabbix的web是基于php开发的，所以需要lnmp环境&lt;/li&gt;
&lt;li&gt;部署zabbix server和zabbix web&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix-server编译安装&#34;&gt;zabbix server编译安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;server端加参数--enable-agent主要是为了使用工具zabbix_get&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y libevent-devel wget tar gcc gcc-c++ make net-snmp-devel libxml2-devel libcurl-devel 
useradd -s /sbin/nologin zabbix
cd /usr/local/src/
wget &amp;quot;https://nchc.dl.sourceforge.net/project/zabbix/ZABBIX%20Latest%20Stable/4.4.4/zabbix-4.4.4.tar.gz&amp;quot;
tar -zxvf zabbix-4.4.4.tar.gz
cd zabbix-4.4.4
./configure --prefix=/usr/local/zabbix --enable-server --enable-agent --with-mysql=/usr/local/mysql/bin/mysql_config --with-net-snmp --with-libcurl --with-libxml2
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编译说明&#34;&gt;编译说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;--prefix 指定安装目录&lt;/li&gt;
&lt;li&gt;--enable-server 安装zabbix server&lt;/li&gt;
&lt;li&gt;--enable-agent 安装zabbix agent&lt;/li&gt;
&lt;li&gt;--with-mysql 用mysql来存储（如果使用yum安装，则不需要后面的mysql的路径）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix-server的安装验证&#34;&gt;zabbix server的安装验证&lt;/h3&gt;
&lt;h4 id=&#34;环境变量设置&#34;&gt;环境变量设置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/zabbix/sbin:/usr/local/zabbix/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;查看版本&#34;&gt;查看版本&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;zabbix_server --version
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix-server的启动&#34;&gt;zabbix server的启动&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需要到mysql里做数据库的初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#mysql数据库初始化
mysql -h 127.0.0.1 -uroot -pzabbixpwd -A
  create database zabbix character set utf8 collate utf8_bin;
  grant all privileges on zabbix.* to zabbix@&#39;127.0.0.1&#39; identified by &#39;zabbixpwd&#39;;
  flush privileges;
  set names utf8;
  use zabbix;
  source /usr/local/src/zabbix-4.4.4/database/mysql/schema.sql;
  source /usr/local/src/zabbix-4.4.4/database/mysql/data.sql;
  source /usr/local/src/zabbix-4.4.4/database/mysql/images.sql;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;配置zabbix server&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置文件/usr/local/zabbix/etc/zabbix_server.conf
cat &amp;gt;/usr/local/zabbix/etc/zabbix_server.conf &amp;lt;&amp;lt;EOF
LogFile=/usr/local/zabbix/zabbix_server.log
DBHost=127.0.0.1
DBName=zabbix
DBUser=zabbix
DBPassword=zabbixpwd
DBPort=3306
Timeout=30
AlertScriptsPath=/usr/local/zabbix/alertscripts #配置告警脚本
ExternalScripts=/usr/local/zabbix/externalscripts
LogSlowQueries=3000 #慢查询
# SourceIP= 192.168.x.x     #监听地址
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;启动zabbix server&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;chown zabbix:zabbix -R /usr/local/zabbix/
zabbix_server
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;验证&#34;&gt;验证&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程 ps auxf | grep zabbix_server&lt;/li&gt;
&lt;li&gt;端口 netstat -tulnp|grep zabbix&lt;/li&gt;
&lt;li&gt;日志 tail -f /usr/local/zabbix/zabbix_server.log&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix-web安装&#34;&gt;zabbix web安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir /usr/local/nginx/html/zabbix
cp -a /usr/local/src/zabbix-4.4.4/frontends/php/* /usr/local/nginx/html/zabbix
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;zabbix-web的配置&#34;&gt;zabbix web的配置&lt;/h3&gt;
&lt;h4 id=&#34;php配置&#34;&gt;php配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置文件/usr/local/php/etc/php.ini
post_max_size = 32M
max_execution_time = 360
max_input_time = 360
date.timezone = Asia/Shanghai
always_populate_raw_post_data = -1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#重启php-fpm：
systemctl restart php-fpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;登录&#34;&gt;登录&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;初始化配置：http://zabbix服务器IP/zabbix&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Database type:MySQL
Database host:127.0.0.1
Database port:3306
Database name:zabbix
User:zabbix
Password:zabbixpwd
下载配置文件，保存在/usr/local/nginx/html/zabbix/conf/zabbix.conf.php
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;默认用户名密码：Admin zabbix&lt;/li&gt;
&lt;li&gt;禁用Zabbix server主机的监控&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Hosts--&amp;gt;选中zabbix server --&amp;gt;点击disable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;禁用guest用户（只能设置用户组权限）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Administration--&amp;gt;Users groups--&amp;gt;选中Guests--&amp;gt;disable&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;更改Admin的密码&lt;/li&gt;
&lt;/ol&gt;
">06_zabbix4-4版本编译安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/05_lnmp-huan-jing-de-yan-zheng/"" data-c="
          &lt;h3 id=&#34;lnmp架构&#34;&gt;LNMP架构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;用户 --&amp;gt; php文件&lt;/li&gt;
&lt;li&gt;请求到达nginx，nginx通过127.0.0.1:9000去调用php-fpm&lt;/li&gt;
&lt;li&gt;php-fpm --&amp;gt; 运行php程序&lt;/li&gt;
&lt;li&gt;php --&amp;gt; 操作mysql&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lnmp的环境验收&#34;&gt;LNMP的环境验收&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;cat &amp;gt;/usr/local/nginx/html/test_mysql.php &amp;lt;&amp;lt;EOF
&amp;lt;?php
  \$link=mysql_connect(&amp;quot;127.0.0.1&amp;quot;,&amp;quot;root&amp;quot;,&amp;quot;zabbixpwd&amp;quot;);
  if(!\$link){
    echo  &amp;quot;mysql_connect fail&amp;quot;;
  }else{
    echo &amp;quot;mysql_connect success&amp;quot;;
  }
?&amp;gt;
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;验证lnmp环境&#34;&gt;验证LNMP环境&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;http://192.168.3.111/test_mysql.php&#34;&gt;http://192.168.3.111/test_mysql.php&lt;/a&gt;&lt;/p&gt;
">05_LNMP环境的验证</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/04_lnmp-zhi-mysql-yuan-ma-bian-yi-an-zhuang/"" data-c="
          &lt;h3 id=&#34;mysql编译安装脚本&#34;&gt;mysql编译安装脚本&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y gcc gcc-c++ make tar openssl openssl-devel cmake ncurses ncurses-devel
useradd -s /sbin/nologin mysql
cd /usr/local/src
wget &amp;quot;https://cdn.mysql.com//Downloads/MySQL-5.6/mysql-5.6.47.tar.gz&amp;quot;
tar -zxvf mysql-5.6.47.tar.gz
cd mysql-5.6.47
cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_EXTRA_CHARSETS:STRING=all -DWITH_DEBUG=0 -DWITH_SSL=yes -DWITH_READLINE=1 -DENABLED_LOACL_INFILE=1
make &amp;amp;&amp;amp; make install
cp support-files/mysql.server /etc/init.d/mysqld  #用来启动mysql的脚本
chmod a+x /etc/init.d/mysqld
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;编译选项说明&#34;&gt;编译选项说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CMACK_INSTALL_PREFIX 指定安装的目录&lt;/li&gt;
&lt;li&gt;MYSQL_DATADIR 指定mysql的数据目录&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mysql环境变量配置&#34;&gt;mysql环境变量配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/mysql/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mysql的启动步骤&#34;&gt;mysql的启动步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;更新配置&lt;br&gt;
更新mysql配置/etc/my.cnf&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/etc/my.cnf &amp;lt;&amp;lt;EOF
[mysqld]
bind-address=0.0.0.0  #监听地址
port=3306  #监听端口
datadir=/data/mysql  #数据存放目录
user=mysql  #启动用户
skip-name-resolve
long_query_time=2  #和下一句配置结合：查询超过2秒，则记录到日志
slow_query_log_file=/data/mysql/mysql-slow.log
expire_logs_days=2
innodb-file-per-table=1
innodb_flush_log_at_trx_commit=2
log_warnings=1
max_allowed_packet=512M
connect_timeout=60
net_read_timeout=120

[mysqld_safe]
log-error=/data/mysql/mysqld.log
pid-file=/data/mysql/mysqld.pid
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;数据库初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -pv /data/mysql
chown -R mysql:mysql /usr/local/mysql /data/mysql
yum install -y perl-Module-Install
/usr/local/mysql/scripts/mysql_install_db --basedir=/usr/local/mysql --user=mysql --datadir=/data/mysql/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;启动数据库&lt;br&gt;
3.1 使用systemctl管理mysql，/usr/lib/systemd/system/mysqld.service&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/mysqld.service &amp;lt;&amp;lt;EOF
[Unit]
Description=MySQL Community Server
After=network.target
After=syslog.target
[Install]
WantedBy=multi-user.target
Alias=mysql.service
[Service]
User=mysql
Group=mysql
PermissionsStartOnly=true
ExecStart=/usr/local/mysql/bin/mysqld_safe --basedir=/usr/local/mysql
TimeoutSec=600
Restart=always
PrivateTmp=false
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3.2 启动 systemctl start mysqld&lt;br&gt;
3.3 验证mysql是否启动&lt;br&gt;
3.3.1 查看进程 ps auxf | grep mysql&lt;br&gt;
3.3.2 查看监听端口 netstat -tulnp | grep mysql&lt;br&gt;
3.3.3 查看日志  cat /data/mysql/mysqld.log&lt;/p&gt;
&lt;h3 id=&#34;mysql的安全方式&#34;&gt;mysql的安全方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;mysql能限制ip访问、访问需要用户名密码、mysql权限细分&lt;/li&gt;
&lt;li&gt;默认让127.0.0.1访问，用户名root，不需要密码&lt;/li&gt;
&lt;li&gt;mysql -u root -h 127.0.0.1 -A&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;mysql加密码&#34;&gt;mysql加密码&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysqladmin -h 127.0.0.1 -uroot password &amp;quot;zabbixpwd&amp;quot;
mysql -h 127.0.0.1 -uroot -pzabbixpwd 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;mysql授权某ip登录指定用户名&#34;&gt;mysql授权某IP登录，指定用户名&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;grant all privileges on *.* to &#39;root&#39;@&#39;192.168.3.%&#39; identified by &#39;zabbixpwd&#39; with grant option;
flush privileges; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;网络登录mysql&#34;&gt;网络登录mysql&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -h 192.168.3.108 -uroot -pzabbixpwd -A  # -A:不预读数据库
&lt;/code&gt;&lt;/pre&gt;
">04_LNMP之mysql源码编译安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/03_lnmp-zhi-php-yuan-ma-bian-yi-an-zhuang/"" data-c="
          &lt;h3 id=&#34;为什么需要安装php&#34;&gt;为什么需要安装php&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;zabbix的网页后端语言使用php&lt;br&gt;
php的安装相对复杂，需要解决很多依赖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;php编译安装&#34;&gt;php编译安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install epel-release
yum -y install gcc gcc-c++ make pcre pcre-devel zlib zlib-devel openssl openssl-devel libxml2 libxml2-devel libcurl libcurl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel openldap openldap-devel libmcrypt libmcrypt-devel
cd /usr/local/src
wget &amp;quot;https://www.php.net/distributions/php-5.6.40.tar.gz&amp;quot;
tar -zxvf php-5.6.40.tar.gz
cd php-5.6.40
./configure \
--prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc \
--with-mysql=mysqlnd --with-mysqli=mysqlnd \
--enable-ctype --with-freetype-dir \
--with-jpeg-dir --with-png-dir \
--with-zlib --with-libxml-dir=/usr --enable-xml \
--disable-rpath --enable-bcmath --enable-shmop \
--enable-sysvsem --enable-inline-optimization \
--with-curl  --with-iconv \
--enable-mbregex --enable-mbstring \
--with-mcrypt --with-gd --enable-gd-native-ttf \
--with-openssl --with-mhash --enable-pcntl \
--enable-sockets --with-ldap-sasl --with-xmlrpc \
--enable-zip --enable-soap \
--with-gettext --enable-fpm
make &amp;amp;&amp;amp; make install
cp php.ini-production /usr/local/php/etc/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;php编译安装说明&#34;&gt;php编译安装说明&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;--prefix 指定php的安装目录&lt;br&gt;
--with-config-file-path 指定php的配置文件的位置&lt;br&gt;
--with-mysql、--with-mysqli 让php可以操作mysql&lt;br&gt;
--enable-fpm 主要是nginx要来调用php语言使用php-fpm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;启动php-fpm&#34;&gt;启动php-fpm&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;环境变量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/php/sbin:/usr/local/php/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用默认配置文件：mv /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意将&amp;quot;user&amp;quot;和&amp;quot;group&amp;quot;这两个变量的值都改为root&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;检查配置文件：php-fpm -t&lt;/li&gt;
&lt;li&gt;查看php-fpm的listen配置&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;验证php-fpm的启动&#34;&gt;验证php-fpm的启动&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程 ps auxf | grep php-fpm&lt;/li&gt;
&lt;li&gt;端口 netstat -tulnp | grep php-fpm&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;使用systemctl管理php-fpm&#34;&gt;使用systemctl管理php-fpm&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/php-fpm.service &amp;lt;&amp;lt;EOF
[Unit]
Description=php-fpm
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/php/sbin/php-fpm -R
[Install]
WantedBy=multi-user.target
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;-R&amp;quot; 代表root用户启动&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;nginx默认配置无法处理php程序&#34;&gt;nginx默认配置无法处理php程序&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/local/nginx/html/test.php &amp;lt;&amp;lt;EOF
&amp;lt;?php
echo &amp;quot;hello moto zabbix!!!!!!!&amp;quot;;
?&amp;gt;
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;nginxphp-fpm结合的配置&#34;&gt;nginx+php-fpm结合的配置&lt;/h3&gt;
&lt;p&gt;配置文件：/usr/local/nginx/conf/nginx.conf&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;# 将第二个配置在配置文件中存在，需要去掉前面的注释，其次要修改fastcgi_param这一行
location / {
  root html;
  index index.html index.htm index.php;
}
location ~\.php${
  root html;
  fastcgi_pass 127.0.0.1:9000;
  fastcgi_index index.php;
  fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
  include fastcgi_params;
}
&lt;/code&gt;&lt;/pre&gt;
">03_LNMP之PHP源码编译安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/02_lnmp-zhi-nginx-fu-wu-qi-bian-yi-an-zhuang/"" data-c="
          &lt;h3 id=&#34;web服务器&#34;&gt;web服务器&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Apache&lt;/li&gt;
&lt;li&gt;Nginx：安装配置简洁（官网：http://nginx.org）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lnmp之nginx服务器编译安装&#34;&gt;LNMP之nginx服务器编译安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y wget gcc gcc-c++ make pcre pcre-devel zlib zlib-devel openssl openssl-devel
cd /usr/local/src
wget &amp;quot;http://nginx.org/download/nginx-1.9.9.tar.gz&amp;quot;
tar -zxvf nginx-1.9.9.tar.gz
cd nginx-1.9.9
./configure --prefix=/usr/local/nginx
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;手动启动和关闭nginx&#34;&gt;手动启动和关闭nginx&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;环境变量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/nginx/sbin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;检查nginx配置：nginx -t&lt;/li&gt;
&lt;li&gt;启动nginx：nginx&lt;/li&gt;
&lt;li&gt;关闭nginx：nginx -s stop&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;验证nginx安装是否成功&#34;&gt;验证nginx安装是否成功&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;查看进程&lt;/li&gt;
&lt;li&gt;查看监控端口&lt;/li&gt;
&lt;li&gt;浏览器访问&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;使用systemctl管理nginx&#34;&gt;使用systemctl管理nginx&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/nginx.service &amp;lt;&amp;lt;EOF
[Unit]
Description=nginx
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/nginx/sbin/nginx
[Install]
WantedBy=multi-user.target
EOF
&lt;/code&gt;&lt;/pre&gt;
">02_LNMP之Nginx服务器编译安装</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/01_zabbix4-4-jian-kong-xi-tong-da-jian-li-lun/"" data-c="
          &lt;h3 id=&#34;开源监控系统&#34;&gt;开源监控系统&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Naglos&lt;br&gt;
1.1  重在监管告警，但zabbix更出色，告警配置web化&lt;br&gt;
1.2 Nagios添加监控需要更改配置文件&lt;br&gt;
1.3 无监控历史数据，图形支持差&lt;br&gt;
1.4 不支持分布式监控&lt;/li&gt;
&lt;li&gt;Cacti&lt;br&gt;
2.1 重在采集服务器、网络设备的监控数据并绘图&lt;br&gt;
2.2 依赖于snmp协议&lt;br&gt;
2.3 不好自定义监控&lt;br&gt;
2.4 告警支持不友好&lt;/li&gt;
&lt;li&gt;Zabbix&lt;br&gt;
3.1 所有监控配置都web化，web采用php开发&lt;br&gt;
3.2 支持分布式监控&lt;br&gt;
3.3 支持多种数据采集：简单监控、agent监控、snmp监控、jmx监控&lt;br&gt;
3.4 告警配置web化：邮件、微信、钉钉、短信&lt;br&gt;
3.5 zabbix和grafana的结合方便监控数据的可视化&lt;br&gt;
3.6 先搭建zabbix，在实战中zabbix&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;zabbix监控的搭建&#34;&gt;Zabbix监控的搭建&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;zabbix server会去采集监控数据，采集的监控数据会写入到sql数据库&lt;/li&gt;
&lt;li&gt;zabbix的web后端采用php语言开发，所有配置信息、用户认证信息等都会写入sql数据库&lt;/li&gt;
&lt;li&gt;企业级zabbix的搭建依赖环境：主流采用LNMP环境（centos7+nginx+mysql+php）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;lnmp-web环境下用户的请求流程&#34;&gt;LNMP web环境下用户的请求流程&lt;/h3&gt;
&lt;p&gt;用户---&amp;gt;nginx---&amp;gt;php-fpm---&amp;gt;运行php程序---&amp;gt;操作mysql&lt;/p&gt;
&lt;h3 id=&#34;zabbix实战环境介绍&#34;&gt;zabbix实战环境介绍&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;IP地址：xx.xx.xx.xx(课堂上为192.168.237.49)&lt;/li&gt;
&lt;li&gt;vmware虚拟的centos7系统&lt;/li&gt;
&lt;li&gt;防火墙和selinux关闭&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;部署顺序说明&#34;&gt;部署顺序说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;nginx+php-fpm&lt;/li&gt;
&lt;li&gt;mysql服务器搭建&lt;/li&gt;
&lt;li&gt;zabbix server搭建&lt;/li&gt;
&lt;li&gt;zabbix网页展示&lt;/li&gt;
&lt;/ol&gt;
">01_Zabbix4-4监控系统搭建理论</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/00-zabbix-xue-xi-mu-lu/"" data-c="
          &lt;p&gt;zabbix课程大纲（索引）&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h5 id=&#34;第1章-lnmp环境搭建和zabbix40源码编译安装以及中文乱码解决&#34;&gt;第1章 LNMP环境搭建和Zabbix4.0源码编译安装以及中文乱码解决&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;01_Zabbix4.4监控系统搭建理论&lt;/li&gt;
&lt;li&gt;02_LNMP之Nginx服务器编译安装&lt;/li&gt;
&lt;li&gt;03_LNMP之PHP源码编译安装&lt;/li&gt;
&lt;li&gt;04_LNMP之mysql源码编译安装&lt;/li&gt;
&lt;li&gt;05_LNMP环境的验证&lt;/li&gt;
&lt;li&gt;06_zabbix4.4版本编译安装&lt;/li&gt;
&lt;li&gt;07_zabbix4.4网页汉化和乱码处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第2章-zabbix44入门使用&#34;&gt;第2章 Zabbix4.4入门使用&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;08_zabbix添加主机监控&lt;/li&gt;
&lt;li&gt;09_zabbix添加简单监控项目&lt;/li&gt;
&lt;li&gt;10_zabbix添加监控图形和触发器&lt;/li&gt;
&lt;li&gt;11_zabbix模板使用&lt;/li&gt;
&lt;li&gt;12_zabbix用户管理&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第3章-zabbix44邮件-微信-钉钉报警&#34;&gt;第3章 Zabbix4.4邮件、微信、钉钉报警&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;13_zabbix邮件告警&lt;/li&gt;
&lt;li&gt;14_告警内容自定义和告警抑制&lt;/li&gt;
&lt;li&gt;15_微信告警实战&lt;/li&gt;
&lt;li&gt;16_钉钉告警实战&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第4章-zabbix监控linux服务器&#34;&gt;第4章 Zabbix监控Linux服务器&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;17_Linux下zabbix客户端编译安装&lt;/li&gt;
&lt;li&gt;18_zabbix监控cpu、内存、磁盘、流量&lt;/li&gt;
&lt;li&gt;19_zabbix客户端的主动式和被动式&lt;/li&gt;
&lt;li&gt;20_zabbix使用模板监控Linux&lt;/li&gt;
&lt;li&gt;21_zabbix自定义key监控Linux&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第5章-zabbix监控windows7&#34;&gt;第5章 Zabbix监控Windows7&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;22_windows7安装zabbix客户端&lt;/li&gt;
&lt;li&gt;23_zabbix监控windows实战&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第6章-zabbix分布式-自动发现-自动注册&#34;&gt;第6章 Zabbix分布式、自动发现、自动注册&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;24_zabbix分布式proxy编译安装&lt;/li&gt;
&lt;li&gt;25_zabbix分布式监控Linux&lt;/li&gt;
&lt;li&gt;26_zabbix主机自动发现&lt;/li&gt;
&lt;li&gt;27_zabbix主机自动注册&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第7章-zabbix40的snmp使用实战&#34;&gt;第7章 Zabbix4.0的SNMP使用实战&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;28_snmp服务器的安装&lt;/li&gt;
&lt;li&gt;29_snmp的OID和MIB&lt;/li&gt;
&lt;li&gt;30_zabbix使用SNMP监控实战&lt;/li&gt;
&lt;li&gt;31_zabbix的snmp自动发现实战&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第8章-grafana60酷炫图大屏监控&#34;&gt;第8章 Grafana6.0酷炫图大屏监控&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;32_grafana简介与安装&lt;/li&gt;
&lt;li&gt;33_grafana简单使用和插件安装&lt;/li&gt;
&lt;li&gt;34_grafana读取zabbix数据展现&lt;/li&gt;
&lt;li&gt;35_grafana变量高级功能&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第9章-zabbix监控mysql数据库&#34;&gt;第9章 Zabbix监控Mysql数据库&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;36_zabbix自定义key监控mysql&lt;/li&gt;
&lt;li&gt;37_zabbix自动发现监控mysql&lt;/li&gt;
&lt;li&gt;38_zabbix监控mysql主从同步&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;第10章-python调用zabbix-api实战入门&#34;&gt;第10章 Python调用Zabbix Api实战入门&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;39_zabbix的api认证实战&lt;/li&gt;
&lt;li&gt;40_zabbix的api获取主机信息&lt;/li&gt;
&lt;li&gt;41_zabbix的api获取模板信息&lt;/li&gt;
&lt;li&gt;42_zabbix的api创建监控主机&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;faq&#34;&gt;[FAQ]&lt;/h5&gt;
">00 zabbix学习目录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/wireshark-de-lua-cha-jian-kai-fa/"" data-c="
          &lt;p&gt;wireshark解析自定义协议&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;加载配置&#34;&gt;加载配置&lt;/h3&gt;
&lt;p&gt;安装根目录下&lt;code&gt;init.lua&lt;/code&gt;文件为wireshark打开之后、读取或者抓取数据之前加载的配置文件，这里面包含wireshark对数据的解析配置，如果想要加载自己编写的lua插件，可在此文件末尾追加&lt;code&gt;dofile(DATA_DIR..&amp;quot;dtd_gen.lua&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;解析原理&#34;&gt;解析原理&lt;/h3&gt;
&lt;p&gt;协议使用端口查看：视图--内部--支持协议列表（Dissector Tables）--Integer Tables--TCP port&lt;/p&gt;
&lt;h3 id=&#34;新协议注册&#34;&gt;新协议注册&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;添加新协议：&lt;br&gt;
&lt;code&gt;local test=Proto(name,desc)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;添加解析器：&lt;br&gt;
&lt;code&gt;function test.dissector(tvb.pinfo,tree) end&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注册新协议到wireshark中：&lt;br&gt;
&lt;code&gt;DissectorTable.get(&#39;表名&#39;):add(端口,test)&lt;/code&gt;&lt;br&gt;
保存lua文件到&lt;code&gt;全局配置&lt;/code&gt;中&lt;br&gt;
(全局配置位置：帮助--关于wireshark--文件夹--全局Lua插件)&lt;/li&gt;
&lt;li&gt;Lua插件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local learn = Proto(&#39;learn&#39;,&#39;Learn Protocol&#39;)
function learn.dissector(tvb,pinfo,tree)
end
DissectorTable.get(&#39;tcp.port&#39;):add(10002,learn)
# (tvb,pinfo,tree)
# tvb 缓冲数据包
# pinfo 协议信息
# tree 展示的树状结构
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解释器编写&#34;&gt;解释器编写&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;dissector函数，具体数据包解析在wireshark中的树状结构&lt;/li&gt;
&lt;li&gt;明确协议格式：Learn协议&lt;br&gt;
2.1 Trans_ID(16bit)&lt;br&gt;
2.2 Msg_Type(16bit)&lt;br&gt;
2.3 Msg_Data(32bit)&lt;br&gt;
2.4  Lua语言中的ProtoField表示协议字段&lt;br&gt;
&lt;code&gt;可使用uint8、uint16、uint32等类型&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ProtoField.uint16(&amp;quot;learn.ID&amp;quot;,&amp;quot;ID&amp;quot;)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ProtoField.uint16(&amp;quot;learn.Type&amp;quot;,&amp;quot;Type&amp;quot;)&lt;/code&gt;&lt;br&gt;
&lt;code&gt;ProtoField.uint32(&amp;quot;learn.Data&amp;quot;,&amp;quot;Data&amp;quot;)&lt;/code&gt;&lt;br&gt;
2.5 合并字段&lt;br&gt;
learn.fields={Trans_ID,Msg_Type,Msg_Data}&lt;/li&gt;
&lt;li&gt;解析函数&lt;br&gt;
3.1 设置wireshark报文列表上protocol列文本&lt;br&gt;
&lt;code&gt;pinfo.cols.protocol=learn.name&lt;/code&gt;&lt;br&gt;
或者直接指定协议名称&lt;br&gt;
&lt;code&gt;pinfo.cols.protocol = &amp;quot;learn&amp;quot;&lt;/code&gt;&lt;br&gt;
3.2 添加树状新节点&lt;br&gt;
&lt;code&gt;local subtree = tree:add(learn,tvb(0))&lt;/code&gt;&lt;br&gt;
3.3 添加协议解析树&lt;br&gt;
&lt;code&gt;subtree:add(Trans_ID,tvb(0,2))&lt;/code&gt;&lt;br&gt;
&lt;code&gt;subtree:add(Msg_Type,tvb(2,2))&lt;/code&gt;&lt;br&gt;
&lt;code&gt;subtree:add(Msg_Data,tvb(4,4)) # tvb(4,4) 起始位置为4，偏移4字节&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Lua插件(learn.lua)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-lua&#34;&gt;local learn = Proto(&#39;learn&#39;,&#39;Learn Protocol&#39;)
Trans_ID = ProtoField.uint16(&amp;quot;learn.ID&amp;quot;,&amp;quot;ID&amp;quot;)
Msg_Type = ProtoField.uint16(&amp;quot;learn.Type&amp;quot;,&amp;quot;Type&amp;quot;)
Msg_Data = ProtoField.uint32(&amp;quot;learn.Data&amp;quot;,&amp;quot;Data&amp;quot;)

learn.fields = {Trans_ID,Msg_Type,Msg_Data}
function learn.dissector(tvb,pinfo,tree)
	pinfo.cols.protocol = &amp;quot;learn&amp;quot;
	local subtree = tree:add(learn,tvb(0))
	subtree:add(Trans_ID,tvb(0,2))
	subtree:add(Msg_Type,tvb(2,2))
	subtree:add(Msg_Data,tvb(4,4)) 
end
DissectorTable.get(&#39;tcp.port&#39;):add(10002,learn) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新协议测试&#34;&gt;新协议测试&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;xcap介绍&lt;br&gt;
&lt;a href=&#34;https://xcap.weebly.com&#34;&gt;下载&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;新建数据包&lt;br&gt;
packergroup(报文组)--creat packet group(创建报文组)--名称“learn_packet”--报文界面左上角+号，添加报文--双击添加到报文进行编辑&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585756144770.png&#34; alt=&#34;1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585756165338.png&#34; alt=&#34;2.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585756176680.png&#34; alt=&#34;3.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585756190778.png&#34; alt=&#34;4.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;code&gt;注意：上图中Marker(Hex)的值全部设为0&lt;/code&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585756203151.png&#34; alt=&#34;5.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;wireshark抓包看新协议&lt;/li&gt;
&lt;/ol&gt;
">wireshark的Lua插件开发</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/pycharm-ji-huo/"" data-c="
          &lt;p&gt;pycharm2020激活&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://iamcracker.com/pycharm-crack-latest-2020/&#34;&gt;补丁长期链接&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://zhile.io/&#34;&gt;长期参考链接&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;201933版本&#34;&gt;2019.3.3版本&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.cnblogs.com/cruelty_angel/p/10100760.html&#34;&gt;参考&lt;/a&gt;&lt;/p&gt;
">pycharm激活</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/qun-hui-di-san-fang-cha-jian-yuan/"" data-c="
          &lt;p&gt;整理可用的群晖第三方套件源：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可用的地址&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://packages.jdel.org/
http://packages.pcloadletter.co.uk
http://packages.synocommunity.com
http://packages.synocommunity.com/?beta=1
http://spk.unzureichende.info/
http://syno.dierkse.nl/
http://synology.acmenet.ru
http://synology.sysco.ch
http://www.cphub.net
http://www.hildinger.us/sspks/
http://www.pulse-station.com/repo/
https://get.filebot.net/syno/
https://spk.netzbaer.de/
https://synology.cambier.org/
https://synology.emby.media/?package_repository=360efc6e-de72-4073-b603-2bfbd7001586
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;已经不可用地址&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;http://cytec.us/spk
http://e-remonty.info/spkrepo/packages
http://ggteknikus.tk/sspks/
http://jaspr.kastner.wtf/
http://packages.hoel.dk
http://packages.missilehugger.com
http://packages.page81.net/
http://packages.quadrat4.de
http://repo.synozwave.com/
http://spk.diablos-netzwerk.de/
http://spk.naefmarco.ch/spkrepo/packages/
http://spk.nas-mirror.de/spkrepo/packages
http://spk.q14six.de
http://subtitlessh.no-ip.biz/repo_spk/
http://synobox.fr.nf/synopackages/
http://synobox.fr.nf/synopackages/beta.php
http://synology.mdevries.org/spkrepo/packages
http://synology.nzbusenet.com/
http://synopkg.superzebulon.org/spkrepo/packages
http://synopkgs-garble.rhcloud.com/
http://update.10trum.de/packageupdate/getpackages.php
http://www.need-soft.com/packages/index.php/spkrepo/packages
https://www.christoph-papke.de/spkrepo/spkrepo/packages
&lt;/code&gt;&lt;/pre&gt;
">群晖第三方套件源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/win7-kai-qi-duo-yong-hu-yuan-cheng-he-ben-di-tong-shi-deng-lu/"" data-c="
          &lt;p&gt;多用户远程登录&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;win+R --&amp;gt; gpedit.msc --&amp;gt; 回车(进入本地组策略编辑器) --&amp;gt; 计算机配置 ---&amp;gt; 管理模板 ---&amp;gt; Windows组件 ---&amp;gt; 远程桌面服务 ---&amp;gt; 远程桌面会话主机 ---&amp;gt; 连接&lt;br&gt;
---&amp;gt; 限制连接的数量 --&amp;gt; 打开限制连接数，这里未配置时，默认的最大连接数是1 --&amp;gt; 点击已启用 ---&amp;gt; 允许的RD最大连接数为该为2 ---&amp;gt; 确定&lt;/p&gt;
&lt;p&gt;--&amp;gt; 将远程桌面服务用户限制到单独的远程桌面服务会话 --&amp;gt; 已禁用 --&amp;gt; 确定&lt;/p&gt;
&lt;p&gt;--&amp;gt;下载universal termsrv.dll patch第三方工具 --&amp;gt; 以管理员身份运行UniversalTermsrvPatch-x64.exe文件 --&amp;gt; 破解 --&amp;gt;重启计算机&lt;/p&gt;
">win7开启多用户远程和本地同时登录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/flash-chi-xian-an-zhuang-bao-xia-zai/"" data-c="
          &lt;p&gt;针对不同浏览器下载flash插件&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;Flash中国官网地址：&lt;a href=&#34;https://www.flash.cn&#34;&gt;https://www.flash.cn&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;适用于firefox&#34;&gt;适用于Firefox&lt;/h3&gt;
&lt;p&gt;下载离线版，需要添加：/flashplayer/3200330/install_flash_player_cn.exe&lt;br&gt;
即下载地址为：&lt;a href=&#34;https://www.flash.cn/flashplayer/3200330/install_flash_player_cn.exe&#34;&gt;https://www.flash.cn/flashplayer/3200330/install_flash_player_cn.exe&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;适用于chrome&#34;&gt;适用于Chrome&lt;/h3&gt;
&lt;p&gt;下载离线版，需要添加：/flashplayer/3200330/install_flash_player_ppapi_cn.exe&lt;br&gt;
即下载地址为：&lt;a href=&#34;https://www.flash.cn/flashplayer/3200330/install_flash_player_ppapi_cn.exe&#34;&gt;https://www.flash.cn/flashplayer/3200330/install_flash_player_ppapi_cn.exe&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;追加部分解释&#34;&gt;追加部分解释&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Firefox没有后缀，直接是_cn结尾，代表中国版；Chrome的flash插件是ppapi版；适用于IE的是activex版。&lt;/li&gt;
&lt;li&gt;&amp;quot;3200330&amp;quot;是版本号，需要从中国官网获取，如下图，版本号为“32.0.0.330”，去掉中间的点就得到url中的版本号&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1585754987519.png&#34; alt=&#34;Flash离线安装包下载&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
">Flash离线安装包下载</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/chrome-chi-xian-an-zhuang-bao-xia-zai/"" data-c="
          &lt;h2 id=&#34;谷歌浏览器&#34;&gt;谷歌浏览器&lt;/h2&gt;
&lt;h2 id=&#34;windows&#34;&gt;windows&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;打开&lt;a href=&#34;http://www.google.cn/chrome/browser/desktop/index.html&#34;&gt;http://www.google.cn/chrome/browser/desktop/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;在网址最后加上：&lt;strong&gt;?standalone=1&amp;amp;platform=win64&lt;/strong&gt;，回车键后打开的是 64位下载页面，点击“下载Chrome”按钮，得到的就是Google Chrome 64位离线安装包&lt;br&gt;
&lt;strong&gt;注释&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;其中 ?standalone=1 指离线安装包，platform=win64 指64位Windows 版本。&lt;br&gt;
如果加上的只是“?standalone=1”可以用来下载32位的Chrome离线包。用“mac”替换“win”，就可以下载 Mac 版本的了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;linuxcentos7&#34;&gt;linux(Centos7)&lt;/h2&gt;
&lt;p&gt;最新版本下载地址如下：&lt;br&gt;
&lt;a href=&#34;https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm&#34;&gt;https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm&lt;/a&gt;&lt;br&gt;
安装流程如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt; yum install -y lsb
 yum install -y libXScrnSaver 
 yum localinstall -y google-chrome-stable_current_x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;edge浏览器&#34;&gt;Edge浏览器&lt;/h1&gt;
&lt;p&gt;离线安装包下载地址：&lt;a href=&#34;https://www.microsoft.com/zh-cn/edge/business/download&#34;&gt;https://www.microsoft.com/zh-cn/edge/business/download&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;firefox&#34;&gt;FireFox&lt;/h1&gt;
&lt;p&gt;离线安装包下载地址：&lt;a href=&#34;http://www.firefox.com.cn/download/&#34;&gt;http://www.firefox.com.cn/download/&lt;/a&gt;&lt;/p&gt;
">Chrome、Edge、Firefox离线安装包下载</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/pa-chong-zhi-beautifulsoup/"" data-c="
          &lt;p&gt;python中爬虫常用模块“美丽汤”&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;模块功能介绍&#34;&gt;模块功能介绍&lt;/h3&gt;
&lt;p&gt;从html或者xml格式文件中提取数据&lt;/p&gt;
&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 安装BeautifulSoup
pip install bs4
# 安装其他相关解析器
pip install lxml
pip install html5lib
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;模块引用&#34;&gt;模块引用&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 初始化
from bs4 import BeautifulSoup
# 方法一，直接打开文件（需要指定Beautiful的解析器为“html.parser”，否则解析不正常）
soup=BeautifulSoup(open(&amp;quot;index.html&amp;quot;,&#39;r&#39;,encoding=&amp;quot;utf-8&amp;quot;),&amp;quot;html.parser&amp;quot;)
# 方法二，指定数据
resp=&amp;quot;&amp;lt;html&amp;gt;data&amp;lt;/html&amp;gt;&amp;quot;
soup=BeautifulSoup(resp, &#39;lxml&#39;)
# soup为BeautifulSoup 类型对象
print(type(soup))
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;基本元素&#34;&gt;基本元素&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;BeautifulSoup&lt;br&gt;
文档的全部内容。&lt;/li&gt;
&lt;li&gt;Tag&lt;br&gt;
HTML的标签，最基本的信息组织单元，分别用&amp;lt;&amp;gt;和&amp;lt;/&amp;gt;标名开头和结尾&lt;/li&gt;
&lt;li&gt;Attributes&lt;br&gt;
标签的属性，字典形式组织，格式：&lt;tag&gt;.attrs&lt;br&gt;
soup.a.attrs  #获取a标签的所有属性(注意到格式是字典)&lt;/li&gt;
&lt;li&gt;NavigableString&lt;br&gt;
标签包含的文字，即标签内非属性字符串，&amp;lt;&amp;gt;...&amp;lt;/&amp;gt;中字符串，格式：&lt;tag&gt;.string&lt;br&gt;
soup.a.string   # a标签的非属性字符串信息，表示尖括号之间的那部分字符串&lt;br&gt;
&lt;strong&gt;.string和.text的区别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;.string可以返回当前节点中的内容，但是当前节点包含子节点时，.string不知道要获取哪一个节点中的内容，故返回空&lt;br&gt;
.text（或者.get_text()）可以返回当前节点所包含的所有文本内容，包括当前节点的子孙节点&lt;br&gt;
举例使用.text的情况：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&amp;quot;&lt;a class =“bets-name” href=&#34;/stock/sh601766.html&#34;&gt;中国中车(&lt;span&gt; 601766 &lt;/span&gt;)&lt;/a&gt;&amp;quot;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;text&#34;&gt;(+49) 228 251 927&lt;br/&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Comment&lt;br&gt;
一种特殊的NavigableString类型，当标签中的NavigableString被注释时，则定义为该类型&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;标签搜索和过滤&#34;&gt;标签搜索和过滤&lt;/h3&gt;
&lt;h4 id=&#34;基本方法&#34;&gt;基本方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;标签搜索有find_all() 和find() 两个基本的搜索方法，find_all() 方法会返回所有匹配关键字的标签列表，find()方法则只返回一个匹配结果&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 返回一个标签名为&amp;quot;a&amp;quot;的Tag
soup.find(&amp;quot;a&amp;quot;)
# 返回所有tag 列表
soup.find_all(&amp;quot;a&amp;quot;)
##    find_all方法可被简写
soup(&amp;quot;a&amp;quot;)
# 找出所有以b开头的标签
for tag in soup.find_all(re.compile(&amp;quot;^b&amp;quot;)):
  print(tag.name)
#找出列表中的所有标签
soup.find_all([&amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;])
# 查找标签名为p，class属性为&amp;quot;title&amp;quot;
soup.find_all(&amp;quot;p&amp;quot;, &amp;quot;title&amp;quot;)
# 查找属性id为&amp;quot;link2&amp;quot;
soup.find_all(id=&amp;quot;link2&amp;quot;)
# 查找存在属性id的
soup.find_all(id=True)
# 设置多个筛选的属性
soup.find_all(href=re.compile(&amp;quot;elsie&amp;quot;), id=&#39;link1&#39;)
# 通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag
#    有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性，同时name由于已经是find_all()方法中的一个参数名（代表tag的名字），
#    所以也不可通过tag中的name属性来搜索tag，但是可以通过 find_all() 方法的 attrs 参数定义一个字典参数来搜索包含特殊属性的tag
soup.find_all(attrs={&amp;quot;data-foo&amp;quot;: &amp;quot;value&amp;quot;})
# 查找标签文字包含&amp;quot;sisters&amp;quot;
soup.find(string=re.compile(&amp;quot;sisters&amp;quot;))
# 获取指定数量的结果
soup.find_all(&amp;quot;a&amp;quot;, limit=2)
# 自定义匹配方法
def has_class_but_no_id(tag):
  return tag.has_attr(&#39;class&#39;) and not tag.has_attr(&#39;id&#39;)
soup.find_all(has_class_but_no_id)
# 仅对属性使用自定义匹配方法
def not_lacie(href):
    return href and not re.compile(&amp;quot;lacie&amp;quot;).search(href)
soup.find_all(href=not_lacie)
# 调用tag的find_all()方法时,BeautifulSoup会检索当前tag的所有子孙节点,如果只想搜索tag的直接子节点,可以使用参数recursive=False 
soup.find_all(&amp;quot;title&amp;quot;, recursive=False)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;扩展方法&#34;&gt;扩展方法&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 所有父辈节点
ind_parents()
# 第一个父辈节点
find_parent()
# 之后的所有兄弟节点
find_next_siblings()
# 之后的第一个兄弟节点
find_next_sibling()
# 之前的所有兄弟节点
find_previous_siblings()
# 之前的第一个兄弟节点
find_previous_sibling()
# 之后的所有元素
find_all_next()
# 之后的第一个元素
find_next()
# 之前的所有元素
find_all_previous()
# 之前的第一个元素
find_previous()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;css选择器&#34;&gt;CSS选择器&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;BeautifulSoup支持大部分的CSS选择器, 在Tag或BeautifulSoup对象的.select()方法中传入字符串参数, 即可使用CSS选择器的语法找到tag&lt;/code&gt;&lt;br&gt;
&lt;code&gt;标签直接写名称，class则用&amp;quot;.&amp;quot;号加名称，id则使用&amp;quot;#&amp;quot;号加名称&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 所有a标签
soup.select(&amp;quot;a&amp;quot;)
# 逐层查找
soup.select(&amp;quot;body a&amp;quot;)
soup.select(&amp;quot;html head title&amp;quot;)
# tag标签下的直接子标签
soup.select(&amp;quot;head &amp;gt; title&amp;quot;)
soup.select(&amp;quot;p &amp;gt; #link1&amp;quot;)
# 所有匹配标签之后的兄弟标签
soup.select(&amp;quot;#link1 ~ .sister&amp;quot;)
# 匹配标签之后的第一个兄弟标签
soup.select(&amp;quot;#link1 + .sister&amp;quot;)
# 根据calss类名
soup.select(&amp;quot;.sister&amp;quot;)
soup.select(&amp;quot;[class~=sister]&amp;quot;)
# 根据id查找
soup.select(&amp;quot;#link1&amp;quot;)
soup.select(&amp;quot;a#link1&amp;quot;)
# 根据多个id查找
soup.select(&amp;quot;#link1,#link2&amp;quot;)
# 根据属性查找
soup.select(&#39;a[href]&#39;)
# 根据属性值查找
soup.select(&#39;a[href^=&amp;quot;http://example.com/&amp;quot;]&#39;)
soup.select(&#39;a[href$=&amp;quot;tillie&amp;quot;]&#39;)
soup.select(&#39;a[href*=&amp;quot;.com/el&amp;quot;]&#39;)
# 只获取一个匹配结果
soup.select(&amp;quot;.sister&amp;quot;, limit=1)
# 只获取一个匹配结果
soup.select_one(&amp;quot;.sister&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;标签对象方法&#34;&gt;标签对象方法&lt;/h3&gt;
&lt;h4 id=&#34;标签属性&#34;&gt;标签属性&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 获取所有的 p标签对象
tags = soup.find_all(&amp;quot;p&amp;quot;)
# 获取第一个p标签对象
tag = soup.p
# 输出标签类型 
type(tag)
# 标签名
tag.name
# 标签属性
tag.attrs
# 标签属性class 的值
tag[&#39;class&#39;]
# 标签包含的文字内容，对象NavigableString 的内容
tag.string
# 返回标签内所有的文字内容
for string in tag.strings:
  print(repr(string))
# 返回标签内所有的文字内容, 并去掉空行
for string in tag.stripped_strings:
  print(repr(string))
# 获取到tag中包含的所有及包括子孙tag中的NavigableString内容，并以Unicode字符串格式输出
tag.get_text()
##    以&amp;quot;|&amp;quot;分隔
tag.get_text(&amp;quot;|&amp;quot;)
##    以&amp;quot;|&amp;quot;分隔，不输出空字符
tag.get_text(&amp;quot;|&amp;quot;, strip=True)
# 获取过滤出的a标签中href的链接
tag.select(&#39;a[target=&amp;quot;_blank&amp;quot;]&#39;)[0].get(&amp;quot;href&amp;quot;)
# 获取子节点
##    返回第一层子节点的列表
tag.contents
##    返回第一层子节点的listiterator对象
tag.children 
for child in tag.children:
  print(child)
##    递归返回所有子节点
tag.descendants 
for child in tag.descendants:
  print(child)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;获取父节点&#34;&gt;获取父节点&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 返回第一层父节点标签
tag.parent 
# 递归得到元素的所有父辈节点
tag.parents 
##    父辈节点为空则打印父节点标签，否则打印名字
for parent in tag.parents:
  if parent is None:
    print(parent)
  else:
    print(parent.name)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;获取兄弟节点&#34;&gt;获取兄弟节点&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 下一个兄弟元素
tag.next_sibling 
# 当前标签之后的所有兄弟元素
tag.next_siblings
for sibling in tag.next_siblings:
  print(repr(sibling))
# 上一个兄弟元素
tag.previous_sibling
# 当前标签之前的所有兄弟元素
tag.previous_siblings
for sibling in tag.previous_siblings:
  print(repr(sibling))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;元素的遍历&#34;&gt;元素的遍历&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;BeautifulSoup中把每个tag定义为一个元素element，每个元素element被自上而下的在HTML中排列，可以通过遍历命令逐个显示标签&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 当前标签的下一个元素
tag.next_element
# 当前标签之后的所有元素
for element in tag.next_elements:
  print(repr(element))
# 当前标签的前一个元素
tag.previous_element
# 当前标签之前的所有元素
for element in tag.previous_elements:
  print(repr(element))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改标签属性&#34;&gt;修改标签属性&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup = BeautifulSoup(&#39;&amp;lt;b  name=&amp;quot;test&amp;quot; class=&amp;quot;boldest&amp;quot;&amp;gt;Extremely bold&amp;lt;/b&amp;gt;&#39;)
# 获取b标签对象
tag = soup.b
# 修改对象标签的名字
tag.name = &amp;quot;blockquote&amp;quot;
# 修改对象的class
tag[&#39;class&#39;] = &#39;verybold&#39;
# 修改对象的id
tag[&#39;id&#39;] = 1
# 修改对象中的字符串（标签内容）
tag.string = &amp;quot;New link text.&amp;quot;
print(tag)
#  &amp;lt;blockquote class=&amp;quot;verybold&amp;quot; id=&amp;quot;1&amp;quot;&amp;gt;New link text.&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改标签内容&#34;&gt;修改标签内容&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup = BeautifulSoup(&#39;&amp;lt;b class=&amp;quot;boldest&amp;quot;&amp;gt;Extremely bold&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.b
# 修改标签中字符串
tag.string = &amp;quot;New link text.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;添加标签内容&#34;&gt;添加标签内容&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 直接使用append对标签a对象进行操作
from bs4 import BeautifulSoup
soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;Foo&amp;lt;/a&amp;gt;&amp;quot;, &amp;quot;html.parser&amp;quot;)
tag = soup.a
tag.append(&amp;quot;Bar&amp;quot;)
print(tag)
# 或者使用NavigableString，对整个soup对象进行操作
from bs4 import NavigableString
soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;Foo&amp;lt;/a&amp;gt;&amp;quot;, &amp;quot;html.parser&amp;quot;)
new_string = NavigableString(&amp;quot;Bar&amp;quot;)
tag.append(new_string)
print(tag)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;添加注释&#34;&gt;添加注释&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;注释是一个特殊的NavigableString对象，可以通过append()方法进行添加&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bs4 import BeautifulSoup
from bs4 import Comment
soup=BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;Foo&amp;lt;/a&amp;gt;&amp;quot;, &amp;quot;html.parser&amp;quot;)
new_comment=soup.new_string(&amp;quot;Nice to see you.&amp;quot;, Comment)
soup.append(new_comment)
print(soup)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;添加标签&#34;&gt;添加标签&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;添加标签方法有两种，一种是在指定标签的内部添加（append方法），另一种是在指定位置添加(insert、insert_before、insert_after方法)&lt;/code&gt;&lt;/p&gt;
&lt;h5 id=&#34;append方法&#34;&gt;append方法&lt;/h5&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup=BeautifulSoup(&amp;quot;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&amp;quot;,&amp;quot;html.parser&amp;quot;)
tag=soup.b
new_tag=soup.new_tag(&amp;quot;a&amp;quot;, href=&amp;quot;http://www.example.com&amp;quot;,rel=&amp;quot;external nofollow&amp;quot; )
new_tag.string = &amp;quot;Link text.&amp;quot;
tag.append(new_tag)
print(tag)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;insert方法&#34;&gt;insert方法&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;在当前标签子节点列表的指定位置插入对象(Tag或NavigableString)&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup = BeautifulSoup(&#39;&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot; rel=&amp;quot;external nofollow&amp;quot;&amp;gt;I linked to&amp;lt;i&amp;gt;example.com&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.a
tag.insert(1, &amp;quot;,but did not endorse &amp;quot;)
print(tag)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;insert_before-和-insert_after&#34;&gt;insert_before() 和 insert_after()&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;在当前标签之前或之后的兄弟节点添加元素&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup = BeautifulSoup(&#39;&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot; rel=&amp;quot;external nofollow&amp;quot;&amp;gt;I linked to&amp;lt;i&amp;gt;example.com&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.new_tag(&amp;quot;i&amp;quot;)
tag.string = &amp;quot;Don&#39;t&amp;quot;
soup.b.insert_before(tag)
print(soup)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id=&#34;wrap-和-unwrap&#34;&gt;wrap() 和 unwrap()&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;可以对指定的tag元素进行包装或解包,并返回包装后的结果&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 添加包装
##      对字符串添加标签b
soup=BeautifulSoup(&amp;quot;&amp;lt;p&amp;gt;I wish I was bold.&amp;lt;/p&amp;gt;&amp;quot;,&amp;quot;html.parser&amp;quot;)
soup.p.string.wrap(soup.new_tag(&amp;quot;b&amp;quot;))
print(soup)
##      对p标签外添加div标签
soup.p.wrap(soup.new_tag(&amp;quot;div&amp;quot;))
print(soup)
# 拆解包装
##      去除div标签
soup.div.unwrap()
print(soup)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;删除标签&#34;&gt;删除标签&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup = BeautifulSoup(&#39;&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot; rel=&amp;quot;external nofollow&amp;quot;&amp;gt;I linked to&amp;lt;i&amp;gt;example.com&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
# 将i标签之外的所有标签删除，并返回为i_tag
i_tag=soup.i.extract()
print(i_tag)
print(soup)
# 将当前标签a及所有子节点从soup 中移除，无返回。
soup.a.decompose()
print(soup)

soup = BeautifulSoup(&#39;&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot; rel=&amp;quot;external nofollow&amp;quot;&amp;gt;I linked to&amp;lt;i&amp;gt;example.com&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
# 将当前标签替换为指定的元素
tag = soup.i
new_tag = soup.new_tag(&amp;quot;p&amp;quot;)
new_tag.string = &amp;quot;Don&#39;t&amp;quot;
tag.replace_with(new_tag)
print(soup)
# 清除当前标签的所有子节点，即删除b标签所有内容
soup.b.clear()
print(soup)

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;其他方法&#34;&gt;其他方法&lt;/h3&gt;
&lt;h4 id=&#34;格式化输出&#34;&gt;格式化输出&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;使用BeautifulSoup解析后,文档都被转换成了unicode，特殊字符也被转换为unicode，如果将文档转换成字符串,unicode编码会被编码成utf8.这样就无法正确显示HTML特殊字符了。 使用unicode时,BeautifulSoup还会智能的把“引号”转换成HTML或XML中的特殊字符&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;soup = BeautifulSoup(&#39;&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot; rel=&amp;quot;external nofollow&amp;quot;&amp;gt;I linked to&amp;lt;i&amp;gt;example.com&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&#39;,&amp;quot;html.parser&amp;quot;)
tag = soup.a
# 格式化输出
print(tag.prettify())
print(tag.prettify(&amp;quot;latin-1&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;文档编码&#34;&gt;文档编码&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;使用BeautifulSoup解析后,文档都被转换成了unicode，其使用了“编码自动检测”子库来识别当前文档编码并转换成unicode编码&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bs4 import BeautifulSoup #,&amp;quot;html.parser&amp;quot;

html=&#39;&amp;lt;b&amp;gt;&amp;lt;a href=&amp;quot;http://example.com/&amp;quot; rel=&amp;quot;external nofollow&amp;quot;&amp;gt;I linked to&amp;lt;i&amp;gt;example.com&amp;lt;/i&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/b&amp;gt;&#39;
# 默认编码
soup = BeautifulSoup(html)
print(soup.original_encoding) #告警可忽视

# 手动指定文档的编码
soup = BeautifulSoup(html, from_encoding=&amp;quot;iso-8859-8&amp;quot;)
print(soup.original_encoding) #告警可忽视

# 为提高“编码自动检测”的检测效率，也可以预先排除一些编码
soup = BeautifulSoup(html, exclude_encodings=[&amp;quot;iso-8859-8&amp;quot;]) #告警可忽视


# 通过BeautifulSoup输出文档时, 不管输入文档是什么编码方式, 默认输出编码a均为utf8编码文档解析器
# BeautifulSoup目前支持的有 “lxml”(pip install lxml)、 “html5lib”(pip install html5lib)、 “html.parser”
soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;&amp;lt;b /&amp;gt;&amp;lt;/a&amp;gt;&amp;quot;)
print(soup)     # 输出： &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;a&amp;gt;&amp;lt;b&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;, &amp;quot;lxml&amp;quot;)
print(soup)     # 输出： &amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;, &amp;quot;html5lib&amp;quot;)
print(soup)     # 输出： &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&amp;lt;a&amp;gt;&amp;lt;p&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;
soup = BeautifulSoup(&amp;quot;&amp;lt;a&amp;gt;&amp;lt;/p&amp;gt;&amp;quot;, &amp;quot;html.parser&amp;quot;)
print(soup)     # 输出： &amp;lt;a&amp;gt;&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;实例&#34;&gt;实例&lt;/h3&gt;
&lt;h4 id=&#34;kanguowai网站所有分类网址离线爬取&#34;&gt;kanguowai网站所有分类网址离线爬取&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bs4 import BeautifulSoup
import csv

Webs=[[&amp;quot;索引&amp;quot;,&amp;quot;名称&amp;quot;,&amp;quot;国家&amp;quot;,&amp;quot;类型&amp;quot;,&amp;quot;网址&amp;quot;,&amp;quot;描述&amp;quot;]]
for webindex in range(2,12133): #range(2,12133)
    try:
        html=BeautifulSoup(open(&amp;quot;./site/{webindex}.html&amp;quot;.format(webindex=webindex),&#39;r&#39;,encoding=&amp;quot;utf-8&amp;quot;),&amp;quot;html.parser&amp;quot;)
    except:
        print(webindex)  # 打印空的web索引
        WebName=&amp;quot;Null&amp;quot;
        WebCountry=&amp;quot;Null&amp;quot;
        WebType=&amp;quot;Null&amp;quot;
        WebLink=&amp;quot;Null&amp;quot;
        WebDesc=&amp;quot;Null&amp;quot;
    try:
        WebName=html.select(&#39;.baseinfo li h1&#39;)[0].text
    except:
        WebName = &amp;quot;Null&amp;quot;
    try:
        WebCountry=html.select(&#39;.baseinfo .linfo a&#39;)[0].text
    except:
        WebCountry=&amp;quot;Null&amp;quot;
    try:
        WebType=html.select(&#39;.baseinfo .rinfo a&#39;)[0].text
    except:
        WebType=&amp;quot;Null&amp;quot;
    try:
        WebLink=html.select(&#39;.baseinfo .siteurl a&#39;)[0].text
    except:
        WebLink=&amp;quot;Null&amp;quot;
    try:
        WebDesc=html.select(&#39;.sitetext p&#39;)[0].text
    except:
        WebDesc=&amp;quot;Null&amp;quot;
    Webs.append([webindex,WebName,WebCountry,WebType,WebLink,WebDesc])
# 写入csv
with open(&amp;quot;webs.csv&amp;quot;,&amp;quot;w&amp;quot;,newline=&#39;&#39;,encoding=&amp;quot;utf-8&amp;quot;) as f:
    out=csv.writer(f)
    for row in Webs:
        out.writerow(row)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;kanguowai网站所有分类网址在线爬取&#34;&gt;kanguowai网站所有分类网址在线爬取&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from bs4 import BeautifulSoup
import urllib.request
import csv

# 变量声明：
# 索引 webindex
# 名称 WebName
# 国家 WebCountry
# 类型 WebType
# 网站 WebLink
# 描述 WebDesc
Webs=[[&amp;quot;索引&amp;quot;,&amp;quot;名称&amp;quot;,&amp;quot;国家&amp;quot;,&amp;quot;类型&amp;quot;,&amp;quot;网址&amp;quot;,&amp;quot;描述&amp;quot;]]
for webindex in range(2,12133): #range(2,12133)
    try:
        html=BeautifulSoup(urllib.request.urlopen(&amp;quot;https://www.kanguowai.com/site/{webindex}.html&amp;quot;.format(webindex=webindex)).read().decode(&amp;quot;utf-8&amp;quot;),&amp;quot;html.parser&amp;quot;)
    except:
        print(webindex)  # 打印空的web索引
        WebName=&amp;quot;Null&amp;quot;
        WebCountry=&amp;quot;Null&amp;quot;
        WebType=&amp;quot;Null&amp;quot;
        WebLink=&amp;quot;Null&amp;quot;
        WebDesc=&amp;quot;Null&amp;quot;
    try:
        WebName=html.select(&#39;.baseinfo li h1&#39;)[0].text
    except:
        WebName = &amp;quot;Null&amp;quot;
    try:
        WebCountry=html.select(&#39;.baseinfo .linfo a&#39;)[0].text
    except:
        WebCountry=&amp;quot;Null&amp;quot;
    try:
        WebType=html.select(&#39;.baseinfo .rinfo a&#39;)[0].text
    except:
        WebType=&amp;quot;Null&amp;quot;
    try:
        WebLink=html.select(&#39;.baseinfo .siteurl a&#39;)[0].text
    except:
        WebLink=&amp;quot;Null&amp;quot;
    try:
        WebDesc=html.select(&#39;.sitetext p&#39;)[0].text
    except:
        WebDesc=&amp;quot;Null&amp;quot;
    Webs.append([webindex,WebName,WebCountry,WebType,WebLink,WebDesc])
# 写入csv
with open(&amp;quot;websbuff.csv&amp;quot;,&amp;quot;w&amp;quot;,newline=&#39;&#39;,encoding=&amp;quot;utf-8&amp;quot;) as f:
    out=csv.writer(f)
    for row in Webs:
        out.writerow(row)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;egouz所有领事馆离线爬取&#34;&gt;egouz所有领事馆离线爬取&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 领事馆
from bs4 import BeautifulSoup
import csv,os

htmls=os.listdir(&amp;quot;./consulate/yes&amp;quot;)
Consulates=[[&amp;quot;名称&amp;quot;,&amp;quot;机构类型&amp;quot;,&amp;quot;联系邮箱&amp;quot;,&amp;quot;联系电话&amp;quot;,&amp;quot;传真地址&amp;quot;,&amp;quot;工作时间&amp;quot;,&amp;quot;网站&amp;quot;,&amp;quot;大使（机构负责人）&amp;quot;,&amp;quot;联系地址&amp;quot;]]
for html in htmls:
    htmlitem=BeautifulSoup(open(&amp;quot;./consulate/yes/{html}&amp;quot;.format(html=html), &#39;r&#39;, encoding=&amp;quot;utf-8&amp;quot;), &amp;quot;html.parser&amp;quot;).select(&#39;.website-info .item-list .item&#39;)
    try:
        # 获取领事馆名称
        Name=htmlitem[0].select(&amp;quot;.btn-quick&amp;quot;)[0].text
        # 获取了领事馆类型
        Type=htmlitem[1].select(&amp;quot;.text&amp;quot;)[0].text
        Email=htmlitem[1].select(&amp;quot;.text&amp;quot;)[1].text
        Call=htmlitem[2].select(&amp;quot;.text&amp;quot;)[0].text
        Fax=htmlitem[2].select(&amp;quot;.text&amp;quot;)[1].text
        WorkTime=htmlitem[3].select(&amp;quot;.text&amp;quot;)[0].text
        Web=htmlitem[3].select(&amp;quot;.text&amp;quot;)[1].text
        People=htmlitem[4].select(&amp;quot;.text&amp;quot;)[0].text
        Address=htmlitem[5].select(&amp;quot;.text&amp;quot;)[0].text
        Consulates.append([Name,Type,Email,Call,Fax,WorkTime,Web,People,Address])
    except:
        print(html)
# 写入csv
with open(&amp;quot;领事馆.csv&amp;quot;,&amp;quot;w&amp;quot;,newline=&#39;&#39;,encoding=&amp;quot;utf-8&amp;quot;) as f:
    out=csv.writer(f)
    for row in Consulates:
        out.writerow(row)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;egouz所有大使馆离线爬取&#34;&gt;egouz所有大使馆离线爬取&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 大使馆
from bs4 import BeautifulSoup
import csv,os

htmls=os.listdir(&amp;quot;./embassy/yes&amp;quot;)
Consulates=[[&amp;quot;名称&amp;quot;,&amp;quot;机构类型&amp;quot;,&amp;quot;联系邮箱&amp;quot;,&amp;quot;联系电话&amp;quot;,&amp;quot;传真地址&amp;quot;,&amp;quot;工作时间&amp;quot;,&amp;quot;网站&amp;quot;,&amp;quot;大使（机构负责人）&amp;quot;,&amp;quot;联系地址&amp;quot;]]
for html in htmls:
    htmlitem=BeautifulSoup(open(&amp;quot;./embassy/yes/{html}&amp;quot;.format(html=html), &#39;r&#39;, encoding=&amp;quot;utf-8&amp;quot;), &amp;quot;html.parser&amp;quot;).select(&#39;.website-info .item-list .item&#39;)
    try:
        # 获取领事馆名称
        Name=htmlitem[0].select(&amp;quot;.btn-quick&amp;quot;)[0].text
        # 获取了领事馆类型
        Type=htmlitem[1].select(&amp;quot;.text&amp;quot;)[0].text
        Email=htmlitem[1].select(&amp;quot;.text&amp;quot;)[1].text
        Call=htmlitem[2].select(&amp;quot;.text&amp;quot;)[0].text
        Fax=htmlitem[2].select(&amp;quot;.text&amp;quot;)[1].text
        WorkTime=htmlitem[3].select(&amp;quot;.text&amp;quot;)[0].text
        Web=htmlitem[3].select(&amp;quot;.text&amp;quot;)[1].text
        People=htmlitem[4].select(&amp;quot;.text&amp;quot;)[0].text
        Address=htmlitem[5].select(&amp;quot;.text&amp;quot;)[0].text
        Consulates.append([Name,Type,Email,Call,Fax,WorkTime,Web,People,Address])
    except:
        print(html)
# 写入csv
with open(&amp;quot;大使馆.csv&amp;quot;,&amp;quot;w&amp;quot;,newline=&#39;&#39;,encoding=&amp;quot;utf-8&amp;quot;) as f:
    out=csv.writer(f)
    for row in Consulates:
        out.writerow(row)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;参考链接&#34;&gt;参考链接：&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://www.jb51.net/article/178653.htm&#34;&gt;Python下利用BeautifulSoup解析HTML的实现&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/hanmk/p/8724162.html&#34;&gt;python爬虫学习(一)：BeautifulSoup库基础及一般元素提取方法&lt;/a&gt;&lt;/p&gt;
">爬虫之BeautifulSoup</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/ju-yu-wang-nei-bu-da-jian-pip-yuan/"" data-c="
          &lt;p&gt;python的pip源的搭建&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;原因&#34;&gt;原因&lt;/h3&gt;
&lt;p&gt;局域网无法连接互联网，每次安装python模块需要在公网机器下载、刻盘、导入、安装、再去下载依赖......一来一回不仅消耗很多光盘，并且浪费大量的开发时间。&lt;/p&gt;
&lt;h3 id=&#34;下载pypi所有模块&#34;&gt;下载pypi所有模块&lt;/h3&gt;
&lt;p&gt;首先安装msys2，并且添加到环境变量，在命令行中能够使用wget命令，如果不添加环境变量则需要使用wget.exe的绝对路径。&lt;br&gt;
此处使用的是阿里的镜像源，镜像源2020年初大约9T，之后会慢慢增加，需要提前准备好存储。下载时间可能比较长，需要耐心等待。&lt;br&gt;
下载下来主要是两个文件夹：simple和packages&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;#https://mirrors.aliyun.com/pypi/simple/
import multiprocessing,queue,os
from bs4 import BeautifulSoup

#下载进程
def download_process(url):
	#wget -m -t 10 -c -np -q -b --execute robots=off https://mirrors.aliyun.com/pypi/packages/00/00/
	out=os.popen(&amp;quot;C:\\msys64\\usr\\bin\\wget -m -t 10 -T 180 -c -q --execute robots=off {url}&amp;quot;.format(url=url)).read()
	if out!=&amp;quot;&amp;quot;:
		print(&amp;quot;ERROR：{url}&amp;quot;.format(url=url))
		with open(&amp;quot;error_simple.log&amp;quot;,&amp;quot;a&amp;quot;) as log:
			log.write(&amp;quot;ERROR：{url}\n&amp;quot;.format(url=url))
	else:
		print(&amp;quot;下载完成：{url}&amp;quot;.format(url=url))
		with open(&amp;quot;success_simple.log&amp;quot;,&amp;quot;a&amp;quot;) as log:
			log.write(&amp;quot;下载完成：{url}\n&amp;quot;.format(url=url))
	
if __name__==&amp;quot;__main__&amp;quot;:
	#多线程支持and参数获取
	multiprocessing.freeze_support()
	# 下载所有模块列表
	os.popen(&amp;quot;C:\\msys64\\usr\\bin\\wget https://mirrors.aliyun.com/pypi/simple/&amp;quot;).read()
	# 获取所有的a标签中的连接
	html=BeautifulSoup(open(&amp;quot;index.html&amp;quot;,&#39;r&#39;,encoding=&amp;quot;utf-8&amp;quot;),&amp;quot;html.parser&amp;quot;)
	tag=html.select(&#39;a[href]&#39;)
	urls=[]
	for ahref in tag:
		urls.append(&amp;quot;https://mirrors.aliyun.com/pypi/simple/&amp;quot;+ahref.get(&amp;quot;href&amp;quot;))

	#创建任务队列
	TaskQue=queue.Queue()
	for i in urls:
		TaskQue.put(i)

	# 开启下载线程
	pool=multiprocessing.Pool(processes=16) # 开启16个进程，当然也可以根据CPU数目开启进程，processes=multiprocessing.cpu_count()
	for i in range(TaskQue.qsize()):
		TaskQue_One=TaskQue.get()
		pool.apply_async(download_process,(TaskQue_One,))
	pool.close()
	pool.join()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;部署nginx&#34;&gt;部署nginx&lt;/h3&gt;
&lt;p&gt;nginx服务器局域网地址为&amp;lt;192.168.1.195&amp;gt;&lt;br&gt;
如果内网有web服务可以直接挂载到相应目录下，开启目录遍历功能即可。我是使用源码搭建的nginx服务（具体步骤见&lt;a href=&#34;https://www.jianshu.com/p/172063887a51&#34;&gt;https://www.jianshu.com/p/172063887a51&lt;/a&gt;）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 修改配置文件
vim /usr/local/nginx/conf/nginx.conf
# 在你自己自定义的目录下添加如下3行内容，我是直接放在根目录下，所以追加在location /{...}这个下面
autoindex on;
autoindex_exact_size off;
autoindex_localtime on;
# 重启nginx服务
systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;使用pypi源&#34;&gt;使用pypi源&lt;/h3&gt;
&lt;p&gt;配置文件位置：&lt;br&gt;
Windows：win+R---输入%USERPROFILE%（或者%HOMEPATH%）之后回车---在此目录中新建文件夹pip---在pip文件夹中新建文件pip.ini&lt;br&gt;
Linux：vim ~/.pip/pip.conf&lt;br&gt;
配置文件内容如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[global]
index-url = http://192.168.1.195/pypi/simple
[install]
trusted-host = 192.168.1.195
&lt;/code&gt;&lt;/pre&gt;
">局域网内部搭建pip源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-shi-xian-tcp-xie-yi-fa-song-he-jie-shou-xin-xi/"" data-c="
          &lt;p&gt;使用pythons实现信息发送与接收&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;服务端必须先运行&#34;&gt;服务端(必须先运行)&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 服务端(server)
import socket

# 创建socket对象
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  # 必须和客户端保持一致
# 需要自己绑定一个ip地址和端口号
s.bind((&#39;127.0.0.1&#39;, 8000))
# 服务端监听操作时刻注意是否有客户端请求发来
s.listen(3)  # 可以同时监听3个，但是这里只有一个客户请求，因为没有写多线程
# 同意连接请求
s1, addr = s.accept()  # s是服务端的socket对象s1是接入的客户端socket对象
print(addr)
# revice接收数据
data = s1.recv(1024)  # 设定一次可以接收1024字节大小
print(data.decode())  # 传过来的字节流需要用decode()解码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;客户端&#34;&gt;客户端&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 客户端(client）
# TCP必须建立连接
import socket  #导入模块
# SOCK_STREAM---TCP协议方式
# AF_INET----我的是ipv4地址
# 创建socket对象：指定传输协议
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
# 建立连接发送连接请求 ip地址和端口号
s.connect((&#39;127.0.0.1&#39;,8000))
message=&amp;quot;Hello World! 你好，中国！&amp;quot;
s.send(message.encode()) #只能发送字节流需要用encode转码字符串成字节，不然无法发送文件
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于多线程等相关内容，请参考我在博客园上的博客：&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/JYLCSS/p/11006249.html&#34;&gt;https://www.cnblogs.com/JYLCSS/p/11006249.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/JYLCSS/p/11037227.html&#34;&gt;https://www.cnblogs.com/JYLCSS/p/11037227.html&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://www.cnblogs.com/JYLCSS/p/11070406.html&#34;&gt;https://www.cnblogs.com/JYLCSS/p/11070406.html&lt;/a&gt;&lt;/p&gt;
">python实现tcp协议发送和接收信息</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/python-duo-jin-cheng-yu-duo-xian-cheng-pei-he-kao-bei-wen-jian-mu-lu/"" data-c="
          &lt;p&gt;多线程与多进程&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;版本一&#34;&gt;版本一&lt;/h3&gt;
&lt;p&gt;使用shutil进行拷贝&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-
# @author: Tele
# @Time  : 2019/04/02 下午 3:09
# 待改进:
# 1.拷贝逻辑使用原生的io
# 2.针对大文件在进程内部实现多线程方式进行拷贝


import time
import re
import os
import shutil
import multiprocessing


# 遍历文件夹
def walk_file(file):
    file_list = list()
    for root, dirs, files in os.walk(file):
        # 遍历文件
        for f in files:
            file_list.append(f)
    return file_list


# 计算文件数量
def get_file_count(dir):
    return len(walk_file(dir))


def copy(src, target, queue):
    target_number = 1
    if os.path.isdir(src):
        target_number = get_file_count(src)
        shutil.copytree(src, target)
    else:
        shutil.copyfile(src, target)
    # 将拷贝完成的文件数量放入队列中
    queue.put(target_number)


def copy_dir(src, desc):
    total_number = get_file_count(src)
    # 分隔符检测
    src = check_separator(src)
    desc = check_separator(desc)
    # print(&amp;quot;src:&amp;quot;,src)
    # print(&amp;quot;desc:&amp;quot;,desc)

    file_dir_list = [src + &amp;quot;/&amp;quot; + i for i in os.listdir(src)]
    if os.path.exists(desc):
        shutil.rmtree(desc)
    pool = multiprocessing.Pool(3)

    # 创建队列
    queue = multiprocessing.Manager().Queue()

    # 一个文件/目录开启一个进程去拷贝
    for f_name in file_dir_list:
        target = desc + &amp;quot;/&amp;quot; + f_name[index_list(&amp;quot;/&amp;quot;, f_name)[1] + 1:]
        # print(target)
        # 创建target目录
        parent_path = os.path.split(target)[0]
        if not os.path.exists(parent_path):
            os.makedirs(parent_path)
        pool.apply_async(copy, args=(f_name, target, queue,))

    start = time.time()
    pool.close()
    #    pool.join()
    count = 0
    while True:
        count += queue.get()
        # 格式化输出时两个%输出一个%,不换行,每次定位到行首,实现覆盖
        print(&amp;quot;\r拷贝进度为 %.2f %%&amp;quot; % (count * 100 / total_number), end=&amp;quot;&amp;quot;)
        if count &amp;gt;= total_number:
            break
    end = time.time()
    print()
    print(&amp;quot;耗时-----&amp;quot;, (end - start), &amp;quot;s&amp;quot;)


# 查找指定字符出现的全部索引位置
def index_list(c, s):
    return [i.start() for i in re.finditer(c, s)]


# 检测目录结尾是否有 &amp;quot;/&amp;quot;
def check_separator(path):
    if path.rindex(&amp;quot;/&amp;quot;) == len(path) - 1:
        return path[0:path.rindex(&amp;quot;/&amp;quot;)]
    return path


def main():
    copy_dir(&amp;quot;f:/ftp_mypc/&amp;quot;, &amp;quot;e:/ftp_mypc/&amp;quot;)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;版本二&#34;&gt;版本二&lt;/h3&gt;
&lt;p&gt;这样做仍然有些小问题,对于大文件可以在进程内部采用多线程的方式,可以看到使用shutil进行拷贝时我们没有办法实现字节切割,于是有了下面的版本二&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# -*- coding: utf-8 -*-
# @author: Tele
# @Time  : 2019/04/02 下午 3:09
# 使用多进程拷贝文件夹,对于大文件进程内部又使用了多线程进行拷贝
# 使用进程池实现多进程时,使用的消息队列要使用multiprocessing.Manager().Queue()创建

import time
import re
import os
import shutil
import multiprocessing
import math
from concurrent.futures import ThreadPoolExecutor, wait

# 设置单个文件的最大值:209715200 200M
MAX_SINGLE_FILE_SIZE = 209715200
mutex = multiprocessing.Lock()
executor = ThreadPoolExecutor(max_workers=3)


# 遍历文件夹
def walk_file(file):
    file_list = list()
    for root, dirs, files in os.walk(file):
        # 遍历文件
        for f in files:
            file_list.append(f)

        # 空文件夹处理
        for d in dirs:
            if len(os.listdir(os.path.join(root, d))) == 0:
                file_list.append(d)
    return file_list


# 计算文件数量
def get_file_count(dir):
    return len(walk_file(dir))


def copy(src, target, queue):
    target_number = 1
    buffer = 1024
    # 文件夹
    if os.path.isdir(src):
        target_number = get_file_count(src)
        for root, dirs, files in os.walk(src):
            # 遍历文件
            for f in files:
                drive = os.path.splitdrive(target)[0]
                target = drive + os.path.splitdrive(os.path.join(root, f))[1]
                copy_single_file(buffer, os.path.join(root, f), target)
            # 空文件夹
            for d in dirs:
                drive = os.path.splitdrive(target)[0]
                target = drive + os.path.splitdrive(os.path.join(root, d))[1]
                # 检查文件的层级目录
                if not os.path.exists(target):
                    os.makedirs(target)
    else:
        copy_single_file(buffer, src, target)
    # 将拷贝完成的文件数量放入队列中
    queue.put(target_number)


# 拷贝单文件
def copy_single_file(buffer, src, target):
    file_size = os.path.getsize(src)
    rs = open(src, &amp;quot;rb&amp;quot;)

    # 检查文件的层级目录
    parent_path = os.path.split(target)[0]
    if not os.path.exists(parent_path):
        os.makedirs(parent_path)

    ws = open(target, &amp;quot;wb&amp;quot;)
    # 小文件直接读写
    if file_size &amp;lt;= MAX_SINGLE_FILE_SIZE:
        while True:
            content = rs.read(buffer)
            ws.write(content)
            if len(content) == 0:
                break
        ws.flush()
    else:
        # 设置每个线程拷贝的字节数 50M
        PER_THREAD_SIZE = 52428800
        # 构造参数并执行
        task_list = list()
        for i in range(math.ceil(file_size / PER_THREAD_SIZE)):
            byte_size = PER_THREAD_SIZE
            # 最后一个线程拷贝的字节数应该是取模
            if i == math.ceil(file_size / PER_THREAD_SIZE) - 1:
                byte_size = file_size % PER_THREAD_SIZE
            start = i * PER_THREAD_SIZE + i
            t = executor.submit(copy_file_thread, start, byte_size, rs, ws)
            task_list.append(t)
        wait(task_list)
    if rs:
        rs.close()
    if ws:
        ws.close()


# 多线程拷贝
def copy_file_thread(start, byte_size, rs, ws):
    mutex.acquire()
    buffer = 1024
    count = 0
    rs.seek(start)
    ws.seek(start)
    while True:
        if count + buffer &amp;lt;= byte_size:
            content = rs.read(buffer)
            count += len(content)
            write(content, ws)
        else:
            content = rs.read(byte_size % buffer)
            count += len(content)
            write(content, ws)
            break
    # global total_count
    # total_count += byte_size
    # print(&amp;quot;\r拷贝进度为%.2f %%&amp;quot; % (total_count * 100 / file_size), end=&amp;quot;&amp;quot;)
    mutex.release()


def write(content, ws):
    ws.write(content)
    ws.flush()


def copy_dir(src, desc):
    # 获得待拷贝的文件总数(含空文件夹)
    total_number = get_file_count(src)
    # 分隔符检测
    src = check_separator(src)
    desc = check_separator(desc)
    # print(&amp;quot;src:&amp;quot;,src)
    # print(&amp;quot;desc:&amp;quot;,desc)

    file_dir_list = [src + &amp;quot;/&amp;quot; + i for i in os.listdir(src)]
    if os.path.exists(desc):
        shutil.rmtree(desc)

    # 进程池
    pool = multiprocessing.Pool(3)

    # 创建队列
    queue = multiprocessing.Manager().Queue()

    # 一个文件/目录开启一个进程去拷贝
    for f_name in file_dir_list:
        target = os.path.splitdrive(desc)[0] + &amp;quot;/&amp;quot; + os.path.splitdrive(f_name)[1]
        # target = desc + &amp;quot;/&amp;quot; + f_name[index_list(&amp;quot;/&amp;quot;, f_name)[1] + 1:]
        # print(target)
        # 创建target目录
        parent_path = os.path.split(target)[0]
        if not os.path.exists(parent_path):
            os.makedirs(parent_path)
        pool.apply_async(copy, args=(f_name, target, queue))

    start = time.time()
    pool.close()
    # pool.join()
    count = 0
    while True:
        count += queue.get()
        # 格式化输出时两个%输出一个%,不换行,每次定位到行首,实现覆盖
        print(&amp;quot;\r当前进度为 %.2f %%&amp;quot; % (count * 100 / total_number), end=&amp;quot;&amp;quot;)
        if count &amp;gt;= total_number:
            break

    executor.shutdown()
    end = time.time()
    print()
    print(&amp;quot;耗时-----&amp;quot;, (end - start), &amp;quot;s&amp;quot;)


# 查找指定字符出现的全部索引位置
def index_list(c, s):
    return [i.start() for i in re.finditer(c, s)]


# 检测目录结尾是否有 &amp;quot;/&amp;quot;
def check_separator(path):
    if path.rindex(&amp;quot;/&amp;quot;) == len(path) - 1:
        return path[0:path.rindex(&amp;quot;/&amp;quot;)]
    return path


def main():
    copy_dir(&amp;quot;f:/ftp_mypc/&amp;quot;, &amp;quot;e:/ftp_mypc/&amp;quot;)


if __name__ == &#39;__main__&#39;:
    main()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参考链接&lt;a href=&#34;https://www.cnblogs.com/tele-share/p/10656811.html&#34;&gt;https://www.cnblogs.com/tele-share/p/10656811.html&lt;/a&gt;&lt;/p&gt;
">python-多进程与多线程配合拷贝文件目录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/yuan-ma-bian-yi-wireshark2615/"" data-c="
          &lt;p&gt;centos7安装wireshark&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;环境说明&#34;&gt;环境说明&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;centos7-1908-mini&lt;/li&gt;
&lt;li&gt;yum源为清华镜像源&lt;/li&gt;
&lt;li&gt;已经安装wget和lrzsz&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;不安装wireshark3的原因&#34;&gt;不安装wireshark3的原因&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;需要更高版本的cmake&lt;/li&gt;
&lt;li&gt;需要更高版本的python&lt;/li&gt;
&lt;li&gt;需要其他更高版本的依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;如果确实需要安装wireshark3，&lt;a href=&#34;https://hualong1009.github.io/2019/08/13/Wireshark-v3.x-%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B/#wireshark%E5%AE%89%E8%A3%85&#34;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;开始部署&#34;&gt;开始部署&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 依赖环境安装
yum install -y gcc* libpcap* bison* byacc* flex* perl-podlators* libgcrypt* glib* gtk* qt5*
# 编译
cd /usr/local/src
wget &amp;quot;https://1.na.dl.wireshark.org/src/wireshark-2.6.15.tar.xz&amp;quot;
tar -Jxvf wireshark-2.6.15.tar.xz
cd wireshark-2.6.15
./configure
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
">源码编译wireshark2.6.15</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/wang-qia-ju-he-duo-wang-qia-bang-ding/"" data-c="
          &lt;p&gt;centos7网卡聚合-bonding&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;需要集合的网卡配置&#34;&gt;需要集合的网卡配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/sysconfig/network-scripts/ifcfg-enp4s0f0
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=enp4s0f0
MASTER=bond0
SLAVE=yes

vim /etc/sysconfig/network-scripts/ifcfg-enp4s0f1
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=enp4s0f1
MASTER=bond0
SLAVE=yes
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;虚拟网卡配置&#34;&gt;虚拟网卡配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/sysconfig/network-scripts/ifcfg-bond0
TYPE=Ethernet
BOOTPROTO=none
ONBOOT=yes
USERCTL=no
DEVICE=bond0
IPADDR=6.6.6.114
PREFIX=24
GATEWAY=6.6.6.1
NM_CONTROLLED=no
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置文件&#34;&gt;配置文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 采用bond6平均负载模式
vim /etc/modprobe.d/bond.conf
alias bond0 bonding
options bond0 miimon=100 mode=6
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;命令&#34;&gt;命令&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;modprobe --first-time bond0
modprobe bond0 miimon=100 mode=6
systemctl disable NetworkManager
systemctl stop NetworkManager
systemctl restart network
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;删除&#34;&gt;删除&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;rm -rf /etc/sysconfig/network-scripts/ifcfg-bond0
# 然后把之前绑定的网卡的配置恢复
rmmod bonding
&lt;/code&gt;&lt;/pre&gt;
">网卡聚合（多网卡绑定）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/ntp-fu-wu-duan-he-ke-hu-duan-da-jian/"" data-c="
          &lt;p&gt;时间同步&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;服务端&#34;&gt;服务端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ntp服务搭建&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install ntp ntpdate
systemctl enable ntpd
systemctl start ntpd
systemctl status ntpd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vi /etc/ntp.conf
  # 注释掉如下几行
  server 0.centos.pool.ntp.org iburst
  server 1.centos.pool.ntp.org iburst
  server 2.centos.pool.ntp.org iburst
  server 3.centos.pool.ntp.org iburst
  # 追加如下内容（将本机的时间作为标准时间）：
  server 127.127.1.0 iburst
systemctl restart ntpd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;防火墙设置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;firewall-cmd --permanent --add-port=123/udp
firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;系统时间修改&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;date -s &amp;quot;2020-02-06 17:04:00&amp;quot;
clock -w
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;客户端&#34;&gt;客户端&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;ntp服务搭建&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install ntp ntpdate
systemctl enable ntpd
systemctl start ntpd
systemctl status ntpd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;修改配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vi /etc/ntp.conf
  # 注释掉如下几行
  server 0.centos.pool.ntp.org iburst
  server 1.centos.pool.ntp.org iburst
  server 2.centos.pool.ntp.org iburst
  server 3.centos.pool.ntp.org iburst
  # 追加如下内容（6.6.6.253为局域网内时间同步服务器，就是上面搭建好的那台服务端IP）：
  server  6.6.6.253
  restrict 6.6.6.253 nomodify notrap noquery
systemctl restart ntpd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;进行时间同步&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 同步时间
ntpdate -u 6.6.6.253
# 查看状态
ntpq -p
&lt;/code&gt;&lt;/pre&gt;
">NTP服务端和客户端搭建</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/nginx-tian-jia-mi-ma-ren-zheng/"" data-c="
          &lt;p&gt;nginx部分配置&lt;/p&gt;
&lt;!-- more --&gt;
&lt;ol&gt;
&lt;li&gt;修改配置文件&lt;br&gt;
在nginx配置文件中添加一下两行内容&lt;br&gt;
&lt;code&gt;如果全站加认证则添加到server下，如果某一个目录添加，则添加到相应的location下&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;# 认证信息提示框显示内容
auth_basic  &amp;quot;请输入用户名和密码！&amp;quot;;
# 密码文件
auth_basic_user_file /usr/local/nginx/conf/passwd;
# 补充内容：
# autoindex on; #开启目录遍历
# autoindex_localtime on; #显示的文件时间为文件的服务器时间
# autoindex_exact_size off; #显示出文件的大概大小，单位是kB或者MB或者GB
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;生成密码文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 方法一：
yum install httpd-tools -y  
# 特殊符号要用 \ 转义
htpasswd -bc /usr/local/nginx/conf/passwd  wuyun qwe123\!\@\#    
# 方法二：
也可以用页面设置密码
登陆http://tool.oschina.net/htpasswd 输入用户名和密码，在线生成加密密码
将生成的密码写入/usr/local/nginx/conf/passwd文件中
echo &amp;quot;wuyun:$apr1$TrU5vUSC$RBuz3xG67Mr2pnAV596N5&amp;quot; &amp;gt;/usr/local/nginx/conf/passwd
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;重启nginx服务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;方法一：重新加载配置文件
nginx -s reload
方法二：重启nginx服务
systemctl restart nginx
&lt;/code&gt;&lt;/pre&gt;
">Nginx添加密码认证</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/nfs-fu-wu-duan-he-ke-hu-duan-da-jian/"" data-c="
          &lt;h3 id=&#34;服务端&#34;&gt;服务端&lt;/h3&gt;
&lt;h4 id=&#34;安装&#34;&gt;安装&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y nfs-utils
systemctl enable nfs-server
systemctl enable rpcbind
systemctl start nfs-server
systemctl start rpcbind
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;修改配置文件&#34;&gt;修改配置文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;常用共享权限参数说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ro 只读&lt;/p&gt;
&lt;p&gt;rw 读写&lt;/p&gt;
&lt;p&gt;root_squash 当nfs客户端以root管理员访问时，映射为NFS服务器的匿名用户&lt;/p&gt;
&lt;p&gt;no_root_squash 当nfs客户端以root管理员访问时，映射为NFS服务器的root管理员&lt;/p&gt;
&lt;p&gt;all_squash 无论nfs客户端使用什么账户访问，均映射为nfs服务器的匿名用户&lt;/p&gt;
&lt;p&gt;sync 同时将数据写入到内存与硬盘中，保证数据不丢失&lt;/p&gt;
&lt;p&gt;async 优先将数据保存到内存中，然后再写入硬盘，这样效率更高，但可能会丢失数据&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 配置文件一：
	vim /etc/exports
	# 追加如下参数：一行为一个分享目录，格式为“共享目录的路径 允许访问的NFS客户端（共享权限参数）”
		/nfsshare1 192.168.1.*(rw,sync,all_squash)
		/nfsshare2 192.168.2.2(ro,sync,root_sqush)
	# 或者使用如下命令
		echo &amp;quot;/nfsfile 192.168.1.*(rw,sync,all_squash)&amp;quot; &amp;gt;&amp;gt;/etc/exports
		echo &amp;quot;/nfsshare 192.168.2.2(ro,sync,root_sqush)&amp;quot; &amp;gt;&amp;gt;/etc/exports
# （此项非必须）配置文件二：
	vim /etc/sysconfig/nfs
	# 追加如下参数：修改默认端口，为之后添加防火墙规则做准备（如果关闭防火墙，此步可以不做）
		RQUOTAD_PORT=30001
		LOCKD_TCPPORT=30002
		LOCKD_UDPPORT=30002
		MOUNT_PORT=30003
		STATD_PORT=3004
	# 或者使用如下命令
		echo &amp;quot;RQUOTAD_PORT=30001&amp;quot; &amp;gt;&amp;gt;/etc/sysconfig/nfs
		echo &amp;quot;LOCKD_TCPPORT=30002&amp;quot; &amp;gt;&amp;gt;/etc/sysconfig/nfs
		echo &amp;quot;LOCKD_UDPPORT=30002&amp;quot; &amp;gt;&amp;gt;/etc/sysconfig/nfs
		echo &amp;quot;MOUNT_PORT=30003&amp;quot; &amp;gt;&amp;gt;/etc/sysconfig/nfs
		echo &amp;quot;STATD_PORT=3004&amp;quot; &amp;gt;&amp;gt;/etc/sysconfig/nfs
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;防火墙配置&#34;&gt;防火墙配置&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 添加服务
firewall-cmd --permanent --add-service=nfs
firewall-cmd --permanent --add-service=rpc-bind
firewall-cmd --permanent --add-service=mountd
# （此项非必须）nfsd
firewall-cmd --permanent --add-port=2049/tcp
firewall-cmd --permanent --add-port=2049/udp
firewall-cmd --permanent --add-port=30001/tcp
firewall-cmd --permanent --add-port=30001/udp
firewall-cmd --permanent --add-port=30002/tcp
firewall-cmd --permanent --add-port=30002/udp
firewall-cmd --permanent --add-port=30003/tcp
firewall-cmd --permanent --add-port=30003/udp
firewall-cmd --permanent --add-port=30004/tcp
firewall-cmd --permanent --add-port=30004/udp
firewall-cmd --permanent --add-port=30005/tcp
firewall-cmd --permanent --add-port=30005/udp
# （此项非必须）rpcbind
firewall-cmd --permanent --add-port=111/tcp
firewall-cmd --permanent --add-port=111/udp
# 重新加载防火墙规则
firewall-cmd --reload
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;客户端&#34;&gt;客户端&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;开机自动挂载/etc/fstab配置参数详解&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“分区名”   “挂载点”   “文件系统类型&amp;quot;  &amp;quot;挂载参数”   “dump备份配置”   “开机磁盘检查顺序”&lt;/p&gt;
&lt;p&gt;例如：/dev/sdb1 /mount  xfs defaults 0 0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分区名：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果多个磁盘，每个磁盘被标记为/dev/sda、/dev/sdb等等，每个磁盘的分区则为/dev/sdb1、/dev/sdb2等。&lt;/p&gt;
&lt;p&gt;此处除了使用设备接口，还可以使用唯一标识符（UUID），磁盘插拔之后设备接口可能变化，但是唯一标识符是不变的，例如：UUID=62837155-f2ec-45a9-88b8-5b7443fdfca5，查看UUID的命令为blkid。&lt;/p&gt;
&lt;p&gt;当然还可以使用设备卷标签（Lable，不常用，需要使用LVM），例如 Label=root&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;挂载点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;挂载点必须为当前已经存在的目录，如果挂载点的路径中包含空格，需要使用“/040”代替，当然也可以将挂载路径放到引号内&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;文件系统类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;常见的有ext2、ext3、ext4、xfs、iso9660(光盘)、ntfs(需要提前yum -y install ntfs-3g)等，此字段必须与分区格式化时的格式相同&lt;/p&gt;
&lt;p&gt;也可以使用auto这个特殊的参数，让系统自动侦测目标分区类型，常常用于挂载移动设备&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;挂载参数：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;async / sync：设置磁盘是否以异步方式运行，默认async&lt;/p&gt;
&lt;p&gt;auto / noauto：当使用mount -a时，此文件系统是否被挂载，默认auto&lt;/p&gt;
&lt;p&gt;rw / ro：该分区是可读写还是只读的形式挂载，如果分享的存储系统是只读，那么这里rw失效，默认rw&lt;/p&gt;
&lt;p&gt;exec / noexec：是否在此文件系统中可以“执行”操作，如果是单纯存储数据，则使用noexec比较安全，默认exec&lt;/p&gt;
&lt;p&gt;user / users / nouser / owner：是否允许用户使用mount命令来挂载，为了安全，不希望一般用户使用mount。user允许任意用户挂载文件系统，users允许所有users组中的用户挂载文件系统，nouser只能被root用户挂载，owner只允许设备所有者进行挂载，默认为nouser&lt;/p&gt;
&lt;p&gt;suid / nosuid：表示该文件系统是否允许suid的存在，如果不是执行文件（二进制可执行文件）存放目录，可以设置为nosuid，默认suid&lt;/p&gt;
&lt;p&gt;uquota / gquota：启动文件系统支持用户/用户组磁盘配额模式&lt;/p&gt;
&lt;p&gt;noatime / nodiratime / relatime：noatime不更新文件系统上inode访问记录，可以提升性能；nodiratime不更新文件系统上的目录inode访问记录，可以提升性能；实时更新inode access记录，只有记录中的访问时间早于当前访问才会被跟新，可以提升性能。&lt;/p&gt;
&lt;p&gt;flush：更频繁的刷新数据，复制对话框或进度条在全部数据写入后才消失。&lt;/p&gt;
&lt;p&gt;dev / nodev：是否解析文件系统上的块特殊设备，默认dev&lt;/p&gt;
&lt;p&gt;defaults：同时具有以下参数的功能，rw、dev、suid、exec、auto、nouser、async等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;dump备份配置：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0代表不备份，1代表要每天进行dump备份，2代表不定期的dump备份操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;开机磁盘检查顺序：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;0代表 不检查，1代表最早检查（一般只有根目录才设为1），2也会被检查，但晚于1，其他分区一般设为从2开始或者0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;showmount参数解释&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;-e 显示NFS服务器的共享列表&lt;/p&gt;
&lt;p&gt;-a 显示本机挂载的文件资源的情况&lt;/p&gt;
&lt;p&gt;-v 显示版本号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y nfs-utils
# 查看nfs共享目录
showmount -e 6.6.6.103
# 将nfs添加到开机挂载
echo &amp;quot;6.6.6.103:/Data_out/IN /Share/IN/103 nfs defaults 0 0&amp;quot; &amp;gt;&amp;gt;/etc/fstab
mount -a
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;使用autofs挂载&#34;&gt;使用autofs挂载&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;最优选，防止开机出问题,建议网络挂载均使用autofs&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install autofs
# 主配置文件格式：主挂载目录 子配置文件
echo &amp;quot;/Share/IN /etc/auto.master.d/IN.misc&amp;quot; &amp;gt;&amp;gt; /etc/auto.master
echo &amp;quot;/Share/OUT /etc/auto.master.d/OUT.misc&amp;quot; &amp;gt;&amp;gt; /etc/auto.master
# 子配置文件格式：子挂在目录 挂载文件类型及权限 :设备名称
# 挂载目录：主配置文件中的主挂载目录/子配置文件中的子挂载目录
vim /etc/auto.master.d/IN.misc
    103 -fstype=nfs,rw 6.6.6.103:/Data_out/IN
    104 -fstype=nfs,rw 6.6.6.104:/Data_out/IN
    105 -fstype=nfs,rw 6.6.6.105:/Data_out/IN
    106 -fstype=nfs,rw 6.6.6.106:/Data_out/IN
    107 -fstype=nfs,rw 6.6.6.107:/Data_out/IN
vim /etc/auto.master.d/OUT.misc
    103 -fstype=nfs,rw 6.6.6.103:/Data_out/OUT
    104 -fstype=nfs,rw 6.6.6.104:/Data_out/OUT
    105 -fstype=nfs,rw 6.6.6.105:/Data_out/OUT
    106 -fstype=nfs,rw 6.6.6.106:/Data_out/OUT
    107 -fstype=nfs,rw 6.6.6.107:/Data_out/OUT
systemctl restart autofs
&lt;/code&gt;&lt;/pre&gt;
">NFS服务端和客户端搭建</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/nextcloud-da-jian/"" data-c="
          &lt;h1 id=&#34;nextcloud搭建&#34;&gt;NextCloud搭建&lt;/h1&gt;
&lt;h2 id=&#34;初始化环境lamp&#34;&gt;初始化环境LAMP&lt;/h2&gt;
&lt;h3 id=&#34;安装apache如果为nginx&#34;&gt;安装apache（如果为nginx）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install httpd
systemctl enable httpd
systemctl start httpd &amp;amp;&amp;amp; systemctl status httpd
# 如果为nginx
vim /etc/yum.repos.d/mginx.repo
    [nginx-stable]
    name=nginx stable repo
    baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
    gpgcheck=0
    enabled=1
    gpgkey=https://nginx.org/keys/nginx_signing.key
    [nginx-mainline]
    name=nginx mainline repo
    baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
    gpgcheck=0
    enabled=1
    gpgkey=https://nginx.org/keys/nginx_signing.key
yum -y install nginx
systemctl enable nginx &amp;amp;&amp;amp; systemctl start nginx &amp;amp;&amp;amp; systemctl status nginx

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装mariadb&#34;&gt;安装mariadb&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install mariadb mariadb-server
systemctl enable mariadb
systemctl start mariadb &amp;amp;&amp;amp; systemctl status mariadb
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;初始化数据库&#34;&gt;初始化数据库&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql_secure_installation
# 此处直接按回车即可（一开始没有密码，以后改密码则需要输入已设定的密码）
# 然后会要求你输入两次密码，然后回车
# 然后一路按Y加回车
# 直到出现Thanks for using MariaDB
systemctl restart mariadb &amp;amp;&amp;amp; systemctl status mariadb
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装php以及相关组件&#34;&gt;安装php以及相关组件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install php72w php72w-mysql php72w-gd php72w-ldap php72w-odbc php72w-pear php72w-xml php72w-xmlrpc php72w-mbstring php72w-bcmath php72w-mhash libjpeg* 
systemctl restart mariadb &amp;amp;&amp;amp; systemctl status mariadb
systemctl restart httpd &amp;amp;&amp;amp; systemctl status httpd
# nginx
systemctl restart nginx &amp;amp;&amp;amp; systemctl status nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;搭建nextcloud&#34;&gt;搭建NextCloud&lt;/h2&gt;
&lt;h3 id=&#34;新建数据库&#34;&gt;新建数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysql -u root -p
	show databases;
	create database nextcloud; 
	exit
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;下载nextcloud文件并解压&#34;&gt;下载nextcloud文件并解压&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install unzip
cd /usr/local/src
wget https://download.nextcloud.com/server/releases/nextcloud-18.0.4.zip
unzip nextcloud-18.0.4.zip -d /var/www/html/
cd /var/www/html/
chmod 777 nextcloud -Rf
chown apache:apache nextcloud
systemctl restart mariadb &amp;amp;&amp;amp; systemctl status mariadb
systemctl restart httpd &amp;amp;&amp;amp; systemctl status httpd
# 如果为nginx
chown nginx:nginx nextcloud
systemctl restart nginx &amp;amp;&amp;amp; systemctl status nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;解决-通过不被信任的域名访问&#34;&gt;解决 “通过不被信任的域名访问”&lt;/h3&gt;
&lt;h4 id=&#34;方法一&#34;&gt;方法一：&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;1. 打开 ../nextcloud/config/config.php
2. 找到 trusted_domains
3. 增加一项:
preg_match(&#39;/cli/i&#39;,php_sapi_name())?&#39;127.0.0.1&#39;:$_SERVER[&#39;SERVER_NAME&#39;]
//完整的代码
//索引数字顺延就可以
&#39;trusted_domains&#39; =&amp;gt; array(
	0 =&amp;gt; &#39;127.0.0.1&#39;,
    1 =&amp;gt; preg_match(&#39;/cli/i&#39;,php_sapi_name())?&#39;127.0.0.1&#39;:$_SERVER[&#39;SERVER_NAME&#39;],
),
4. 解释：$_SERVER[‘SERVER_NAME’] 为获得当前访问的域名或IP，最初只设置了server_name，后来在查看cron任务时，发现在cli模式下是无法获得的，所以增加了cli模式判断，cli模式直接给个本地IP忽悠程序，正常模式将当前访问的域名或IP动态的添加的信任的域名中。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;方法二&#34;&gt;方法二：&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&#39;trusted_domains&#39; =&amp;gt;
array (
  0 =&amp;gt; &#39;47.95.219.151:8080&#39;,
  1 =&amp;gt; &#39;172.17.145.245:8080&#39;,
),
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;onlyoffice搭建&#34;&gt;OnlyOffice搭建&lt;/h1&gt;
&lt;h2 id=&#34;onlyoffice硬件要求&#34;&gt;onlyoffice硬件要求&lt;/h2&gt;
&lt;p&gt;【参考】&lt;a href=&#34;http://blog.51yip.com/server/2174.html&#34;&gt;http://blog.51yip.com/server/2174.html&lt;/a&gt;&lt;br&gt;
要求不低&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;CPU dual core 2 GHz or better  
RAM 2 GB or more  
HDD at least 40 GB of free space  
Additional requirements at least 4 GB of swap  
OS RHEL 7 or CentOS 7  
Additional requirements  
  PostgreSQL: version 9.1 or later  
  NGINX: version 1.3.13 or later  
  Node.js: version 8.12.0  
  Redis  
  RabbitMQ 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装epel源&#34;&gt;安装epel源&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install epel-release
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装nginx源&#34;&gt;安装nginx源&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
[nginx-mainline]
name=nginx mainline repo
baseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/
gpgcheck=0
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install gcc-c++ automake autoconf gcc make  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装nodejs12源可以不安装epel中有&#34;&gt;安装nodejs12源（可以不安装，epel中有）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;curl -sL https://rpm.nodesource.com/setup_12.x | bash -
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装nginx配置nginxconf&#34;&gt;安装nginx，配置nginx.conf&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install nginx  
# vim /etc/nginx/nginx.conf  
#     user nginx;  
#     worker_processes auto;  
#     error_log /var/log/nginx/error.log;  
#     pid /run/nginx.pid;  
# 
#     # Load dynamic modules. See /usr/share/nginx/README.dynamic.  
#     include /usr/share/nginx/modules/*.conf;  
# 
#     events {  
#         worker_connections 1024;  
#     }  
# 
#     http {  
#         log_format  main  &#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &#39;  
#                           &#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &#39;  
#                           &#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&#39;;  
# 
#         access_log  /var/log/nginx/access.log  main;  
#         sendfile            on;  
#         keepalive_timeout   65;  
#         include             /etc/nginx/mime.types;  
#         default_type        application/octet-stream;  
#         include /etc/nginx/conf.d/*.conf;  
# 
#     } 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装启动redisrabbitmq-server&#34;&gt;安装启动redis，rabbitmq-server&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install redis rabbitmq-server  
systemctl enable redis 
systemctl enable rabbitmq-server  
systemctl start redis &amp;amp;&amp;amp; systemctl status redis
systemctl start rabbitmq-server &amp;amp;&amp;amp; systemctl status rabbitmq-server 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装postgresql并创建数据库&#34;&gt;安装postgresql，并创建数据库&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install postgresql postgresql-server 
systemctl enable postgresql
service postgresql initdb  # 初始化数据库
vim /var/lib/pgsql/data/pg_hba.conf  
    host all all 127.0.0.1/32 trust # ident换成trust  
    host all all ::1/128 trust # ident换成trust  
systemctl start postgresql
# vim /usr/lib/systemd/system/postgresql.service
# 	将&amp;quot;Environment=PGDATA=/var/lib/pgsql/data&amp;quot;修改为&amp;quot;Environment=PGDATA=/tmp&amp;quot;
cd /tmp #防止could not change directory to &amp;quot;/root&amp;quot;从根目录运行时发出警告。然后必须创建数据库和用户
sudo -u postgres psql -c &amp;quot;CREATE DATABASE onlyoffice;&amp;quot;  
sudo -u postgres psql -c &amp;quot;CREATE USER onlyoffice WITH password &#39;onlyoffice&#39;;&amp;quot;  
sudo -u postgres psql -c &amp;quot;GRANT ALL privileges ON DATABASE onlyoffice TO onlyoffice;&amp;quot;  
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装onlyoffice源&#34;&gt;安装onlyoffice源&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install https://download.onlyoffice.com/repo/centos/main/noarch/onlyoffice-repo.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装配置onlyoffice&#34;&gt;安装配置onlyoffice&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install onlyoffice-documentserver  
bash documentserver-configure.sh  
    Configuring PostgreSQL access...  
    Host: localhost 
    Database name: onlyoffice  
    User: onlyoffice  
    Password:onlyoffice  
    Trying to establish PostgreSQL connection... OK  
    Installing PostgreSQL database... OK  
    Configuring redis access...  
    Host: localhost  

    Trying to establish redis connection... OK  
    Configuring RabbitMQ access...  
    Host: localhost  
    User: guest  
    Password:guest  
    Trying to establish RabbitMQ connection... OK  
    Restarting services... OK  
systemctl enable supervisord
systemctl start supervisord  
# 浏览器访问：http://服务器IP/web-apps/apps/api/documents/api.js
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;配置nginx-https可以不配置&#34;&gt;配置nginx https（可以不配置）&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /etc/onlyoffice/documentserver/nginx  
cp ds-ssl.conf.tmpl ds-ssl.conf  
ln -s /etc/onlyoffice/documentserver/nginx/ds-ssl.conf /etc/nginx/conf.d/  
vim /etc/nginx/conf.d/ds-ssl.conf
    include /etc/nginx/includes/http-common.conf;  
    ## Normal HTTP host  
    server {  
     listen 80;  
     server_name onlineoffice.netjoy.com;  
     server_tokens off;  

     ## Redirects all traffic to the HTTPS host  
     root /nowhere; ## root doesn&#39;t have to be a valid path since we are redirecting  
     rewrite ^ https://$host$request_uri? permanent;  
    }  

    #HTTP host for internal services  
    server {  
     listen 127.0.0.1:80;  
     listen [::1]:80;  
     server_name localhost;  
     server_tokens off;  

     include /etc/nginx/includes/ds-common.conf;  
     include /etc/nginx/includes/ds-docservice.conf;  
    }  

    ## HTTPS host  
    server {  
     listen 443;  
     server_name onlineoffice.netjoy.com;  
     server_tokens off;  
     root /usr/share/nginx/html;  

     ## Strong SSL Security  
     ## https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html  
     ssl on;  
     ssl_certificate /etc/nginx/cert/office.pem;  
     ssl_certificate_key /etc/nginx/cert/office.key;  
     ssl_verify_client off;  

     ssl_ciphers &amp;quot;EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH&amp;quot;;  

     ssl_protocols TLSv1 TLSv1.1 TLSv1.2;  
     ssl_session_cache builtin:1000 shared:SSL:10m;  

     ssl_prefer_server_ciphers on;  

     add_header Strict-Transport-Security max-age=31536000;  
     # add_header X-Frame-Options SAMEORIGIN;  
     add_header X-Content-Type-Options nosniff;  

     ## [Optional] If your certficate has OCSP, enable OCSP stapling to reduce the overhead and latency of running SSL.  
     ## Replace with your ssl_trusted_certificate. For more info see:  
     ## - https://medium.com/devops-programming/4445f4862461  
     ## - https://www.ruby-forum.com/topic/4419319  
     ## - https://www.digitalocean.com/community/tutorials/how-to-configure-ocsp-stapling-on-apache-and-nginx  
     # ssl_stapling on;  
     # ssl_stapling_verify on;  
     # ssl_trusted_certificate /etc/nginx/ssl/stapling.trusted.crt;  
     # resolver 208.67.222.222 208.67.222.220 valid=300s; # Can change to your DNS resolver if desired  
     # resolver_timeout 10s;  

     ## [Optional] Generate a stronger DHE parameter:  
     ## cd /etc/ssl/certs  
     ## sudo openssl dhparam -out dhparam.pem 4096  
     ##  
     # ssl_dhparam /etc/ssl/certs/dhparam.pem;  

     include /etc/nginx/includes/ds-*.conf;  

    }  
systemctl restart nginx  

&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;下载nextcloud-onlyoffice插件&#34;&gt;下载nextcloud-onlyoffice插件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd nextcloud路径/apps/  
git clone https://github.com/ONLYOFFICE/onlyoffice-owncloud.git onlyoffice  
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装日志&#34;&gt;安装日志&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;=====================================================================
 Package                    架构    版本            源          大小
=====================================================================
正在安装:
 onlyoffice-documentserver  x86_64  5.5.1-76        onlyoffice 363 M
为依赖而安装:
 GConf2                     x86_64  3.2.6-8.el7     base       1.0 M
 adwaita-cursor-theme       noarch  3.28.0-1.el7    base       641 k
 adwaita-icon-theme         noarch  3.28.0-1.el7    base        11 M
 at-spi2-atk                x86_64  2.26.2-1.el7    base        81 k
 at-spi2-core               x86_64  2.28.0-1.el7    base       158 k
 atk                        x86_64  2.28.1-2.el7    base       263 k
 avahi-libs                 x86_64  0.6.31-20.el7   base        62 k
 cairo                      x86_64  1.15.12-4.el7   base       741 k
 cairo-gobject              x86_64  1.15.12-4.el7   base        26 k
 colord-libs                x86_64  1.3.4-2.el7     base       186 k
 cups-libs                  x86_64  1:1.6.3-43.el7  base       358 k
 dconf                      x86_64  0.28.0-4.el7    base       106 k
 dejavu-fonts-common        noarch  2.33-6.el7      base        64 k
 dejavu-sans-fonts          noarch  2.33-6.el7      base       1.4 M
 fontconfig                 x86_64  2.13.0-4.3.el7  base       254 k
 fontpackages-filesystem    noarch  1.44-8.el7      base       9.9 k
 fribidi                    x86_64  1.0.2-1.el7_7.1 base        79 k
 gdk-pixbuf2                x86_64  2.36.12-3.el7   base       570 k
 glib-networking            x86_64  2.56.1-1.el7    base       145 k
 gnutls                     x86_64  3.3.29-9.el7_6  base       680 k
 graphite2                  x86_64  1.3.10-1.el7_3  base       115 k
 gsettings-desktop-schemas  x86_64  3.28.0-3.el7    base       606 k
 gtk-update-icon-cache      x86_64  3.22.30-5.el7   base        27 k
 gtk3                       x86_64  3.22.30-5.el7   base       4.4 M
 harfbuzz                   x86_64  1.7.5-2.el7     base       267 k
 hicolor-icon-theme         noarch  0.12-7.el7      base        42 k
 jasper-libs                x86_64  1.900.1-33.el7  base       150 k
 jbigkit-libs               x86_64  2.0-11.el7      base        46 k
 json-glib                  x86_64  1.4.2-2.el7     base       134 k
 lcms2                      x86_64  2.6-3.el7       base       150 k
 libICE                     x86_64  1.0.9-9.el7     base        66 k
 libSM                      x86_64  1.2.2-2.el7     base        39 k
 libXScrnSaver              x86_64  1.2.2-6.1.el7   base        24 k
 libXcomposite              x86_64  0.4.4-4.1.el7   base        22 k
 libXcursor                 x86_64  1.1.15-1.el7    base        30 k
 libXdamage                 x86_64  1.1.4-4.1.el7   base        20 k
 libXdmcp                   x86_64  1.1.2-6.el7     base        34 k
 libXext                    x86_64  1.3.3-3.el7     base        39 k
 libXfixes                  x86_64  5.0.3-1.el7     base        18 k
 libXfont2                  x86_64  2.0.3-1.el7     base       143 k
 libXft                     x86_64  2.3.2-2.el7     base        58 k
 libXi                      x86_64  1.7.9-1.el7     base        40 k
 libXinerama                x86_64  1.1.3-2.1.el7   base        14 k
 libXmu                     x86_64  1.1.2-2.el7     base        71 k
 libXrandr                  x86_64  1.5.1-2.el7     base        27 k
 libXrender                 x86_64  0.9.10-1.el7    base        26 k
 libXt                      x86_64  1.1.5-3.el7     base       173 k
 libXtst                    x86_64  1.2.3-1.el7     base        20 k
 libXxf86vm                 x86_64  1.1.4-1.el7     base        18 k
 libepoxy                   x86_64  1.5.2-1.el7     base       211 k
 liberation-fonts-common    noarch  1:1.07.2-16.el7 base        27 k
 liberation-mono-fonts      noarch  1:1.07.2-16.el7 base       227 k
 libfontenc                 x86_64  1.1.3-3.el7     base        31 k
 libglvnd                   x86_64  1:1.0.1-0.8.git base        89 k
 libglvnd-egl               x86_64  1:1.0.1-0.8.git base        44 k
 libglvnd-glx               x86_64  1:1.0.1-0.8.git base       125 k
 libgusb                    x86_64  0.2.9-1.el7     base        40 k
 libmodman                  x86_64  2.0.1-8.el7     base        28 k
 libproxy                   x86_64  0.4.11-11.el7   base        64 k
 libsoup                    x86_64  2.62.2-2.el7    base       411 k
 libthai                    x86_64  0.1.14-9.el7    base       187 k
 libtiff                    x86_64  4.0.3-32.el7    base       171 k
 libusbx                    x86_64  1.0.21-1.el7    base        61 k
 libwayland-client          x86_64  1.15.0-1.el7    base        33 k
 libwayland-cursor          x86_64  1.15.0-1.el7    base        20 k
 libwayland-egl             x86_64  1.15.0-1.el7    base        13 k
 libwayland-server          x86_64  1.15.0-1.el7    base        39 k
 libxkbcommon               x86_64  0.7.1-3.el7     base       108 k
 libxkbfile                 x86_64  1.0.9-3.el7     base        83 k
 libxshmfence               x86_64  1.2-1.el7       base       7.2 k
 mesa-libEGL                x86_64  18.3.4-7.el7_8. updates    109 k
 mesa-libGL                 x86_64  18.3.4-7.el7_8. updates    165 k
 mesa-libgbm                x86_64  18.3.4-7.el7_8. updates     39 k
 mesa-libglapi              x86_64  18.3.4-7.el7_8. updates     46 k
 nettle                     x86_64  2.7.1-8.el7     base       327 k
 pango                      x86_64  1.42.4-4.el7_7  base       280 k
 pixman                     x86_64  0.34.0-1.el7    base       248 k
 psmisc                     x86_64  22.20-16.el7    base       141 k
 pwgen                      x86_64  2.08-1.el7      epel        26 k
 python-backports           x86_64  1.0-8.el7       base       5.8 k
 python-backports-ssl_ma... noarch  3.5.0.1-1.el7   base        13 k
 python-ipaddress           noarch  1.0.16-2.el7    base        34 k
 python-meld3               x86_64  0.6.10-1.el7    epel        73 k
 python-setuptools          noarch  0.9.8-7.el7     base       397 k
 rest                       x86_64  0.8.1-2.el7     base        63 k
 supervisor                 noarch  3.4.0-1.el7     epel       498 k
 trousers                   x86_64  0.3.14-2.el7    base       289 k
 xkeyboard-config           noarch  2.24-1.el7      base       834 k
 xorg-x11-server-Xvfb       x86_64  1.20.4-10.el7   base       854 k
 xorg-x11-server-common     x86_64  1.20.4-10.el7   base        55 k
 xorg-x11-xauth             x86_64  1:1.0.9-1.el7   base        30 k
 xorg-x11-xkb-utils         x86_64  7.7-14.el7      base       103 k
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;onlyoffice安装中文字体的问题&#34;&gt;onlyoffice安装中文字体的问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在windows中的目录&lt;code&gt;C:\Windows\Fonts&lt;/code&gt;下查找所需要的的字体或者从网络下下载所需要的的字体&lt;/li&gt;
&lt;li&gt;准备软件FontCreator&lt;/li&gt;
&lt;li&gt;如果字体文件是&lt;code&gt;.ttf&lt;/code&gt;，则直接使用FontCreator打开字体文件，然后修改：字体--属性--识别--字体族，此处如果为中文则不需要修改，如果为英文则需要修改为相应的中文（中文字体修改为中文，如果是英文或者其他字体则不需要修改）。如果字体文件是&lt;code&gt;.ttc&lt;/code&gt;，则需要先使用FontCreator将字体文件提取成&lt;code&gt;.ttf&lt;/code&gt;，可以只提取里面需要的字体，不需要全部提取。&lt;/li&gt;
&lt;li&gt;将onlyoffice服务器本身的字体库中的字体暂时迁移到别的地方&lt;code&gt;mkdir /tmp/fontbak &amp;amp;&amp;amp; mv /usr/share/fonts/* /tmp/fontbak&lt;/code&gt;（如果编辑文档时需要这些字体，则不需要迁移，第8部也就不需要了）&lt;/li&gt;
&lt;li&gt;删除/var/www/html/documentserver/fonts下面的所有文件&lt;code&gt;rm -rf /var/www/html/documentserver/fonts/*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要onlyoffice自带的字体，则不需要删除/var/www/html/documentserver/core-fonts中的文件，如果不需要则可以直接清空此目录，然后将自己修改好的字体文件上传至此目录&lt;/li&gt;
&lt;li&gt;执行&lt;code&gt;documentserver-generate-allfonts.sh&lt;/code&gt;生成字体缓存文件&lt;/li&gt;
&lt;li&gt;将onlyoffice服务器本身的字体迁移回去&lt;code&gt;mv /tmp/fontbak/* /usr/share/fonts&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
">NextCloud+OnlyOffice搭建</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/gitlab-bu-shu-ji-han-hua/"" data-c="
          &lt;p&gt;gitlab部署&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;部署&#34;&gt;部署&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y checkpolicy libcgroup libsemanage-python policycoreutils-python python-IPy setools-libs audit-libs-python 
cd /usr/local/src
wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-12.3.5-ce.0.el7.x86_64.rpm
yum -y localinstall gitlab-ce-12.3.5-ce.0.el7.x86_64.rpm
gitlab-ctl reconfigure
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;汉化&#34;&gt;汉化&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd /usr/local/src
wget https://gitlab.com/xhang/gitlab/-/archive/12-3-stable-zh/gitlab-12-3-stable-zh.tar.gz
tar -zxvf gitlab-12-3-stable-zh.tar.gz
cd gitlab-12-3-stable-zh
unalias cp
mkdir /tmp/confbak
cp -rf /opt/gitlab/embedded/service/gitlab-rails/* /tmp/confbak
cp -rf /usr/local/src/gitlab-12-3-stable-zh/* /opt/gitlab/embedded/service/gitlab-rails
gitlab-ctl reconfigure
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;修改配置&#34;&gt;修改配置&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim /etc/gitlab/gitlab.rb
&amp;gt; 更改external_url为http://&amp;quot;本机IP&amp;quot;:&amp;quot;自定义的端口，默认为80&amp;quot;
gitlab-ctl reconfigure
gitlab-ctl restart
#开机自启
systemctl enable gitlab-runsvdir.service
# 默认存储位置在：/var/opt/gitlab/git-data/repositories，通常需要更改此路径到单独的一个分区来存储仓库的数据
# 例如把数据存放到/data/gitlab目录下
mkdir -p /data/gitlab
vim /etc/gitlab/gitlab.rb
# 在git_data_dir下面添加一句git_data_dir “/data/gitlab”
gitlab-ctl stop
gitlab-ctl reconfigure
gitlab-ctl start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;登录&#34;&gt;登录&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 默认用户名为root
# 密码为第一次访问时设置的密码
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;常用命令&#34;&gt;常用命令&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;语法：gitlab-ctl command (subcommand)
  start  #启动所有服务
  stop  #关闭所有服务
  restart  #重启所有服务
  status  #查看所有服务状态
  tail  #查看日志信息
  service-list  #列举所有启动服务
  graceful-kill  #平稳停止一个服务
  help  #帮助
  reconfigure  #修改配置文件之后，需要重新加载下
  show-config  #查看所有服务配置文件信息
  uninstall  #卸载这个软件，yum -y remove gitlab-ce，rm -rf /etc/gitlab /var/log/gitlab /var/opt/gitlab /opt/gitlab，find / -name gitlab｜xargs rm -rf
  cleanse  #删除gitlab数据
  remove-accounts #删除账户信息
gitlab-rails console  # 进入rails控制台
gitlab-rake gitlab:backup:create  #备份数据库。使用以上命令会在/var/opt/gitlab/backups目录下创建一个名称类似为1481598919_gitlab_backup.tar的压缩包, 这个压缩包就是 Gitlab 整个的完整部分, 其中开头的：1481598919是备份创建的日期，/etc/gitlab/gitlab.rb配置文件须备份，/var/opt/gitlab/nginx/conf nginx配置文件，/etc/postfix/main.cfpostfix 邮件配置备份
gitlab-rake gitlab:backup:restore BACKUP=1481598919  #备份恢复，后面的数字是备份的时间戳，可以通过备份文件名看到
# 0 2 * * * /opt/gitlab/bin/gitlab-rake gitlab:backup:create  #Gitlab自动备份，实现每天凌晨2点进行一次自动备份:通过crontab使用备份命令实现

示例：
  gitlab-ctl start  #启动所有服务
  gitlab-ctl start nginx  #启动单独一个服务
  gitlab-ctl tail  #查看日志，类似tail -f
  gitlab-ctl tail nginx  #查看一个应用的日志
  gitlab-ctl show-config  #显示所有服务配置文件
  gitlab-ctl uninstall  #卸载gitlab
&lt;/code&gt;&lt;/pre&gt;
">Gitlab部署及汉化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/centos7-yuan-ma-an-zhuang-php7/"" data-c="
          &lt;p&gt;php7&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h3 id=&#34;php编译安装&#34;&gt;php编译安装&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum -y install epel-release
yum -y install gcc gcc-c++ make ncurses curl argon2 openssl openssl-devel openldap openldap-devel bzip2 bzip2-devel zlib zlib-devel libxml2 libxml2-devel libcurl libcurl-devel libargon2 libargon2-devel libjpeg libjpeg-devel libpng libpng-devel libxslt libxslt-devel libicu libicu-devel libmemcached libmemcached-devel freetype freetype-devel gmp gmp-devel readline readline-devel glibc glibc-devel glib2 glib2-devel pcre pcre-devel xmlrpc-c xmlrpc-c-devel gdbm gdbm-devel db4 db4-devel libXpm libXpm-devel libX11 libX11-devel gd gd-devel expat expat-devel oniguruma oniguruma-devel libsodium libsodium-devel
useradd -s /sbin/nologin www
cd /usr/local/src
wget &amp;quot;https://www.php.net/distributions/php-7.4.2.tar.gz&amp;quot;
tar -zxvf php-7.4.2.tar.gz
cd php-7.4.2
./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-fpm-user=www --with-fpm-group=www --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-libdir=lib64 --with-zlib-dir --with-zlib --with-iconv-dir --with-jpeg --with-freetype --with-curl --with-gettext --with-xsl --with-libxml --with-xmlrpc --with-ldap-sasl --with-kerberos --with-openssl --with-password-argon2 --with-pear --with-bz2 --with-mhash --with-sodium --without-sqlite3 --without-pdo-sqlite --enable-mysqlnd --enable-fpm --enable-gd --enable-ctype --enable-bcmath --enable-exif --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl --enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-sysvshm --enable-xml --enable-ftp --enable-intl --disable-rpath --disable-fileinfo --disable-debug
make &amp;amp;&amp;amp; make install
cp php.ini-production /usr/local/php/etc/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;启动php-fpm&#34;&gt;启动php-fpm&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;环境变量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/php/sbin:/usr/local/php/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用默认配置文件：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mv /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf
mv /usr/local/php/etc/php-fpm.d/www.conf.default  /usr/local/php/etc/php-fpm.d/www.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;检查配置文件：php-fpm -t&lt;/li&gt;
&lt;li&gt;使用systemctl管理php-fpm&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/php-fpm.service &amp;lt;&amp;lt;EOF
[Unit]
Description=php-fpm
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/php/sbin/php-fpm -R
[Install]
WantedBy=multi-user.target
EOF
systemctl enable php-fpm
systemctl start php-fpm
systemctl status php-fpm
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;-R&amp;quot; 代表root用户启动，可以不加。如果加则需要把 /usr/local/php/etc/php-fpm.d/www.conf文件中的user和group均改为root（或者在主配置文件/usr/local/php/etc/php-fpm.conf中加入user=root和group=root这两行）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;验证php-fpm的启动&#34;&gt;验证php-fpm的启动&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;进程 ps auxf | grep php-fpm&lt;/li&gt;
&lt;li&gt;端口 netstat -tulnp | grep php-fpm&lt;/li&gt;
&lt;/ol&gt;
">Centos7源码安装php7</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/shu-mei-pai-cong-ling-kai-shi-da-jian-lnmp/"" data-c="
          &lt;h3 id=&#34;系统安装&#34;&gt;系统安装&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;下载镜像并解压&lt;br&gt;
&lt;a href=&#34;http://mirrors.huaweicloud.com/centos-altarch/7.7.1908/isos/armhfp/CentOS-Userland-7-armv7hl-RaspberryPI-Minimal-1908-sda.raw.xz&#34;&gt;http://mirrors.huaweicloud.com/centos-altarch/7.7.1908/isos/armhfp/CentOS-Userland-7-armv7hl-RaspberryPI-Minimal-1908-sda.raw.xz&lt;/a&gt;&lt;br&gt;
下载完成后使用7-zip软件将镜像解压成raw文件&lt;/li&gt;
&lt;li&gt;使用DiskGenius将SD卡（orU盘）格式化&lt;br&gt;
&lt;code&gt;默认会添加盘符，如果没有，请手动添加&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用Win32DiskImager将raw文件刷入SD卡&lt;br&gt;
&lt;code&gt;选择文件时默认为img文件，下拉选择所有文件即可选择刚才解压的raw文件&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;镜像刷入成功后，打开SD卡中文件cmdline.txt，在头部插入ip=&amp;quot;你要设置的IP&amp;quot;，后面加空格&lt;br&gt;
&lt;code&gt;此步可以省略。树莓派IP可以登录路由器上查找。&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认用户名（root）和密码（centos）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;扩展内存空间&#34;&gt;扩展内存空间&lt;/h3&gt;
&lt;p&gt;使用终端登录之后执行以下命令&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;fdisk /dev/mmcblk0  # 进入磁盘分区shell
 # 查看目前分区情况，有三个mmcblk0p1~3
&amp;gt; p 
# 删除最后一个分区，之后直接按enter即可
&amp;gt; d  
# 查看是否删除成功
&amp;gt; p 
# 新建分区 
&amp;gt; n 
# 选择主分区，因为刚才删除的就是主分区，分区号（Partition number）默认是3 
&amp;gt; p  
# .......... 注意 .......
# 下面看清楚：默认的起始sector如果是2048，则需要输入分区2（mmcblk0p2）结束（End）块区+1，然后一直ender下去即可；否则一直enter即可
#退出并保存分区
&amp;gt; w 
# .......... 注意 .......
# 此时已经回到centos7的shell，执行以下命令，否则** 无法开机 **
touch /.rootfs-repartition  
# 重启系统
 systemctl reboot
# 开机之后执行，重新加载分区信息
resize2fs /dev/mmcblk0p3
# 查看分区信息
df -h
lsblk
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;更换yum源&#34;&gt;更换yum源&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -p /etc/yum.repos.d/bak
mv /etc/yum.repos.d/* /etc/yum.repos.d/bak
cat &amp;gt;/etc/yum.repos.d/development.repo &amp;lt;&amp;lt;EOF
[base]
name=CentOS-\$releasever - Base
baseurl=http://mirrors.ustc.edu.cn/centos-altarch/\$releasever/os/\$basearch/
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
       file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-AltArch-Arm32

[updates]
name=CentOS-\$releasever - Updates
baseurl=http://mirrors.ustc.edu.cn/centos-altarch/\$releasever/updates/\$basearch/
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
       file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-AltArch-Arm32
 
[extras]
name=CentOS-\$releasever - Extras
baseurl=http://mirrors.ustc.edu.cn/centos-altarch/\$releasever/extras/\$basearch/
gpgcheck=1
enabled=1
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
       file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-AltArch-Arm32
 
[centosplus]
name=CentOS-\$releasever - Plus
baseurl=http://mirrors.ustc.edu.cn/centos-altarch/\$releasever/centosplus/\$basearch/
gpgcheck=1
enabled=0
gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7
       file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-SIG-AltArch-Arm32
EOF
yum makecache
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;暂时关闭selinux和防火墙&#34;&gt;暂时关闭selinux和防火墙&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;sed -i &#39;s/SELINUX=enforcing/SELINUX=disabled/g&#39;  /etc/selinux/config
setenforce 0
systemctl disable firewalld
systemctl stop firewalld
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;顺序部署php-nginx-mysql&#34;&gt;顺序部署php、nginx、mysql&lt;/h3&gt;
&lt;h4 id=&#34;php&#34;&gt;php&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编译安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;&amp;lt;!-- more --&amp;gt;

&amp;lt;!-- more --&amp;gt;

yum -y install gcc gcc-c++ make pcre pcre-devel zlib zlib-devel openssl openssl-devel libxml2 libxml2-devel libcurl libcurl-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel openldap openldap-devel
cd /usr/local/src
wget &amp;quot;https://nchc.dl.sourceforge.net/project/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gz&amp;quot;
tar -zxvf libmcrypt-2.5.8.tar.gz
cd libmcrypt-2.5.8
./configure
make &amp;amp;&amp;amp; make install
cd /usr/local/src
wget &amp;quot;https://www.php.net/distributions/php-5.6.40.tar.gz&amp;quot;
tar -zxvf php-5.6.40.tar.gz
cd php-5.6.40
./configure \
--prefix=/usr/local/php \
--with-config-file-path=/usr/local/php/etc \
--enable-ctype --with-mysql=mysqlnd \
--with-mysqli=mysqlnd \
--with-freetype-dir \
--with-jpeg-dir \
--with-png-dir \
--with-zlib --with-libxml-dir=/usr \
--enable-xml \
--disable-rpath \
--enable-bcmath \
--enable-shmop \
--enable-sysvsem \
--enable-inline-optimization \
--with-curl \
--enable-mbregex \
--enable-mbstring \
--with-mcrypt \
--with-gd \
--enable-gd-native-ttf \
--with-openssl \
--with-mhash \
--enable-pcntl \
--enable-sockets \
--with-ldap-sasl \
--with-xmlrpc \
--enable-zip \
--enable-soap \
--with-gettext \
--enable-fpm
make &amp;amp;&amp;amp; make install
cp php.ini-production /usr/local/php/etc/php.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/php/sbin:/usr/local/php/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;配置修改&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mv /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意将&amp;quot;user&amp;quot;和&amp;quot;group&amp;quot;这两个变量的值都改为root&lt;br&gt;
检查配置文件：php-fpm -t&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;systemctl管理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/php-fpm.service &amp;lt;&amp;lt;EOF
[Unit]
Description=php-fpm
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/php/sbin/php-fpm -R
[Install]
WantedBy=multi-user.target
EOF
systemctl enable php-fpm
systemctl start php-fpm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;nginx&#34;&gt;nginx&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编译安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y wget gcc gcc-c++ make pcre pcre-devel zlib zlib-devel openssl openssl-devel
cd /usr/local/src
wget &amp;quot;http://nginx.org/download/nginx-1.9.9.tar.gz&amp;quot;
tar -zxvf nginx-1.9.9.tar.gz
cd nginx-1.9.9
./configure --prefix=/usr/local/nginx
make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/nginx/sbin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;配置修改&lt;br&gt;
配置文件：/usr/local/nginx/conf/nginx.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;# 将第二个配置在配置文件中存在，需要去掉前面的注释，其次要修改fastcgi_param这一行
location / {
  root html;
  index index.html index.htm index.php;
}
location ~\.php${
  root html;
  fastcgi_pass 127.0.0.1:9000;
  fastcgi_index index.php;
  fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
  include fastcgi_params;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;systemctl管理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/nginx.service &amp;lt;&amp;lt;EOF
[Unit]
Description=nginx
After=network.target
[Service]
Type=forking
ExecStart=/usr/local/nginx/sbin/nginx
[Install]
WantedBy=multi-user.target
EOF
systemctl enable nginx
systemctl start nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;mysql&#34;&gt;mysql&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;编译安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;yum install -y gcc gcc-c++ make tar openssl openssl-devel cmake ncurses ncurses-devel
useradd -s /sbin/nologin mysql
cd /usr/local/src
wget &amp;quot;https://cdn.mysql.com//Downloads/MySQL-5.6/mysql-5.6.47.tar.gz&amp;quot;
tar -zxvf mysql-5.6.47.tar.gz
cd mysql-5.6.47
cmake -DCMAKE_INSTALL_PREFIX=/usr/local/mysql -DMYSQL_DATADIR=/data/mysql -DDEFAULT_CHARSET=utf8 -DDEFAULT_COLLATION=utf8_general_ci -DWITH_EXTRA_CHARSETS:STRING=all -DWITH_DEBUG=0 -DWITH_SSL=yes -DWITH_READLINE=1 -DENABLED_LOACL_INFILE=1
make &amp;amp;&amp;amp; make install
cp support-files/mysql.server /etc/init.d/mysqld
chmod a+x /etc/init.d/mysqld
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;环境变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;export PATH=\$PATH:/usr/local/mysql/bin&amp;quot; &amp;gt;&amp;gt;/etc/profile &amp;amp;&amp;amp; source /etc/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;配置文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/etc/my.cnf &amp;lt;&amp;lt;EOF
[mysqld]
bind-address=0.0.0.0
port=3306
datadir=/data/mysql
user=mysql
skip-name-resolve
long_query_time=2
slow_query_log_file=/data/mysql/mysql-slow.log
expire_logs_days=2
innodb-file-per-table=1
innodb_flush_log_at_trx_commit=2
log_warnings=1
max_allowed_packet=512M
connect_timeout=60
net_read_timeout=120
[mysqld_safe]
log-error=/data/mysql/mysqld.log
pid-file=/data/mysql/mysqld.pid
EOF
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mkdir -pv /data/mysql
chown -R mysql:mysql /usr/local/mysql /data/mysql
yum install -y perl-Module-Install
/usr/local/mysql/scripts/mysql_install_db --basedir=/usr/local/mysql --user=mysql --datadir=/data/mysql/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;systemctl管理&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cat &amp;gt;/usr/lib/systemd/system/mysqld.service &amp;lt;&amp;lt;EOF
[Unit]
Description=MySQL Community Server
After=network.target
After=syslog.target
[Install]
WantedBy=multi-user.target
Alias=mysql.service
[Service]
User=mysql
Group=mysql
PermissionsStartOnly=true
ExecStart=/usr/local/mysql/bin/mysqld_safe --basedir=/usr/local/mysql
TimeoutSec=600
Restart=always
PrivateTmp=false
EOF
systemctl enable mysqld
systemctl start mysqld
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;安全设置&lt;br&gt;
设置密码和本地登录&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;mysqladmin -h 127.0.0.1 -uroot password &amp;quot;raspberrypwd&amp;quot;
mysql -h 127.0.0.1 -uroot -praspberrypwd
&lt;/code&gt;&lt;/pre&gt;
">树莓派从零开始搭建LNMP（centos7）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/wang-luo-xiang-guan/"" data-c="
          &lt;p&gt;**问题描述：**虚拟机centos7的网络连接为“直接连接物理网络”模式，内部网络可以ping同，但是无法ping通外部网络，在网卡配置文件中配置&amp;quot;DNS=114.114.114.114&amp;quot;之后仍然无效&lt;br&gt;
&lt;strong&gt;解决方法：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo &amp;quot;nameserver 114.114.114.114&amp;quot; &amp;gt;&amp;gt;/etc/resolv.conf &amp;amp;&amp;amp; systemctl restart network &amp;amp;&amp;amp; ping www.baidu.com
# 将dns服务器写入/etc/resolv.conf，然后重启网络
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
">网络相关</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/shi-yong-wget-bei-fen-wang-zhan/"" data-c="
          &lt;p&gt;wget命令详解以及常用组合&lt;/p&gt;
&lt;!-- more --&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 如果备份的是网站根目录，例如https://www.egouz.com/，则使用如下命令（不遍历父目录 -nq）
wget -m -t 10 -T 180 -c -np -q --execute robots=off https://www.egouz.com/ec/
# 如果从网站的子目录开始备份，且备份整个网站（遍历父目录）
wget -m -t 10 -T 180 -c -q --execute robots=off https://www.egouz.com/ec/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;wget命令详解&#34;&gt;wget命令详解&lt;/h3&gt;
&lt;h4 id=&#34;启动&#34;&gt;启动&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-V,  --version&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;显示 Wget 的版本信息并退出。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-h,  --help&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打印此帮助。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-b,  --background&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;启动后转入后台。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-e,  --execute=COMMAND&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;运行一个‘.wgetrc’风格的命令。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;输入输出文件&#34;&gt;输入输出文件&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-o,  --output-file=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将信息写入 FILE。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-a,  --append-output=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将信息添加至 FILE。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-d,  --debug&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打印大量调试信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-q,  --quiet&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;安静模式(无信息输出)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-v,  --verbose&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;详尽的输出(此为默认值)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-nv, --no-verbose&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭详尽输出，但不进入安静模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-i,  --input-file=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;下载本地或外部 FILE 中的 URLs。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-F,  --force-html&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;把输入文件当成 HTML 文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-B,  --base=URL&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;解析与 URL 相关的HTML 输入文件（由 -i -F 选项指定）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;下载&#34;&gt;下载&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-t,  --tries=NUMBER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置重试次数为 NUMBER (0 代表无限制)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--retry-connrefused&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;即使拒绝连接也是重试。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-O,  --output-document=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将文档写入 FILE。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-nc, --no-clobber&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要重复下载已存在的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-c,  --continue&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;继续下载部分下载的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--progress=TYPE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择进度条类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-N,  --timestamping&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;只获取比本地文件新的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-S,  --server-response&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;打印服务器响应。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--spider&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不下载任何文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-T,  --timeout=SECONDS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将所有超时设为 SECONDS 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--dns-timeout=SECS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置 DNS 查寻超时为 SECS 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--connect-timeout=SECS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置连接超时为 SECS 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--read-timeout=SECS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置读取超时为 SECS 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-w,  --wait=SECONDS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;等待间隔为 SECONDS 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--waitretry=SECONDS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在取回文件的重试期间等待 1..SECONDS 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--random-wait&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;取回时等待 0...2*WAIT 秒。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-proxy&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭代理。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-Q,  --quota=NUMBER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置取回配额为 NUMBER 字节。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--bind-address=ADDRESS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;绑定至本地主机上的 ADDRESS (主机名或是 IP)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--limit-rate=RATE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;限制下载速率为 RATE。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-dns-cache&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭 DNS 查寻缓存。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--restrict-file-names=OS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;限定文件名中的字符为 OS 允许的字符。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ignore-case&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;匹配文件/目录时忽略大小写。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-4,  --inet4-only&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;仅连接至 IPv4 地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-6,  --inet6-only&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;仅连接至 IPv6 地址。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--prefer-family=FAMILY&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;首先连接至指定协议的地址，FAMILY 为 IPv6，IPv4 或是 none。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--user=USER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将 ftp 和 http 的用户名均设置为 USER。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--password=PASS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将 ftp 和 http 的密码均设置为 PASS。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ask-password&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;提示输入密码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-iri&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;关闭 IRI 支持。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--local-encoding=ENC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;IRI 使用 ENC 作为本地编码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--remote-encoding=ENC&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 ENC 作为默认远程编码。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;目录&#34;&gt;目录&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-nd, --no-directories&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不创建目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-x,  --force-directories&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;强制创建目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-nH, --no-host-directories&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要创建主目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--protocol-directories&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在目录中使用协议名称。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-P,  --directory-prefix=PREFIX&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以 PREFIX/... 保存文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--cut-dirs=NUMBER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;忽略 NUMBER 个远程目录路径。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;递归下载&#34;&gt;递归下载&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-r,  --recursive&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;指定递归下载。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-l,  --level=NUMBER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;最大递归深度( inf 或 0 代表无限制，即全部下载)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--delete-after&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;下载完成后删除本地文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-k,  --convert-links&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;让下载得到的 HTML 或 CSS 中的链接指向本地文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-K,  --backup-converted&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在转换文件 X 前先将它备份为 X.orig。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-m,  --mirror&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-N -r -l inf --no-remove-listing 的缩写形式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-p,  --page-requisites&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;下载所有用于显示 HTML 页面的图片之类的元素。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--strict-comments&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;开启 HTML 注释的精确处理(SGML)。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;列表与排除&#34;&gt;列表与排除&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-A,  --accept=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;逗号分隔的可接受的扩展名列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-R,  --reject=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;逗号分隔的要拒绝的扩展名列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-D,  --domains=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;逗号分隔的可接受的域列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--exclude-domains=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;逗号分隔的要拒绝的域列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--follow-ftp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;跟踪 HTML 文档中的 FTP 链接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--follow-tags=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;逗号分隔的跟踪的 HTML 标识列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ignore-tags=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;逗号分隔的忽略的 HTML 标识列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-H,  --span-hosts&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;递归时转向外部主机。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-L,  --relative&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;只跟踪有关系的链接。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-I,  --include-directories=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;允许目录的列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-X,  --exclude-directories=LIST&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;排除目录的列表。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-np, --no-parent&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不追溯至父目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;ftp&#34;&gt;FTP&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ftp-user=USER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置 ftp 用户名为 USER。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ftp-password=PASS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置 ftp 密码为 PASS。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-remove-listing&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要删除‘.listing’文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-glob&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不在 FTP 文件名中使用通配符展开。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-passive-ftp&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;禁用“passive”传输模式。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--retr-symlinks&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;递归目录时，获取链接的文件(而非目录)。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;http&#34;&gt;HTTP&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--http-user=USER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置 http 用户名为 USER。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--http-password=PASS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;设置 http 密码为 PASS。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-cache&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不在服务器上缓存数据。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--default-page=NAME&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;改变默认页（默认页通常是“index.html”）。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-E,  --adjust-extension&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;以合适的扩展名保存 HTML/CSS 文档。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ignore-length&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;忽略头部的‘Content-Length’区域。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--header=STRING&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在头部插入 STRING。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--max-redirect&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;每页所允许的最大重定向。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--proxy-user=USER&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 USER 作为代理用户名。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--proxy-password=PASS&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 PASS 作为代理密码。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--referer=URL&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在 HTTP 请求头包含‘Referer: URL’。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--save-headers&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;将 HTTP 头保存至文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;-U,  --user-agent=AGENT&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;标识为 AGENT 而不是 Wget/VERSION。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-http-keep-alive&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;禁用 HTTP keep-alive(永久连接)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-cookies&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不使用 cookies。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--load-cookies=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;会话开始前从 FILE 中载入 cookies。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--save-cookies=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;会话结束后保存 cookies 至 FILE。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--keep-session-cookies&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;载入并保存会话(非永久) cookies。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--post-data=STRING&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 POST 方式；把 STRING 作为数据发送。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--post-file=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;使用 POST 方式；发送 FILE 内容。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--content-disposition&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;当选中本地文件名时,允许 Content-Disposition 头部(尚在实验)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--auth-no-challenge&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;在不等待服务器质询的情况下发送基本的HTTP身份验证信息。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;https&#34;&gt;HTTPS&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:left&#34;&gt;命令&lt;/th&gt;
&lt;th style=&#34;text-align:left&#34;&gt;详解&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--secure-protocol=PR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;选择安全协议，可以是 auto、SSLv2、SSLv3 或是 TLSv1 中的一个。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--no-check-certificate&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;不要验证服务器的证书。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--certificate=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端证书文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--certificate-type=TYPE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;客户端证书类型， PEM 或 DER。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--private-key=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;私钥文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--private-key-type=TYPE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;私钥文件类型， PEM 或 DER。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ca-certificate=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;带有一组 CA 认证的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--ca-directory=DIR&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;保存 CA 认证的哈希列表的目录。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--random-file=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;带有生成 SSL PRNG 的随机数据的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:left&#34;&gt;--egd-file=FILE&lt;/td&gt;
&lt;td style=&#34;text-align:left&#34;&gt;用于命名带有随机数据的 EGD 套接字的文件。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;!-- more --&gt;
">使用wget备份网站</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/centos7-xi-tong-ru-he-qing-kong-ying-pan-shu-ju/"" data-c="
          &lt;p&gt;Linux系统磁盘格式化&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;如果仅仅是简单的的删除数据，使用&lt;code&gt;rm -rf &amp;quot;目录&amp;quot;&lt;/code&gt;即可达到效果，当然也可以使用&lt;code&gt;fdisk&lt;/code&gt;或者&lt;code&gt;parted&lt;/code&gt;或者&lt;code&gt;mkfs&lt;/code&gt;等。&lt;br&gt;
但有的时候出于数据的保密性等要求，需要我们对硬盘进行低格，如果将硬盘拿到Windows系统上，使用低格工具进行处理，又过于繁琐，幸好在Linux系统上有相应的工具，只是这个工具发明的初衷是用来备份硬盘的，如果硬盘写白盘，不知道多少企业要遭殃，&lt;em&gt;技术是一把双刃剑！&lt;/em&gt;&lt;br&gt;
&lt;strong&gt;【注意：在使用以下命令时，一定！一定！一定！要把硬盘写对，可以使用&lt;code&gt;fdisk -l&lt;/code&gt;查看硬盘】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用全0复写硬盘&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 假设需要低格的硬盘为/dev/sdx
dd if=/dev/zero of=/dev/sdx
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用随机序列复写硬盘&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;dd if=/dev/urandom of=/dev/sdx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复写后的分区无法挂载，并且创建和拷贝文件都会报错。&lt;/p&gt;
">Centos7系统如何清空硬盘数据</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://fqj-web.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;谢谢浏览这篇博文，很高兴读者能来了解作者！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h1&gt;
&lt;p&gt;记录个人学习笔记和一些读书心得，偶尔会分享一些心情或者安利好物&lt;/p&gt;
&lt;h1 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h1&gt;
&lt;p&gt;许飞琼，飞琼君&lt;/p&gt;
&lt;h1 id=&#34;擅长与爱好&#34;&gt;⛹ 擅长与爱好&lt;/h1&gt;
&lt;p&gt;Linux，Python，Route &amp;amp; Switch，网络安全，健身，FPGA，嵌入式，摄影......&lt;/p&gt;
&lt;h1 id=&#34;其他笔记&#34;&gt;📘 其他笔记&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fqj.myds.me:4434/rhce/index.html&#34;&gt;红帽认证RHCE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;自学历程&#34;&gt;➕ 自学历程&lt;/h1&gt;
&lt;h2 id=&#34;1-linux&#34;&gt;1. Linux&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.linuxprobe.com/&#34;&gt;Linux运维（已经取得红帽认证），《Linux就该这么学》作者，刘遄（chuan）老师&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1618809482733.png&#34; alt=&#34;RHCE&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-python&#34;&gt;2. Python&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.oldboyedu.com/&#34;&gt;Python开发，除了自学之外，还跟老男孩的金角大王Alex老师进行了系统的学习&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-rs&#34;&gt;3. R&amp;amp;S&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.qytang.com/&#34;&gt;网络运维，数通方向，乾颐堂的周亚军（安德，习惯称他军哥）、白伟鹏（老白）、李伟达（达叔）&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://fqj-web.github.io/post-images/1618809796377.jpg&#34; alt=&#34;R&amp;amp;S&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">关于</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  !function () {
    let times = document.querySelectorAll('.publish-time');
    for (let i = 0; i < times.length; i++) {
      let date = times[i].dataset.t;
      let time = Math.floor((new Date().getTime() - new Date(date).getTime()) / 1000);
      if (time < 60) {
        str = time + '秒之前';
      } else if (time < 3600) {
        str = Math.floor(time / 60) + '分钟之前';
      } else if (time >= 3600 && time < 86400) {
        str = Math.floor(time / 3600) + '小时之前';
      } else if (time >= 86400 && time < 259200) {
        str = Math.floor(time / 86400) + '天之前';
      } else {
        str = times[i].textContent;
      }
      times[i].textContent = str;
    }
  }();
</script>

<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>


<script src="/media/js/mouse/love.js"></script>




</html>